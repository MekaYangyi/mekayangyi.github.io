<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鉴心</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/child/"/>
  <updated>2017-07-08T06:31:07.373Z</updated>
  <id>http://yoursite.com/child/</id>
  
  <author>
    <name>YangYi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis源码阅读-跳跃表</title>
    <link href="http://yoursite.com/child//blog/2017/07/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8.html"/>
    <id>http://yoursite.com/child//blog/2017/07/redis源码阅读-跳跃表.html</id>
    <published>2017-07-08T06:29:58.000Z</published>
    <updated>2017-07-08T06:31:07.373Z</updated>
    
    <content type="html"><![CDATA[<p>跳跃表一种有序数据结构，每个节点维护多个指向其他节点的指针，达到快速访问节点的目的。</p>
<p>大部分情况下跳跃表的效率可以和平衡数媲美，实现比平衡树简单，不少程序使用跳跃表来代替平衡树。</p>
<p>跳跃表有时会作为有序集合的实现。以分值排序。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳跃表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</div><div class="line">    robj *obj; <span class="comment">// 保存的对象</span></div><div class="line">    <span class="keyword">double</span> score; <span class="comment">// 分值 跳跃表按照分值进行排序</span></div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward; <span class="comment">// 上一节点</span></div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;</div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward; <span class="comment">// 前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span; <span class="comment">// 跨度 记录两个节点之间的距离</span></div><div class="line">    &#125; level[]; <span class="comment">// 层</span></div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line"><span class="comment">// 跳跃表</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail; <span class="comment">// 头、尾指针</span></div><div class="line">    PORT_ULONG length; <span class="comment">// 跳跃表长度</span></div><div class="line">    <span class="keyword">int</span> level; <span class="comment">// 层数最大节点层数</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<h2 id="跳跃表的创建"><a href="#跳跃表的创建" class="headerlink" title="跳跃表的创建"></a>跳跃表的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建节点</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// 申请内存</span></div><div class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zskiplistLevel));</div><div class="line">    zn-&gt;score = score; <span class="comment">// 赋值分数</span></div><div class="line">    zn-&gt;obj = obj; <span class="comment">// 设定成员对象</span></div><div class="line">    <span class="keyword">return</span> zn;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建跳跃表</span></div><div class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    <span class="comment">// 申请内存</span></div><div class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</div><div class="line">    zsl-&gt;level = <span class="number">1</span>; <span class="comment">// 设置层数初始为1</span></div><div class="line">    zsl-&gt;length = <span class="number">0</span>; <span class="comment">// 设置长度初始为0</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建头节点 层数为32 分数为0</span></div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 将每层的forward指针指向null，跨度0</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</div><div class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设定backward指向null</span></div><div class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</div><div class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>逻辑是先找到节点插入位置，插入位置前一个节点的信息。<br>插入，并更新前一节点信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个成员为obj，分值为score的新节点</span></div><div class="line"><span class="comment">// 将新节点插入到跳跃表中</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// updata[]数组记录每一层位于插入节点的前一个节点</span></div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="comment">// rank[]记录每一层位于插入节点的前一个节点的排名</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    <span class="keyword">int</span> i, level;</div><div class="line"></div><div class="line">    redisAssert(!isnan(score));</div><div class="line">    x = zsl-&gt;header; <span class="comment">// 表头节点</span></div><div class="line">    <span class="comment">// 从最高层开始查找</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">// i == (zsl-&gt;level-1) 为0</span></div><div class="line">        <span class="comment">//否则第i层起始rank值为i+1的rank值</span></div><div class="line">        <span class="comment">// 最终rank[0]的值+1就是新节点的前置节点排位</span></div><div class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</div><div class="line">        <span class="comment">// 沿着前几指针遍历跳跃表</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            <span class="comment">// 比对分值</span></div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                <span class="comment">// 比对成员</span></div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 记录沿途跨越多少节点</span></div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            <span class="comment">// 移动到下一个指针</span></div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 记录将要和新节点相连接的节点</span></div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">       *</div><div class="line">    <span class="comment">// zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</span></div><div class="line">    <span class="comment">// 所以这里不需要进一步进行检查，可以直接创建新元素。</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取一个随机值作为新节点的层数</span></div><div class="line">    level = zslRandomLevel();</div><div class="line"></div><div class="line">    <span class="comment">// 如果新节点的层数比其他节点层数大</span></div><div class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</div><div class="line">        <span class="comment">// 初始化未使用层</span></div><div class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = <span class="number">0</span>;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 创建新节点</span></div><div class="line">    x = zslCreateNode(level,score,obj);</div><div class="line"></div><div class="line">    <span class="comment">// 将前面记录的指针指向新节点，并做相应的设置</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 设置新节点的前进指针</span></div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        update[i]-&gt;level[i].forward = x; <span class="comment">// 将沿途记录的各个节点的前进指针指向新节点</span></div><div class="line"></div><div class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></div><div class="line">        <span class="comment">// 计算新节点跨越的节点数量</span></div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</div><div class="line">        <span class="comment">// 更新新节点插入后，沿途节点的span值</span></div><div class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* increment span for untouched levels */</span></div><div class="line">    <span class="comment">// 未接触的节点的span值也需要增加1，这些节点从表头指向新节点</span></div><div class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置新节点的后退指针</span></div><div class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        zsl-&gt;tail = x;</div><div class="line"></div><div class="line">    <span class="comment">// 长度+1</span></div><div class="line">    zsl-&gt;length++;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>Redis提供三种删除跳跃表节点的方式：</p>
<ol>
<li><p>根据给定分值和成员来删除节点，zslDelete。</p>
</li>
<li><p>根据给定分值来删除节点，zslDeleteByScore。</p>
</li>
<li><p>根据给定排名来删除节点，zslDeleteByRank。</p>
</li>
</ol>
<p>删除操作均由zslDeleteNode执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 更新所有和被删除节点x有关的节点指针，解除它们之间的关系</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新被删除节点x的前进后退指针</span></div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新跳跃表的最大层数</span></div><div class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</div><div class="line">        zsl-&gt;level--;</div><div class="line"></div><div class="line">    <span class="comment">// 计数器-1</span></div><div class="line">    zsl-&gt;length--;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据节点的分值和成员删除节点,其余两种情况只是查找方法与判断方式不同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历跳跃表，查找目标节点，并记录所有沿途及节点</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 分值和对象相同时，将其删除</span></div><div class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</div><div class="line">        zslDeleteNode(zsl, x, update);</div><div class="line">        zslFreeNode(x);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查找给定分值和成员对象的节点在跳跃表中的排位"><a href="#查找给定分值和成员对象的节点在跳跃表中的排位" class="headerlink" title="查找给定分值和成员对象的节点在跳跃表中的排位"></a>查找给定分值和成员对象的节点在跳跃表中的排位</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历整个跳跃表</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历节点并对比元素</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                <span class="comment">// 比对分值</span></div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                <span class="comment">// 比对成员对象</span></div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 累积跨越的节点数量</span></div><div class="line">            rank += x-&gt;level[i].span;</div><div class="line"></div><div class="line">            <span class="comment">// 沿着前进指针遍历跳跃表</span></div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 必须确保不仅分值相等，而且成员对象也要相等</span></div><div class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</div><div class="line">            <span class="keyword">return</span> rank;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 没找到</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跳跃表一种有序数据结构，每个节点维护多个指向其他节点的指针，达到快速访问节点的目的。&lt;/p&gt;
&lt;p&gt;大部分情况下跳跃表的效率可以和平衡数媲美，实现比平衡树简单，不少程序使用跳跃表来代替平衡树。&lt;/p&gt;
&lt;p&gt;跳跃表有时会作为有序集合的实现。以分值排序。&lt;/p&gt;
&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 跳跃表节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistNode &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    robj *obj; &lt;span class=&quot;comment&quot;&gt;// 保存的对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; score; &lt;span class=&quot;comment&quot;&gt;// 分值 跳跃表按照分值进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistNode *backward; &lt;span class=&quot;comment&quot;&gt;// 上一节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistLevel &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistNode *forward; &lt;span class=&quot;comment&quot;&gt;// 前进指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; span; &lt;span class=&quot;comment&quot;&gt;// 跨度 记录两个节点之间的距离&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; level[]; &lt;span class=&quot;comment&quot;&gt;// 层&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; zskiplistNode;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 跳跃表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplist &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistNode *header, *tail; &lt;span class=&quot;comment&quot;&gt;// 头、尾指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    PORT_ULONG length; &lt;span class=&quot;comment&quot;&gt;// 跳跃表长度&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; level; &lt;span class=&quot;comment&quot;&gt;// 层数最大节点层数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; zskiplist;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;跳跃表的创建&quot;&gt;&lt;a href=&quot;#跳跃表的创建&quot; class=&quot;headerlink&quot; title=&quot;跳跃表的创建&quot;&gt;&lt;/a&gt;跳跃表的创建&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;zskiplistNode *&lt;span class=&quot;title&quot;&gt;zslCreateNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; level, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; score, robj *obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 申请内存&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zskiplistNode *zn = zmalloc(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(*zn)+level*&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistLevel));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zn-&amp;gt;score = score; &lt;span class=&quot;comment&quot;&gt;// 赋值分数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zn-&amp;gt;obj = obj; &lt;span class=&quot;comment&quot;&gt;// 设定成员对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; zn;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建跳跃表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;zskiplist *&lt;span class=&quot;title&quot;&gt;zslCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zskiplist *zsl;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 申请内存&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl = zmalloc(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(*zsl));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;level = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 设置层数初始为1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;length = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 设置长度初始为0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建头节点 层数为32 分数为0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将每层的forward指针指向null，跨度0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; ZSKIPLIST_MAXLEVEL; j++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        zsl-&amp;gt;header-&amp;gt;level[j].forward = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        zsl-&amp;gt;header-&amp;gt;level[j].span = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设定backward指向null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;header-&amp;gt;backward = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;tail = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; zsl;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-字典</title>
    <link href="http://yoursite.com/child//blog/2017/06/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8.html"/>
    <id>http://yoursite.com/child//blog/2017/06/redis源码阅读-字典.html</id>
    <published>2017-06-30T07:09:34.000Z</published>
    <updated>2017-07-08T04:30:39.031Z</updated>
    
    <content type="html"><![CDATA[<p>Redis字典由哈希表实现的保存键值对的抽象数据结构。</p>
<p>实现文件在dict.h\dict.c中。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>Redis字典结构体定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</div><div class="line">    <span class="keyword">void</span> *key;<span class="comment">// key 键</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">        <span class="keyword">double</span> d;</div><div class="line">    &#125; v;<span class="comment">// 值，支持多种类型,使用联合。</span></div><div class="line">    <span class="keyword">struct</span> dictEntry *next;<span class="comment">// 下一个点 采用链式来解决索引冲突问题</span></div><div class="line">&#125; dictEntry;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictType &#123;</div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;<span class="comment">// hash函数</span></div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">// key复制函数</span></div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);<span class="comment">// value复制函数</span></div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);<span class="comment">// key比较函数</span></div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);<span class="comment">// key释放函数</span></div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);<span class="comment">// value释放函数</span></div><div class="line">&#125; dictType;</div><div class="line"></div><div class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></div><div class="line"> * implement incremental rehashing, for the old to the new table. */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</div><div class="line">    dictEntry **table;<span class="comment">// 指针的数组头的指针</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;<span class="comment">// 大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">// 大小的掩码 总是等于size-1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;<span class="comment">// 被使用的节点数</span></div><div class="line">&#125; dictht;<span class="comment">// hash表</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</div><div class="line">    dictType *type;<span class="comment">// 绑定的函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;<span class="comment">// 私有数据</span></div><div class="line">    dictht ht[<span class="number">2</span>];<span class="comment">// hash表，一般只使用[0]，在rehash的时候使用[1]</span></div><div class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">// 记录rehash的进度，不进行rehash的时候为-1</span></div><div class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></div><div class="line">&#125; dict;<span class="comment">// 字典</span></div><div class="line"></div><div class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></div><div class="line"> * dictAdd, dictFind, and other functions against the dictionary even while</div><div class="line"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</div><div class="line"> * should be called while iterating. */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictIterator &#123;</div><div class="line">    dict *d;</div><div class="line">    <span class="keyword">long</span> index;</div><div class="line">    <span class="keyword">int</span> table, safe;</div><div class="line">    dictEntry *entry, *nextEntry;</div><div class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</div><div class="line">&#125; dictIterator;<span class="comment">// 迭代器</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>确认一个键值插入到字典的位置是哪，需要调用hash算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算key的hash值</span></div><div class="line">hash = dict-&gt;type-&gt;hashFunction(key);</div><div class="line"><span class="comment">//按位与确认在hash表中的位置</span></div><div class="line"><span class="comment">//根据情况，可能是ht[0]或者ht[1]</span></div><div class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</div></pre></td></tr></table></figure>
<p>字典在redis中使用MurmurHash2算法进行计算键的哈希值。有点在于计算速度非常快，即使输入的键有规律也能够很好的给出一个随机分布。</p>
<h2 id="键的冲突解决"><a href="#键的冲突解决" class="headerlink" title="键的冲突解决"></a>键的冲突解决</h2><p>在key获取的index相同的情况下，产生了键的冲突。redis采用链式解决冲突，新的键值放在链的头部。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着hash表不断插入删除数据，hash表的负载因子会不断变化。当负载因子在一个不合理的范围内，则redis的会对hash表进行rehash。</p>
<h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><p>渐进式rehash的目的是为了防止一次性rehash的情况下，服务器停止响应。</p>
<p>redis渐进式rehash的步骤:</p>
<p>1）为ht[1]分配空间，让字典同时持有 ht[0]和ht[1]两个哈希表</p>
<p>2）在字典位置一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</p>
<p>3）在rehash进行期间，每次对字典执行删除、添加、查找或者更新操作时候，程序除了执行指定的操作外，还顺便将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后将rehashidx属性的值增加1</p>
<p>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehsh至ht[1]，这时程序将rehashidx属性值设为-1，表示rehash操作已完成。</p>
<p>渐进式rehash过程中，字典会同时对ht[0]和ht[1]两个哈希表进行操作，字典在删除、查找、更新等操作会在两个哈希表进行。</p>
<p>在渐进式rehash执行期间，新添加到字典的键值对一律会被保存在ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减少不增加，并随着rehash操作的执行最终变为空。</p>
<p>rehash有两种方式，一种是单步，在字典没有安全迭代器的情况下能够执行。一种是执行一段时间跳出。两种方法均调用int dictRehash(dict *d, int n) 完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</div><div class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</div><div class="line">    <span class="comment">// 开始时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</div><div class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</div><div class="line">        rehashes += <span class="number">100</span>;</div><div class="line">        <span class="comment">// 时间到达，跳出</span></div><div class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rehashes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>int dictRehash(dict *d, int n) 算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//执行N步渐进式rehash操作，rehash之后如果旧表还存在数据，则返回1，不存在返回0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">// 最大允许访问的空桶值</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 判断是否允许rehash</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        <span class="comment">// rehashidx不能大于哈希表的大小</span></div><div class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</div><div class="line">        <span class="comment">// 跳过空节点</span></div><div class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            <span class="comment">// 超过空节点最大值，直接跳出</span></div><div class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取需要rehash的节点</span></div><div class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</div><div class="line">        <span class="comment">// 将该桶下所有节点移动到新表</span></div><div class="line">        <span class="keyword">while</span>(de) &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            <span class="comment">// 获取新表中hash索引</span></div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div><div class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</div><div class="line">            d-&gt;ht[<span class="number">0</span>].used--;</div><div class="line">            d-&gt;ht[<span class="number">1</span>].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否都迁移完成，完成返回0</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 释放旧表,将rehashidx设置为-1</span></div><div class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</div><div class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</div><div class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 未完成返回1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="dict部分API"><a href="#dict部分API" class="headerlink" title="dict部分API"></a>dict部分API</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dict *dictCreate(dictType *type, void *privDataPtr); // 创建一个新字典</div><div class="line">int dictExpand(dict *d, unsigned long size); // 在字典中创建一个新hash表</div><div class="line">int dictAdd(dict *d, void *key, void *val); // 尝试将给定键值添加到字典中</div><div class="line">dictEntry *dictAddRaw(dict *d, void *key); // 尝试将给定键插入到字典中，键已经存在则返回null</div><div class="line">int dictReplace(dict *d, void *key, void *val); // 将给定键值添加到字典中，如果已经存在就替换</div><div class="line">dictEntry *dictReplaceRaw(dict *d, void *key); // 将给定键值添加到字典中，如果已经存在则不添加，返回已经存在的值</div><div class="line">int dictDelete(dict *d, const void *key); // 删除字典中给定键的节点</div><div class="line">int dictDeleteNoFree(dict *d, const void *key);// 删除包含给定键的及诶单，但是不释放</div><div class="line">void dictRelease(dict *d); // 删除并释放整个字典</div><div class="line">dictEntry * dictFind(dict *d, const void *key); // 查找节点</div><div class="line">void *dictFetchValue(dict *d, const void *key); // 获取包含给定键的节点值</div><div class="line">int dictResize(dict *d); // 缩小字典，使得已用节点和字典大小比率接近1:1</div><div class="line">dictIterator *dictGetIterator(dict *d); // 创建并返回给定字典的不安全迭代器</div><div class="line">dictIterator *dictGetSafeIterator(dict *d); // 创建并返回给定节点的安全迭代器</div><div class="line">dictEntry *dictNext(dictIterator *iter); // 返回当前节点，指向下个节点</div><div class="line">void dictReleaseIterator(dictIterator *iter); // 释放迭代器</div><div class="line">dictEntry *dictGetRandomKey(dict *d); // 随机返回字典中一个节点</div><div class="line">void dictEmpty(dict *d, void(callback)(void*)); // 清空字典中所有哈希表节点，并重置属性</div><div class="line">void dictEnableResize(void); // 开启自动rehash</div><div class="line">void dictDisableResize(void); // 关闭自动rehash</div></pre></td></tr></table></figure>
<h3 id="创建dict"><a href="#创建dict" class="headerlink" title="创建dict"></a>创建dict</h3><p>使用dictCreate创建字典。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建字典</span></div><div class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type,</span></span></div><div class="line">        <span class="keyword">void</span> *privDataPtr)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 分配空间</span></div><div class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</div><div class="line"></div><div class="line">    <span class="comment">// 初始化字典</span></div><div class="line">    _dictInit(d,type,privDataPtr);</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</div><div class="line">&#123;</div><div class="line">    ht-&gt;table = <span class="literal">NULL</span>;</div><div class="line">    ht-&gt;size = <span class="number">0</span>;</div><div class="line">    ht-&gt;sizemask = <span class="number">0</span>;</div><div class="line">    ht-&gt;used = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化字典</span></div><div class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</div><div class="line">        <span class="keyword">void</span> *privDataPtr)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 重置hash表</span></div><div class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</div><div class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">    d-&gt;type = type; <span class="comment">// 设置字典类型</span></div><div class="line">    d-&gt;privdata = privDataPtr;</div><div class="line">    d-&gt;rehashidx = <span class="number">-1</span>; <span class="comment">// 初始为-1，表明没有进行rehash</span></div><div class="line">    d-&gt;iterators = <span class="number">0</span>; <span class="comment">//正在使用的迭代器数量</span></div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h3><p>使用int dictAdd(dict <em>d, void </em>key, void *val)添加键值对</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加一个键值对到dict中</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 往字典中添加一个只有key的键值对</span></div><div class="line">    dictEntry *entry = dictAddRaw(d,key);</div><div class="line"></div><div class="line">    <span class="comment">// 添加失败，则返回错误</span></div><div class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</div><div class="line">    <span class="comment">//使用宏，添加成功则设置key键值对的值</span></div><div class="line">    dictSetVal(d, entry, val);</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 添加键到字典中</span></div><div class="line"> <span class="comment">// 键存在则返回null</span></div><div class="line"> <span class="comment">// 不存在则创建节点，与键关联，并返回节点</span></div><div class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    dictEntry *entry;</div><div class="line">    dictht *ht;</div><div class="line"></div><div class="line">    <span class="comment">// 尝试进行单步式rehash</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    <span class="comment">// 尝试获取hash表中的索引值，返回-1表示键已经存在</span></div><div class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// rehash使用1号哈希表，不在rehash使用0号</span></div><div class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 分配空间，将节点添加到链表表头</span></div><div class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</div><div class="line">    entry-&gt;next = ht-&gt;table[index];</div><div class="line">    ht-&gt;table[index] = entry;</div><div class="line">    ht-&gt;used++;</div><div class="line"></div><div class="line">    <span class="comment">// 使用宏，设置新节点的键</span></div><div class="line">    dictSetKey(d, entry, key);</div><div class="line">    <span class="keyword">return</span> entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="替换键值对"><a href="#替换键值对" class="headerlink" title="替换键值对"></a>替换键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 如果键值不存在，返回1</span></div><div class="line"> <span class="comment">//存在，更新键值，返回0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></div><div class="line">&#123;</div><div class="line">    dictEntry *entry, auxentry;</div><div class="line"></div><div class="line">    <span class="comment">// 添加成功返回1</span></div><div class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 查找键</span></div><div class="line">    entry = dictFind(d, key);</div><div class="line">    </div><div class="line">    <span class="comment">// 更新键值</span></div><div class="line">    auxentry = *entry;</div><div class="line">    dictSetVal(d, entry, val);</div><div class="line"></div><div class="line">    <span class="comment">// 释放原值</span></div><div class="line">    dictFreeVal(d, &amp;auxentry);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找键值对"><a href="#查找键值对" class="headerlink" title="查找键值对"></a>查找键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></div><div class="line">&#123;</div><div class="line">    dictEntry *he;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</div><div class="line"></div><div class="line">    <span class="comment">// hash表大小为0，表名无值</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* We don't have a table at all */</span></div><div class="line">    <span class="comment">// 如果在rehash，则单步rehash</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    <span class="comment">// 查找索引</span></div><div class="line">    h = dictHashKey(d, key);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历索引下的键</span></div><div class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                <span class="keyword">return</span> he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果没有进行rehash，则不再查找ht[1]</span></div><div class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 删除该键值对，并释放键和值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除该键值对，不释放键和值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 查找并删除对应的键值对</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx;</div><div class="line">    dictEntry *he, *prevHe;</div><div class="line">    <span class="keyword">int</span> table;</div><div class="line"></div><div class="line">    <span class="comment">// 空则直接返回错误信息</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR; <span class="comment">/* d-&gt;ht[0].table is NULL */</span></div><div class="line"></div><div class="line">    <span class="comment">// rehash时，进行一次rehash</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line">    h = dictHashKey(d, key); <span class="comment">// 获取hash索引</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        prevHe = <span class="literal">NULL</span>;</div><div class="line">        <span class="comment">// 查找，遍历整个链表</span></div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key)) &#123;</div><div class="line">                <span class="comment">/* Unlink the element from the list */</span></div><div class="line">                <span class="keyword">if</span> (prevHe)</div><div class="line">                    prevHe-&gt;next = he-&gt;next;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</div><div class="line">                <span class="keyword">if</span> (!nofree) &#123;</div><div class="line">                    <span class="comment">// 根据传入参数是否释放键值</span></div><div class="line">                    dictFreeKey(d, he);</div><div class="line">                    dictFreeVal(d, he);</div><div class="line">                &#125;</div><div class="line">                zfree(he);</div><div class="line">                d-&gt;ht[table].used--;</div><div class="line">                <span class="keyword">return</span> DICT_OK;</div><div class="line">            &#125;</div><div class="line">            prevHe = he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没有进行rehash则不查找ht[1]</span></div><div class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字典删除"><a href="#字典删除" class="headerlink" title="字典删除"></a>字典删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清理释放整个字典</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 释放ht[0]</span></div><div class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>],<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 释放ht[1]</span></div><div class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>],<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 释放字典</span></div><div class="line">    zfree(d);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _dictClear(dict *d, dictht *ht, <span class="keyword">void</span>(callback)(<span class="keyword">void</span> *)) &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 释放所有元素</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; <span class="number">0</span>; i++) &#123;</div><div class="line">        dictEntry *he, *nextHe;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (callback &amp;&amp; (i &amp; <span class="number">65535</span>) == <span class="number">0</span>) callback(d-&gt;privdata);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((he = ht-&gt;table[i]) == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            nextHe = he-&gt;next;</div><div class="line">            <span class="comment">// 释放键值对</span></div><div class="line">            dictFreeKey(d, he);</div><div class="line">            dictFreeVal(d, he);</div><div class="line">            zfree(he);</div><div class="line">            ht-&gt;used--;</div><div class="line">            he = nextHe;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 释放hash表</span></div><div class="line">    zfree(ht-&gt;table);</div><div class="line">    </div><div class="line">    <span class="comment">// 重置hsh表</span></div><div class="line">    _dictReset(ht);</div><div class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">/* never fails */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis字典由哈希表实现的保存键值对的抽象数据结构。&lt;/p&gt;
&lt;p&gt;实现文件在dict.h\dict.c中。&lt;/p&gt;
&lt;h2 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h2&gt;&lt;p&gt;Redis字典结构体定义。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictEntry &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key;&lt;span class=&quot;comment&quot;&gt;// key 键&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *val;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;uint64_t&lt;/span&gt; u64;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int64_t&lt;/span&gt; s64;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; d;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; v;&lt;span class=&quot;comment&quot;&gt;// 值，支持多种类型,使用联合。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictEntry *next;&lt;span class=&quot;comment&quot;&gt;// 下一个点 采用链式来解决索引冲突问题&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictEntry;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictType &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(*hashFunction)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// hash函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*keyDup)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key);&lt;span class=&quot;comment&quot;&gt;// key复制函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*valDup)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *obj);&lt;span class=&quot;comment&quot;&gt;// value复制函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (*keyCompare)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key1, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key2);&lt;span class=&quot;comment&quot;&gt;// key比较函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*keyDestructor)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key);&lt;span class=&quot;comment&quot;&gt;// key释放函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*valDestructor)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *obj);&lt;span class=&quot;comment&quot;&gt;// value释放函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictType;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* This is our hash table structure. Every dictionary has two of this as we&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * implement incremental rehashing, for the old to the new table. */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictht &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictEntry **table;&lt;span class=&quot;comment&quot;&gt;// 指针的数组头的指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size;&lt;span class=&quot;comment&quot;&gt;// 大小&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; sizemask;&lt;span class=&quot;comment&quot;&gt;// 大小的掩码 总是等于size-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; used;&lt;span class=&quot;comment&quot;&gt;// 被使用的节点数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictht;&lt;span class=&quot;comment&quot;&gt;// hash表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dict &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictType *type;&lt;span class=&quot;comment&quot;&gt;// 绑定的函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata;&lt;span class=&quot;comment&quot;&gt;// 私有数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictht ht[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;// hash表，一般只使用[0]，在rehash的时候使用[1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; rehashidx; &lt;span class=&quot;comment&quot;&gt;// 记录rehash的进度，不进行rehash的时候为-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; iterators; &lt;span class=&quot;comment&quot;&gt;/* number of iterators currently running */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dict;&lt;span class=&quot;comment&quot;&gt;// 字典&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* If safe is set to 1 this is a safe iterator, that means, you can call&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * dictAdd, dictFind, and other functions against the dictionary even while&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * iterating. Otherwise it is a non safe iterator, and only dictNext()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * should be called while iterating. */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictIterator &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dict *d;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; index;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; table, safe;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictEntry *entry, *nextEntry;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* unsafe iterator fingerprint for misuse detection. */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; fingerprint;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictIterator;&lt;span class=&quot;comment&quot;&gt;// 迭代器&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书摘录-编程大师访谈录</title>
    <link href="http://yoursite.com/child//blog/2017/05/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95.html"/>
    <id>http://yoursite.com/child//blog/2017/05/读书摘录-编程大师访谈录.html</id>
    <published>2017-05-04T00:48:08.000Z</published>
    <updated>2017-05-04T00:49:55.025Z</updated>
    
    <content type="html"><![CDATA[<p>【美】Susan Lammers</p>
<p>第1篇　查尔斯•西蒙尼<br>2017-04-30<br>采访者：编程是一种技巧或技能吗？ 西蒙尼：什么是编程？人们对此一直各持己见。有人说它是科学，有人说它是艺术，还有人称之为技能或手艺。我认为这三方面兼而有之。我们喜欢说它蕴含大量艺术成分，但是我们都知道它里面更多的是科学。 孩子们在学校里学习数学，高中毕业时，他们会以为数学就是加法和乘法，甚或代数和微积分。其实，算术，即使简单如加法的运算，背后也有令人难以置信的科学理论作支持。 计算机编程背后也有大量科学理论作支持。例如，哥德尔定理的数学证明冗长而复杂，但是如果借用计算机科学的图灵定理，证明起来不费吹灰之力。信息理论和计算机科学其他领域对数学影响巨大，反之亦然。 编程包含有大量科学，同时，它也有点像手艺。实际上，在许多人看来，编程是一项复杂的技能，这跟工具制造很像，需要精雕细琢。我认为，只要将科学、艺术和技能这三者拿捏得恰到好处，你就能取得一些引人瞩目的成绩。<br>2017-04-30<br>别人读几段你的源代码，有没有可能断定“这代码是查尔斯·西蒙尼写的”？ 西蒙尼：噢，是的，毫无疑问。是不是我本人写的可能很难分辨，但有一点是确定无疑的：只要看了代码，你就能知道它是不是我的团队写的，或者是不是受我的影响写的。这是因为我从1972年起写的代码都遵循特定的命名规范，许多人称之为“匈牙利命名法”。你一眼就能分辨出哪些代码是受我的影响写出来的，包括Microsoft Word、Multiplan和Bravo，以及其他许多遵循这些规范写成的程序。<br>註: 原来是他<br>2017-04-30<br>进入公司第一天，程序员就会拿到几本书。其中一本是数学家乔治·波利亚写的《怎样解题》。（西蒙尼边说边从他办公桌旁的书柜里取出那本书，翻到某一页。）这两页很重要。这本书的其余内容就是基于这两页展开的。这就像一张问题求解的检查单。这是起飞前、起飞和着陆检查单。它不会教你如何飞行，但是如果不照做，即使你已经懂得怎么飞行，也有可能会坠机身亡。 求解问题时，我们遵循以下四个步骤：首先理解问题，然后拟定计划，接着执行计划，最后回顾整个过程。这样的书我们大概有四本，我觉得我们能使程序员比刚加入公司时变得更加优秀。</p>
<a id="more"></a>
<p>第2篇　巴特勒•兰普森<br>2017-04-30<br>但是我坚持认为，如果你打算在研究生院攻读计算机科学，那么本科学习计算机科学就是犯了大忌。 采访者：为什么？ 兰普森：因为从长远来看，你学的内容大部分都没什么价值。你学不到施展聪明才智的新方法，而这些方法对你来说，要比学习如何编写编译器的细枝末节有 用得多，尽管后者可能是你本科念计算机科学时的学习内容。我认为，要是所有计算机科学研究生院联合起来，一致决定不接受本科念计算机科学的毕业生，世界会变得更好。学校应当要求这些人补习一年，学习数学或历史等科目，才能继续攻读计算机科学的研究生。不过，我还没看到有学校这么做的。<br>2017-04-30<br>举例来说，鲍勃·斯普劳尔（Bob Sproull）和我花了大量时间设计Interpress项目，那是一种印刷标准。我为此投入了很大精力，原本衷心希望施乐公司接受并促使所有人采纳。相反，他们完全把它搞砸了。结果，参与开发的部分人员离职并创办了Adobe系统公司，开发出一种类似的产品PostScript。很显然，后者成了大家现在都会采用的标准。这种事情很恼人，但是研究实验室的主要产品就是创意。<br>註: 这不就和盛大研究院一样<br>2017-04-30<br>：程序员需要具备什么样的素质才能写出成功的程序？ 兰普森：最重要的素质是能够把问题的解决方案组织成容易操控的结构，其中每个组件都可以用简单的方式说明。有时，成功的程序员可以做到这一点，但他们无法解释自己做了什么，因为他们看不到那个结构。有些人之所以成为出色的程序员，是因为他们可以比多数人处理更多的细节。<br>2017-04-30<br>你有没有看到20年后每个指尖上都有一台计算机会出现什么问题？ 兰普森：我不觉得那有什么问题。显然每只手腕上都会有计算机。计算机的存在是予人帮助，我希望它们会给人们带来正面的影响。<br>註: 手机</p>
<p>第3篇　约翰•沃诺克<br>2017-05-01<br>你编程有什么诀窍？ 沃诺克：我不知道能不能归结到几点上。我前面提到过一些。不要早作绑定，尽可能推迟决定时间。眼界放宽一些，设计要比你自认为需要的程度更加灵活，因为从长远看你最终会需要这样。快速让某样东西工作起来，然后还能弃之不用。 从小的开始实验而不是大的入手学习。不要一头扎进周期长达两年且中间不出什么成果的开发当中。最好每两个月就要出点成果，这样你才能进行评估、重组和重新开始。程序员经常在一开始时过度定义他们的方法。他们可能会从一个中心构思着手，从第一天就开始编码。然后他们发现自己陷入重围，每件东西都开始膨胀，因为它们依赖于太多其他因素。应当反其道而行之，如果让过程较为宽松，保持一定的自由度，并在最后阶段加快速度，长远来说，你会做出更好的产品。</p>
<p>第4篇　加里•基尔代尔<br>2017-05-01<br>你说编程对很多人来说也是一种宗教体验，这是什么意思呢？ 基尔代尔：嗯，如果你和一群使用相同编程语言的程序员谈论编程的话，他们几乎可以成为那种编程语言的传教士。他们组成了一个紧密结合的社群，坚持一定的信念，在编程时遵循一定的规则。就像是一个把编程语言当作是圣经的教会。 FORTH是一个很好的例子，它是一种编程语言，对于很多人来说，可能很接近宗教的体验。当FORTH刚出来的时候，其信徒就声称它做任何算法都能快上十倍。这是一个典型的宣言。如果你在这点或其他任何方面有异议，你会发现自己是对牛弹琴，而且你是绝对不会被容许加入“教会”的。我并不想贬低使用这一种语言的人。那是一个非常能给人帮助的团体，所用的也是一种非常有效的语言，但他们没有基于理性去讨论问题，他们是基于信仰的。说过这句话，我可能会收到一千封有关FORTH及人们对其宗教体验的邮件。但是就算我能整天鼓吹LISP的神奇，我也不会把自己归到一个特殊的派别中。<br>註: 哈哈。php</p>
<p>第5篇　比尔•盖茨<br>2017-05-01<br>不，我认为在过了最初的三四年后，就会非常明显地显现出你是否是一个优秀的程序员。刚开始的几年中，你可能会更多地知道怎样去管理大型项目和不同个性的人，但在三四年后，就能很清楚地看出你会成为什么样的程序员了。在微软没有哪个程序员是在平庸了几年之后突然间一鸣惊人的。我和一个人谈谈他的程序，马上就能知道他是否是个好程序员。如果他真的很棒，每个细节他都会脱口而出。 就像下棋的人一样。如果你特别喜欢下棋，会很容易记住10盘棋中的每一步，因为你已置身其中了。其他人看到国际象棋选手或程序员能记住每个细节时，觉得他们像个怪物。其实这很正常。即使到了今天，在我写了微软的BASIC程序10年后，我仍可以在黑板上大段大段写出当时的源代码。<br>2017-05-01<br>编程需要非常大量的精力，所以大多数程序员都比较年轻。这就会带来一个问题，因为编程需要很多的训练。在年轻时，目标不是很持久，可能会被这样那样的事分心。但是年轻的程序员应当坚持下去，他们会变得更出色。作为程序员，我认为自己在1975年到1980年之间的提高是最明显的。在1975年，我会说：“嘿，看看，我什么事情都能做。”我真的认为自己可以，因为我读了大量代码，从来没有发现哪段代码是我无法快速读懂的。今天我仍旧认为检验编程能力的最好方法之一就是给程序员一本30来页的代码，看看他阅读和理解的速度有多快</p>
<p>第6篇　约翰•佩奇<br>2017-05-01<br>从一个计算机程序员转变到运营一个庞大的公司，你觉得困难吗？ 佩奇：这个角色转换是一个非常平缓的过程，因为我已经做了二十多年的管理人员，我可以告诉你真相，最难的是从管理者重新变成程序员。在创办公司前，我 在惠普已经习惯于领导很多人了。再回到编程工作时，我被迫完全依靠自己。真是让人一震。事实上这有点儿可怕——我不知道自己是否还能编程。但是，就像骑自行车一样——你永远都不会忘记的，只要一踏脚蹬，车就奔着夕阳去了。<br>2017-05-01<br>独自一人编程和一个团队合作编程有什么不同？ 佩奇：如果一个产品需要四到五个人开发，那和你自己一个人编程时采取的方法是不同的。我坚信只能由一个人来做产品和高层结构的设计，最多不能超过两个人。所有的设计出于一个头脑，才能够实现和谐与一致。如果试图取悦于所有人，让一个委员会来做设计，你的方向就错了。那绝对是致命的。 所以我在定义阶段会用一个人数非常少的团队来工作，然后如果有必要，再扩大团队来实施编程设计。实施设计方案所需要的队伍越大，就越必须严格地把整个系统划分成可管理的模块，并定义好相互间的接 口。除非一个程序大到必须由两三个人以上来做，否则不必编写很多结构化程序报告，也不用为每个步骤都编写文档。 有些系统，例如设计一个控制航天飞机的程序，需要上百名程序员。那就必须严格地把结构划分成可管理的模块才行。一个小系统的架构可能会过于大，一个大系统的架构可能会过于小——使用的技术必须与问题的规模相匹配。我就是这样做的。<br>2017-05-01<br>有些人觉得完成项目真是太过瘾了，他们做完一个项目就接着又做另一个了。这样会把自己累垮的。如果连续开始新的项目，情况会变得很糟。 另外，当你在复杂的程序上艰苦工作时，锻炼身体是很重要的。大部分程序员都缺乏身体锻炼，这样会失去敏锐的思维。往往在连续完成了第二个或第三个工作后，身体就虚弱了，以至于你会产生幻灭感，你会对着镜子说：“上帝啊，看看我，我为什么要这样做呢？</p>
<p>第7篇　C.韦恩•莱特莱夫<br>2017-05-01<br>另一方面，非常有意思的是专家系统。我的预测是，在两三年之内，专家系统不必再和人工智能牵扯在一起。这就是人工智能的历史：当某件东西开始变得众所周知时，它就独立出来了。模式识别曾经被当作是人工智能，但现在这是一个独立的领域。这也正是专家系统当下的命运。我认为专家系统在我们产业里将变得非常重要，就像垂直应用一样。<br>註: 和现在一样</p>
<p>第11篇　雷•奥奇<br>2017-05-02<br>我推崇严谨、一致而清晰的结构。另外，我认为软件应该高度模块化和分层，非常灵活地运用大量文件和目录。如果你必须分别构建不同组件，那么接口自然就会更加凸显出来，要求你规范这些接口。<br>当许多人共同开发一个程序时，在项目早期确立全局的错误处理、参数传递和子程序命名规范（虽然不见得所有人都会同意），显得非常重要。不过，对于代码该怎么注释、大括号怎么用或者代码该怎么缩进，我觉得你绝不应该对别人指手画脚。在修改别人的模块时，你最好还是按照他的惯例编写代码。这是学会与他人共事的必修课。<br>交流想法的环境应该是开放的。设计会议上允许非常激烈和紧张的讨论。我发现许多优秀设计师往往固执己见，但只要他们觉得是对的，就会毫不客气地坚持，但他们也知道什么时候应该怎么让步。优秀设计师不会有“非此创造”综合征。<br>2017-05-02<br>我过去常想，个人时间管理程序应该会非常便利。结果现在却得在公文包里装一台计算机随身携带，打开并启动计算机，就只为了查看我的会面安排，远不及我那口袋大小的通讯记事簿来得方便。我想要一本通讯记事簿，让我的秘书和我可以同时写入，这非常有用，因为我们俩都能便捷地安排我的时间。我希望哪个聪明的家伙能发明这种记事簿。<br>註: 手机日程管理软件</p>
<p>第14篇　杰夫•拉斯金<br>2017-05-03<br>1979年，苹果公司正致力于开发Lisa。不管你信不信，它最初的目标是开发一款字符界面的机器。我在苹果公司担任高级系统经理，对Lisa很不满。它非常昂贵，我认为苹果公司不够理智，居然以小型机的价格去跟DEC、通用数据公司和IBM比拼。<br>70年代初，我在斯坦福大学人工智能实验室做访问学者期间，在施乐PARC度过了大量时光。在我看来，施乐PARC在位图屏幕、通用键盘和图形方面的研究真是不可思议。因此，我极力游说，说服苹果公司把Lisa改成位图机器。我把施乐和苹果公司撮合到一起。施乐一度持有苹果公司10%的股票。<br>我提议开发一款容易使用并融合文字和图形的电脑，售价在1000美元左右。乔布斯认为这想法太疯狂了，这种机器不会有销路，我们绝不要这种玩意。他试图否决这个项目。<br>因此，我越过乔布斯直接找到当时的董事长迈克·马库拉（Mike Markkula），和他探讨我的想法。幸运的是，马库拉和时任总裁迈克·斯科特（Mike Scott）叮嘱乔布斯别管我。<br>我招揽了早期成员：巴德·特里伯（Bud Tribble）、布里安·霍华德（Brian Howard）和布雷尔·史密斯（Burrell Smith）。我们搬到另一栋大楼，打造Macintosh及其软件的原型，搭建并让它运行起来。后来，乔布斯接手后，他还编了个故事，把Mac项目称为“海盗行动”。我们并未像他后来说的那样，试图让这个项目远离苹果公司。我们跟苹果公司其他部门的联系十分紧密，我们只是尽量不让乔布斯干预这个项目。在头两年，乔布斯总想着要毙掉这个项目，因为他不明白它到底是怎么回事。<br>最初的Macintosh设计得既精心又合理。最后，苹果公司所有人都意识到，这是公司继Apple II后推出新产品的希望所在。随后，乔布斯接管了这个项目。他径直走进来，对我说：“我接手Macintosh硬件，你可以负责软件和出版物。”他抛出软件设计，要求Macintosh软件与Lisa保持兼容，并坚持使用鼠标。机器变得更大、更复杂，也昂贵得多。现在它跑起来黏糊糊的。你有没有用过MacWrite？我们这里把它叫做MacWait。又过了几个月，乔布斯对我说：“我来接手软件，你可以负责出版物。”于是我回答：“你也可以接手出版物。”说完便离开了。那是1982年5月。他和马库拉对我说：“请别走。再过一个月，我们会提供一份你无法拒绝的薪酬。”于是我给了他们一个月时间，他们开了一份薪酬，我没接受。<br>2017-05-03<br>近期《新闻周刊》上的一篇文章把我逗乐了，他说：“我还有几个不错的设计。”他从来没做过什么设计，他一款产品都没设计过。沃兹（Steve Wozniak）设计了Apple II。肯·罗斯穆勒（Ken Rothmuller）等人设计了Lisa。我和我的团队设计了Macintosh。温德尔·桑德斯（Wendell Sanders）设计了Apple III。乔布斯设计了什么？什么也没有。<br>註: 哈哈，乔布斯<br>2017-05-03<br>人工智能教会了我们大量关于我们自身以及知识的内容。非常廉价的机器上用不了靠谱的人工智能程序，至少目前行不通。<br>真正的人工智能有点像宗教。从前人们都说天空上面就是天堂和天使。然后你搭乘火箭飞船到了那里，发现并不是那么回事。于是你知道原来的理解有误。一旦你实现了某样东西，它就不再是人工智能。<br>曾几何时，国际象棋博弈程序一度被认为包含人工智能的成分。当我还在念研究生时，只要学会编写国际象棋博弈程序，你就可以拿到人工智能博士学位。现在你花上29.95美元就能买到国际象棋博弈程序，没有人称之为人工智能。它只是个会下棋的小算法。<br>首先，有个定义的问题。然后，它变得更加复杂。人们认为程序应该理解自然语言，但我们的话语方式对电脑或别人来说太不精确，无法弄清楚要做什么。这正是我们创造编程语言的原因。只要试过以英文写成的规格为基础开展工作，他们就会知道自己无法借此编写程序，因为它不够精确。因此，如果人类都不能做到这一点，基本上就不可能指望还能让机器做到。当你面对所谓的人工智能程序时，电脑必须已经掌握一个词汇表。比方说，你有5个命令，你想让机器理解与之等价的所有可能的英文表述，但是它理解不了所有等价的英文表述。有人可能会说：“拿个工号。”而英国绅士可能会说：“劳烦你给我们的员工派个数字编号。”这正是搞AI的人试图解决的大麻烦。<br>人工智能相关的许多承诺都被误解了。人工智能已经教导我们的有关语言的东西是美好的。那么，我是否认为人工智能值得做？绝对是。我是否认为这会转化出很棒的产品？会有一些。我是否认为这会实现你在大众传媒上了解到的承诺？根本不会。我会投很多钱到人工智能领域吗？没门</p>
<p>第15篇　安迪•赫兹菲尔德<br>2017-05-03<br>有个故事是关于沃兹的。沃兹是公司创始人之一，不用说，他分到了大量股票。有些人一点股票都没有，而有的人却拥有这么多股票，对此他觉得很不公平。于是他拿出自己的股票，宣布只要是在苹果公司工作满一定年限的员工，都可以从他那里买到2500股。沃兹的用意无疑是最好的，但结果这反倒让那些坏心肠的人欢天喜地。事情是这样的，许多不在乎钱财的雇员并没有行使股票购买权，于是那些贪心的家伙就对他们说：“好吧，我给你钱，我来买你的股份。”有些人不再认真工作，反而成了股票买手；他们令人生厌，个性糟糕，是不够格的工程师，毛孔里都滴着贪婪。在一个月内，有个家伙光靠这个捞了几十万美元。这实质上是在窃取沃兹的钱财。但这也是苹果公司上市时发生的故事的一部分。<br>到了1980年年底，在苹果公司工作不再那么有趣。通常你的头儿是从另一家公司挖过来的，对产品一无所知。最后，迈克·斯科特意识到苹果公司聘请的管理人员都是些眼高手低的家伙，1981年2月，他在一天之内把这些人都给解雇了。工程部门一共有90人，他解雇了其中40人。这一天在苹果历史上被称为“黑色星期三”。人们都惊呆了。<br>2017-05-03<br>就在Mac发布之后，Mac团队开始组建管理层的时候，我离开了苹果公司。我跟新来的技术经理有矛盾，他最初是我面试和同意录用的，没想到他是个控制和权力狂。这家伙认为我太傲慢，自以为可以通过考核给我差评打击我。我很震惊。我掏心掏肺地为这家公司卖命，尽我所能做到最好，每天工作15个小时开发这个项目。Macintosh本不该是这样的，但是这家伙却进来把它搞成了这样。因此我不得不选择离开，但是我把自己生命中整整两年献给了Macintosh，它是我最在意的。所以我一直待到Mac发布之后才离开苹果公司，开始自己单干。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【美】Susan Lammers&lt;/p&gt;
&lt;p&gt;第1篇　查尔斯•西蒙尼&lt;br&gt;2017-04-30&lt;br&gt;采访者：编程是一种技巧或技能吗？ 西蒙尼：什么是编程？人们对此一直各持己见。有人说它是科学，有人说它是艺术，还有人称之为技能或手艺。我认为这三方面兼而有之。我们喜欢说它蕴含大量艺术成分，但是我们都知道它里面更多的是科学。 孩子们在学校里学习数学，高中毕业时，他们会以为数学就是加法和乘法，甚或代数和微积分。其实，算术，即使简单如加法的运算，背后也有令人难以置信的科学理论作支持。 计算机编程背后也有大量科学理论作支持。例如，哥德尔定理的数学证明冗长而复杂，但是如果借用计算机科学的图灵定理，证明起来不费吹灰之力。信息理论和计算机科学其他领域对数学影响巨大，反之亦然。 编程包含有大量科学，同时，它也有点像手艺。实际上，在许多人看来，编程是一项复杂的技能，这跟工具制造很像，需要精雕细琢。我认为，只要将科学、艺术和技能这三者拿捏得恰到好处，你就能取得一些引人瞩目的成绩。&lt;br&gt;2017-04-30&lt;br&gt;别人读几段你的源代码，有没有可能断定“这代码是查尔斯·西蒙尼写的”？ 西蒙尼：噢，是的，毫无疑问。是不是我本人写的可能很难分辨，但有一点是确定无疑的：只要看了代码，你就能知道它是不是我的团队写的，或者是不是受我的影响写的。这是因为我从1972年起写的代码都遵循特定的命名规范，许多人称之为“匈牙利命名法”。你一眼就能分辨出哪些代码是受我的影响写出来的，包括Microsoft Word、Multiplan和Bravo，以及其他许多遵循这些规范写成的程序。&lt;br&gt;註: 原来是他&lt;br&gt;2017-04-30&lt;br&gt;进入公司第一天，程序员就会拿到几本书。其中一本是数学家乔治·波利亚写的《怎样解题》。（西蒙尼边说边从他办公桌旁的书柜里取出那本书，翻到某一页。）这两页很重要。这本书的其余内容就是基于这两页展开的。这就像一张问题求解的检查单。这是起飞前、起飞和着陆检查单。它不会教你如何飞行，但是如果不照做，即使你已经懂得怎么飞行，也有可能会坠机身亡。 求解问题时，我们遵循以下四个步骤：首先理解问题，然后拟定计划，接着执行计划，最后回顾整个过程。这样的书我们大概有四本，我觉得我们能使程序员比刚加入公司时变得更加优秀。&lt;/p&gt;
    
    </summary>
    
      <category term="摘录" scheme="http://yoursite.com/child/categories/%E6%91%98%E5%BD%95/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/child/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>读书摘录-调试九法：软硬件错误的排查之道</title>
    <link href="http://yoursite.com/child//blog/2017/04/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%EF%BC%9A%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B9%8B%E9%81%93.html"/>
    <id>http://yoursite.com/child//blog/2017/04/读书摘录-调试九法：软硬件错误的排查之道.html</id>
    <published>2017-04-30T08:54:08.000Z</published>
    <updated>2017-04-30T08:55:07.674Z</updated>
    
    <content type="html"><![CDATA[<p>【美】阿甘斯</p>
<p>第3章 理解系统<br>2017-04-07<br>你必须掌握系统的工作原理以及它是如何设计的。在某些情况下，还要知道为什么这样设计。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方。（这不仅仅是“墨菲定律”的问题，如果你不能理解你所设计的系统，你的工作可能会变得一团糟。）</p>
<p>3.1 阅读手册<br>2017-04-07<br>如果你是一位工程师，正在调试自己公司的产品，那么你需要读一读内部手册。工程师们设计它是用来做什么的？读一下功能说明以及所有的设计规范，研究一下图表、时序图和状态机。分析它们的代码，还要读一下注释。（是的，读一下注释，这非常重要。）一定要检查产品的设计。查明构建它的工程师们打算用它来做什么（除了用它来赚钱买辆宝马车以外）。<br>注意，手册上的信息也不可全信。手册（以及那些只想着赚钱买宝马车的工程师们）可能也是错的，很多难以发现的bug就出现在这里。但你仍需要了解他们的想法，哪怕其中有些信息是很难接受的。</p>
<p>3.2 逐字逐句阅读整个手册<br>2017-04-07<br>参考设计和样本程序给出了产品的一种使用方式，有时这些就是能获得的全部文档了。但是，在使用这些设计时一定要注意，创建它们的人往往只了解他们的产品，而没有遵循好的设计实践，或者不是为真实应用而设计的（最常见的缺点是不能进行错误恢复）。不要照搬这些设计，如果你没有在开始的时候发现bug，那么将来也会发现。此外，即使是最好的参考设计可能也不会完全符合应用程序的特定需求，而不符合的地方可能就是出问题的地方。当我照搬了朋友的微处理器设计时，就发生了问题，因为他的设计无法处理中<br><a id="more"></a><br>3.3 知道什么是正常的<br>2017-04-07<br>当你检查系统时，必须知道系统的正常工作状态。如果你不知道低位字节首先由使用了Intel芯片的PC程序来处理，那么你会认为所有长字（longword）都是随意处理的。如果你不知道缓存是干什么的，就会非常奇怪有些数据为什么没有马上写入内存。如果你不了解三态（tri-state）数据总线的工作原理，你将会认为它们可能是主板上的故障信号。如果你从未听说过电锯，你可能会认为那个发出讨厌的嗡嗡声的东西一定是出了什么毛病。知道什么是正常的可以帮助你注意到什么是不正常的。<br>你必须掌握一些你所工作的技术领域的基础知识。如果我不知道时钟选通脉冲和地址线是做什么的，那么即使我读了手册之后也无法理解中断问题。本书中几乎所有的（即使不是全部的话）示例都假定人们已经掌握了系统工具原理的一些基本知识。（如果我在前面使你误认为读完本书就可以调试任何技术领域的bug，那么请恕我无心之过。如果你是一位游戏编程人员，最好不要去管核电厂的调试。如果你不是医生，那么就不要试图诊断你手臂上的灰绿色斑点是什么。如果你是一位政客，那么就不要介入任何有关bug的事情。）</p>
<p>3.7 小结<br>2017-04-07<br>理解系统<br>这是第一条规则，因为它是最重要的。<br>阅读手册。它会告诉你在使用除草机时，要在除草头上涂润滑油，这样除草绳就不会被烧化。<br>仔细阅读每个细节。有关微处理器如何处理中断的详细信息就隐藏在数据手册的第37页。<br>掌握基础知识。电锯本来就会发出很大的噪声。<br>了解工作流程。引擎的转速可能与轮胎的转速不同，这是由传动轴造成的。<br>了解工具。弄清楚体温计的哪一端才是用来测量体温的，弄清楚Glitch-O-Matic逻辑分析器的强大功能是如何使用的。<br>查阅细节。连爱因斯坦都会去查阅细节，而Kneejerk却盲目相信自己的记忆力</p>
<p>第4章 制造失败<br>2017-04-09<br>“当你发现一个故障时该怎么办？”他会回答说：“试着让它再次发生。”（Charlie是一位训练有素的调试人员）。这样做有3个原因。<br>可以观察它。要观察错误（下一节将更详细地讨论这个问题），就必须使它发生。我们必须尽可能有规律地制造失败。在前面讲的电视游戏的例子中，当问题发生时我可以集中注意力观察示波器（虽然当时我已经很疲倦）。<br>可以专心查找原因。准确地知道问题在什么条件下会发生，有助于集中精力查找原因（但是请注意，有时这会产生误导，例如，“烤箱只有在你把面包放进去的时候才会把面包烤焦，因此问题就出在面包上。”这个问题后文也会详细讨论。）<br>可以判断是否已修复问题。当你认为已经修复了问题时，如何才能确信它确实已被修复呢？那就是明确知道问题是如何发生的。当问题没有修复时，如果你执行X操作，失败率为100%；在修复问题后，再执行X操作，如果失败率为0，那么你知道bug确实已被修复。（我这么说并不多余。很多时候，开发人员在修复bug时会修改软件，然后在一个与当初发现bug的不同条件下测试新软件。软件当然能运行，即使他在代码中输入一行打油诗，而他也高兴地回家了。然而，几星期后，在测试过程中，或者更糟，在客户现场，软件再次失败。后文将讨论更多这方面的内容。</p>
<p>4.4 不要模拟失败<br>2017-04-09<br>记住，这并不意味着不能用自动化过程来引发失败，也不意味着在这个过程中不能采用一些起到放大效果的措施。自动测试能够使间歇性的问题更快发生，例如电视游戏的例子。放大效果可以使得细微的问题更明显，例如在修窗户的例子中，我可以用喷水管来找到漏雨的窗户，而不用等待偶尔才有的暴风雨来检查。这两种技术都有助于引发失败，而不是模拟失败的机理。所做的改变应该是一些高层次的改变，只影响错误发生的频率，而不影响错误的发生方式。<br>此外，还要注意不要画蛇添足，引发新的问题。不要因为假设芯片的问题是由于热量引起的，就用热风枪来给芯片加热以模拟错误，这样只会把芯片烧化，然后你会误认为bug完全就是电路板上那堆被烧化的塑料。如果我用消防用的水龙来检查漏雨问题，可能会断定问题显然就是出在被击碎的窗子上。</p>
<p>4.9 小结<br>2017-04-10<br>制造失败<br>虽然看起来很简单，但如果不制造失败的话，调试就会变得很困难。<br>制造失败。目的是为了观察它，找到原因，并检查是否已修复。<br>从头开始。修车工需要知道汽车车窗在被冻结之前你洗过车。<br>引发失败。用喷水管向漏雨的那扇窗子喷水。<br>但不要模拟失败。用喷水管向漏雨的那扇窗子喷水，而不要向另一扇不同的、“类似的”窗子喷水。<br>查找不受你控制的条件（正是它导致了间歇性失败）。改变能够改变的每件事情，振动、摇晃、扭曲，直到再现失败。<br>记录每件事情，并找到间歇性bug的特征。我们的绑定系统总是只在呼叫顺序错乱时才会失败。<br>不要过于相信统计数据。绑定问题看起来与时间段有关，但实际上真正的原因是当地的年轻人占用了电话线路。<br>要认识到“那”是可能会发生的。甚至冰淇淋的口味也会影响汽车的发动。<br>永远不要丢掉一个调试工具。自动击球板可能在某一天就会派上用场。</p>
<p>5.6 猜测只是为了确定搜索的重点目标<br>2017-04-11<br>不要想，而要看”并不意味着不能做任何猜想。事实上猜测是好事，特别是当你理解了系统之后。你的猜测可能很接近事实，但猜测只是为了确定搜索的重点。在尝试修复问题之前，仍需要再次看到失败，以便确认你的猜测是正确的。</p>
<p>5.7 小结<br>2017-04-11<br>不要想，而要看<br>凭空想象，问题可能有几千条原因。而实际的原因只有去看了才能发现。<br>观察失败。高级工程师看到了真实的问题，并且能够找到原因。而初级工程师们认为他们知道错误发生在哪里，结果他们修复的地方根本没有出错。<br>查看细节。听到水泵似乎发出声音时不要停下来。到地下室查明是哪个水泵。<br>植入插装工具。使用源代码调试器、调试日志、状态消息、信号灯和臭鸡蛋的气味。<br>添加外部插装工具。使用分析器、示波器、量表、金属检测仪、心电图仪和肥皂泡。<br>不要害怕深入研究。虽然它是软件成品，但它出问题了，你必须打开并修复它。<br>注意海森堡效应。不要让仪器影响了系统。<br>猜测只是为了确定搜索的重点。大胆地猜测内存时序发生了错误，但在修复之前应该先查看它。</p>
<p>6.4 修复已知bug<br>2017-04-12<br>有时，我们很难相信一个系统中会有多个bug，就像在旅店预订的例子中一样。这使得用“分而治之”原则隔离每个bug变得更加困难。因此，如果同时出现了多个问题，当你确实查明了其中的一个问题时，应该立即修复它，然后再查找其他问题。我总听人们说“那里出问题了，但它不可能影响我们正在查找的问题。”事实上，它确实（而且经常）会产生影响。如果你修复了已知的错误，就可以专心致志地查找其他问题。在旅店预订系统中，技术人员只有在修复了转接盒中的双向电阻阻值过高的问题之后，才能够发现速度最慢的那台终端的接线问题。<br>有时修复了一个问题，另一个问题也解决了，两个问题实际上是同一个bug。<br>此外，如果修复某个问题对其他的问题有影响，一定要首先修复它之后再测试其他的问题。如果修复了一个问题后将会引发新的问题，那么你可以尽早发现，并有更多时间处理新的问题。</p>
<p>6.5 首先消除噪声干扰<br>2017-04-12<br>人们也很容易成为一个“完美主义者”，为了达到全面的高质量把你发现的所有不好的设计都“修复”一遍。你可能只是因为先前的程序员编写的GOTO语句看起来很差劲就删掉它们，但是，如果它们并没有实际引起问题，最好还是保留它们吧。</p>
<p>6.6 小结<br>2017-04-12<br>分而治之<br>当bug的藏身之地不断被缩小一半时，它将很难再隐藏下去。<br>通过逐次逼近缩小搜索范围。猜测1～100内的一个数字，只需7次。<br>确定范围。如果数字是135而你却认为它在1～100内，那么你必须扩大范围。<br>确定你位于bug的哪一侧。如果你所在的位置有排放物，则排放管就在上游。如果没有排放物，则排放管就在下游。<br>使用易于查看的测试模式。从干净、清澈的水开始，以便当排放物进入河流中时很容易看到它。<br>从有问题的一端开始搜索。如果你验证的是正确的部分，那么需要验证的地方太多了。应该从有问题的地方开始，然后向后追查原因。<br>修复已知bug。bug互相保护，互相隐藏。因此一旦找到，立即修复它们。<br>首先消除噪声干扰。注意那些导致系统问题的干扰因素。但对一些无足轻重的问题不要过于极端，也不要为了追求完美而去修改所有地方。</p>
<p>第7章 一次只改一个地方<br>2017-04-12<br>我们的软件工程师为了修复问题而更改了一个地方，但这个修改并没有解决问题，而他认为这不会产生什么影响。这是一个非常错误的假设。它确实有影响，它使得音频数据发生错误，只是两次错误与一次错误也没有什么太大的区别。当原来的错误被修复后，他犯的错误仍然存在，因此声音的质量仍很差。当他的修改没有解决问题时，应该立即把它改回来。<br>註: 经常遇到</p>
<p>7.2 用双手抓住黄铜杆<br>2017-04-23<br>在很多情况下，你可能想改变系统的不同部分，以便看看它们是否对问题有影响。这往往是一个危险的信号，说明你正在猜测，而不是使用插装工具来观察正在发生什么。你正在改变条件，而不是捕捉错误的自然发生。这可能会把最初的错误隐藏起来，而且引起更多错误。</p>
<p>7.5 自从上一次能够正常工作以来你更改了什么<br>2017-04-23<br>有时，正常的系统和错误的系统之间的区别是由于一项更改造成的。做了更改之后，正常的系统开始出现故障。一种非常有效的办法是找出第一个导致系统出错的版本，尽管这可能需要连续测试原来的版本，直到找到没有故障的版本。一旦找到了这个版本，再前进到下一个版本，验证故障是否再次出现。做完这一步之后，至少可以把问题的范围限定到两个版本之间所做的修改。<br>2017-04-23<br>问题已经存在了很长时间，但只是某个地方（例如时序或数据库大小）被改变之后，它才显露出来</p>
<p>7.6 小结<br>2017-04-23<br>一次只改一个地方<br>我们在生活中要有一点先见之明。如果你所做的更改没有起到预期的作用，那么就把它改回来。它们可能会产生无法预料的影响。<br>隔离关键因素。如果你在检查日照时间的影响，就不要改变灌溉方案。<br>用双手抓住黄铜杆。如果你在不知道具体发生了什么问题的情况下就试图去修理核潜艇，可能会引发一次水下的切尔诺贝利爆炸。<br>一次只改一个测试。我之所以知道我的VGA采集相位被破坏了，就是因为其他东西都没有发生改变。<br>与正常情况进行比较。如果所有出错的情况都有一些特征，而这些特征是正常情况所没有的，那么<br>你就找到了问题所在。<br>确定自从上一次正常工作以来你改变了什么地方。我的工友改变了唱机转盘上的唱头，因此这是一个很好的调试起点。</p>
<p>8.6 小结<br>2017-04-23<br>保持审计跟踪<br>不要只是在心里记住“保持审计跟踪”这条规则，而要把它写下来。<br>把你的操作、操作的顺序和结果全部记录下来。你上一次喝咖啡是什么时候？你的头痛是从什么时候开始的？<br>要知道，任何细节都可能是重要的。视频压缩芯片的崩溃是由于格子衬衫造成的。<br>把事件关联到一起。“它发出噪声，从21:04:53开始，持续4秒”比仅仅说“它发出噪声”要好得多。<br>用于设计的审计跟踪在测试中也非常有用。软件配置控制工具可以告诉你哪次修订引入了bug。<br>把事情记录下来！无论那个时刻多么恐怖，都要把它记到备忘录中，这样你才不会忘记。</p>
<p>9.4 小结<br>2017-04-23<br>检查插头<br>一些显而易见的假设往往是错误的。请恕我赘述，假设错误通常是最容易修复的错误。<br>置疑你的假设。是否运行了正确的代码？是不是燃气用完了？插头是否已插好？<br>从头开始。是否正确地对内存进行了初始化？是否按了除草机上的“primer bulb”按钮？开关是否已打开？<br>对工具进行测试。是否运行了正确的编译器？燃料油表是否被粘住了？量表是不是没电了？</p>
<p>10.5 小结<br>2017-04-23<br>获得全新观点<br>不管怎样，你都需要休息一下，喝杯咖啡。<br>征求别人的意见。甚至一个不说话的人体模特也能帮助你认识到你先前没有注意到的事情。<br>获取专业知识。只有VGA视频采集卡的厂商才能够肯定相位功能发生了错误。<br>听取别人的经验。别人会告诉你车内顶灯的线被挤压出来了。<br>帮助无处不在。同事、供应商、网络，还有书店，都在等待着为你提供帮助。<br>放下面子。bug发生了。以除掉bug为自豪，而不要非得以自己除掉bug才为自豪。<br>报告症状，而不要讲你的理论。不要把别人拖进你的思维定式中。<br>你提出的问题不必十分肯定。甚至连“穿了格子衬衫”这样的事情也可以提出来。</p>
<p>11.6 小结<br>2017-04-23<br>如果你不修复bug，它将依然存在<br>现在你已经掌握了所有的技术，没有理由再让bug存在了。<br>查证问题确实已被修复。不要假设是电路的问题，而仍然让汽车带着脏的滤油嘴上路。<br>查证确实是你的修复措施解决了问题。口中大喊“Wubba!”并不是使计算机打开的窍门。<br>要知道，bug从来不会自己消失。使用最初导致它失败的方法再次制造失败。如果必须交付产品，那么就在产品中设计一个用于捕捉bug的“陷阱”，以便产品在客户现场发生失败时，把它捉住。<br>从根本上解决问题。在烧坏另一台变压器之前，先把无用的8音轨磁带卡座扔掉。<br>对过程进行修复。不要只是擦掉地上的油，而要纠正设计机器的方式。</p>
<p>14.3 小结<br>2017-04-25<br>从帮助台得到的观点是不明确的<br>只能通过远程方式了解问题，眼睛和耳朵接收到的信息并不十分准确，而且关键是时间紧迫。<br>遵循规则。无论用户多么糊涂，都必须找到应用规则的途径。<br>对行动和结果加以确认。用户会误解你的意思，同时会犯错误。通过确认他们所说和所做的一切可以及早发现这些问题。<br>使用自动工具。不要让用户参与系统生成的日志和远程监控与控制工具。<br>即使是最简单的假设也需要确认。是的，有些人就是不知道有电才能使用字处理器。<br>使用可用的故障检修指南。要处理的很可能就是已知的、好的设计。不要忽略历史。<br>帮助完善故障检修指南。如果找到了某个已知系统的一个新问题，将解决问题的所有内容进行归档可以帮助下一位支持人员。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【美】阿甘斯&lt;/p&gt;
&lt;p&gt;第3章 理解系统&lt;br&gt;2017-04-07&lt;br&gt;你必须掌握系统的工作原理以及它是如何设计的。在某些情况下，还要知道为什么这样设计。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方。（这不仅仅是“墨菲定律”的问题，如果你不能理解你所设计的系统，你的工作可能会变得一团糟。）&lt;/p&gt;
&lt;p&gt;3.1 阅读手册&lt;br&gt;2017-04-07&lt;br&gt;如果你是一位工程师，正在调试自己公司的产品，那么你需要读一读内部手册。工程师们设计它是用来做什么的？读一下功能说明以及所有的设计规范，研究一下图表、时序图和状态机。分析它们的代码，还要读一下注释。（是的，读一下注释，这非常重要。）一定要检查产品的设计。查明构建它的工程师们打算用它来做什么（除了用它来赚钱买辆宝马车以外）。&lt;br&gt;注意，手册上的信息也不可全信。手册（以及那些只想着赚钱买宝马车的工程师们）可能也是错的，很多难以发现的bug就出现在这里。但你仍需要了解他们的想法，哪怕其中有些信息是很难接受的。&lt;/p&gt;
&lt;p&gt;3.2 逐字逐句阅读整个手册&lt;br&gt;2017-04-07&lt;br&gt;参考设计和样本程序给出了产品的一种使用方式，有时这些就是能获得的全部文档了。但是，在使用这些设计时一定要注意，创建它们的人往往只了解他们的产品，而没有遵循好的设计实践，或者不是为真实应用而设计的（最常见的缺点是不能进行错误恢复）。不要照搬这些设计，如果你没有在开始的时候发现bug，那么将来也会发现。此外，即使是最好的参考设计可能也不会完全符合应用程序的特定需求，而不符合的地方可能就是出问题的地方。当我照搬了朋友的微处理器设计时，就发生了问题，因为他的设计无法处理中&lt;br&gt;
    
    </summary>
    
      <category term="摘录" scheme="http://yoursite.com/child/categories/%E6%91%98%E5%BD%95/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/child/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>vs2017与vs2005冲突解决</title>
    <link href="http://yoursite.com/child//blog/2017/04/vs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3.html"/>
    <id>http://yoursite.com/child//blog/2017/04/vs2017与vs2005冲突解决.html</id>
    <published>2017-04-16T06:24:59.000Z</published>
    <updated>2017-04-16T07:13:28.695Z</updated>
    
    <content type="html"><![CDATA[<p>先安装vs2005，后安装vs2017，vs2017无法运行<br>原因：vs2005注册了Microsoft.VisualStudio.Shell.Interop.8.0.dll，优先于vs2017需要的dll。导致运行错误。</p>
<p>解决方法：</p>
<p>复制<br>C:\Program<em>Files</em>(x86)\Microsoft_Visual Studio\2017\Enterprise\Common7\IDE\PublicAssemblies\Microsoft.VisualStudio.Shell.Interop.8.0.dll<br>到<br>C:\Windows\assembly\GAC\Microsoft.VisualStudio.Shell.Interop.8.0\8.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualStudio.Shell.Interop.8.0.dll</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先安装vs2005，后安装vs2017，vs2017无法运行&lt;br&gt;原因：vs2005注册了Microsoft.VisualStudio.Shell.Interop.8.0.dll，优先于vs2017需要的dll。导致运行错误。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;复制
    
    </summary>
    
      <category term="技巧" scheme="http://yoursite.com/child/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="http://yoursite.com/child/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-链表</title>
    <link href="http://yoursite.com/child//blog/2017/03/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8.html"/>
    <id>http://yoursite.com/child//blog/2017/03/redis源码阅读-链表.html</id>
    <published>2017-03-26T12:14:40.000Z</published>
    <updated>2017-03-26T12:15:17.520Z</updated>
    
    <content type="html"><![CDATA[<p>C语言程序由于没有标准库的存在，各种造轮子。Redis为了满足需求，同样写了一个链表。</p>
<p>实现文件在adlist.h/adlist.c中。</p>
<h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>和普通的C写的双向链表差不多。没有什么特点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</div><div class="line">    <span class="keyword">struct</span> listNode *prev; <span class="comment">// 前节点</span></div><div class="line">    <span class="keyword">struct</span> listNode *next; <span class="comment">// 后节点</span></div><div class="line">    <span class="keyword">void</span> *value; <span class="comment">// 值</span></div><div class="line">&#125; listNode;</div><div class="line"></div><div class="line"><span class="comment">// 迭代器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listIter &#123;</div><div class="line">    listNode *next;<span class="comment">// 下一个节点</span></div><div class="line">    <span class="keyword">int</span> direction;<span class="comment">// 方向</span></div><div class="line">&#125; listIter;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</div><div class="line">    listNode *head; <span class="comment">// 头</span></div><div class="line">    listNode *tail; <span class="comment">// 尾</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr); <span class="comment">// 自定义节点复制函数</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr); <span class="comment">// 自定义节点释放函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 自定义节点匹配函数</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">// 链表长度</span></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>定义了一些快速操作的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* Functions implemented as macros */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len) <span class="comment">// 获取list长度</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head) <span class="comment">// 获取list头节点指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail) <span class="comment">// 获取list尾节点指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev) <span class="comment">// 获取当前节点前一个节点</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next) <span class="comment">// 获取当前节点后一个节点</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value) <span class="comment">// 获取当前节点的值</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m)) <span class="comment">// 设定节点值复制函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m)) <span class="comment">// 设定节点值释放函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m)) <span class="comment">// 设定节点值匹配函数</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup) <span class="comment">// 获取节点值赋值函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free) <span class="comment">// 获取节点值释放函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match) <span class="comment">// 获取节点值匹配函数</span></span></div></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>都是些链表常用的API，比较有特点的是迭代器的C语言实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Prototypes */</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;</div><div class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;</div><div class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;</div><div class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</div><div class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言程序由于没有标准库的存在，各种造轮子。Redis为了满足需求，同样写了一个链表。&lt;/p&gt;
&lt;p&gt;实现文件在adlist.h/adlist.c中。&lt;/p&gt;
&lt;h2 id=&quot;结构体定义&quot;&gt;&lt;a href=&quot;#结构体定义&quot; class=&quot;headerlink&quot; title=&quot;结构体定义&quot;&gt;&lt;/a&gt;结构体定义&lt;/h2&gt;&lt;p&gt;和普通的C写的双向链表差不多。没有什么特点。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; listNode &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; listNode *prev; &lt;span class=&quot;comment&quot;&gt;// 前节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; listNode *next; &lt;span class=&quot;comment&quot;&gt;// 后节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *value; &lt;span class=&quot;comment&quot;&gt;// 值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; listNode;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 迭代器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; listIter &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    listNode *next;&lt;span class=&quot;comment&quot;&gt;// 下一个节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; direction;&lt;span class=&quot;comment&quot;&gt;// 方向&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; listIter;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    listNode *head; &lt;span class=&quot;comment&quot;&gt;// 头&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    listNode *tail; &lt;span class=&quot;comment&quot;&gt;// 尾&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*dup)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *ptr); &lt;span class=&quot;comment&quot;&gt;// 自定义节点复制函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *ptr); &lt;span class=&quot;comment&quot;&gt;// 自定义节点释放函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (*match)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *ptr, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key); &lt;span class=&quot;comment&quot;&gt;// 自定义节点匹配函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; len; &lt;span class=&quot;comment&quot;&gt;// 链表长度&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-动态字符串sds</title>
    <link href="http://yoursite.com/child//blog/2017/03/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds.html"/>
    <id>http://yoursite.com/child//blog/2017/03/redis源码阅读-动态字符串sds.html</id>
    <published>2017-03-26T11:45:58.000Z</published>
    <updated>2017-03-26T11:49:53.240Z</updated>
    
    <content type="html"><![CDATA[<p>Redis没有使用c语言的字符串结构，自己设计了一个简单的动态字符串。特点是：修改时大小不足则扩容，大小足够直接使用不缩小。末尾使用‘\0’，与c语言字符串兼容。</p>
<p>sds的源代码在sds.h与sds.c中。</p>
<h2 id="sds的定义"><a href="#sds的定义" class="headerlink" title="sds的定义"></a>sds的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;<span class="comment">// 兼容C</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> sdshdr &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;<span class="comment">// 字符串长度</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;<span class="comment">// 未分配的空间</span></div><div class="line">    <span class="keyword">char</span> buf[];<span class="comment">// 末尾'/0'的C风格字符串</span></div><div class="line">&#125;;<span class="comment">// SDS的实际结构，兼容char*则返回buf地址</span></div></pre></td></tr></table></figure>
<h2 id="SDS这样设计的优点："><a href="#SDS这样设计的优点：" class="headerlink" title="SDS这样设计的优点："></a>SDS这样设计的优点：</h2><ol>
<li>重用部分C字符串库函数的函数。</li>
<li>在常数复杂度的情况下获取字符串长度(以下代码)。</li>
<li>杜绝缓冲区溢出，通过获取空余空间函数，来进行处理(sdscat函数)。</li>
<li>减少字符串内存的重分配。不足则分配更大的空间，足够也不减少空间，而是记录新的len、free值。</li>
<li>二进制兼容。C字符串以空字符结尾，而某些二进制数据中间可能存在空字符。SDS兼容该种数据。</li>
</ol>
<a id="more"></a>
<h2 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h2><h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 获取字符串长度</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">return</span> sh-&gt;len;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取空余空间</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SDS创建"><a href="#SDS创建" class="headerlink" title="SDS创建"></a>SDS创建</h3><p>有两个函数，一个定长创建，一个是不定长创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (init) &#123;</div><div class="line">        <span class="comment">//为空则使用malloc</span></div><div class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//不为空使用calloc分配</span></div><div class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 分配失败处理</span></div><div class="line">    <span class="comment">//设定sds的参数</span></div><div class="line">    sh-&gt;len = initlen;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="comment">//值的复制</span></div><div class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</div><div class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</div><div class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;<span class="comment">// 尾部结束符</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制一个char*</span></div><div class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</div><div class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成一个空sd</span></div><div class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制一个sds</span></div><div class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds释放函数"><a href="#sds释放函数" class="headerlink" title="sds释放函数"></a>sds释放函数</h3><p>先获取sdshdr的首地址，使用zfree释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">  	<span class="comment">// 获取真实首地址释放</span></div><div class="line">    zfree(s-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds动态空间调整"><a href="#sds动态空间调整" class="headerlink" title="sds动态空间调整"></a>sds动态空间调整</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 空间增长</span></div><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh, *newsh;</div><div class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;<span class="comment">// 空间足够直接返回</span></div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    newlen = (len+addlen);<span class="comment">// 新的长度</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)<span class="comment">// 不足1MB直接翻倍分配</span></div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span><span class="comment">// 超过1MB，多分配1MB空余空间</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);<span class="comment">// 分配空间</span></div><div class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 分配失败</span></div><div class="line">    <span class="comment">// 设置参数</span></div><div class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line">    <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 空间的重分配</span></div><div class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line"></div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    sh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+sh-&gt;len+<span class="number">1</span>);</div><div class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> sh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds连接操作"><a href="#sds连接操作" class="headerlink" title="sds连接操作"></a>sds连接操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line">    <span class="keyword">size_t</span> curlen = sdslen(s); <span class="comment">// 获取字符串长度</span></div><div class="line"></div><div class="line">    s = sdsMakeRoomFor(s,len);<span class="comment">// 扩展字符串</span></div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);<span class="comment">// 连接字符串到末尾</span></div><div class="line">    sh-&gt;len = curlen+len;<span class="comment">// 设置长度</span></div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</div><div class="line">    s[curlen+len] = <span class="string">'\0'</span>;<span class="comment">// 设置尾部</span></div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds复制"><a href="#sds复制" class="headerlink" title="sds复制"></a>sds复制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</div><div class="line"></div><div class="line">    <span class="comment">// 空间不足，分配空间</span></div><div class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;</div><div class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</div><div class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 复制</span></div><div class="line">    <span class="built_in">memcpy</span>(s, t, len);</div><div class="line">    s[len] = <span class="string">'\0'</span>;</div><div class="line">    sh-&gt;len = len;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一些其他接口"><a href="#一些其他接口" class="headerlink" title="一些其他接口"></a>一些其他接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;<span class="comment">// 格式化输出</span></div><div class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>; <span class="comment">// 去除cset中所含字符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;<span class="comment">// 获取指定区间字符串</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>; <span class="comment">// 更新字符串长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>; <span class="comment">// 清空字符串</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span></span>; <span class="comment">// 字符串比较</span></div><div class="line"><span class="comment">// 依据sep将s分割，返回 一个二维数组</span></div><div class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span>;</div><div class="line"><span class="comment">// 释放由sdssplitlen函数解析的二维数组 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>; <span class="comment">// 转小写</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>; <span class="comment">// 转大写</span></div><div class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;<span class="comment">// ll转sds</span></div><div class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span></span>; <span class="comment">// 以分隔符连接字符串子数组构成新的字符串</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis没有使用c语言的字符串结构，自己设计了一个简单的动态字符串。特点是：修改时大小不足则扩容，大小足够直接使用不缩小。末尾使用‘\0’，与c语言字符串兼容。&lt;/p&gt;
&lt;p&gt;sds的源代码在sds.h与sds.c中。&lt;/p&gt;
&lt;h2 id=&quot;sds的定义&quot;&gt;&lt;a href=&quot;#sds的定义&quot; class=&quot;headerlink&quot; title=&quot;sds的定义&quot;&gt;&lt;/a&gt;sds的定义&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *sds;&lt;span class=&quot;comment&quot;&gt;// 兼容C&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; sdshdr &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len;&lt;span class=&quot;comment&quot;&gt;// 字符串长度&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// 未分配的空间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; buf[];&lt;span class=&quot;comment&quot;&gt;// 末尾&#39;/0&#39;的C风格字符串&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;span class=&quot;comment&quot;&gt;// SDS的实际结构，兼容char*则返回buf地址&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;SDS这样设计的优点：&quot;&gt;&lt;a href=&quot;#SDS这样设计的优点：&quot; class=&quot;headerlink&quot; title=&quot;SDS这样设计的优点：&quot;&gt;&lt;/a&gt;SDS这样设计的优点：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;重用部分C字符串库函数的函数。&lt;/li&gt;
&lt;li&gt;在常数复杂度的情况下获取字符串长度(以下代码)。&lt;/li&gt;
&lt;li&gt;杜绝缓冲区溢出，通过获取空余空间函数，来进行处理(sdscat函数)。&lt;/li&gt;
&lt;li&gt;减少字符串内存的重分配。不足则分配更大的空间，足够也不减少空间，而是记录新的len、free值。&lt;/li&gt;
&lt;li&gt;二进制兼容。C字符串以空字符结尾，而某些二进制数据中间可能存在空字符。SDS兼容该种数据。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书摘录-程序员的思维方式</title>
    <link href="http://yoursite.com/child//blog/2017/03/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F.html"/>
    <id>http://yoursite.com/child//blog/2017/03/读书摘录-程序员的思维方式.html</id>
    <published>2017-03-26T04:26:05.000Z</published>
    <updated>2017-03-26T04:58:09.151Z</updated>
    
    <content type="html"><![CDATA[<p>2.2 德雷福斯模型的5个阶段</p>
<p>2017-01-24</p>
<p>但是，如果给新手提供与情境无关的规则去参照，他们就会变得能干起来。也就是说，需要这种形式的规则：“当X发生时，执行Y。”换言之，需要一份指令清单。<br>图2-2　玉米饼食谱，不过你知道需要烹饪多长时间吗<br>这就是呼叫中心的工作原理。你可以雇用一大批对当前技术没有很多经验的人，然后让他们按照一个决策树按部就班地执行下去。</p>
<p>3.3 L型和R型的特征</p>
<p>2017-02-06</p>
<p>事实上，综合是一项非常强大的学习技术，以至于麻省理工学院媒体实验室的尼葛洛庞蒂在Don’t Dissect the Frog, Build It [Neg94]中建议，真正想要了解一只青蛙，传统的解剖不是办法，更好的方式是构造一只青蛙。<br>也就是说，要求学生构造一个具有青蛙特征的生物。这是一种伟大的方式，可以真正了解到，什么使青蛙成之为青蛙，以及青蛙如何适应其特定环境。这是一个综合学习的绝佳例子。</p>
<p>4.4 收获R型线索</p>
<p>2017-02-08</p>
<p>这种方法为什么会起作用？我认为这是因为晨写让毫无防备的大脑倾倒想法。早上刚起床时，你还没有像你想的那样清醒。潜意识仍然占主角。你还没有提起所有防备，也还未适应有限的现实世界。你可以直接连通R型，至少一小会儿。</p>
<p>2017-02-08</p>
<p>你需要培养一种非目标驱动的思维方式。正如庞加莱所做，把一切都写在纸上（或者编辑器中，如果你必须得这么做的话），然后不去管它。不要试图思考。记住它，如布朗所说，不要关注它。只要简单地记住它。让事实和问题自由地搅和、浸泡（我们将在8.2节讨论这一话题）</p>
<a id="more"></a>
<p>4.5 收获模式</p>
<p>2017-02-08</p>
<p>“在开始练习武术之后，我感觉到我的注意力持续时间和控制能力（比如在糟糕的环境下集中注意力）都有了提高。我一直在向软件开发人员和其他知识工作者推荐我的实践经验。它就是气功，它既有武术的一面，也包含太极、冥想和呼吸的方面。</p>
<p>注</p>
<p>跑步应该也行的。</p>
<p>6.2 瞄准SMART目标</p>
<p>2017-03-05</p>
<p>使用SMART方法实现你的目标。<br>在这里，SMART代表具体的、可度量的、可实现的、相关的和时间可控的（Specific, Measurable, Achievable, Relevant, and Time-boxed）。对于任何目标（减肥、炒老板鱿鱼、征服世界等），你都需要制定一个计划，定出一系列帮助你实现目标的任务（objective）。每一个任务都应该具有SMART特性。</p>
<p>6.3 建立一个务实的投资计划</p>
<p>2017-03-05</p>
<p>就像任何投资一样——无论是金融还是艺术上的——都必须时刻进行管理。<br>很多年来，戴维·托马斯（Dave Thomas）和我一直把实用投资计划作为咨询实践的一部分，在这里我简单地介绍一下这些内容。实用投资计划基于一种非常简单但是有效的理念：像管理你的金融投资一样小心管理你的知识投资。</p>
<p>6.4 使用你的原生学习模式</p>
<p>2017-03-05</p>
<p>很多教育家把学习者分为三大类：视觉型、听觉型和动觉型。<br>视觉型学习者需要看到学习资料和老师。图片和图表对视觉型学习者都很有效，他们对肢体语言和面部表情也很敏感。<br>听觉型学习者必须听到学习材料。讲座、研讨会和播客都很有效。他们对语气、语速和其他细节都很敏感。<br>动觉型学习者通过活动和触摸来学习。他们需要亲身感受学习材料。特别是对运动、艺术和<br>工艺等领域，你都需要通过动手来学习。</p>
<p>6.9 利用文档的真正力量</p>
<p>2017-03-05</p>
<p>创建低层次的设计文档，简单地反映代码的细节（几乎很快就会过时）对任何人都没有意义。但是其他形式的文档可能是有价值的，即使没有明确的读者。</p>
<p>6.10 以教代学</p>
<p>2017-03-05</p>
<p>为了省掉你的同事过来，我们建议你在桌子上摆一只黄色橡皮鸭作替身，当你遇到问题时，先和它<br>聊聊。<br>另一种有用的办法是尝试向一个孩子或者你所在领域之外的人解释你的东西。诀窍就是用他们能理解的话语进行解释。这是一个向你的Edna大婶解释你的工作的好机会，也是一个练习从听众角度观察问题并创建隐喻的好机会，这些隐喻有助于解释、阐明你的工作。你可能会在这个过程中惊奇地发现一些新的收获和领悟。</p>
<p>第7章 积累经验</p>
<p>2017-03-05</p>
<p>我们应该小心翼翼地从实践中获得智慧并适可而止，否则我们就会像不慎坐在热炉子上的猫一样，它再也不会坐在热炉子上——这还好，但是它也再也不会坐在冷炉子上。<br>——马克·吐温</p>
<p>7.3 正确对待实践中的失败</p>
<p>2017-03-05</p>
<p>你可以在公司范围之外尝试，比如在家里做开源项目。这起码会减少产生负面结果的风险。但是仅仅这样不足以为你建立一个积极的学习环境。不论是在公司团队还是在黑夜里偷偷进行的独自实验，你都需要做到以下几点。</p>
<p>7.4 了解内在诀窍</p>
<p>2017-03-05</p>
<p>在采取纠正行动之前完全知道“这是什么”对于调试非常重要。太多程序员（包括我自己）往往在没有完全明白真正的错误是什么之前就着急修正它。匆忙地作出判断或者过早地进行修补。你需要首先完全明白系统的原理，然后再判断哪部分错了，最后提供解决方案。也就说，不要动手做，而是要袖手旁观。琼·金姆介绍下述方法来帮助大家充分了解。</p>
<p>8.2 通过分散注意力来集中注意力</p>
<p>2017-03-05</p>
<p>怎么区分你是在浸泡思想还是在拖延、浪费时间呢？<br>我总是把拖延称为“做纸娃娃”。一个密友（姓名保密）第二天有一门重要的考试，但是前一天晚上，她并不学习，而是坐在沙发上剪纸娃娃。当时这在我看来就是典型的耗费时间：一个无关的非生产性的活动阻碍了你需要做的真正工作。<br>但也许我错了。也许这不是拖延。这是一个高级触觉练习，也许是她浸泡思想的方法。她通过了测验并以优异成绩毕业。<br>如果某个任务你真的不想做，那么任何分散注意力的努力都很可能只是耗费时间。如果你仍然有兴趣，但感觉“困难”，那么思想其实是在继<br>续发酵，这当然没问题。</p>
<p>8.6 保持足够大的情境</p>
<p>2017-03-05</p>
<p>事实上，保持情境中任务相关的东西很有益处。不论你如何衡量生产力，仅仅多使用一台显示器就可以让你的生产力提升20%~30%。<br>这是为什么？<br>适合你的不是桌面隐喻，而是Frederick Brooks在几年前描述的拥挤的飞机座位隐喻。在一个大桌面上，你可以展开你的工作，看到你在做什么——同时看到所有的。在拥挤的飞机座位上，你没有足够的空间同时看两份以上的文档（或者文档的一部分）。你必须来回地切换文档。<br>我敢打赌，让你去Staples或者Office Depot等办公用品店寻找一张17英寸的办公桌，你找不到，因为这个尺寸实在是太小了。然而，大多数显示器都是17到21英寸。这点空间就是我们办公的地方。你不得不在活动窗口和应用程序之间切换，因为你无法在如此小的空间里保持足够的情境。<br>你知道Alt-Tab组合键（Mac上的Command-Tab）称为什么吗?情境切换。正如我们看到的，情景切换扼杀生产力。即使是类似使用Alt-Tab切换不同窗口的小动作也会花费时间、短期记忆力和精力。</p>
<p>2017-03-05</p>
<p>在最先进的操作系统上你可以使用虚拟桌面切换器，允许你拥有很多不同的屏幕，你可以使用特殊键随意切换。每一个屏幕都是独立的，称为工作空间。秘诀在于你如何在工作空间中分配应用。</p>
<p>9.2 明天上午做什么</p>
<p>2017-03-05</p>
<p>现在就开始吧！你选择开始做什么并不特别重要，重要的是主动尝试本书中提到的知识，这是你明天一大早要做的第一件事。<br>下面是对第一步的一些建议。<br>开始承担责任，不要害怕问“为什么”，也不要害怕问“你怎么知道的”或者“我怎么知道的”，同样要大方地回答“我目前还不知道”。<br>挑两件帮助你维持情境、免受干扰的事情，立即实施。<br>创建一个实用投资计划，设定SMART目标。<br>弄清楚你在所属专业领域中所处的位置（从新手到专家）和你期望的位置。保证诚实。你需要更多的诀窍还是更多的情境？更多规则还是更多直觉？<br>实践。某段代码遇到问题了吗？尝试用五种不同的方式编写。<br>允许犯更多错误——错误是许可的，要从中学习教训。<br>携带一个笔记本（最好不带横线）。涂鸦，做思维导图，记笔记。让你的思想自由地流动。<br>打开心扉接收美感和其他的感官输入。不论是<br>你的房间、桌面还是代码，关注它们是多么地赏心悦目。<br>开始在私人wiki上记录你感兴趣的事情。<br>开始写博客。为你读过的书写评论。阅读更多书，你会有更多可写的东西。使用SQ3R和思维导图。<br>让散步成为你每天生活的一部分。<br>启动一个读书小组。<br>再拿一个显示器，开始使用虚拟桌面。<br>回顾每章的“实践单元”，尝试去做。</p>
<p>9.3 超越专家</p>
<p>2017-03-05</p>
<p>达芬奇在600年前抱怨说：“人们看却没有看见，听却没有听见，吃却没有味觉，接触却没有触觉，说话却没有思考。”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2.2 德雷福斯模型的5个阶段&lt;/p&gt;
&lt;p&gt;2017-01-24&lt;/p&gt;
&lt;p&gt;但是，如果给新手提供与情境无关的规则去参照，他们就会变得能干起来。也就是说，需要这种形式的规则：“当X发生时，执行Y。”换言之，需要一份指令清单。&lt;br&gt;图2-2　玉米饼食谱，不过你知道需要烹饪多长时间吗&lt;br&gt;这就是呼叫中心的工作原理。你可以雇用一大批对当前技术没有很多经验的人，然后让他们按照一个决策树按部就班地执行下去。&lt;/p&gt;
&lt;p&gt;3.3 L型和R型的特征&lt;/p&gt;
&lt;p&gt;2017-02-06&lt;/p&gt;
&lt;p&gt;事实上，综合是一项非常强大的学习技术，以至于麻省理工学院媒体实验室的尼葛洛庞蒂在Don’t Dissect the Frog, Build It [Neg94]中建议，真正想要了解一只青蛙，传统的解剖不是办法，更好的方式是构造一只青蛙。&lt;br&gt;也就是说，要求学生构造一个具有青蛙特征的生物。这是一种伟大的方式，可以真正了解到，什么使青蛙成之为青蛙，以及青蛙如何适应其特定环境。这是一个综合学习的绝佳例子。&lt;/p&gt;
&lt;p&gt;4.4 收获R型线索&lt;/p&gt;
&lt;p&gt;2017-02-08&lt;/p&gt;
&lt;p&gt;这种方法为什么会起作用？我认为这是因为晨写让毫无防备的大脑倾倒想法。早上刚起床时，你还没有像你想的那样清醒。潜意识仍然占主角。你还没有提起所有防备，也还未适应有限的现实世界。你可以直接连通R型，至少一小会儿。&lt;/p&gt;
&lt;p&gt;2017-02-08&lt;/p&gt;
&lt;p&gt;你需要培养一种非目标驱动的思维方式。正如庞加莱所做，把一切都写在纸上（或者编辑器中，如果你必须得这么做的话），然后不去管它。不要试图思考。记住它，如布朗所说，不要关注它。只要简单地记住它。让事实和问题自由地搅和、浸泡（我们将在8.2节讨论这一话题）&lt;/p&gt;
    
    </summary>
    
      <category term="摘录" scheme="http://yoursite.com/child/categories/%E6%91%98%E5%BD%95/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/child/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-内存分配</title>
    <link href="http://yoursite.com/child//blog/2017/03/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html"/>
    <id>http://yoursite.com/child//blog/2017/03/redis源码阅读-内存分配.html</id>
    <published>2017-03-21T02:21:33.000Z</published>
    <updated>2017-04-16T07:12:34.561Z</updated>
    
    <content type="html"><![CDATA[<p>redis的内存分配主要就是对malloc和free进行了一层简单的封装。具体的实现在zmalloc.h和zmalloc.c中。</p>
<h2 id="内存分配器的选择"><a href="#内存分配器的选择" class="headerlink" title="内存分配器的选择"></a>内存分配器的选择</h2><p>redis支持多种内存分配器，可以选择的分配器tcmalloc、jemalloc、dlmalloc、malloc/malloc.h(apple)，这几个分配器自带内存大小的记录。如果不进行设置，则默认使用malloc进行分配。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// zmalloc.h</span></div><div class="line"><span class="comment">// 选择使用的内存分配器，分别为tcmalloc、jemalloc、dlmalloc、malloc/malloc.h</span></div><div class="line"><span class="comment">// 同时设置HAVE_MALLOC_SIZE为真，内存分配器自带大小统计。</span></div><div class="line"><span class="comment">// 如果不选择内存分配器，则使用默认的malloc，同时同时设置HAVE_MALLOC_SIZE为假。</span></div><div class="line"><span class="comment">// 指定zmalloc_size</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"tcmalloc-"</span> __xstr(TC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(TC_VERSION_MINOR))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6) || (TC_VERSION_MAJOR &gt; 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) tc_malloc_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of tcmalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"jemalloc-"</span> __xstr(JEMALLOC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_MINOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_BUGFIX))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jemalloc/jemalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (JEMALLOC_VERSION_MAJOR == 2 &amp;&amp; JEMALLOC_VERSION_MINOR &gt;= 1) || (JEMALLOC_VERSION_MAJOR &gt; 2)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) je_malloc_usable_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of jemalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) malloc_size(p)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_DLMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Win32_Interop/win32_dlmalloc.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"dlmalloc-"</span> __xstr(2) <span class="meta-string">"."</span> __xstr(8) )</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p)  g_msize(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ZMALLOC_LIB</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB <span class="meta-string">"libc"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// zmalloc.c</span></div><div class="line"><span class="comment">// 依据选择的内存分配器，设定好宏定义，否则使用系统默认分配。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) tc_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) tc_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) tc_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) tc_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) je_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) je_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) je_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) je_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_DLMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) g_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) g_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) g_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) g_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h2 id="功能函数一栏"><a href="#功能函数一栏" class="headerlink" title="功能函数一栏"></a>功能函数一栏</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void *zmalloc(size_t size);// 调用malloc，分配size大小的空间</div><div class="line">void *zcalloc(size_t size);// 调用calloc，分配size大小的空间</div><div class="line">void *zrealloc(void *ptr, size_t size);// 调用realloc，重新分配size大小的空间</div><div class="line">void zfree(void *ptr);// 释放ptr</div><div class="line">char *zstrdup(const char *s);// c风格字符串copy</div><div class="line">size_t zmalloc_used_memory(void); // 获取当前占用的内存大小</div><div class="line">void zmalloc_enable_thread_safeness(void); // 设置线程安全</div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)); // 设置内存分配失败的处理方法</div><div class="line">float zmalloc_get_fragmentation_ratio(size_t rss);// 获取所给内存和已经使用的内存大小之比</div><div class="line">size_t zmalloc_get_rss(void); // 获取RSS信息（Resident Set Size）</div><div class="line">size_t zmalloc_get_private_dirty(void);// 获取实际内存大小</div><div class="line">size_t zmalloc_get_smap_bytes_by_field(char *field);// 获取/proc/self/smaps字段的字节数</div><div class="line">void zlibc_free(void *ptr); // 获取物理内存大小</div><div class="line">WIN32_ONLY(void zmalloc_free_used_memory_mutex(void);) //原始系统free的释放方法</div></pre></td></tr></table></figure>
<h2 id="统计使用的内存总数"><a href="#统计使用的内存总数" class="headerlink" title="统计使用的内存总数"></a>统计使用的内存总数</h2><p>redis每次分配内存、释放内存都会进行记录。用来统计redis使用的总内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;<span class="comment">// 获取使用的内存，直接获取used_memory的变量的值。</span></div><div class="line">    <span class="keyword">size_t</span> um;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123;<span class="comment">// 线程安全</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC)</span></div><div class="line">        um = update_zmalloc_stat_add(<span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        pthread_mutex_lock(&amp;used_memory_mutex);</div><div class="line">        um = used_memory;</div><div class="line">        pthread_mutex_unlock(&amp;used_memory_mutex);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 非线程安全</span></div><div class="line">        um = used_memory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> um;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;<span class="comment">// 定义了一个全局变量，用来记录使用的内存数量。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;<span class="comment">// 默认不线程安全，调用zmalloc_enable_thread_safeness进行设置为线程安全。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32<span class="comment">// 根据系统选择多线程锁。</span></span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// __ATOMIC_RELAXED提供原子加减操作</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) __atomic_add_fetch(&amp;used_memory, (__n), __ATOMIC_RELAXED)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) __atomic_sub_fetch(&amp;used_memory, (__n), __ATOMIC_RELAXED)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAVE_ATOMIC)<span class="comment">// GCC提供的原子加减操作</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) __sync_add_and_fetch(&amp;used_memory, (__n))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) __sync_sub_and_fetch(&amp;used_memory, (__n))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">// 使用多线程锁来实现多线程加减操作</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory += (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; while(0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory -= (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; while(0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// 增加redis内存计数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="meta-keyword">if</span> (_n&amp;(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&amp;(sizeof(PORT_LONG)-1)); \ <span class="comment">// 将n调整为sizeof(PORT_LONG)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \ <span class="comment">// 开启线程安全</span></div><div class="line">        update_zmalloc_stat_add(_n); \</div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory += _n; \ <span class="comment">// 不开启线程安全</span></div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment">// 减少redis内存计数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="meta-keyword">if</span> (_n&amp;(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&amp;(sizeof(PORT_LONG)-1)); \ <span class="comment">// 将n调整为sizeof(PORT_LONG)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_sub(_n); \<span class="comment">// 开启线程安全</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory -= _n; \<span class="comment">// 不开启线程安全</span></div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h2 id="内存管理函数"><a href="#内存管理函数" class="headerlink" title="内存管理函数"></a>内存管理函数</h2><h3 id="异常处理函数"><a href="#异常处理函数" class="headerlink" title="异常处理函数"></a>异常处理函数</h3><p>异常处理函数, 在内存分配失败时进行调用。</p>
<p>默认使用zmalloc_default_oom，也可以通过zmalloc_set_oom_handler进行设置异常处理方式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;</div><div class="line"></div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) &#123;</div><div class="line">    zmalloc_oom_handler = oom_handler;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void zmalloc_default_oom(size_t size) &#123;</div><div class="line">    fprintf(stderr, "zmalloc: Out of memory trying to allocate %Iu bytes\n",    WIN_PORT_FIX /* %zu -&gt; %Iu */</div><div class="line">        size);// 打印日志</div><div class="line">    fflush(stderr);</div><div class="line">    abort();// 中断退出</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zmalloc"><a href="#zmalloc" class="headerlink" title="zmalloc"></a>zmalloc</h3><p>zmalloc用来分配指定大小的内存。实际上对malloc进行了一层封装，加入了异常处理和内存统计。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用malloc进行内存分配</span></div><div class="line">    <span class="comment">// 多出的PREFIX_SIZE大内存用来记录该段内存大小。</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 分配失败的异常处理</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 统计内存使用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line"></div><div class="line">    <span class="comment">// 内存分配器自带内存大小</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zcalloc"><a href="#zcalloc" class="headerlink" title="zcalloc"></a>zcalloc</h3><p>calloc是分配内存，并初始化为0。封装的和zmalloc类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配内存</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 分配失败的异常处理</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 统计内存使用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zrealloc"><a href="#zrealloc" class="headerlink" title="zrealloc"></a>zrealloc</h3><p>zrealloc用来重新调整分配的内存大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line">    <span class="keyword">void</span> *newptr;</div><div class="line"></div><div class="line">    <span class="comment">// ptr为空，直接使用zmalloc进行分配size大小内存。</span></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    oldsize = zmalloc_size(ptr); <span class="comment">// 获取ptr指向的内存大小</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(ptr,size); <span class="comment">// 重新分配内存</span></div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size); <span class="comment">// 异常处理</span></div><div class="line"></div><div class="line">    update_zmalloc_stat_free(oldsize);<span class="comment">// 先减</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));<span class="comment">// 后加</span></div><div class="line">    <span class="keyword">return</span> newptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);<span class="comment">// 获取ptr指向的内存大小</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);<span class="comment">// 重新分配内存</span></div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);<span class="comment">// 异常处理</span></div><div class="line"></div><div class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</div><div class="line">    update_zmalloc_stat_free(oldsize);<span class="comment">// 先减</span></div><div class="line">    update_zmalloc_stat_alloc(size);<span class="comment">// 后加</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zfree"><a href="#zfree" class="headerlink" title="zfree"></a>zfree</h3><p>释放函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">// 空直接返回</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));<span class="comment">// 减少统计数量</span></div><div class="line">    <span class="built_in">free</span>(ptr);<span class="comment">// 释放</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE; <span class="comment">// 获取真实的指针</span></div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);<span class="comment">// 获取大小</span></div><div class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);<span class="comment">// 减少统计数量</span></div><div class="line">    <span class="built_in">free</span>(realptr);<span class="comment">// 释放</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zmalloc-size"><a href="#zmalloc-size" class="headerlink" title="zmalloc_size"></a>zmalloc_size</h3><p>获取指针指向内存大小，在内存分配器不自带该函数时定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// zmalloc.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">// zmalloc.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</div><div class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(PORT_LONG) by</span></div><div class="line">     * the underlying allocator. */</div><div class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(PORT_LONG)-(size&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>));</div><div class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis的内存分配主要就是对malloc和free进行了一层简单的封装。具体的实现在zmalloc.h和zmalloc.c中。&lt;/p&gt;
&lt;h2 id=&quot;内存分配器的选择&quot;&gt;&lt;a href=&quot;#内存分配器的选择&quot; class=&quot;headerlink&quot; title=&quot;内存分配器的选择&quot;&gt;&lt;/a&gt;内存分配器的选择&lt;/h2&gt;&lt;p&gt;redis支持多种内存分配器，可以选择的分配器tcmalloc、jemalloc、dlmalloc、malloc/malloc.h(apple)，这几个分配器自带内存大小的记录。如果不进行设置，则默认使用malloc进行分配。&lt;/p&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-开始</title>
    <link href="http://yoursite.com/child//blog/2017/03/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B.html"/>
    <id>http://yoursite.com/child//blog/2017/03/redis源码阅读-开始.html</id>
    <published>2017-03-21T02:21:21.000Z</published>
    <updated>2017-04-16T07:12:30.977Z</updated>
    
    <content type="html"><![CDATA[<p>自本博客之后的文章大概都是依照《Redis设计与实现》对Redis的源码进行的记录。目的是为了对于Redis有一个了解，同时对之后需要使用Redis的项目上能够有所帮助。</p>
<h2 id="Redis的介绍"><a href="#Redis的介绍" class="headerlink" title="Redis的介绍"></a>Redis的介绍</h2><p>redis是一个使用C编写的key-value数据库。性能极高且支持丰富的数据类型。它所有的操作都是原子性的。代码精简，只有3w行不到，利于阅读。</p>
<h2 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h2><p><a href="http://blog.huangz.me/diary/2014/how-to-read-redis-source-code.html" target="_blank" rel="external">如何阅读Redis源码？</a>阅读的顺序主要还是按照黄建宏老师所建议的顺序进行阅读。</p>
<ol>
<li>阅读数据结构的实现。</li>
<li>阅读内存编码数据结构的实现。</li>
<li>阅读数据类型的实现。</li>
<li>阅读数据库实现相关代码。</li>
<li>阅读客户端和服务端相关代码。</li>
<li>阅读多机功能的实现。</li>
</ol>
<p>至此将Redis阅读完毕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自本博客之后的文章大概都是依照《Redis设计与实现》对Redis的源码进行的记录。目的是为了对于Redis有一个了解，同时对之后需要使用Redis的项目上能够有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;Redis的介绍&quot;&gt;&lt;a href=&quot;#Redis的介绍&quot; class=&quot;he
    
    </summary>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/child/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>gitlab workflow</title>
    <link href="http://yoursite.com/child//blog/2017/01/gitlab-workflow.html"/>
    <id>http://yoursite.com/child//blog/2017/01/gitlab-workflow.html</id>
    <published>2017-01-29T13:40:40.000Z</published>
    <updated>2017-01-28T14:54:37.330Z</updated>
    
    <content type="html"><![CDATA[<p>建立一个长期分支，就是master，master分支上的版本都是能够编译运行的版本。<br>整个工作流程如下。<br>第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。<br>第二步：新分支开发完成后，或者需要讨论的时候，先从master合并到分支，解决冲突，然后向master发起一个pull request（简称PR）。<br>第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。<br>第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</p>
<h1 id="建立测试项目"><a href="#建立测试项目" class="headerlink" title="建立测试项目"></a>建立测试项目</h1><p>新建一个项目用于测试工作流。<br>演示项目地址：<a href="http://10.10.10.98/MekaYangyi/workflow" target="_blank" rel="external">http://10.10.10.98/MekaYangyi/workflow</a><br><img src="/img/gitlab工作流程/10-21-42.jpg" alt=""></p>
<h1 id="设置分支保护"><a href="#设置分支保护" class="headerlink" title="设置分支保护"></a>设置分支保护</h1><p>新建项目默认master用户才能够push和merge。<br>其余用户只能新建分支，在分支测试完毕后，再发起Merge Requests。发起后，由master进行审核后合并。<br><img src="/img/gitlab工作流程/10-32-56.jpg" alt=""></p>
<a id="more"></a>
<h1 id="设置开发成员"><a href="#设置开发成员" class="headerlink" title="设置开发成员"></a>设置开发成员</h1><p>项目创建者在项目页面选择Member。<br><img src="/img/gitlab工作流程/10-31-10.jpg" alt=""></p>
<p>设置开发人员分为两种，一种是直接设置用户，一种是设置一Group都为指定权限。<br>权限分为四类：</p>
<blockquote>
<p>Guest<br>Reporter<br>Developer<br>Master</p>
</blockquote>
<p>一般开发人员指定为Developer。<br>具体权限在<a href="http://10.10.10.98/help/user/permissions.md查看。" target="_blank" rel="external">http://10.10.10.98/help/user/permissions.md查看。</a><br>设置用户权限<br><img src="/img/gitlab工作流程/11-23-52.jpg" alt=""><br>设置整个Group的权限<br><img src="/img/gitlab工作流程/11-24-20.jpg" alt=""></p>
<h1 id="建立本地分支"><a href="#建立本地分支" class="headerlink" title="建立本地分支"></a>建立本地分支</h1><p>在项目文件夹右键，选择TortoiseGit→Create Branch。<br><img src="/img/gitlab工作流程/11-43-08.jpg" alt=""><br>填写信息<br><img src="/img/gitlab工作流程/11-52-57.jpg" alt=""></p>
<h1 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h1><p>在项目文件夹右键，选择TortoiseGit→Switch/Checkout。<br><img src="/img/gitlab工作流程/11-54-23.jpg" alt=""><br>选择OK。<br><img src="/img/gitlab工作流程/11-55-03.jpg" alt=""></p>
<h1 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h1><p>分出分支后，可以在本地进行Commit，知道一个功能开发完毕后，再上传到服务器。<br>修改本地的文件，Commit。<br><img src="/img/gitlab工作流程/11-57-19.jpg" alt=""><br>填写上传备注，Commit。</p>
<h1 id="将Master向Test-WorkFlow合并"><a href="#将Master向Test-WorkFlow合并" class="headerlink" title="将Master向Test_WorkFlow合并"></a>将Master向Test_WorkFlow合并</h1><p>先从服务器pull最新版本，然后将master向Test_WorkFlow合并，防止master在分支分出之后被修改导致的冲突。<br>从服务器pull最新版本。<br><img src="/img/gitlab工作流程/22-39-02.jpg" alt=""><br>将master向Test_WorkFlow合并。<br><img src="/img/gitlab工作流程/22-41-09.jpg" alt=""><br>合并解决冲突。<br><img src="/img/gitlab工作流程/22-41-37.jpg" alt=""></p>
<h1 id="push"><a href="#push" class="headerlink" title="push"></a>push</h1><p>上传成功后选择push。<br><img src="/img/gitlab工作流程/22-44-54.jpg" alt=""></p>
<p>确认。<br><img src="/img/gitlab工作流程/11-59-05.jpg" alt=""><br>成功。<br><img src="/img/gitlab工作流程/11-59-45.jpg" alt=""></p>
<h1 id="发起Merge-Request"><a href="#发起Merge-Request" class="headerlink" title="发起Merge Request"></a>发起Merge Request</h1><p>在项目页面找到分支，选择Merge Request<br><img src="/img/gitlab工作流程/12-05-10.jpg" alt=""><br>填写相关信息，Submit merge request<br><img src="/img/gitlab工作流程/12-06-31.jpg" alt=""></p>
<h1 id="检视代码并讨论"><a href="#检视代码并讨论" class="headerlink" title="检视代码并讨论"></a>检视代码并讨论</h1><p>选择Merge Request。<br>单击测试分支合并功能这一个Merge Request<br><img src="/img/gitlab工作流程/12-08-38.jpg" alt=""><br>弹出页面。<br><img src="/img/gitlab工作流程/12-09-43.jpg" alt=""><br>检视代码</p>
<h2 id="Commit，查看修改记录。"><a href="#Commit，查看修改记录。" class="headerlink" title="Commit，查看修改记录。"></a>Commit，查看修改记录。</h2><p>图中红色区域单击可以Diff与查看源文件。<br><img src="/img/gitlab工作流程/12-11-44.jpg" alt=""><br>单击任意版本提交记录，增加检视意见，在diff时，任意处可以添加讨论。或者在页面底部对整个修改进行评价。<br><img src="/img/gitlab工作流程/112-18-49.jpg" alt=""></p>
<p><img src="/img/gitlab工作流程/12-19-25.jpg" alt=""></p>
<h2 id="Changes，查看版本区别。"><a href="#Changes，查看版本区别。" class="headerlink" title="Changes，查看版本区别。"></a>Changes，查看版本区别。</h2><p><img src="/img/gitlab工作流程/12-12-47.jpg" alt=""></p>
<h2 id="Discusion，填写建议"><a href="#Discusion，填写建议" class="headerlink" title="Discusion，填写建议"></a>Discusion，填写建议</h2><p>填写建议后，选择Comment可以互相讨论。<br>或者选择Close merge request关闭请求。<br><img src="/img/gitlab工作流程/12-15-41.jpg" alt=""></p>
<h2 id="Accept-merge-request或者Close-merge-request"><a href="#Accept-merge-request或者Close-merge-request" class="headerlink" title="Accept merge request或者Close merge request"></a>Accept merge request或者Close merge request</h2><p><img src="/img/gitlab工作流程/12-22-44.jpg" alt=""></p>
<h2 id="合并完成"><a href="#合并完成" class="headerlink" title="合并完成"></a>合并完成</h2><p>选择Accept Merge Request,同时选择合并时将分支删除。<br><img src="/img/gitlab工作流程/12-23-55.jpg" alt=""><br>合并结果。<br><img src="/img/gitlab工作流程/12-25-09.jpg" alt=""></p>
<h1 id="本地pull"><a href="#本地pull" class="headerlink" title="本地pull"></a>本地pull</h1><p>在本地项目进行pull,同步服务器版本。<br><img src="/img/gitlab工作流程/12-26-33.jpg" alt=""><br>本地同步结果。<br><img src="/img/gitlab工作流程/12-27-07.jpg" alt=""></p>
<h1 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h1><p>由于远程分支与本地分支没有关系，那么当远程正式Merge之后，需要删除本地分支，防止以后分支一直增加，不减少。<br>在项目文件夹右键，选择TortoiseGit→Switch/Checkout，先把分支切换到本地master。<br><img src="/img/gitlab工作流程/11-54-23.jpg" alt=""><br>切换完成后，再次进入该界面选择….<br><img src="/img/gitlab工作流程/12-47-04.jpg" alt=""><br>删除分支<br><img src="/img/gitlab工作流程/12-45-50.jpg" alt=""></p>
<h1 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h1><p>Issue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。</p>
<h2 id="新建Issue"><a href="#新建Issue" class="headerlink" title="新建Issue"></a>新建Issue</h2><p>选择New Issue<br><img src="/img/gitlab工作流程/12-32-50.jpg" alt=""><br>填写相关信息。<br>功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如”1-测试Issue”。<br><img src="/img/gitlab工作流程/12-36-52.jpg" alt=""></p>
<p>新建完成,每一个Issue都有一个编号，本Issue的编号为#1。<br><img src="/img/gitlab工作流程/12-37-36.jpg" alt=""><br>在分支开发完成后，在commit message里面，可以写上”fixes #14”或者”closes #67”。<br><img src="/img/gitlab工作流程/12-39-48.jpg" alt=""><br>Github规定，只要commit message里面有下面这些动词 + 编号，就会关闭对应的issue。</p>
<blockquote>
<p>close<br>closes<br>closed<br>fix<br>fixes<br>fixed<br>resolve<br>resolves<br>resolved</p>
</blockquote>
<p>这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是username/repository#issue_number。<br>Pull Request被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。</p>
<h2 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h2><p><img src="/img/gitlab工作流程/12-41-19.jpg" alt=""><br><img src="/img/gitlab工作流程/12-41-51.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建立一个长期分支，就是master，master分支上的版本都是能够编译运行的版本。&lt;br&gt;整个工作流程如下。&lt;br&gt;第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。&lt;br&gt;第二步：新分支开发完成后，或者需要讨论的时候，先从master合并到分支，解决冲突，然后向master发起一个pull request（简称PR）。&lt;br&gt;第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。&lt;br&gt;第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）&lt;/p&gt;
&lt;h1 id=&quot;建立测试项目&quot;&gt;&lt;a href=&quot;#建立测试项目&quot; class=&quot;headerlink&quot; title=&quot;建立测试项目&quot;&gt;&lt;/a&gt;建立测试项目&lt;/h1&gt;&lt;p&gt;新建一个项目用于测试工作流。&lt;br&gt;演示项目地址：&lt;a href=&quot;http://10.10.10.98/MekaYangyi/workflow&quot;&gt;http://10.10.10.98/MekaYangyi/workflow&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/img/gitlab工作流程/10-21-42.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h1 id=&quot;设置分支保护&quot;&gt;&lt;a href=&quot;#设置分支保护&quot; class=&quot;headerlink&quot; title=&quot;设置分支保护&quot;&gt;&lt;/a&gt;设置分支保护&lt;/h1&gt;&lt;p&gt;新建项目默认master用户才能够push和merge。&lt;br&gt;其余用户只能新建分支，在分支测试完毕后，再发起Merge Requests。发起后，由master进行审核后合并。&lt;br&gt;&lt;img src=&quot;/img/gitlab工作流程/10-32-56.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="gitlab" scheme="http://yoursite.com/child/categories/gitlab/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/child/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>第一次使用gitlab</title>
    <link href="http://yoursite.com/child//blog/2017/01/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab.html"/>
    <id>http://yoursite.com/child//blog/2017/01/第一次使用gitlab.html</id>
    <published>2017-01-28T01:19:43.000Z</published>
    <updated>2017-01-28T01:32:46.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>版本差别不大，目前使用的版本git2.11.0.3。<br>一路下一步,不修改安装位置，直接使用默认设置。</p>
<h1 id="安装TortoiseGit"><a href="#安装TortoiseGit" class="headerlink" title="安装TortoiseGit"></a>安装TortoiseGit</h1><p>一路下一步，不修改安装位置，直接使用默认设置。</p>
<h1 id="登录账户"><a href="#登录账户" class="headerlink" title="登录账户"></a>登录账户</h1><h2 id="管理员创建账户"><a href="#管理员创建账户" class="headerlink" title="管理员创建账户"></a>管理员创建账户</h2><p>Admin→New User。新建账户、并设置密码。同时设置该用户所属Group。</p>
<blockquote>
<p>name：上传显示的名字，可以经常更改，使用中文名好。</p>
<p>username：登陆的用户名，不可修改，用于账户登陆。</p>
<p>email：账户email，内网联系email。</p>
<p>password：密码，牢记，root用户可修改。</p>
</blockquote>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登陆内网gitlab，目前网址：10.10.10.98。<br><img src="/img/第一次使用gitlab/22-04-07.jpg" alt=""></p>
<a id="more"></a>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>登录后会要求修改密码，自己输入即可。<br><img src="/img/第一次使用gitlab/22-05-00.jpg" alt=""></p>
<h1 id="设置TortoiseGit"><a href="#设置TortoiseGit" class="headerlink" title="设置TortoiseGit"></a>设置TortoiseGit</h1><p>将注册的用户填入TortoiseGit中,设置为全局账号。<br><img src="/img/第一次使用gitlab/21-07-01.jpg" alt=""></p>
<h1 id="添加ssh"><a href="#添加ssh" class="headerlink" title="添加ssh"></a>添加ssh</h1><p>如果不添加shh，每次修改都会要求输入账号密码，比较麻烦。添加后与设备绑定，修改不再需要填写账号密码。如果不再使用一个设备，请删除ssh。</p>
<h2 id="生成ssh"><a href="#生成ssh" class="headerlink" title="生成ssh"></a>生成ssh</h2><p>任意空白处，选择git bash。<br><img src="/img/第一次使用gitlab/06-27-40.jpg" alt=""><br>窗口中输入，一路按回车。<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"你注册的email地址"</span></div></pre></td></tr></table></figure></p>
<p>生成后的公钥会存放在 C:/Users/You_User_Name/.ssh/id_rsa.pub。<br>用记事本打开，复制。<br><img src="/img/第一次使用gitlab/06-30-35.jpg" alt=""></p>
<h2 id="将ssh加入gitlab"><a href="#将ssh加入gitlab" class="headerlink" title="将ssh加入gitlab"></a>将ssh加入gitlab</h2><p>浏览器转到<a href="http://10.10.10.98/profile/keys。" target="_blank" rel="external">http://10.10.10.98/profile/keys。</a><br>将复制的Key粘贴，Add key。<br><img src="/img/第一次使用gitlab/06-32-52.jpg" alt=""></p>
<h1 id="新建一个项目"><a href="#新建一个项目" class="headerlink" title="新建一个项目"></a>新建一个项目</h1><h2 id="新建一个私有项目"><a href="#新建一个私有项目" class="headerlink" title="新建一个私有项目"></a>新建一个私有项目</h2><p>新建一个私有项目进行实验，gitlab是否能够正常上传。<br>选择new project。<br><img src="/img/第一次使用gitlab/06-07-09.jpg" alt=""></p>
<h2 id="填写基本信息"><a href="#填写基本信息" class="headerlink" title="填写基本信息"></a>填写基本信息</h2><blockquote>
<p>Project name：项目名称。<br>Project description：项目描述。<br>Visibility Level：项目级别，内网使用只选择public与private。private除了项目成员不可见，public在内网均可见。</p>
</blockquote>
<p>选择Create project创建项目。<br><img src="/img/第一次使用gitlab/06-08-43.jpg" alt=""></p>
<h1 id="Clone项目"><a href="#Clone项目" class="headerlink" title="Clone项目"></a>Clone项目</h1><p>项目创建完成，复制项目地址。<br>复制浏览器的项目地址：<a href="http://10.10.10.98/test/test_project。" target="_blank" rel="external">http://10.10.10.98/test/test_project。</a><br><img src="/img/第一次使用gitlab/06-14-02.jpg" alt=""><br>选择计算机一个文件夹，右键，选择git clone。<br><img src="/img/第一次使用gitlab/06-15-28.jpg" alt=""><br>clone之前复制地址项目，确认，输入用户名与密码，clone成功，会新建一个文件夹。<br><img src="/img/第一次使用gitlab/06-16-37.jpg" alt=""></p>
<h1 id="第一次push"><a href="#第一次push" class="headerlink" title="第一次push"></a>第一次push</h1><p>在该文件夹中建立一个README.md文件。<br><img src="/img/第一次使用gitlab/06-18-54.jpg" alt=""></p>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>右键add，确认，ok。<br><img src="/img/第一次使用gitlab/06-19-25.jpg" alt=""></p>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>commit将修改更新到本地。<br>在项目文件夹空白处右键，选择git commit。<br><img src="/img/第一次使用gitlab/06-25-26.jpg" alt=""><br>填写上传理由，commit。<br><img src="/img/第一次使用gitlab/06-26-03.jpg" alt=""></p>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>选择push，push能够将修改push到服务器。<br><img src="/img/第一次使用gitlab/06-36-23.jpg" alt=""><br>确认。<br><img src="/img/第一次使用gitlab/06-37-12.jpg" alt=""><br>成功界面。<br><img src="/img/第一次使用gitlab/06-37-36.jpg" alt=""></p>
<h1 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h1><p>成功在网页端看到修改记录(之前误上传为.md.txt文件，修改为.md文件网页端会显示文字)。<br><img src="/img/第一次使用gitlab/06-40-03.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装git&quot; class=&quot;headerlink&quot; title=&quot;安装git&quot;&gt;&lt;/a&gt;安装git&lt;/h1&gt;&lt;p&gt;版本差别不大，目前使用的版本git2.11.0.3。&lt;br&gt;一路下一步,不修改安装位置，直接使用默认设置。&lt;/p&gt;
&lt;h1 id=&quot;安装TortoiseGit&quot;&gt;&lt;a href=&quot;#安装TortoiseGit&quot; class=&quot;headerlink&quot; title=&quot;安装TortoiseGit&quot;&gt;&lt;/a&gt;安装TortoiseGit&lt;/h1&gt;&lt;p&gt;一路下一步，不修改安装位置，直接使用默认设置。&lt;/p&gt;
&lt;h1 id=&quot;登录账户&quot;&gt;&lt;a href=&quot;#登录账户&quot; class=&quot;headerlink&quot; title=&quot;登录账户&quot;&gt;&lt;/a&gt;登录账户&lt;/h1&gt;&lt;h2 id=&quot;管理员创建账户&quot;&gt;&lt;a href=&quot;#管理员创建账户&quot; class=&quot;headerlink&quot; title=&quot;管理员创建账户&quot;&gt;&lt;/a&gt;管理员创建账户&lt;/h2&gt;&lt;p&gt;Admin→New User。新建账户、并设置密码。同时设置该用户所属Group。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;name：上传显示的名字，可以经常更改，使用中文名好。&lt;/p&gt;
&lt;p&gt;username：登陆的用户名，不可修改，用于账户登陆。&lt;/p&gt;
&lt;p&gt;email：账户email，内网联系email。&lt;/p&gt;
&lt;p&gt;password：密码，牢记，root用户可修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;登录&quot;&gt;&lt;a href=&quot;#登录&quot; class=&quot;headerlink&quot; title=&quot;登录&quot;&gt;&lt;/a&gt;登录&lt;/h2&gt;&lt;p&gt;登陆内网gitlab，目前网址：10.10.10.98。&lt;br&gt;&lt;img src=&quot;/img/第一次使用gitlab/22-04-07.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="gitlab" scheme="http://yoursite.com/child/categories/gitlab/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/child/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] stl源码剖析 总结</title>
    <link href="http://yoursite.com/child//blog/2016/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.html"/>
    <id>http://yoursite.com/child//blog/2016/11/读书笔记-stl源码剖析.html</id>
    <published>2016-11-21T12:32:26.000Z</published>
    <updated>2016-11-21T15:03:05.477Z</updated>
    
    <content type="html"><![CDATA[<p>大致上是将STL源码剖析看过了一篇。<br>前三章看到比较认真，后面几章就看到比较粗略了。<br>我想STL的精髓正是在内存配置、迭代器、容器中。<br>至于后面的一些关联式容器，用的红黑树稍复杂，不过在之前的数据结构的基础上和前几章对stl的一些常用方法是熟悉下，其实也就简单了。算法，利用迭代器，同时特化不同的版本。仿函数则是模仿函数效果的对象。整体上都算简单了。<br>我的计划是在未来的一小段日子里实现一个小型的stl，所谓实现，可能也不过是重新将sgi的代码打一遍罢了。不过对于整个stl的理解，我相信会更好一些。<br>之后我应该会更新一些写小型stl遇到的问题和解决方案。<br>项目的地址：<br><a href="https://github.com/MekaYangyi/STL/" target="_blank" rel="external">https://github.com/MekaYangyi/STL/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大致上是将STL源码剖析看过了一篇。&lt;br&gt;前三章看到比较认真，后面几章就看到比较粗略了。&lt;br&gt;我想STL的精髓正是在内存配置、迭代器、容器中。&lt;br&gt;至于后面的一些关联式容器，用的红黑树稍复杂，不过在之前的数据结构的基础上和前几章对stl的一些常用方法是熟悉下，其实也就
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/child/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="stl源码剖析" scheme="http://yoursite.com/child/tags/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] stl源码剖析 第四章 序列式容器</title>
    <link href="http://yoursite.com/child//blog/2016/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8.html"/>
    <id>http://yoursite.com/child//blog/2016/11/读书笔记-stl源码剖析-第四章-序列式容器.html</id>
    <published>2016-11-20T12:32:26.000Z</published>
    <updated>2016-11-21T23:00:46.493Z</updated>
    
    <content type="html"><![CDATA[<p>容器分类<br><img src="/img/20161120124915.png" alt=""></p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>vector还是比较简单，也就是一个动态数组，提供了些操作，带三个指针，start/finish/end<br>核心就是动态调整内存的方法，也就是满了开大一倍空间，拷贝过去。<br>push_back等操作都是值语义的，拷贝传进来的内容放入到vector中。<br>因为是连续的空间，所有元素连续存储在一整块内存上，迭代器直接用的原始指针。</p>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>list复杂些.<br>模型和常见的list是一致的，动态创建节点，插入。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _List_node_base &#123;</div><div class="line">  _List_node_base* _M_next;</div><div class="line">  _List_node_base* _M_prev;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">struct</span> _List_node : <span class="keyword">public</span> _List_node_base &#123;</div><div class="line">  _Tp _M_data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//迭代器base</span></div><div class="line"><span class="keyword">struct</span> _List_iterator_base &#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>                     size_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</div><div class="line"></div><div class="line">  _List_node_base* _M_node;<span class="comment">//节点指针</span></div><div class="line"></div><div class="line">  _List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125;</div><div class="line">  _List_iterator_base() &#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</div><div class="line">  <span class="keyword">void</span> _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125;</div><div class="line"></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> _M_node == __x._M_node;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> _M_node != __x._M_node;</div><div class="line">  &#125;</div><div class="line">&#125;;  </div><div class="line"></div><div class="line"><span class="comment">//迭代器,重载了++ -- == * -&gt;等操作</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</div><div class="line"><span class="keyword">struct</span> _List_iterator : <span class="keyword">public</span> _List_iterator_base &#123;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,<span class="keyword">const</span> _Tp&amp;,<span class="keyword">const</span> _Tp*&gt; const_iterator;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Ref,_Ptr&gt;             _Self;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  <span class="keyword">typedef</span> _Ptr pointer;</div><div class="line">  <span class="keyword">typedef</span> _Ref reference;</div><div class="line">  <span class="keyword">typedef</span> _List_node&lt;_Tp&gt; _Node;</div><div class="line"></div><div class="line">  _List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125;</div><div class="line">  _List_iterator() &#123;&#125;</div><div class="line">  _List_iterator(<span class="keyword">const</span> iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125;</div><div class="line"></div><div class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ((_Node*) _M_node)-&gt;_M_data; &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></div><div class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></div><div class="line"></div><div class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; </div><div class="line">    <span class="keyword">this</span>-&gt;_M_incr();</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </div><div class="line">    _Self __tmp = *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;_M_incr();</div><div class="line">    <span class="keyword">return</span> __tmp;</div><div class="line">  &#125;</div><div class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; </div><div class="line">    <span class="keyword">this</span>-&gt;_M_decr();</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </div><div class="line">    _Self __tmp = *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;_M_decr();</div><div class="line">    <span class="keyword">return</span> __tmp;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>双向开头的连续空间</p>
<p><img src="/img/20161120163459.png" alt=""><br>比较特别的地方是用一个双指针维护了一个多个连续的空间</p>
<p><img src="/img/20161120165939.png" alt=""><br>迭代器保持连续的方式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> __size) &#123;</div><div class="line">  <span class="keyword">return</span> __size &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / __size) : <span class="keyword">size_t</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</div><div class="line"><span class="keyword">struct</span> _Deque_iterator &#123;</div><div class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</div><div class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, <span class="keyword">const</span> _Tp&amp;, <span class="keyword">const</span> _Tp*&gt; const_iterator;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_buffer_size() &#123; <span class="keyword">return</span> __deque_buf_size(<span class="keyword">sizeof</span>(_Tp)); &#125;</div><div class="line"></div><div class="line">.....</div><div class="line"></div><div class="line">  _Tp* _M_cur;</div><div class="line">  _Tp* _M_first;</div><div class="line">  _Tp* _M_last;</div><div class="line">  _Map_pointer _M_node;</div><div class="line"></div><div class="line">  _Deque_iterator(_Tp* __x, _Map_pointer __y) </div><div class="line">    : _M_cur(__x), _M_first(*__y),</div><div class="line">      _M_last(*__y + _S_buffer_size()), _M_node(__y) &#123;&#125;</div><div class="line">  _Deque_iterator() : _M_cur(<span class="number">0</span>), _M_first(<span class="number">0</span>), _M_last(<span class="number">0</span>), _M_node(<span class="number">0</span>) &#123;&#125;</div><div class="line">  _Deque_iterator(<span class="keyword">const</span> iterator&amp; __x)</div><div class="line">    : _M_cur(__x._M_cur), _M_first(__x._M_first), </div><div class="line">      _M_last(__x._M_last), _M_node(__x._M_node) &#123;&#125;</div><div class="line"></div><div class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *_M_cur; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></div><div class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _M_cur; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></div><div class="line"></div><div class="line">  difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> difference_type(_S_buffer_size()) * (_M_node - __x._M_node - <span class="number">1</span>) +</div><div class="line">      (_M_cur - _M_first) + (__x._M_last - __x._M_cur);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">//++</span></div><div class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123;</div><div class="line">    ++_M_cur;</div><div class="line">    <span class="keyword">if</span> (_M_cur == _M_last) &#123;</div><div class="line">    <span class="comment">//到尾部了就进入下一个区域</span></div><div class="line">      _M_set_node(_M_node + <span class="number">1</span>);<span class="comment">//_M_node + 1就是下一个区域</span></div><div class="line">      _M_cur = _M_first;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </div><div class="line">  &#125;</div><div class="line">......</div><div class="line"><span class="comment">//重置first等指针</span></div><div class="line">  <span class="keyword">void</span> _M_set_node(_Map_pointer __new_node) &#123;</div><div class="line">    _M_node = __new_node;</div><div class="line">    _M_first = *__new_node;</div><div class="line">    _M_last = _M_first + difference_type(_S_buffer_size());</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果map不足，分配空间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</div><div class="line"><span class="keyword">class</span> _Deque_base &#123;</div><div class="line">....</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  _Tp** _M_map;</div><div class="line">  <span class="keyword">size_t</span> _M_map_size;  <span class="comment">//记录的map的大小</span></div><div class="line">  iterator _M_start;</div><div class="line">  iterator _M_finish;</div><div class="line">  ....</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>空间不足分配空间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; <span class="keyword">__t</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (_M_finish._M_cur != _M_finish._M_last - <span class="number">1</span>) &#123;</div><div class="line">      construct(_M_finish._M_cur, <span class="keyword">__t</span>);</div><div class="line">      ++_M_finish._M_cur;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      _M_push_back_aux(<span class="keyword">__t</span>);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</div><div class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;_Tp,_Alloc&gt;::_M_push_back_aux(<span class="keyword">const</span> value_type&amp; <span class="keyword">__t</span>)</div><div class="line">&#123;</div><div class="line">  value_type __t_copy = <span class="keyword">__t</span>;</div><div class="line">  _M_reserve_map_at_back();</div><div class="line">  *(_M_finish._M_node + <span class="number">1</span>) = _M_allocate_node();</div><div class="line">  __STL_TRY &#123;</div><div class="line">    construct(_M_finish._M_cur, __t_copy);</div><div class="line">    _M_finish._M_set_node(_M_finish._M_node + <span class="number">1</span>);</div><div class="line">    _M_finish._M_cur = _M_finish._M_first;</div><div class="line">  &#125;</div><div class="line">  __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + <span class="number">1</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>以deuqe为底部结构，封闭头端开口，就是stack。<br>没有迭代器。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//这里设定了了 以deque为基础</div><div class="line">template &lt;class _Tp, </div><div class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;</div><div class="line">class stack;</div><div class="line"></div><div class="line">template &lt;class _Tp, class _Seq&gt;</div><div class="line">bool operator==(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);</div><div class="line"></div><div class="line">template &lt;class _Tp, class _Seq&gt;</div><div class="line">bool operator&lt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);</div><div class="line"></div><div class="line"></div><div class="line">template &lt;class _Tp, class _Sequence&gt;</div><div class="line">class stack &#123;</div><div class="line">.....</div><div class="line"></div><div class="line"></div><div class="line">#ifdef __STL_MEMBER_TEMPLATES</div><div class="line">  template &lt;class _Tp1, class _Seq1&gt;</div><div class="line">  friend bool operator== (const stack&lt;_Tp1, _Seq1&gt;&amp;,</div><div class="line">                          const stack&lt;_Tp1, _Seq1&gt;&amp;);</div><div class="line">  template &lt;class _Tp1, class _Seq1&gt;</div><div class="line">  friend bool operator&lt; (const stack&lt;_Tp1, _Seq1&gt;&amp;,</div><div class="line">                         const stack&lt;_Tp1, _Seq1&gt;&amp;);</div><div class="line">#else /* __STL_MEMBER_TEMPLATES */</div><div class="line">  friend bool __STD_QUALIFIER</div><div class="line">  operator== __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</div><div class="line">  friend bool __STD_QUALIFIER</div><div class="line">  operator&lt; __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</div><div class="line">#endif /* __STL_MEMBER_TEMPLATES */</div><div class="line"></div><div class="line">.....</div><div class="line"></div><div class="line">protected:</div><div class="line">  _Sequence c;</div><div class="line">public:</div><div class="line">  stack() : c() &#123;&#125;</div><div class="line">  explicit stack(const _Sequence&amp; __s) : c(__s) &#123;&#125;</div><div class="line"></div><div class="line">  bool empty() const &#123; return c.empty(); &#125;</div><div class="line">  size_type size() const &#123; return c.size(); &#125;</div><div class="line">  reference top() &#123; return c.back(); &#125;</div><div class="line">  const_reference top() const &#123; return c.back(); &#125;</div><div class="line">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</div><div class="line">  void pop() &#123; c.pop_back(); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>同样以deque为基础<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">template &lt;class _Tp, </div><div class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;</div><div class="line">class queue;</div><div class="line"></div><div class="line">template &lt;class _Tp, class _Seq&gt;</div><div class="line">inline bool operator==(const queue&lt;_Tp, _Seq&gt;&amp;, const queue&lt;_Tp, _Seq&gt;&amp;);</div><div class="line"></div><div class="line">template &lt;class _Tp, class _Seq&gt;</div><div class="line">inline bool operator&lt;(const queue&lt;_Tp, _Seq&gt;&amp;, const queue&lt;_Tp, _Seq&gt;&amp;);</div><div class="line"></div><div class="line"></div><div class="line">template &lt;class _Tp, class _Sequence&gt;</div><div class="line">class queue &#123;</div><div class="line"></div><div class="line">.....</div><div class="line"></div><div class="line">#ifdef __STL_MEMBER_TEMPLATES </div><div class="line">  template &lt;class _Tp1, class _Seq1&gt;</div><div class="line">  friend bool operator== (const queue&lt;_Tp1, _Seq1&gt;&amp;,</div><div class="line">                          const queue&lt;_Tp1, _Seq1&gt;&amp;);</div><div class="line">  template &lt;class _Tp1, class _Seq1&gt;</div><div class="line">  friend bool operator&lt; (const queue&lt;_Tp1, _Seq1&gt;&amp;,</div><div class="line">                         const queue&lt;_Tp1, _Seq1&gt;&amp;);</div><div class="line">#else /* __STL_MEMBER_TEMPLATES */</div><div class="line">  friend bool __STD_QUALIFIER</div><div class="line">  operator== __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</div><div class="line">  friend bool __STD_QUALIFIER</div><div class="line">  operator&lt;  __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</div><div class="line">#endif /* __STL_MEMBER_TEMPLATES */</div><div class="line"></div><div class="line">.....</div><div class="line"></div><div class="line">protected:</div><div class="line">  _Sequence c;</div><div class="line">public:</div><div class="line">  queue() : c() &#123;&#125;</div><div class="line">  explicit queue(const _Sequence&amp; __c) : c(__c) &#123;&#125;</div><div class="line"></div><div class="line">  bool empty() const &#123; return c.empty(); &#125;</div><div class="line">  size_type size() const &#123; return c.size(); &#125;</div><div class="line">  reference front() &#123; return c.front(); &#125;</div><div class="line">  const_reference front() const &#123; return c.front(); &#125;</div><div class="line">  reference back() &#123; return c.back(); &#125;</div><div class="line">  const_reference back() const &#123; return c.back(); &#125;</div><div class="line">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</div><div class="line">  void pop() &#123; c.pop_front(); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><p>堆也就是个完全二叉树。用个数组或者vector就能实现<br>stl中的heap是保证每个父节点大于等于子节点，每次插入删除节点需要重新调整树</p>
<h2 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h2><p>push操作,后调整树，查看父节点是不是符合要求<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">__push_heap(_RandomAccessIterator __first,</div><div class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value)</div><div class="line">&#123;</div><div class="line">  _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//父节点</span></div><div class="line">  <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123;</div><div class="line">    <span class="comment">//调整节点</span></div><div class="line">    *(__first + __holeIndex) = *(__first + __parent);</div><div class="line">    __holeIndex = __parent;</div><div class="line">    __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//再判断父节点</span></div><div class="line">  &#125;    </div><div class="line">  *(__first + __holeIndex) = __value;<span class="comment">//把新值移动到新位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </div><div class="line">__push_heap_aux(_RandomAccessIterator __first,</div><div class="line">                _RandomAccessIterator __last, _Distance*, _Tp*)</div><div class="line">&#123;</div><div class="line">  __push_heap(__first, _Distance((__last - __first) - <span class="number">1</span>), _Distance(<span class="number">0</span>), </div><div class="line">              _Tp(*(__last - <span class="number">1</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//push_heap算法，这个时候值已经插入heap的最尾端，调用此函数调整heap</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> </span></div><div class="line"><span class="title">push_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></div><div class="line">&#123;</div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</div><div class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</div><div class="line">                 _LessThanComparable);</div><div class="line">  __push_heap_aux(__first, __last,</div><div class="line">                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h2><p>调整相关节点，使得上部全部填满，最底层空出区域。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">void</span> </div><div class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</div><div class="line">              _Distance __len, _Tp __value)</div><div class="line">&#123;</div><div class="line">  _Distance __topIndex = __holeIndex;</div><div class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>;</div><div class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</div><div class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>)))</div><div class="line">      __secondChild--;</div><div class="line">    *(__first + __holeIndex) = *(__first + __secondChild);</div><div class="line">    __holeIndex = __secondChild;</div><div class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;</div><div class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>));</div><div class="line">    __holeIndex = __secondChild - <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </div><div class="line">__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</div><div class="line">           _RandomAccessIterator __result, _Tp __value, _Distance*)</div><div class="line">&#123;</div><div class="line">  <span class="comment">//把first放到last-1</span></div><div class="line">  *__result = *__first;</div><div class="line">  <span class="comment">//重新整理first到last-1之间重新成为heap</span></div><div class="line">  __adjust_heap(__first, _Distance(<span class="number">0</span>), _Distance(__last - __first), __value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </div><div class="line">__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,</div><div class="line">               _Tp*)</div><div class="line">&#123;</div><div class="line">  <span class="comment">//pop出的是最大值，也就是删除掉first，把first放到last-1，然后重新整理first到last-1之间重新成为heap</span></div><div class="line">  <span class="comment">//这样之后只要去取last-1的值，就是弹出的值了。</span></div><div class="line">  __pop_heap(__first, __last - <span class="number">1</span>, __last - <span class="number">1</span>, </div><div class="line">             _Tp(*(__last - <span class="number">1</span>)), __DISTANCE_TYPE(__first));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//pop</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(_RandomAccessIterator __first, </span></span></div><div class="line">                     _RandomAccessIterator __last)</div><div class="line">&#123;</div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</div><div class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</div><div class="line">                 _LessThanComparable);</div><div class="line">  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h2><p>不断调用__adjust_heap调整heap的话，最终会是一个heap<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt;</div><div class="line"><span class="keyword">void</span> </div><div class="line">__make_heap(_RandomAccessIterator __first,</div><div class="line">            _RandomAccessIterator __last, _Tp*, _Distance*)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) <span class="keyword">return</span>;</div><div class="line">  _Distance __len = __last - __first;</div><div class="line">  _Distance __parent = (__len - <span class="number">2</span>)/<span class="number">2</span>;</div><div class="line">    </div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));</div><div class="line">    <span class="keyword">if</span> (__parent == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    __parent--;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> </span></div><div class="line"><span class="title">make_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></div><div class="line">&#123;</div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</div><div class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</div><div class="line">                 _LessThanComparable);</div><div class="line">  __make_heap(__first, __last,</div><div class="line">              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h2><p>对一个heap一直pop，最大值移到末尾，那么就是增序序列 了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span></div><div class="line">&#123;</div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</div><div class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</div><div class="line">                 _LessThanComparable);</div><div class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">1</span>)</div><div class="line">    pop_heap(__first, __last--);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>优先弹出权值高的项目，用上面的max_heap就能够实现。<br>操作不多。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">template &lt;class _Tp, </div><div class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector&lt;_Tp&gt;),</div><div class="line">          class _Compare</div><div class="line">          __STL_DEPENDENT_DEFAULT_TMPL(less&lt;typename _Sequence::value_type&gt;) &gt;</div><div class="line">class priority_queue &#123;</div><div class="line">......</div><div class="line">protected:</div><div class="line">  _Sequence c;</div><div class="line">  _Compare comp;</div><div class="line">public:</div><div class="line">  priority_queue() : c() &#123;&#125;</div><div class="line">  explicit priority_queue(const _Compare&amp; __x) :  c(), comp(__x) &#123;&#125;</div><div class="line">  priority_queue(const _Compare&amp; __x, const _Sequence&amp; __s) </div><div class="line">    : c(__s), comp(__x) </div><div class="line">    &#123; make_heap(c.begin(), c.end(), comp); &#125;</div><div class="line">.....</div><div class="line">  bool empty() const &#123; return c.empty(); &#125;</div><div class="line">  size_type size() const &#123; return c.size(); &#125;</div><div class="line">  const_reference top() const &#123; return c.front(); &#125;</div><div class="line">  void push(const value_type&amp; __x) &#123;</div><div class="line">    __STL_TRY &#123;</div><div class="line">      c.push_back(__x); </div><div class="line">      push_heap(c.begin(), c.end(), comp);</div><div class="line">    &#125;</div><div class="line">    __STL_UNWIND(c.clear());</div><div class="line">  &#125;</div><div class="line">  void pop() &#123;</div><div class="line">    __STL_TRY &#123;</div><div class="line">      pop_heap(c.begin(), c.end(), comp);</div><div class="line">      c.pop_back();</div><div class="line">    &#125;</div><div class="line">    __STL_UNWIND(c.clear());</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器分类&lt;br&gt;&lt;img src=&quot;/img/20161120124915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h1 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h1&gt;&lt;p&gt;vector还是比较简单，也就是一个动态数组，提供了些操作，带三个指针，start/finish/end&lt;br&gt;核心就是动态调整内存的方法，也就是满了开大一倍空间，拷贝过去。&lt;br&gt;push_back等操作都是值语义的，拷贝传进来的内容放入到vector中。&lt;br&gt;因为是连续的空间，所有元素连续存储在一整块内存上，迭代器直接用的原始指针。&lt;/p&gt;
&lt;h1 id=&quot;list&quot;&gt;&lt;a href=&quot;#list&quot; class=&quot;headerlink&quot; title=&quot;list&quot;&gt;&lt;/a&gt;list&lt;/h1&gt;&lt;p&gt;list复杂些.&lt;br&gt;模型和常见的list是一致的，动态创建节点，插入。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _List_node_base &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_node_base* _M_next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_node_base* _M_prev;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _Tp&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _List_node : &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; _List_node_base &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Tp _M_data;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//迭代器base&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _List_iterator_base &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt;                     size_type;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ptrdiff_t&lt;/span&gt;                  difference_type;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; bidirectional_iterator_tag iterator_category;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_node_base* _M_node;&lt;span class=&quot;comment&quot;&gt;//节点指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator_base(_List_node_base* __x) : _M_node(__x) &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator_base() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; _M_incr() &amp;#123; _M_node = _M_node-&amp;gt;_M_next; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; _M_decr() &amp;#123; _M_node = _M_node-&amp;gt;_M_prev; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;==(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; _List_iterator_base&amp;amp; __x) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _M_node == __x._M_node;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;!=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; _List_iterator_base&amp;amp; __x) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _M_node != __x._M_node;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//迭代器,重载了++ -- == * -&amp;gt;等操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _Tp, &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _Ref, &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _Ptr&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _List_iterator : &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; _List_iterator_base &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _List_iterator&amp;lt;_Tp,_Tp&amp;amp;,_Tp*&amp;gt;             iterator;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _List_iterator&amp;lt;_Tp,&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; _Tp&amp;amp;,&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; _Tp*&amp;gt; const_iterator;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _List_iterator&amp;lt;_Tp,_Ref,_Ptr&amp;gt;             _Self;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _Tp value_type;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _Ptr pointer;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _Ref reference;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _List_node&amp;lt;_Tp&amp;gt; _Node;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator(_Node* __x) : _List_iterator_base(__x) &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; iterator&amp;amp; __x) : _List_iterator_base(__x._M_node) &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  reference &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;*() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((_Node*) _M_node)-&amp;gt;_M_data; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifndef&lt;/span&gt; __SGI_STL_NO_ARROW_OPERATOR&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  pointer &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;-&amp;gt;() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;amp;(&lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;*()); &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* __SGI_STL_NO_ARROW_OPERATOR */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Self&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;++() &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;_M_incr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Self &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;++(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _Self __tmp = *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;_M_incr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __tmp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Self&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;--() &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;_M_decr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Self &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;--(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _Self __tmp = *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;_M_decr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __tmp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/child/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="stl源码剖析" scheme="http://yoursite.com/child/tags/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] stl源码剖析 第三章 迭代器</title>
    <link href="http://yoursite.com/child//blog/2016/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8.html"/>
    <id>http://yoursite.com/child//blog/2016/11/读书笔记-stl源码剖析-第三章-迭代器.html</id>
    <published>2016-11-17T12:32:26.000Z</published>
    <updated>2016-11-20T21:10:12.383Z</updated>
    
    <content type="html"><![CDATA[<p>迭代器是一种抽象的设计概念。iterator模式：提供一种方法，使能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表述方式。</p>
<h1 id="迭代器的设计思维-stl关键所在"><a href="#迭代器的设计思维-stl关键所在" class="headerlink" title="迭代器的设计思维-stl关键所在"></a>迭代器的设计思维-stl关键所在</h1><p>STL的中心思想在于：将数据容器和算法分开，彼此独立设计。容器和算法的泛型化。<br>迭代器就是扮演着粘胶角色。</p>
<h1 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h1><p>list迭代器stl的实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//listnode的基础类</span></div><div class="line"><span class="keyword">struct</span> _List_node_base &#123;</div><div class="line">  _List_node_base* _M_next;</div><div class="line">  _List_node_base* _M_prev;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//listnode</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">struct</span> _List_node : <span class="keyword">public</span> _List_node_base &#123;</div><div class="line">  _Tp _M_data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//迭代器基础类</span></div><div class="line"><span class="keyword">struct</span> _List_iterator_base &#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>                     size_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</div><div class="line"></div><div class="line">  _List_node_base* _M_node;<span class="comment">//包含一个node</span></div><div class="line"></div><div class="line">  _List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125;</div><div class="line">  _List_iterator_base() &#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</div><div class="line">  <span class="keyword">void</span> _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125;</div><div class="line"></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> _M_node == __x._M_node;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> _M_node != __x._M_node;</div><div class="line">  &#125;</div><div class="line">&#125;;  </div><div class="line"><span class="comment">//迭代器</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</div><div class="line"><span class="keyword">struct</span> _List_iterator : <span class="keyword">public</span> _List_iterator_base &#123;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,<span class="keyword">const</span> _Tp&amp;,<span class="keyword">const</span> _Tp*&gt; const_iterator;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Ref,_Ptr&gt;             _Self;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  <span class="keyword">typedef</span> _Ptr pointer;</div><div class="line">  <span class="keyword">typedef</span> _Ref reference;</div><div class="line">  <span class="keyword">typedef</span> _List_node&lt;_Tp&gt; _Node;</div><div class="line"></div><div class="line">  _List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125;</div><div class="line">  _List_iterator() &#123;&#125;</div><div class="line">  _List_iterator(<span class="keyword">const</span> iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125;</div><div class="line"></div><div class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ((_Node*) _M_node)-&gt;_M_data; &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></div><div class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></div><div class="line">  <span class="comment">//重载了几个操作实现了迭代器，不是很复杂</span></div><div class="line">  <span class="comment">//++i</span></div><div class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; </div><div class="line">    <span class="keyword">this</span>-&gt;_M_incr();</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//i++</span></div><div class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </div><div class="line">    _Self __tmp = *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;_M_incr();</div><div class="line">    <span class="keyword">return</span> __tmp;</div><div class="line">  &#125;</div><div class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; </div><div class="line">    <span class="keyword">this</span>-&gt;_M_decr();</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </div><div class="line">    _Self __tmp = *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;_M_decr();</div><div class="line">    <span class="keyword">return</span> __tmp;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="Traits编程技法"><a href="#Traits编程技法" class="headerlink" title="Traits编程技法"></a>Traits编程技法</h1><p>之前就见到用过，通过类型获取，其余的类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Category, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance = <span class="keyword">ptrdiff_t</span>,</div><div class="line">          <span class="keyword">class</span> _Pointer = _Tp*, <span class="keyword">class</span> _Reference = _Tp&amp;&gt;</div><div class="line"><span class="keyword">struct</span> iterator &#123;</div><div class="line">  <span class="keyword">typedef</span> _Category  iterator_category;</div><div class="line">  <span class="keyword">typedef</span> _Tp        value_type;</div><div class="line">  <span class="keyword">typedef</span> _Distance  difference_type;</div><div class="line">  <span class="keyword">typedef</span> _Pointer   pointer;</div><div class="line">  <span class="keyword">typedef</span> _Reference reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Iterator&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits &#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//对原生指针特化</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;_Tp*&gt; &#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</div><div class="line">  <span class="comment">//ptrdiff_t是C/C++标准库中定义的一个与机器相关的数据类型。ptrdiff_t类型变量通常用来保存两个指针减法操作的结果。ptrdiff_t定义在stddef.h（cstddef）这个文件内。ptrdiff_t通常被定义为long int类型。</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> _Tp*                        pointer;</div><div class="line">  <span class="keyword">typedef</span> _Tp&amp;                        reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;<span class="keyword">const</span> _Tp*&gt; &#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*                  pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;                  reference;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>迭代器的分类：<br>input iter：只读iter<br>output iter:只写iter<br>forward iter:允许写入型算法在这种迭代器所形成的区间操作，前向迭代器<br>bidirectional iterator：双向移动iter。<br>random access iter：前三种支持++,第四种支持++ –。这种支持所有指针的算术能力。</p>
<p><img src="/img/20161116205706.png" alt=""><br>typedef typename _Iterator::iterator_category iterator_category;的作用就是能够在编译器发现迭代器的类型，选用最合适的函数版本。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> output_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> forward_iterator_tag : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> bidirectional_iterator_tag : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> random_access_iterator_tag : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _InputIter, <span class="keyword">class</span> _Distance&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(_InputIter&amp; __i, _Distance __n, input_iterator_tag) &#123;</div><div class="line">  <span class="keyword">while</span> (__n--) ++__i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _BidirectionalIterator, <span class="keyword">class</span> _Distance&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(_BidirectionalIterator&amp; __i, _Distance __n, </div><div class="line">                      bidirectional_iterator_tag) &#123;</div><div class="line">  __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);</div><div class="line">  <span class="keyword">if</span> (__n &gt;= <span class="number">0</span>)</div><div class="line">    <span class="keyword">while</span> (__n--) ++__i;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">while</span> (__n++) --__i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(_RandomAccessIterator&amp; __i, _Distance __n, </div><div class="line">                      random_access_iterator_tag) &#123;</div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);</div><div class="line">  __i += __n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _InputIterator, <span class="keyword">class</span> _Distance&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(_InputIterator&amp; __i, _Distance __n)</span> </span>&#123;</div><div class="line">  __STL_REQUIRES(_InputIterator, _InputIterator);</div><div class="line">  <span class="comment">//通过下面的函数，选用合适的版本</span></div><div class="line">  <span class="comment">//不需要传递参数，能够在编译器选定版本</span></div><div class="line">  __advance(__i, __n, iterator_category(__i));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="type-traits"><a href="#type-traits" class="headerlink" title="__type_traits"></a>__type_traits</h1><p>提供一种机制，允许针对不同的型别熟悉，完成函数派送。<br>在内存配置器中就用到了，比如有没有拷贝构造函数等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __true_type &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> __false_type &#123;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//选择使用__false_type为struct的目的是为了类型推倒，而不是使用bool值作为参数的话只是运行时的选择。</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">struct</span> __type_traits &#123; </div><div class="line">   <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</div><div class="line">                   <span class="comment">/* Do not remove this member. It informs a compiler which</span></div><div class="line">                      automatically specializes __type_traits that this</div><div class="line">                      __type_traits template is special. It just makes sure that</div><div class="line">                      things work if an implementation is using a template</div><div class="line">                      called __type_traits for something unrelated. */</div><div class="line"></div><div class="line">   <span class="comment">/* The following restrictions should be observed for the sake of</span></div><div class="line">      compilers which automatically produce type specific specializations </div><div class="line">      of this class:</div><div class="line">          - You may reorder the members below if you wish</div><div class="line">          - You may remove any of the members below if you wish</div><div class="line">          - You must not rename members without making the corresponding</div><div class="line">            name change in the compiler</div><div class="line">          - Members you add will be treated like regular members unless</div><div class="line">            you add the appropriate support in the compiler. */</div><div class="line"> </div><div class="line"></div><div class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</div><div class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</div><div class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</div><div class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</div><div class="line">   <span class="keyword">typedef</span> __false_type    is_POD_type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在这个文件里定义了大量的特化，主要是特化C++标准类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> __type_traits&lt;<span class="keyword">bool</span>&gt; &#123;</div><div class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</div><div class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</div><div class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</div><div class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</div><div class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//等。。。</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迭代器是一种抽象的设计概念。iterator模式：提供一种方法，使能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表述方式。&lt;/p&gt;
&lt;h1 id=&quot;迭代器的设计思维-stl关键所在&quot;&gt;&lt;a href=&quot;#迭代器的设计思维-stl关键所在&quot; class=&quot;headerlink&quot; title=&quot;迭代器的设计思维-stl关键所在&quot;&gt;&lt;/a&gt;迭代器的设计思维-stl关键所在&lt;/h1&gt;&lt;p&gt;STL的中心思想在于：将数据容器和算法分开，彼此独立设计。容器和算法的泛型化。&lt;br&gt;迭代器就是扮演着粘胶角色。&lt;/p&gt;
&lt;h1 id=&quot;迭代器是一种smart-pointer&quot;&gt;&lt;a href=&quot;#迭代器是一种smart-pointer&quot; class=&quot;headerlink&quot; title=&quot;迭代器是一种smart pointer&quot;&gt;&lt;/a&gt;迭代器是一种smart pointer&lt;/h1&gt;&lt;p&gt;list迭代器stl的实现&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//listnode的基础类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _List_node_base &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_node_base* _M_next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_node_base* _M_prev;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//listnode&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _Tp&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _List_node : &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; _List_node_base &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Tp _M_data;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//迭代器基础类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _List_iterator_base &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt;                     size_type;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ptrdiff_t&lt;/span&gt;                  difference_type;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; bidirectional_iterator_tag iterator_category;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_node_base* _M_node;&lt;span class=&quot;comment&quot;&gt;//包含一个node&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator_base(_List_node_base* __x) : _M_node(__x) &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator_base() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; _M_incr() &amp;#123; _M_node = _M_node-&amp;gt;_M_next; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; _M_decr() &amp;#123; _M_node = _M_node-&amp;gt;_M_prev; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;==(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; _List_iterator_base&amp;amp; __x) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _M_node == __x._M_node;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;!=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; _List_iterator_base&amp;amp; __x) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _M_node != __x._M_node;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//迭代器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _Tp, &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _Ref, &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _Ptr&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _List_iterator : &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; _List_iterator_base &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _List_iterator&amp;lt;_Tp,_Tp&amp;amp;,_Tp*&amp;gt;             iterator;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _List_iterator&amp;lt;_Tp,&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; _Tp&amp;amp;,&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; _Tp*&amp;gt; const_iterator;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _List_iterator&amp;lt;_Tp,_Ref,_Ptr&amp;gt;             _Self;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _Tp value_type;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _Ptr pointer;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _Ref reference;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; _List_node&amp;lt;_Tp&amp;gt; _Node;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator(_Node* __x) : _List_iterator_base(__x) &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _List_iterator(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; iterator&amp;amp; __x) : _List_iterator_base(__x._M_node) &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  reference &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;*() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((_Node*) _M_node)-&amp;gt;_M_data; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifndef&lt;/span&gt; __SGI_STL_NO_ARROW_OPERATOR&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  pointer &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;-&amp;gt;() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;amp;(&lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;*()); &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* __SGI_STL_NO_ARROW_OPERATOR */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//重载了几个操作实现了迭代器，不是很复杂&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//++i&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Self&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;++() &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;_M_incr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//i++&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Self &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;++(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _Self __tmp = *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;_M_incr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __tmp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Self&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;--() &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;_M_decr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _Self &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;--(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _Self __tmp = *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;_M_decr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __tmp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/child/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="stl源码剖析" scheme="http://yoursite.com/child/tags/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] stl源码剖析 第一章、第二章 概论、内存配置器</title>
    <link href="http://yoursite.com/child//blog/2016/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E3%80%81%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8.html"/>
    <id>http://yoursite.com/child//blog/2016/11/读书笔记-stl源码剖析-第一、二章-概论、内存配置器.html</id>
    <published>2016-11-16T00:32:26.000Z</published>
    <updated>2016-11-16T14:13:43.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>第一章基本都是C++基础的知识，读了《C++ Primer》的话都懂。关于各种C++的特性、STL特性都有。</p>
<h2 id="STL六大组件-功能与运用"><a href="#STL六大组件-功能与运用" class="headerlink" title="STL六大组件 功能与运用"></a>STL六大组件 功能与运用</h2><p>STL提供六大组件，彼此可以组合套用</p>
<ol>
<li>容器：各种数据结构。Vector,list,deque,set,map</li>
<li>算法：各种常用算法如sort,search,copy,erase</li>
<li>迭代器：扮演容器与算法之间的粘合剂，所谓的泛型指针。五种类型</li>
<li>仿函数：行为类似函数，可以作为算法的某种策略。仿函数是重载了()的class或者class template，一般函数指针可视为狭义的仿函数</li>
<li>配接器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>配置器：负责控件的配置与管理。</li>
</ol>
<a id="more"></a>
<p><img src="/img/20161108212017.png" alt=""></p>
<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p>SGI STL时间了一个专属的，拥有次层配置能力的、效率优越的特殊配置器。<br>SGI STL的缺省分配器都是其自己的分配器。</p>
<h2 id="SGI特殊的空间配置器-std-alloc"><a href="#SGI特殊的空间配置器-std-alloc" class="headerlink" title="SGI特殊的空间配置器 std::alloc"></a>SGI特殊的空间配置器 std::alloc</h2><p>使用::construct() ::destroy()构造和析构<br>使用alloc::allocate() alloc::deallocate()分配 释放<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//直接利用这个类能够用指定类型指针，转换为其他引用等</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;<span class="keyword">const</span> _Tp*&gt; &#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*                  pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;                  reference;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果有non-trivial 析构函数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIterator&gt;</div><div class="line"><span class="keyword">void</span></div><div class="line">__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)</div><div class="line">    destroy(&amp;*__first);</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果没有non-trivial 析构函数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIterator&gt; </div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIterator, <span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </div><div class="line">__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp&gt;::has_trivial_destructor</div><div class="line">          _Trivial_destructor;</div><div class="line">  __destroy_aux(__first, __last, _Trivial_destructor());<span class="comment">//_Trivial_destructor()将会是_true_type 或者_false_type</span></div><div class="line">  <span class="comment">//利用模板和特化</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(_ForwardIterator __first, _ForwardIterator __last) &#123;</div><div class="line">  __destroy(__first, __last, __VALUE_TYPE(__first));<span class="comment">//__VALUE_TYPE(__first)获取到了类型的指针，然后调用上面函数</span></div><div class="line">  <span class="comment">//利用模板和特化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="空间的配置与释放-std-alloc"><a href="#空间的配置与释放-std-alloc" class="headerlink" title="空间的配置与释放 std::alloc"></a>空间的配置与释放 std::alloc</h2><p>sgi设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略。<br>当分配大于128bytes时候调用第一级，小于128时候，为了降低额外负担，使用负责的memory pool整理方式。</p>
<h3 id="第一级配置器-malloc-alloc-template剖析"><a href="#第一级配置器-malloc-alloc-template剖析" class="headerlink" title="第一级配置器 __malloc_alloc_template剖析"></a>第一级配置器 __malloc_alloc_template剖析</h3><p>以malloc free realloc实现。<br>然后自己实现了一个new handler机制。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</div><div class="line"><span class="keyword">void</span>*</div><div class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (* __my_malloc_handler)();</div><div class="line">    <span class="keyword">void</span>* __result;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</div><div class="line">        (*__my_malloc_handler)();</div><div class="line">        __result = <span class="built_in">malloc</span>(__n);</div><div class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第二级配置器"><a href="#第二级配置器" class="headerlink" title="第二级配置器"></a>第二级配置器</h3><p>SIG第二级配置器的做法，如果区块够大，超过128bytes时候，就移交第一级配置器处理。当区块小鱼128bytes时候，则以内存池管理。每次配置一大块内存，并维护对应之自由链表，下次若再有相同大小的内存需求从free-lists中拨出。如果客端释放小额区块，就由配置器回收到fres-lists中。<br>分配区块时候，自动上调到8的倍数，并维护16个fres-lists,分别管理大小为8/16/24/32/40/48/56/64/72/80/88/96/104/112/120/128的小额区块。</p>
<blockquote>
<p>其实这里和公司用的NG_malloc是一样的策略。ng_malloc之前对于大小的区分是256k的样子，更大。后来又改写了，支持更大的内存块了。</p>
</blockquote>
<p>节点如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__PRIVATE:</div><div class="line">  <span class="keyword">union</span> _Obj &#123;</div><div class="line">        <span class="keyword">union</span> _Obj* _M_free_list_link;</div><div class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p>使用union的话，可以不用每次都去转换。char _M_client_data的存在是，方便去取首地址。实际上下面用到的就是_M_free_list_link，用来作为链表。这样的话，就可以用一个4字节的空间(32位机器指针大小)，实现两个功能。而不是使用struct，因为那样就会浪费空间。</p>
<h4 id="空间配置函数allocate"><a href="#空间配置函数allocate" class="headerlink" title="空间配置函数allocate()"></a>空间配置函数allocate()</h4><p>功能：判断大小，大于128用第一级分配，小于128就查找free list。如果free list中有可用的区块，就直接拿来用，如果没有就将区块大小上调至8的倍数边界，然后调用refill()，准备为free list重新填充空间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">//超过设定的最大值就调用第一级配置器，STL设置为128</span></div><div class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</div><div class="line">      __ret = malloc_alloc::allocate(__n);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//寻找合适的free lists中适当的一个</span></div><div class="line">      _Obj* __STL_VOLATILE* __my_free_list</div><div class="line">          = _S_free_list + _S_freelist_index(__n);</div><div class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></div><div class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></div><div class="line">      <span class="comment">// unwinding.</span></div><div class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></div><div class="line">      <span class="comment">/*REFERENCED*/</span></div><div class="line">      <span class="comment">//多线程锁</span></div><div class="line">      _Lock __lock_instance;</div><div class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></div><div class="line">      _Obj* __RESTRICT __result = *__my_free_list;</div><div class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</div><div class="line">        <span class="comment">//没找到的话，就重新填充free list</span></div><div class="line">        __ret = _S_refill(_S_round_up(__n));</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//指向后一个成员</span></div><div class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</div><div class="line">        __ret = __result;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> __ret;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<h4 id="空间释放函数-deallocate"><a href="#空间释放函数-deallocate" class="headerlink" title="空间释放函数 deallocate()"></a>空间释放函数 deallocate()</h4><p>先判断大小，大于128调用第一级，小于128找出对应的free list，将区块回收。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* __p may not be 0 */</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</div><div class="line">      malloc_alloc::deallocate(__p, __n);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      _Obj* __STL_VOLATILE*  __my_free_list</div><div class="line">          = _S_free_list + _S_freelist_index(__n);</div><div class="line">      _Obj* __q = (_Obj*)__p;</div><div class="line"></div><div class="line">      <span class="comment">// acquire lock</span></div><div class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></div><div class="line">      <span class="comment">/*REFERENCED*/</span></div><div class="line">      _Lock __lock_instance;</div><div class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></div><div class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</div><div class="line">      *__my_free_list = __q;</div><div class="line">      <span class="comment">// lock is released here</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="重新填充free-lists"><a href="#重新填充free-lists" class="headerlink" title="重新填充free lists"></a>重新填充free lists</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</div><div class="line"><span class="keyword">void</span>*</div><div class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</div><div class="line">    <span class="comment">//尝试分配空间 __nobjs是引用传递，作为返回值</span></div><div class="line">    <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</div><div class="line">    _Obj* __STL_VOLATILE* __my_free_list;</div><div class="line">    _Obj* __result;</div><div class="line">    _Obj* __current_obj;</div><div class="line">    _Obj* __next_obj;</div><div class="line">    <span class="keyword">int</span> __i;</div><div class="line">    </div><div class="line">    <span class="comment">//对只分配出一个的时候的优化</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</div><div class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</div><div class="line"></div><div class="line">    <span class="comment">//形成链表</span></div><div class="line">    <span class="comment">/* Build free list in chunk */</span></div><div class="line">      __result = (_Obj*)__chunk;</div><div class="line">      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);</div><div class="line">      <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</div><div class="line">        __current_obj = __next_obj;</div><div class="line">        __next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);</div><div class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;</div><div class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span>(__result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p>从内存池中取空间给free list 使用，是chunk_alloc的工作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</div><div class="line"><span class="keyword">char</span>*</div><div class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, </div><div class="line">                                                            <span class="keyword">int</span>&amp; __nobjs)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span>* __result;<span class="comment">//返回值</span></div><div class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;<span class="comment">//需要分配的空间大小</span></div><div class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;<span class="comment">//内存池剩余空间</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;</div><div class="line">        __result = _S_start_free;<span class="comment">//返回</span></div><div class="line">        _S_start_free += __total_bytes;<span class="comment">//内存池可用空间起始处后移</span></div><div class="line">        <span class="keyword">return</span>(__result);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;<span class="comment">//能够分配一部分空间</span></div><div class="line">        __nobjs = (<span class="keyword">int</span>)(__bytes_left/__size);<span class="comment">//判断能够分配的块数</span></div><div class="line">        __total_bytes = __size * __nobjs;</div><div class="line">        __result = _S_start_free;</div><div class="line">        _S_start_free += __total_bytes;<span class="comment">//与上同</span></div><div class="line">        <span class="keyword">return</span>(__result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//不能够分配一块的大小</span></div><div class="line">        <span class="keyword">size_t</span> __bytes_to_get = </div><div class="line">	  <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</div><div class="line">        <span class="comment">// Try to make use of the left-over piece.</span></div><div class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;<span class="comment">//把剩余空间，分配到合适的free list</span></div><div class="line">            _Obj* __STL_VOLATILE* __my_free_list =</div><div class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</div><div class="line"></div><div class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</div><div class="line">            *__my_free_list = (_Obj*)_S_start_free;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//从堆上重新分配出部分空间</span></div><div class="line">        _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;</div><div class="line">            <span class="keyword">size_t</span> __i;</div><div class="line">            _Obj* __STL_VOLATILE* __my_free_list;</div><div class="line">	    _Obj* __p;</div><div class="line">            <span class="comment">// Try to make do with what we have.  That can't</span></div><div class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></div><div class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></div><div class="line">            <span class="keyword">for</span> (__i = __size;</div><div class="line">                 __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES;</div><div class="line">                 __i += (<span class="keyword">size_t</span>) _ALIGN) &#123;</div><div class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</div><div class="line">                __p = *__my_free_list;</div><div class="line">                <span class="comment">//malloc失败的话，在现有的free list中找未用的、足够大的fee list分配</span></div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</div><div class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</div><div class="line">                    _S_start_free = (<span class="keyword">char</span>*)__p;</div><div class="line">                    _S_end_free = _S_start_free + __i;</div><div class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</div><div class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></div><div class="line">                    <span class="comment">// right free list.</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">	    _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></div><div class="line">            _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(__bytes_to_get);</div><div class="line">            <span class="comment">// This should either throw an</span></div><div class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></div><div class="line">            <span class="comment">// succeeded.</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拿到新空间</span></div><div class="line">        _S_heap_size += __bytes_to_get;</div><div class="line">        _S_end_free = _S_start_free + __bytes_to_get;</div><div class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h3><p>uninitialized_copy、uninitialized_fill、uninitialized_fill_n用来处理一些特殊的复制构造的情况。</p>
<h4 id="uninitialized-fill-n实现"><a href="#uninitialized-fill-n实现" class="headerlink" title="uninitialized_fill_n实现"></a>uninitialized_fill_n实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIter, <span class="keyword">class</span> _Size, <span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">inline</span> _<span class="function">ForwardIter </span></div><div class="line"><span class="title">uninitialized_fill_n</span><span class="params">(_ForwardIter __first, _Size __n, <span class="keyword">const</span> _Tp&amp; __x)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIter, <span class="keyword">class</span> _Size, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Tp1&gt;</div><div class="line"><span class="keyword">inline</span> _ForwardIter </div><div class="line">__uninitialized_fill_n(_ForwardIter __first, _Size __n, <span class="keyword">const</span> _Tp&amp; __x, _Tp1*)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;</div><div class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());<span class="comment">//判断有没有复制构造函数，调用不同的函数处理</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//没有复制构造函数的版本</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIter, <span class="keyword">class</span> _Size, <span class="keyword">class</span> _Tp&gt;</div><div class="line"><span class="keyword">inline</span> _ForwardIter</div><div class="line">__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,</div><div class="line">                           <span class="keyword">const</span> _Tp&amp; __x, __true_type)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> fill_n(__first, __n, __x);</div><div class="line">&#125;</div><div class="line"><span class="comment">//有复制构造函数的版本</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIter, <span class="keyword">class</span> _Size, <span class="keyword">class</span> _Tp&gt;</div><div class="line">_ForwardIter</div><div class="line">__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,</div><div class="line">                           <span class="keyword">const</span> _Tp&amp; __x, __false_type)</div><div class="line">&#123;</div><div class="line">  _ForwardIter __cur = __first;</div><div class="line">  __STL_TRY &#123;</div><div class="line">    <span class="keyword">for</span> ( ; __n &gt; <span class="number">0</span>; --__n, ++__cur)</div><div class="line">      _Construct(&amp;*__cur, __x);</div><div class="line">    <span class="keyword">return</span> __cur;</div><div class="line">  &#125;</div><div class="line">  __STL_UNWIND(_Destroy(__first, __cur));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>uninitialized_copy、uninitialized_fill的实现类似</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概论&quot;&gt;&lt;a href=&quot;#概论&quot; class=&quot;headerlink&quot; title=&quot;概论&quot;&gt;&lt;/a&gt;概论&lt;/h1&gt;&lt;p&gt;第一章基本都是C++基础的知识，读了《C++ Primer》的话都懂。关于各种C++的特性、STL特性都有。&lt;/p&gt;
&lt;h2 id=&quot;STL六大组件-功能与运用&quot;&gt;&lt;a href=&quot;#STL六大组件-功能与运用&quot; class=&quot;headerlink&quot; title=&quot;STL六大组件 功能与运用&quot;&gt;&lt;/a&gt;STL六大组件 功能与运用&lt;/h2&gt;&lt;p&gt;STL提供六大组件，彼此可以组合套用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器：各种数据结构。Vector,list,deque,set,map&lt;/li&gt;
&lt;li&gt;算法：各种常用算法如sort,search,copy,erase&lt;/li&gt;
&lt;li&gt;迭代器：扮演容器与算法之间的粘合剂，所谓的泛型指针。五种类型&lt;/li&gt;
&lt;li&gt;仿函数：行为类似函数，可以作为算法的某种策略。仿函数是重载了()的class或者class template，一般函数指针可视为狭义的仿函数&lt;/li&gt;
&lt;li&gt;配接器：一种用来修饰容器或者仿函数或迭代器接口的东西。&lt;/li&gt;
&lt;li&gt;配置器：负责控件的配置与管理。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/child/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="stl源码剖析" scheme="http://yoursite.com/child/tags/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>阅读谷歌编程规范</title>
    <link href="http://yoursite.com/child//blog/2016/11/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83.html"/>
    <id>http://yoursite.com/child//blog/2016/11/阅读谷歌编程规范.html</id>
    <published>2016-11-06T07:47:25.000Z</published>
    <updated>2016-11-06T08:22:22.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h1><p>好的东西就是这样，你每次看都能够有新的收获。<br>这次也一样，读了一遍谷歌编程规范，又有些新的理解，也有一些需要重新让自己记住的点。<br>遂记录下来，成此博文。</p>
<a id="more"></a>
<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h2 id="define保护"><a href="#define保护" class="headerlink" title="#define保护"></a>#define保护</h2><p>谷歌的格式是<br>当是： <project> <em> <path></path> </em> <file> <em>H</em><br>为保证唯一性，头文件的命名应基于其所在项目源代码树的全路径。例如，项目 foo 中的头<br>文件 foo/src/bar/baz.h 按如下方式保护：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO_BAR_BAZ_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_BAR_BAZ_H_</span></div><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></div></pre></td></tr></table></figure></file></project></p>
<p>比较起来我们的格式是使用项目前缀来防止重复，考虑到我们项目的规模一般是不会重复的，因为文件命名上就不一致。</p>
<h2 id="头文件依赖"><a href="#头文件依赖" class="headerlink" title="头文件依赖"></a>头文件依赖</h2><p>尽量使用前置声明减少头文件的依赖。<br>因为引入一个新的头文件，头文件改变时，包含这个头文件的其他头文件也会被重新编译。<br>1.强数据成员声明为Foo* Foo&amp;<br>2.参数、返回值类型为Foo的函数，只是声明<br>3.今天数据成员的类型可以被声明为Foo，因为静态数据成员定义在类定义之外<br>至于使用指针成员替代成员对象，则会降低可读性，执行效率，不要这样做。</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>少于十行的函数定义为内联函数。<br>小巧的代码更好的利用指令缓存。<br>短小的内联函数直接放在.h文件中，对于比较复杂的内联应该放在-inl.h文件中</p>
<h2 id="函数参数的顺序"><a href="#函数参数的顺序" class="headerlink" title="函数参数的顺序"></a>函数参数的顺序</h2><p>输入参数在前，输出在后。</p>
<h2 id="包含文件顺序"><a href="#包含文件顺序" class="headerlink" title="包含文件顺序"></a>包含文件顺序</h2><p>C库 C++库 其他库 项目内的<br>头文件应该有带有目录信息,不要使用当前目录和父目录<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">举例来说， google-awesome-project<span class="meta-keyword">/src/</span>foo<span class="meta-keyword">/internal/</span>fooserver.cc 的包含次序如下 ：</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"foo/public/fooserver.h"</span> // 优先位置</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hash_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"base/basictypes.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"base/commandlineflags.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"foo/public/bar.h"</span></span></div></pre></td></tr></table></figure></p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在.CC文件中，允许甚至提倡使用不具名命名空间，以避免运行时候的命名冲突。<br>最好不要使用using，不要声明命名空间std下的恩和内容。</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>公开嵌套类作为接口的一部分时候，虽然可以直接放在全局作用域中，但是最好还是放在命名空间里。<br>使用起来的话，</p>
<h2 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h2><p>尽量放在命名空间里。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>将函数变量尽可能置于最小作用域内，在声明变量时候将其初始化。靠近第一次使用，利于阅读。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>全局变量的构造函数、西沟函数以及初始化操作的调用顺序只是被部分规定，每次生产可能会有变化。<br>很多可以用单例模式替代。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。"><a href="#构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。" class="headerlink" title="构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。"></a>构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。</h2><p>构造函数的问题是，没有异常处理。</p>
<h2 id="明确的构造函数"><a href="#明确的构造函数" class="headerlink" title="明确的构造函数"></a>明确的构造函数</h2><p>使用explicit，防止自动转换。</p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>大量类并不要拷贝构造函数，所以应该使用DISALLOW_COPY_AND_ASSIGN来防止拷贝构造函数的自动生成<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 禁止使用拷贝构造函数和赋值操作的宏</span></div><div class="line"><span class="comment">// 应在类的 private:中使用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(TypeName) \</span></div><div class="line">TypeName(<span class="keyword">const</span> TypeName&amp;); \</div><div class="line"><span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> TypeName&amp;)</div><div class="line"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">Foo(<span class="keyword">int</span> f);</div><div class="line">~Foo();</div><div class="line"><span class="keyword">private</span>:</div><div class="line">DISALLOW_COPY_AND_ASSIGN(Foo);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>使用组合一般都比使用继承合适，继承只使用public继承<br>虚析构函数只在有继承同时有虚函数的时候使用。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是指满足特定条件的类，这些类以Interface为后缀<br>定义：纯接口</p>
<blockquote>
<p>只有纯虚函数和静态函数<br>没有非静态数据成员<br>没有定义任何构造函数，如果有，也不含参数，并且为protected<br>如果是子类，也只能继承满足上述条件并以Interface为后缀的类</p>
</blockquote>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>除了少数特定环境外，不要重载操作符。<br>缺点</p>
<blockquote>
<p>混淆你的直觉，让你误以为费时的操作和内建操作一样轻巧<br>查找重载操作符的调用处困难<br>有的操作符可以对指针进行操作<br>重载的副作用，重载操作符&amp;的类不能被前置声明</p>
</blockquote>
<h2 id="声明次序"><a href="#声明次序" class="headerlink" title="声明次序"></a>声明次序</h2><p>在类中使用特定的声明次序：public:在 private:之前，成员函数在数据成员（变量）前。<br>定义次序如下：public:、protected:、private:，如果那一块没有，直接忽略即可。<br>每一块中，声明次序一般如下：<br>1) typedefs 和 enums；<br>2) 常量；<br>3) 构造函数；<br>4) 析构函数；<br>5) 成员函数，含静态成员函数；<br>6) 数据成员，含静态数据成员。<br>宏 DISALLOW_COPY_AND_ASSIGN 置于 private:块之后，作为类的最后部分。参考 拷<br>贝构造函数。<br>.cc 文件中函数的定义应尽可能和声明次序一致。<br>不要将大型函数内联到类的定义中，通常，只有那些没有特别意义的或者性能要求高的，并<br>且是比较短小的函数才被定义为内联函数。更多细节参考译文第一篇的 内联函数。</p>
<h2 id="编写短小函数"><a href="#编写短小函数" class="headerlink" title="编写短小函数"></a>编写短小函数</h2><p>超过40行，考虑分割。</p>
<h1 id="Google特有的风情"><a href="#Google特有的风情" class="headerlink" title="Google特有的风情"></a>Google特有的风情</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>需要使用智能指针的话scoped_ptr完全可以胜任。特殊情况下使用share_ptr。不要使用auto_ptr。<br>倾向于设计对象隶属明确的代码。最明确的对象隶属是根本不使用指针，直接将对象作为一个域或者局部变量使用。</p>
<h1 id="其他C-特征"><a href="#其他C-特征" class="headerlink" title="其他C++特征"></a>其他C++特征</h1><h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>所有按引用传递的参数必须加上const </p>
<h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>禁止使用缺省函数参数，所有参数必须明确指定的话，避免程序员不知道存在的缺省参数。</p>
<h2 id="编程数组和alloca"><a href="#编程数组和alloca" class="headerlink" title="编程数组和alloca"></a>编程数组和alloca</h2><p>禁止使用变长数组。使用安全的分配器。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>将一个单元测试用类声明为待测类的友元，很方便。</p>
<h2 id="不使用C-异常"><a href="#不使用C-异常" class="headerlink" title="不使用C++异常"></a>不使用C++异常</h2><h2 id="不使用RTTI"><a href="#不使用RTTI" class="headerlink" title="不使用RTTI"></a>不使用RTTI</h2><p>直接利用虚函数处理不同类型就好了。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>使用 static_cast<br>比较好处理，直接查找static_cast，就能找到哪里用了转换。C语言转换语义模糊。<br>1) static_cast：和 C 风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上<br>转换；<br>2) const_cast：移除 const 属性；<br>3) reinterpret_cast：指针类型和整型或其他指针间不安全的相互转换，仅在你对所做一<br>切了然于心时使用；<br>4) dynamic_cast：除测试外不要使用，除单元测试外，如果你需要在运行时确定类型信<br>息，说明设计有缺陷（参考  RTTI）。</p>
<h2 id="流-streams"><a href="#流-streams" class="headerlink" title="流 streams"></a>流 streams</h2><p>只在记录日志的时候使用。<br>其他时候使用printf替代。<br>估计是stream的构造使用成本高，printf简单直接。<br>然后steam重载&lt;&lt;会产生很多意想不到的错误，在深入理解C++面向对象的书里面也有提到。</p>
<h2 id="前置自增和自减"><a href="#前置自增和自减" class="headerlink" title="前置自增和自减"></a>前置自增和自减</h2><p>效率更高。<br>对于简单数值来说无所谓，但是对于迭代器这种，前置更好。</p>
<h2 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h2><p>在能够使用const的时候使用const.</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>C++中使用 stdint.h中的确定大小整型<br>不要使用无符号，使用断言声明变量非负数。也就是在传参的时候，在执行前断言判断。</p>
<h2 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h2><p>宏尽量被内联函数、枚举和常量替代<br>下面给出的用法模式可以避免一些使用宏的问题，供使用宏时参考：<br>1) 不要在.h 文件中定义宏；<br>2) 使用前正确#define，使用后正确#undef；<br>3) 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；<br>4) 不使用会导致不稳定的 C++构造（unbalanced C++ constructs，译者注） 的宏，<br>至少文档说明其行为。<br>像我们项目里的宏，完全应该被替代，起码使用一个命名空间，防止污染全局空间事情的发生。</p>
<h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h2><p>不缩写<br>易于理解第一</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TODO(kl@gmail.com): Use a "*" here for concatenation operator.</span></div><div class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></div></pre></td></tr></table></figure>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="swich"><a href="#swich" class="headerlink" title="swich"></a>swich</h2><p>如果 default 永不会执行，可以简单的使用 assert：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (var) &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">0</span>: &#123; <span class="comment">// 2 space indent</span></div><div class="line">... <span class="comment">// 4 space indent</span></div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;</div><div class="line">...</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">default</span>: &#123;</div><div class="line">assert(<span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事情的起因&quot;&gt;&lt;a href=&quot;#事情的起因&quot; class=&quot;headerlink&quot; title=&quot;事情的起因&quot;&gt;&lt;/a&gt;事情的起因&lt;/h1&gt;&lt;p&gt;好的东西就是这样，你每次看都能够有新的收获。&lt;br&gt;这次也一样，读了一遍谷歌编程规范，又有些新的理解，也有一些需要重新让自己记住的点。&lt;br&gt;遂记录下来，成此博文。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/child/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="google" scheme="http://yoursite.com/child/tags/google/"/>
    
      <category term="编程规范" scheme="http://yoursite.com/child/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>windows下Pyqt + guiqwt环境的搭建</title>
    <link href="http://yoursite.com/child//blog/2016/10/windows%E4%B8%8BPyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA.html"/>
    <id>http://yoursite.com/child//blog/2016/10/windows下Pyqt-guiqwt环境的搭建.html</id>
    <published>2016-10-19T15:47:25.000Z</published>
    <updated>2016-11-06T08:22:52.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h1><p>这几天为了搭一个PyQt的生产环境遇到了好一些坑。<br>本身搭建PyQt的目的是为了进行试验，使用PyQt开发曾经开发过的项目的难度。<br>原项目是使用MFC开发，利用自己开发的折线绘制控件，进行高速的工控数据采集后，显示到界面上。难点主要在，高速采集之后，绘图的效率问题。<br>最终通过自己开发了一套平移显示绘图控件，在新增数据的时候，每一次只绘制一部分数据，然后通过平移之前的图像与之后的链接在一起，这样达到比较高的绘图效率，才解决了问题。但是MFC界面开发复杂，在MFC界面上花费过多的时间。同时本身绘图控件的开发，可能可以利用现有开源控件进行开发来避免重复造轮子。<br>于是利用PyQt+guiqwt绘图库来开发的方案构建起来。guiqwt本身是QT下常用的绘图控件，效率足够高，经过一些优化是能够使用的。相对Python经常使用的matplotlib来说不够漂亮，但是进行实时数据的平移绘图，效率高出很多。PyQt是模仿QT写的图形库，可以利用QTCreate进行快速的界面构建，而Python相对C++来说，需要处理的坑更少，出现各类崩溃的异常的情况会更少一些。<br>本文主要讲的是PyQt+guiqwt在windows上的搭建。<br>目的是在之后能够通过本文进行快速的开发环境的搭建。</p>
<a id="more"></a>
<h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2><p><a href="https://www.python.org/downloads/" target="_blank" rel="external">Python官网</a><br>通过Python官网下载相应版本的Python,我这里下载的是：python-3.5.2-amd64。<br>64位版本，记住版本号，用于之后的库的选择。</p>
<h2 id="安装PyQt"><a href="#安装PyQt" class="headerlink" title="安装PyQt"></a>安装PyQt</h2><p>PyQt有完整的安装包，过程中会自动安装PyQt+Qt等完整的依赖库。<br><a href="https://sourceforge.net/projects/pyqt/?source=directory" target="_blank" rel="external">PyQt下载站点</a><br>浏览所有文件找到对应的PyQt完整安装包。<br>我下的是下面网址中的64位版本。<br>PyQt5-5.6-gpl-Py3.5-Qt5.6.0-x64-2<br><a href="https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.6/" target="_blank" rel="external">PyQt完整安装包下载</a><br>安装一路下一步完成。</p>
<h2 id="安装NumPy"><a href="#安装NumPy" class="headerlink" title="安装NumPy"></a>安装NumPy</h2><p>为了能够使用guiqwt必须安装依赖的库。<br>首先安装numpy，注意的是需要安装+mk1的numpy库，否则scipy无法正常安装后使用。<br><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">下载地址</a><br>搜索Numpy找到相应的位置。<br>我选择下载的是，与Python版本对应：numpy-1.11.2+mkl-cp35-cp35m-win_amd64.whl<br>使用pip3.5安装</p>
<h2 id="安装scipy"><a href="#安装scipy" class="headerlink" title="安装scipy"></a>安装scipy</h2><p>同上，在上面的网站找到scipy。<br>版本我选择的是：scipy-0.18.1-cp35-cp35m-win_amd64<br>使用pip3.5在numpy之后安装</p>
<h2 id="安装guiqwt"><a href="#安装guiqwt" class="headerlink" title="安装guiqwt"></a>安装guiqwt</h2><p>安装guiqwt<br>上面网站搜索guiqwt<br>选择guiqwt-3.0.3-cp35-cp35m-win_amd64。<br>在sicpy之后使用pip3.5安装</p>
<h2 id="安装eric6"><a href="#安装eric6" class="headerlink" title="安装eric6"></a>安装eric6</h2><p><a href="https://sourceforge.net/projects/eric-ide/" target="_blank" rel="external">下载地址</a><br>我选择的是：eric6-6.1.10和eric6-i18n-zh_CN-6.1.10<br>解压，放到python的安装目录下：python35/eric6<br>运行python35/eric6、install.py进行安装。<br>运行Python35\Scripts\eric6.bat 就打开了eric6</p>
<p>至此开发环境搭建完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事情的起因&quot;&gt;&lt;a href=&quot;#事情的起因&quot; class=&quot;headerlink&quot; title=&quot;事情的起因&quot;&gt;&lt;/a&gt;事情的起因&lt;/h1&gt;&lt;p&gt;这几天为了搭一个PyQt的生产环境遇到了好一些坑。&lt;br&gt;本身搭建PyQt的目的是为了进行试验，使用PyQt开发曾经开发过的项目的难度。&lt;br&gt;原项目是使用MFC开发，利用自己开发的折线绘制控件，进行高速的工控数据采集后，显示到界面上。难点主要在，高速采集之后，绘图的效率问题。&lt;br&gt;最终通过自己开发了一套平移显示绘图控件，在新增数据的时候，每一次只绘制一部分数据，然后通过平移之前的图像与之后的链接在一起，这样达到比较高的绘图效率，才解决了问题。但是MFC界面开发复杂，在MFC界面上花费过多的时间。同时本身绘图控件的开发，可能可以利用现有开源控件进行开发来避免重复造轮子。&lt;br&gt;于是利用PyQt+guiqwt绘图库来开发的方案构建起来。guiqwt本身是QT下常用的绘图控件，效率足够高，经过一些优化是能够使用的。相对Python经常使用的matplotlib来说不够漂亮，但是进行实时数据的平移绘图，效率高出很多。PyQt是模仿QT写的图形库，可以利用QTCreate进行快速的界面构建，而Python相对C++来说，需要处理的坑更少，出现各类崩溃的异常的情况会更少一些。&lt;br&gt;本文主要讲的是PyQt+guiqwt在windows上的搭建。&lt;br&gt;目的是在之后能够通过本文进行快速的开发环境的搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="开发环境" scheme="http://yoursite.com/child/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="windows" scheme="http://yoursite.com/child/tags/windows/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/child/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] sicp 第三章 模块化 对象和状态</title>
    <link href="http://yoursite.com/child//blog/2016/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81.html"/>
    <id>http://yoursite.com/child//blog/2016/09/读书笔记-sicp-第三章-模块化-对象和状态.html</id>
    <published>2016-09-10T00:33:32.000Z</published>
    <updated>2016-10-16T06:35:48.571Z</updated>
    
    <content type="html"><![CDATA[<p>有效的程序综合还需要一些组织原则，它们能够指导我们系统化地完成系统的整体设计。特别的需要一些能够帮助我们构造起模块化的大型系统策略，也就是说，使这些系统能够“自然地”划分为一些具有内聚力的部分，使这些部分可以分别进行开发和维护。<br>有一种非常强有力的设计策略，特别适合用于构造那类模拟真实物理系统的程序，那就是基于被模拟程序的结构去设计程序的结构。那么有关的物理系统里的每一个对象，我们构造起一个与之对象的计算对象；对该系统里的每种活动，我们在自己的计算系统里顶一种符号操作。采用这一策略时的希望是，在需要针对系统中的新对象或者新活动扩充对应的计算模型时候，我们能够不必对程序的组织方面做得很成功，那么在需要添加新特城或者排除旧东西里的错误时候，就只需要在系统里的一些小局部中工作。<br>本章研究两种特点鲜明的策略。第一种策略将注意力集中在对象上，将大型系统看成一大批对象，它们的行为可能随着时间的进展而不断的变化。另一种组织策略将注意力集中在流过的系统的信息流上，非常像电子工程师观察一个信号处理系统。<br>对于对象途径而言，我们必须关注计算对象可以怎样变化而又同时保持其标识。这将迫使我们抛弃老的计算的代换模型，转向更机械式的，理论上也更不同意把握的计算的环境模型。在处理对象、变化和标识时，各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗。如果允许程序并发指向的可能性，事情会变得更困难许多。流方式特别能用于松解在我们模型中对时间的模拟与计算机求值过程中的各种时间发生的顺序。我们将通过一种称为延时求值的技术做到这一点。</p>
<h1 id="赋值和局部状态"><a href="#赋值和局部状态" class="headerlink" title="赋值和局部状态"></a>赋值和局部状态</h1><p>一个由许多对象组成的系统里，其中的这些对象极少会是完全独立的。每个对象都可能通过交互作用，影响其他对象的状态，所谓交互就是建立起一个对象的状态变量与其他对象的状态变量之间的联系。确实如果一个系统中的状态变量可以分组，形成一些内部紧密结合的子系统，每个子系统与其他子系统之间只存在松散的练习，此时将这个系统看作是由一些独立对象组成的观点就会特别有用。<br>对于一个系统的这种观点，有可能成为组织这一系统的计算模型的有力框架。要使这样的一个模型成为模块化的，就要求它能够分解为一批计算对象，使它们能够模拟系统里的实际对象。每个计算对象必须有它自己的一些局部状态变量，用于描述实际对象的状态。对于被模拟系统里的对象的状态是随着时间的变化的，与它们对象的计算对象的状态也必须变化。<br><a id="more"></a></p>
<h2 id="局部状态变量"><a href="#局部状态变量" class="headerlink" title="局部状态变量"></a>局部状态变量</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">set!</span> &lt;name&gt; &lt;new-value&gt;)<span class="comment">;设置值</span></div><div class="line">(<span class="name">begin</span> &lt;exp1&gt; &lt;exp2&gt;)<span class="comment">;顺序求值</span></div><div class="line"></div><div class="line">(<span class="name">define</span> balance <span class="number">100</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">      (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">             balance)</div><div class="line">      <span class="string">"Insufficient funds"</span>))</div></pre></td></tr></table></figure>
<p>上面使用了全局变量<br>下面使用局部变量</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> new-withdraw</div><div class="line">  (<span class="name">let</span> ((<span class="name">balance</span> <span class="number">100</span>))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">      (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">          (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">                 balance)</div><div class="line">          <span class="string">"Insufficient funds"</span>))))</div></pre></td></tr></table></figure>
<p>构建一个提款机<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>)))</div></pre></td></tr></table></figure></p>
<p>创建一个账户<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) withdraw)</div><div class="line">          ((<span class="name">eq</span>? m 'deposit) deposit)</div><div class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknoew request --MAKE-ACCOUNT"</span></div><div class="line">                       m))))</div><div class="line">  dispatch)</div></pre></td></tr></table></figure></p>
<h2 id="引进赋值带来的收益"><a href="#引进赋值带来的收益" class="headerlink" title="引进赋值带来的收益"></a>引进赋值带来的收益</h2><p>能够简化一部分需要变量状态的过程。</p>
<h2 id="引进赋值的代价"><a href="#引进赋值的代价" class="headerlink" title="引进赋值的代价"></a>引进赋值的代价</h2><p>相比函数是编程，输入什么结果就是什么。显然引进赋值让程序变得更复杂。<br>需要存在一个位置存储变量。</p>
<h3 id="命令式程序设计的缺陷"><a href="#命令式程序设计的缺陷" class="headerlink" title="命令式程序设计的缺陷"></a>命令式程序设计的缺陷</h3><p>与函数式程序设计相对，广泛采用的赋值程序设计被称为命令是程序设计。<br>求值顺序需要保证。</p>
<h1 id="求值的环境模型"><a href="#求值的环境模型" class="headerlink" title="求值的环境模型"></a>求值的环境模型</h1><p>类似于C++的区域。<br>过程也是对象。<br>调用过程就会产生新的上下文环境，过程内的是过程内的环境。过程外全局环境等。</p>
<p>过程应用的环境模型两条规则：</p>
<ol>
<li>将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在构造起的这一新环境的上下文中求</li>
<li>相对于一个给定的环境求值一个lambda表达式，将创建其一个过程对象，这个过程对象是一个序对，由该lambda表达式的征文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时候的环境。</li>
</ol>
<h2 id="简单过程的应用"><a href="#简单过程的应用" class="headerlink" title="简单过程的应用"></a>简单过程的应用</h2><h2 id="将框架看做局部状态的展台"><a href="#将框架看做局部状态的展台" class="headerlink" title="将框架看做局部状态的展台"></a>将框架看做局部状态的展台</h2><h2 id="内部定义"><a href="#内部定义" class="headerlink" title="内部定义"></a>内部定义</h2><ol>
<li>局部过程的名字不会与包容它们的过程之外的名字互相干扰，这是因为这些局部过程名 都是该过程运行时创建的框架里约束的，而不是在全局环境里约束的。</li>
<li>局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数，这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属。</li>
</ol>
<h1 id="用变动的数据做模拟"><a href="#用变动的数据做模拟" class="headerlink" title="用变动的数据做模拟"></a>用变动的数据做模拟</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">append!</span> x y)</div><div class="line">  (<span class="name">set-cdr!</span> (<span class="name">last-pair</span> x) y)</div><div class="line">  x)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">last-pair</span> x)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? (<span class="name">cdr</span> x))</div><div class="line">      x</div><div class="line">      (<span class="name">last-pair</span> (<span class="name">cdr</span> x))))</div></pre></td></tr></table></figure>
<h3 id="共享与相等"><a href="#共享与相等" class="headerlink" title="共享与相等"></a>共享与相等</h3><p>共享会导致多个对象都拥有同一个对象，修改一个会导致另外的也跟着被修改。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">eq</span>? x y)<span class="comment">;检查是不是一个对象</span></div></pre></td></tr></table></figure></p>
<h3 id="改变也就是赋值"><a href="#改变也就是赋值" class="headerlink" title="改变也就是赋值"></a>改变也就是赋值</h3><p>主要是构建了一前一后两个指针。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">cons</span> x y)</div><div class="line">  (<span class="name">define</span> (<span class="name">set-x!</span> v) (<span class="name">set!</span> x v))</div><div class="line">  (<span class="name">define</span> (<span class="name">set-y!</span> v) (<span class="name">set!</span> y v))</div><div class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? m 'car) x)</div><div class="line">          ((<span class="name">eq</span>? m 'cdr) y)</div><div class="line">          ((<span class="name">eq</span>? m 'set-car!) set-x!)</div><div class="line">          ((<span class="name">eq</span>? m 'set-cdr!) set-y!)</div><div class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Undefined operation -- CONS"</span> m))))</div><div class="line">  dispatch)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">car</span> z) (<span class="name">z</span> 'car))</div><div class="line">(<span class="name">define</span> (<span class="name">cdr</span> z) (<span class="name">z</span> 'cdr))</div><div class="line">(<span class="name">define</span> (<span class="name">set-car!</span> z new-value)</div><div class="line">  ((<span class="name">z</span> 'set-car!) new-value)</div><div class="line">  z)</div><div class="line">(<span class="name">define</span> (<span class="name">set-cdr!</span> z new-value)</div><div class="line">  ((<span class="name">z</span> 'set-cdr!) new-value)</div><div class="line">  z)</div></pre></td></tr></table></figure></p>
<h2 id="队列的表示"><a href="#队列的表示" class="headerlink" title="队列的表示"></a>队列的表示</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;构造函数</span></div><div class="line">(<span class="name">define</span> (<span class="name">make-queue</span>) (<span class="name">cons</span> '() '()))</div><div class="line"><span class="comment">;选择函数</span></div><div class="line">(<span class="name">define</span> (<span class="name">front-queue</span> queue)</div><div class="line">  (<span class="name">if</span> (<span class="name">empty-queue</span>? queue)</div><div class="line">      (<span class="name">error</span> <span class="string">"FRONT called with an empty queue"</span> queue)</div><div class="line">      (<span class="name">car</span> (<span class="name">front-ptr</span> queue))))</div><div class="line"><span class="comment">;检测队列是否为空</span></div><div class="line">(<span class="name">define</span> (<span class="name">empty-queue</span>? queue) (<span class="name">null</span>? (<span class="name">front-ptr</span> queue)))</div><div class="line"><span class="comment">;改变函数</span></div><div class="line">(<span class="name">define</span> (<span class="name">insert-queue!</span> queue item)</div><div class="line">  (<span class="name">let</span> ((<span class="name">new-pair</span> (<span class="name">cons</span> item '())))</div><div class="line">    (<span class="name">cond</span> ((<span class="name">empty-queue</span>? queue)</div><div class="line">           (<span class="name">set-front-ptr!</span> queue new-pair)</div><div class="line">           (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">           queue)</div><div class="line">          (<span class="name">else</span></div><div class="line">           (<span class="name">set-cdr!</span> (<span class="name">rear-ptr</span> queue) new-pair)</div><div class="line">           (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">           queue))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">delete-queue!</span> queue)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">empty-queue</span>? queue)</div><div class="line">         (<span class="name">error</span> <span class="string">"DELETE! called with an empty queue"</span> queue))</div><div class="line">        (<span class="name">else</span></div><div class="line">         (<span class="name">set-front-ptr!</span> queue (<span class="name">cdr</span> (<span class="name">front-ptr</span> queue)))</div><div class="line">         queue)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">front-ptr</span> queue) (<span class="name">car</span> queue))</div><div class="line">(<span class="name">define</span> (<span class="name">rear-ptr</span> queue) (<span class="name">cdr</span> queue))</div><div class="line">(<span class="name">define</span> (<span class="name">set-front-ptr!</span> queue item) (<span class="name">set-car!</span> queue item))</div><div class="line">(<span class="name">define</span> (<span class="name">set-rear-ptr!</span> queue item) (<span class="name">set-car!</span> queue item))</div></pre></td></tr></table></figure>
<h2 id="表格的表示"><a href="#表格的表示" class="headerlink" title="表格的表示"></a>表格的表示</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">lookup</span> key table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">cdr</span> record)</div><div class="line">        false)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">assoc</span> key records)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? records) false)</div><div class="line">        ((<span class="name">equal</span>? key (<span class="name">caar</span> records)) (<span class="name">car</span> records))</div><div class="line">        (<span class="name">else</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> records)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">insert!</span> key value table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">set-cdr!</span> record value)</div><div class="line">        (<span class="name">set-cdr!</span> table</div><div class="line">                  (<span class="name">cons</span> (<span class="name">cons</span> key value) (<span class="name">cdr</span> table))))))</div><div class="line">(<span class="name">define</span> (<span class="name">make-table</span>)</div><div class="line">  (<span class="name">list</span> '*table*))</div></pre></td></tr></table></figure>
<h2 id="数字电路的模拟器"><a href="#数字电路的模拟器" class="headerlink" title="数字电路的模拟器"></a>数字电路的模拟器</h2><h1 id="并发：时间本质是个问题"><a href="#并发：时间本质是个问题" class="headerlink" title="并发：时间本质是个问题"></a>并发：时间本质是个问题</h1><p>和普通的并发问题是一致的。<br>串行化共享部分。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> s make-serializer)</div><div class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">=</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line">  (<span class="name">let</span> ((<span class="name">protected</span> (<span class="name">make-serializer</span>)))</div><div class="line">    (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) (<span class="name">protected</span> withdraw))</div><div class="line">            ((<span class="name">eq</span>? m 'deposit) (<span class="name">protected</span> deposit))</div><div class="line">            ((<span class="name">eq</span>? m 'balance) balance)</div><div class="line">            (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request --MAKE-ACCOUNT"</span></div><div class="line">                         m))))</div><div class="line">    dispatch))</div></pre></td></tr></table></figure></p>
<h2 id="串行化的实现"><a href="#串行化的实现" class="headerlink" title="串行化的实现"></a>串行化的实现</h2><p>互斥元同步机制。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-serializer</span>)</div><div class="line">  (<span class="name">let</span> ((<span class="name">mutex</span> (<span class="name">make-mutex</span>)))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">p</span>)</div><div class="line">      (<span class="name">define</span> (<span class="name">serialized-p</span> . args)</div><div class="line">        (<span class="name">mutex</span> 'acquire)</div><div class="line">        (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">apply</span> p args)))</div><div class="line">          (<span class="name">mutex</span> 'release)</div><div class="line">          val))</div><div class="line">      serialized-p)))</div><div class="line"></div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-mutex</span>)</div><div class="line">  (<span class="name">let</span> ((<span class="name">cell</span> (<span class="name">list</span> false)))</div><div class="line">    (<span class="name">define</span> (<span class="name">the-mutex</span> m)</div><div class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'acquire)</div><div class="line">             (<span class="name">if</span> (<span class="name">test-and-set!</span> cell)</div><div class="line">                 (<span class="name">the-mutex</span> 'acquire)))</div><div class="line">            ((<span class="name">eq</span>? m 'release) (<span class="name">clea!</span> cell))))</div><div class="line">    the-mutex))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">test-and-set!</span> cell)</div><div class="line">  (<span class="name">if</span> (<span class="name">car</span> cell)</div><div class="line">      true</div><div class="line">      (<span class="name">begin</span> (<span class="name">set-car!</span> cell true)</div><div class="line">             false)))</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有效的程序综合还需要一些组织原则，它们能够指导我们系统化地完成系统的整体设计。特别的需要一些能够帮助我们构造起模块化的大型系统策略，也就是说，使这些系统能够“自然地”划分为一些具有内聚力的部分，使这些部分可以分别进行开发和维护。&lt;br&gt;有一种非常强有力的设计策略，特别适合用于构造那类模拟真实物理系统的程序，那就是基于被模拟程序的结构去设计程序的结构。那么有关的物理系统里的每一个对象，我们构造起一个与之对象的计算对象；对该系统里的每种活动，我们在自己的计算系统里顶一种符号操作。采用这一策略时的希望是，在需要针对系统中的新对象或者新活动扩充对应的计算模型时候，我们能够不必对程序的组织方面做得很成功，那么在需要添加新特城或者排除旧东西里的错误时候，就只需要在系统里的一些小局部中工作。&lt;br&gt;本章研究两种特点鲜明的策略。第一种策略将注意力集中在对象上，将大型系统看成一大批对象，它们的行为可能随着时间的进展而不断的变化。另一种组织策略将注意力集中在流过的系统的信息流上，非常像电子工程师观察一个信号处理系统。&lt;br&gt;对于对象途径而言，我们必须关注计算对象可以怎样变化而又同时保持其标识。这将迫使我们抛弃老的计算的代换模型，转向更机械式的，理论上也更不同意把握的计算的环境模型。在处理对象、变化和标识时，各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗。如果允许程序并发指向的可能性，事情会变得更困难许多。流方式特别能用于松解在我们模型中对时间的模拟与计算机求值过程中的各种时间发生的顺序。我们将通过一种称为延时求值的技术做到这一点。&lt;/p&gt;
&lt;h1 id=&quot;赋值和局部状态&quot;&gt;&lt;a href=&quot;#赋值和局部状态&quot; class=&quot;headerlink&quot; title=&quot;赋值和局部状态&quot;&gt;&lt;/a&gt;赋值和局部状态&lt;/h1&gt;&lt;p&gt;一个由许多对象组成的系统里，其中的这些对象极少会是完全独立的。每个对象都可能通过交互作用，影响其他对象的状态，所谓交互就是建立起一个对象的状态变量与其他对象的状态变量之间的联系。确实如果一个系统中的状态变量可以分组，形成一些内部紧密结合的子系统，每个子系统与其他子系统之间只存在松散的练习，此时将这个系统看作是由一些独立对象组成的观点就会特别有用。&lt;br&gt;对于一个系统的这种观点，有可能成为组织这一系统的计算模型的有力框架。要使这样的一个模型成为模块化的，就要求它能够分解为一批计算对象，使它们能够模拟系统里的实际对象。每个计算对象必须有它自己的一些局部状态变量，用于描述实际对象的状态。对于被模拟系统里的对象的状态是随着时间的变化的，与它们对象的计算对象的状态也必须变化。&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/child/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="sicp" scheme="http://yoursite.com/child/tags/sicp/"/>
    
      <category term="计算机程序的构造与解释" scheme="http://yoursite.com/child/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E8%A7%A3%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] sicp 第二章 带有通用型操作的系统</title>
    <link href="http://yoursite.com/child//blog/2016/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E6%9C%89%E9%80%9A%E7%94%A8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F.html"/>
    <id>http://yoursite.com/child//blog/2016/09/读书笔记-sicp-第二章-带有通用型操作的系统.html</id>
    <published>2016-09-10T00:32:54.000Z</published>
    <updated>2016-10-16T06:35:48.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用型算术运算"><a href="#通用型算术运算" class="headerlink" title="通用型算术运算"></a>通用型算术运算</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">add</span> x y) (<span class="name">apply-generic</span> 'add x y))</div><div class="line">(<span class="name">define</span> (<span class="name">sub</span> x y) (<span class="name">apply-generic</span> 'sub x y))</div><div class="line">(<span class="name">define</span> (<span class="name">mul</span> x y) (<span class="name">apply-generic</span> 'mul x y))</div><div class="line">(<span class="name">define</span> (<span class="name">div</span> x y) (<span class="name">apply-generic</span> 'div x y))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">install-scheme-number-package</span>)</div><div class="line">  (<span class="name">define</span> (<span class="name">tag</span> x)</div><div class="line">    (<span class="name">attach-tag</span> 'scheme-number x))</div><div class="line">  (<span class="name">put</span> 'add '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">+</span> x y))))</div><div class="line">  (<span class="name">put</span> 'sub '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">-</span> x y))))</div><div class="line">  (<span class="name">put</span> 'mul '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">*</span> x y))))</div><div class="line">  (<span class="name">put</span> 'div '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">/</span> x y))))</div><div class="line">  (<span class="name">put</span> 'make '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">tag</span> x)))</div><div class="line">  'done)</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">make-scheme-number</span> n)</div><div class="line">  ((<span class="name">get</span> 'make 'scheme-number) n))</div></pre></td></tr></table></figure>
<p>利用同样的方法可以加入有理数/复数等操作</p>
<a id="more"></a>
<h1 id="不同类型数据的组合"><a href="#不同类型数据的组合" class="headerlink" title="不同类型数据的组合"></a>不同类型数据的组合</h1><p>处理跨类型的操作。<br>为每一种跨类型操作提供专门的过程处理，是可以，但是太麻烦。每添加一种类型，要增加太多过程。</p>
<h2 id="强制"><a href="#强制" class="headerlink" title="强制"></a>强制</h2><p>类型转换处理能够解决一部分问题。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;实数转虚数</span></div><div class="line">(<span class="name">define</span> (<span class="name">scheme-number-&gt;complex</span> n)</div><div class="line">  (<span class="name">make-complex-from-real-imag</span> (<span class="name">contents</span> n) <span class="number">0</span>))</div></pre></td></tr></table></figure></p>
<p>将这些强制过程安装到一个特护的表格里，用两个类型的名字作为索引。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">put-coercion</span> 'scheme-number 'complex scheme-number-&gt;complex)</div></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">apply-generic</span> op . args)</div><div class="line">  (<span class="name">let</span> ((<span class="name">type-tags</span> (<span class="name">map</span> type-tag args)))</div><div class="line">    (<span class="name">let</span> ((<span class="name">proc</span> (<span class="name">get</span> op type-tags)))</div><div class="line">      (<span class="name">if</span> proc</div><div class="line">          (<span class="name">apply</span> proc (<span class="name">map</span> contents args))</div><div class="line">          (<span class="name">if</span> (<span class="name">=</span> (<span class="name">length</span> args) <span class="number">2</span>)</div><div class="line">              (<span class="name">let</span> ((<span class="name">type1</span> (<span class="name">car</span> type-tags))</div><div class="line">                    (<span class="name">type2</span> (<span class="name">cadr</span> type-tags))</div><div class="line">                    (<span class="name">a1</span> (<span class="name">car</span> args))</div><div class="line">                    (<span class="name">a2</span> (<span class="name">cadr</span> args)))</div><div class="line">                (<span class="name">let</span> ((<span class="name">t1-&gt;t2</span> (<span class="name">get-coercion</span> type1 type2))</div><div class="line">                      (<span class="name">t2-&gt;t1</span> (<span class="name">get-coercion</span> type2 type1)))</div><div class="line">                  (<span class="name">cond</span> (<span class="name">t1-&gt;t2</span></div><div class="line">                         (<span class="name">apply-generic</span> op (<span class="name">t1-&gt;t2</span> a1) a2))</div><div class="line">                        (<span class="name">t2-&gt;t1</span></div><div class="line">                         (<span class="name">apply-generic</span> op a1 (<span class="name">t2-&gt;t1</span> a2)))</div><div class="line">                        (<span class="name">else</span></div><div class="line">                         (<span class="name">error</span> <span class="string">"No method for these types"</span></div><div class="line">                                (<span class="name">list</span> op type-tags))))))</div><div class="line">              (<span class="name">error</span> <span class="string">"No method for these types"</span></div><div class="line">                     (<span class="name">list</span> op type-tags)))))))</div></pre></td></tr></table></figure>
<h1 id="类型的层次结构"><a href="#类型的层次结构" class="headerlink" title="类型的层次结构"></a>类型的层次结构</h1><p>就是继承嘛。子类型有父类型的所有操作。</p>
<p>#层次结构的不足<br>可能产生菱形的层次结构。</p>
<p>在设计大型系统时，处理好一大批相互有关的类型而同时又能保持模块性，这是一个困难的问题，也是当前正在继续研究的领域。<br>编者注：这句话出现在书的第一版本。它的现在就像20年前写出时候正确。开发出一种有用的，具有一般意义的框架，以描述不同类型对象之间的关系(哲学中本体论)，看来是一件极其困难的工作。在10年前存在的混乱和今天存在的混乱之间的主要差异在于，今天已经有了一批各式各样的并不合适的本体理论，它们已经嵌入数量过多而又先天不足的各种程序设计语言里。举例来说，面向对象语言的大部分复杂性-以及当前各种面向对象语言之间细微的而且诗人迷惑的差异-的核心，就是类型之间通用型操作的处理。我们在第三章有关计算性对象的讨论中完全避免了这些问题。熟悉面向对象程序涉及到读者将会注意到，在第三章里关于局部状态说了许多东西，但是却根本没有提到“类”或者“继承”。事实上，我们的猜想是，如果没有知识表示和自动推理工作的帮助，这些问题是无法仅仅通过计算机语言设计的方式合理处理的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;通用型算术运算&quot;&gt;&lt;a href=&quot;#通用型算术运算&quot; class=&quot;headerlink&quot; title=&quot;通用型算术运算&quot;&gt;&lt;/a&gt;通用型算术运算&lt;/h1&gt;&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;define&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;add&lt;/span&gt; x y) (&lt;span class=&quot;name&quot;&gt;apply-generic&lt;/span&gt; &#39;add x y))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;define&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;sub&lt;/span&gt; x y) (&lt;span class=&quot;name&quot;&gt;apply-generic&lt;/span&gt; &#39;sub x y))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;define&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;mul&lt;/span&gt; x y) (&lt;span class=&quot;name&quot;&gt;apply-generic&lt;/span&gt; &#39;mul x y))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;define&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; x y) (&lt;span class=&quot;name&quot;&gt;apply-generic&lt;/span&gt; &#39;div x y))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;define&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;install-scheme-number-package&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;define&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;tag&lt;/span&gt; x)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;attach-tag&lt;/span&gt; &#39;scheme-number x))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;put&lt;/span&gt; &#39;add &#39;(scheme-number scheme-number)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       (&lt;span class=&quot;name&quot;&gt;lambda&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;x&lt;/span&gt; y) (&lt;span class=&quot;name&quot;&gt;tag&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; x y))))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;put&lt;/span&gt; &#39;sub &#39;(scheme-number scheme-number)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       (&lt;span class=&quot;name&quot;&gt;lambda&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;x&lt;/span&gt; y) (&lt;span class=&quot;name&quot;&gt;tag&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;-&lt;/span&gt; x y))))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;put&lt;/span&gt; &#39;mul &#39;(scheme-number scheme-number)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       (&lt;span class=&quot;name&quot;&gt;lambda&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;x&lt;/span&gt; y) (&lt;span class=&quot;name&quot;&gt;tag&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;*&lt;/span&gt; x y))))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;put&lt;/span&gt; &#39;div &#39;(scheme-number scheme-number)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       (&lt;span class=&quot;name&quot;&gt;lambda&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;x&lt;/span&gt; y) (&lt;span class=&quot;name&quot;&gt;tag&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;/&lt;/span&gt; x y))))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;put&lt;/span&gt; &#39;make &#39;(scheme-number scheme-number)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       (&lt;span class=&quot;name&quot;&gt;lambda&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;x&lt;/span&gt;) (&lt;span class=&quot;name&quot;&gt;tag&lt;/span&gt; x)))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &#39;done)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;define&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;make-scheme-number&lt;/span&gt; n)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ((&lt;span class=&quot;name&quot;&gt;get&lt;/span&gt; &#39;make &#39;scheme-number) n))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;利用同样的方法可以加入有理数/复数等操作&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/child/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="sicp" scheme="http://yoursite.com/child/tags/sicp/"/>
    
      <category term="计算机程序的构造与解释" scheme="http://yoursite.com/child/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E8%A7%A3%E9%87%8A/"/>
    
  </entry>
  
</feed>
