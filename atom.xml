<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鉴心</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.coderyang.com/"/>
  <updated>2017-07-18T08:11:04.602Z</updated>
  <id>http://www.coderyang.com/</id>
  
  <author>
    <name>YangYi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis源码阅读-总结</title>
    <link href="http://www.coderyang.com//blog/2017/07/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.coderyang.com//blog/2017/07/Redis源码阅读-总结.html</id>
    <published>2017-07-18T07:59:57.000Z</published>
    <updated>2017-07-18T08:11:04.602Z</updated>
    
    <content type="html"><![CDATA[<p>之前的一系列Redis源码阅读的博客都是基于《Redis设计与实现》的，内容上不免和书有雷同。</p>
<p>本来计划是三月份开始看，但是中间由于接到一个开发速度要求很高的项目，加班很多耽误了些进度，只在这一段时间里看了部分小书（部分书摘录成了博客），耽搁了。</p>
<p>然后快到七月的时候，项目在经过编码、测试，最终投用起来之后，又有了更多的时间来学习。便开始了源码的继续阅读。</p>
<p>阅读redis源码的目的:</p>
<ul>
<li>为了之后项目如果使用redis的话能够游刃有余。</li>
<li>学习其优秀的编码。</li>
</ul>
<p>参加工作两年。</p>
<p>第一年是从机械专业学生转变为程序员，更多的是在打基础，看了挺多计算机的基础书籍。那段时间相对是痛苦的，遇到一个问题往往不明白，不断去探究又探究出一个新的不明白的问题。</p>
<p>第二年在积累了几万行之后，开始感觉基础编码方面比较游刃有余了，遇到的问题大多数能提取终点，找到解决方案。但是想着继续提升，于是开始了部分项目的源码阅读。除了公司项目源码的阅读，网上开源项目的源码阅读也提上了日程，在经过了sgi stl的仿写之后，开始了redis的阅读。</p>
<p>redis是我第一个比较完整的看完的现在流行的开源项目源码。不算中间停下来的时间，大概看了三个星期。这三个星期里不能说对redis理解很深透，但是起码整个项目的结构，怎么实现主要的功能，内部模块的互相调用算是理解了。</p>
<p>收获有很多，修炼还需要继续。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的一系列Redis源码阅读的博客都是基于《Redis设计与实现》的，内容上不免和书有雷同。&lt;/p&gt;
&lt;p&gt;本来计划是三月份开始看，但是中间由于接到一个开发速度要求很高的项目，加班很多耽误了些进度，只在这一段时间里看了部分小书（部分书摘录成了博客），耽搁了。&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-一个命令的旅程</title>
    <link href="http://www.coderyang.com//blog/2017/07/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B.html"/>
    <id>http://www.coderyang.com//blog/2017/07/redis源码阅读-一个命令的旅程.html</id>
    <published>2017-07-18T07:28:23.000Z</published>
    <updated>2017-07-18T07:29:41.517Z</updated>
    
    <content type="html"><![CDATA[<p>redis服务器会与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行的命令，并通过资源管理来维持整个服务器自身的运转。</p>
<p>本文目的是为了理清楚服务器对于命令请求的整个处理过程，说明这个过程中服务器与客户端如何互相交互，服务器内部如何调用内部组件达到对命令的执行。</p>
<h2 id="命令的处理流程"><a href="#命令的处理流程" class="headerlink" title="命令的处理流程"></a>命令的处理流程</h2><p>之前在事务代码部分的阅读，已经对于服务器接收客户端的连接并创建命令请求处理器等待命令请求的过程。</p>
<p>现在以一个简单的set命令为例子，看服务器在接收请求之后如何处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET KEY VALUE</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>从客户端发送set key value命令到接收回复ok，都做了如下操作：</p>
<ul>
<li>客户端发送命令。</li>
<li>服务器命令请求处理器接收，引发命令的执行，并产生命令回复处理器。</li>
<li>命令回复处理器发送ok给客户端。</li>
<li>客户端接收ok，并打印。</li>
</ul>
<a id="more"></a>
<h2 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h2><p>客户端将键入的命令转换为协议格式并套接字发送到服务器</p>
<h2 id="读取命令"><a href="#读取命令" class="headerlink" title="读取命令"></a>读取命令</h2><p>服务器发现客户端连接套接字变为可读时，通过命令请求处理器readQueryFromClient()函数来进行处理。</p>
<h3 id="读取命令到缓冲区并处理"><a href="#读取命令到缓冲区并处理" class="headerlink" title="读取命令到缓冲区并处理"></a>读取命令到缓冲区并处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 读取客户端的查询缓冲区内容</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    redisClient *c = (redisClient*) privdata;</div><div class="line">    <span class="keyword">int</span> nread, readlen;</div><div class="line">    <span class="keyword">size_t</span> qblen;</div><div class="line">    REDIS_NOTUSED(el);</div><div class="line">    REDIS_NOTUSED(mask);</div><div class="line"></div><div class="line">    server.current_client = c; <span class="comment">// 设置服务器的当前客户端</span></div><div class="line">    readlen = REDIS_IOBUF_LEN; <span class="comment">// 读取的默认长度</span></div><div class="line">    <span class="comment">/* If this is a multi bulk request, and we are processing a bulk reply</span></div><div class="line">     * that is large enough, try to maximize the probability that the query</div><div class="line">     * buffer contains exactly the SDS string representing the object, even</div><div class="line">     * at the risk of requiring more read(2) calls. This way the function</div><div class="line">     * processMultiBulkBuffer() can avoid copying buffers to create the</div><div class="line">     * Redis Object representing the argument. */</div><div class="line">    <span class="keyword">if</span> (c-&gt;reqtype == REDIS_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></div><div class="line">        &amp;&amp; c-&gt;bulklen &gt;= REDIS_MBULK_BIG_ARG)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> remaining = (<span class="keyword">unsigned</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (remaining &lt; readlen) readlen = remaining;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取缓存区遗留数据长度</span></div><div class="line">    qblen = sdslen(c-&gt;querybuf);</div><div class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen; <span class="comment">// 查询缓冲区长度峰值更新</span></div><div class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen); <span class="comment">// 重新分配查询缓冲区空间</span></div><div class="line">    nread = read(fd, c-&gt;querybuf+qblen, readlen); <span class="comment">// 读取fd中数据，在遗留数据之后</span></div><div class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// 读取错误处理</span></div><div class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</div><div class="line">            nread = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            redisLog(REDIS_VERBOSE, <span class="string">"Reading from client: %s"</span>,strerror(errno));</div><div class="line">            freeClient(c);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 遇到EOF,关闭客户端</span></div><div class="line">        redisLog(REDIS_VERBOSE, <span class="string">"Client closed connection"</span>);</div><div class="line">        freeClient(c);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (nread) &#123;</div><div class="line">        <span class="comment">// 读取成功</span></div><div class="line">        sdsIncrLen(c-&gt;querybuf,nread); <span class="comment">// 正确更新 free 和 len 属性的。</span></div><div class="line">        c-&gt;lastinteraction = server.unixtime; <span class="comment">// 记录最后一次互动时间</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MASTER) c-&gt;reploff += nread; <span class="comment">// 客户端为master,更新复制偏移量</span></div><div class="line">        server.stat_net_input_bytes += nread;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 在 nread == -1 且 errno == EAGAIN 时运行</span></div><div class="line">        server.current_client = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 缓冲区长度超过服务器最大缓冲区长度</span></div><div class="line">    <span class="comment">// 清空缓冲区并释放客户端</span></div><div class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</div><div class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</div><div class="line"></div><div class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"</span>, ci, bytes);</div><div class="line">        sdsfree(ci);</div><div class="line">        sdsfree(bytes);</div><div class="line">        freeClient(c);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 从缓冲区中读取内容，创建参数，并执行命令</span></div><div class="line">    <span class="comment">// 直到缓冲区所有的内容被处理完为止</span></div><div class="line">    processInputBuffer(c);</div><div class="line">    server.current_client = <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="从缓冲区中读取命令并处理"><a href="#从缓冲区中读取命令并处理" class="headerlink" title="从缓冲区中读取命令并处理"></a>从缓冲区中读取命令并处理</h3><p>redis的readQueryFromClient()函数在将命令读取到缓冲区之后，调用processInputBuffer()对缓冲区内的命令进行处理，直到所有命令处理完毕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理客户端输入的内容</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInputBuffer</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Keep processing while there is something in the input buffer */</span></div><div class="line">    <span class="keyword">while</span>(sdslen(c-&gt;querybuf)) &#123;</div><div class="line">        <span class="comment">// 客户端处于暂停状态，直接返回</span></div><div class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_SLAVE) &amp;&amp; clientsArePaused()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 客户端被阻塞直接返回</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_BLOCKED) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 客户端被设置为关闭，返回</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_CLOSE_AFTER_REPLY) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 判断请求类型</span></div><div class="line">        <span class="keyword">if</span> (!c-&gt;reqtype) &#123;</div><div class="line">            <span class="keyword">if</span> (c-&gt;querybuf[<span class="number">0</span>] == <span class="string">'*'</span>) &#123;</div><div class="line">                c-&gt;reqtype = REDIS_REQ_MULTIBULK;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                c-&gt;reqtype = REDIS_REQ_INLINE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 将缓冲区中的内容转换为命令，以及命令参数</span></div><div class="line">        <span class="comment">// processMultibulkBuffer()处理一般客户端发送的信息</span></div><div class="line">      	<span class="comment">// processInlineBuffer()处理TELNET发送的信息</span></div><div class="line">        <span class="comment">// 命令转换失败跳出循环，也就是可能在没有处理完缓冲区所有数据的情况下跳出。</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;reqtype == REDIS_REQ_INLINE) &#123;</div><div class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != REDIS_OK) <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;reqtype == REDIS_REQ_MULTIBULK) &#123;</div><div class="line">            <span class="keyword">if</span> (processMultibulkBuffer(c) != REDIS_OK) <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            redisPanic(<span class="string">"Unknown request type"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 命令参数为0，不需要执行</span></div><div class="line">            resetClient(c);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 执行命令，在成功执行之后重置客户端</span></div><div class="line">            <span class="keyword">if</span> (processCommand(c) == REDIS_OK)</div><div class="line">                resetClient(c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 命令的转换介绍下processMultibulkBuffer()，此为处理客户端发送来命令，相对协议更复杂。</span></div><div class="line"><span class="comment">// processInlineBuffer()相对协议简单就不介绍了。</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将 c-&gt;querybuf 中的协议内容转换成 c-&gt;argv 中的参数对象</div><div class="line"> * </div><div class="line"> * 比如 *3\r\n$3\r\nSET\r\n$3\r\nMSG\r\n$5\r\nHELLO\r\n</div><div class="line"> * 将被转换为：</div><div class="line"> * argv[0] = SET</div><div class="line"> * argv[1] = MSG</div><div class="line"> * argv[2] = HELLO</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processMultibulkBuffer</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *newline = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, ok;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line">    <span class="comment">// 读取命令参数个数</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;multibulklen == <span class="number">0</span>) &#123;</div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;argc == <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 校验命令参数中"\r\n"的存在</span></div><div class="line">        newline = <span class="built_in">strchr</span>(c-&gt;querybuf,<span class="string">'\r'</span>);</div><div class="line">        <span class="keyword">if</span> (newline == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; REDIS_INLINE_MAX_SIZE) &#123;</div><div class="line">                addReplyError(c,<span class="string">"Protocol error: too big mbulk count string"</span>);</div><div class="line">                setProtocolError(c,<span class="number">0</span>); <span class="comment">// 异步关闭客户端</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (newline-(c-&gt;querybuf) &gt; ((<span class="keyword">signed</span>)sdslen(c-&gt;querybuf)<span class="number">-2</span>))</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">        <span class="comment">// 第一个字符必须时*</span></div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;querybuf[<span class="number">0</span>] == <span class="string">'*'</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 转换出参数的个数</span></div><div class="line">        ok = string2ll(c-&gt;querybuf+<span class="number">1</span>,newline-(c-&gt;querybuf+<span class="number">1</span>),&amp;ll);</div><div class="line"></div><div class="line">        <span class="comment">// 检测参数个数是否超限</span></div><div class="line">        <span class="keyword">if</span> (!ok || ll &gt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</div><div class="line">            addReplyError(c,<span class="string">"Protocol error: invalid multibulk length"</span>);</div><div class="line">            setProtocolError(c,pos); <span class="comment">// 异步关闭客户端</span></div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        pos = (newline-c-&gt;querybuf)+<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (ll &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 参数小于等于0，删除c-&gt;querybuf中从pos到-1的内容</span></div><div class="line">            <span class="comment">// 返回读取成功</span></div><div class="line">            sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</div><div class="line">            <span class="keyword">return</span> REDIS_OK;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 设置参数个数</span></div><div class="line">        c-&gt;multibulklen = ll;</div><div class="line"></div><div class="line">        <span class="comment">// 分配参数空间</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;argv) zfree(c-&gt;argv);</div><div class="line">        c-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;multibulklen);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    redisAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;multibulklen &gt; <span class="number">0</span>);</div><div class="line">    <span class="keyword">while</span>(c-&gt;multibulklen) &#123;</div><div class="line">        <span class="comment">// 读取参数长度</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;bulklen == <span class="number">-1</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 校验命令参数中"\r\n"的存在</span></div><div class="line">            newline = <span class="built_in">strchr</span>(c-&gt;querybuf+pos,<span class="string">'\r'</span>);</div><div class="line">            <span class="keyword">if</span> (newline == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; REDIS_INLINE_MAX_SIZE) &#123;</div><div class="line">                    addReplyError(c,</div><div class="line">                        <span class="string">"Protocol error: too big bulk count string"</span>);</div><div class="line">                    setProtocolError(c,<span class="number">0</span>);</div><div class="line">                    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (newline-(c-&gt;querybuf) &gt; ((<span class="keyword">signed</span>)sdslen(c-&gt;querybuf)<span class="number">-2</span>))</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 确认格式</span></div><div class="line">            <span class="keyword">if</span> (c-&gt;querybuf[pos] != <span class="string">'$'</span>) &#123;</div><div class="line">                addReplyErrorFormat(c,</div><div class="line">                    <span class="string">"Protocol error: expected '$', got '%c'"</span>,</div><div class="line">                    c-&gt;querybuf[pos]);</div><div class="line">                setProtocolError(c,pos);</div><div class="line">                <span class="keyword">return</span> REDIS_ERR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 读取长度</span></div><div class="line">            ok = string2ll(c-&gt;querybuf+pos+<span class="number">1</span>,newline-(c-&gt;querybuf+pos+<span class="number">1</span>),&amp;ll);</div><div class="line">            <span class="keyword">if</span> (!ok || ll &lt; <span class="number">0</span> || ll &gt; <span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>) &#123;</div><div class="line">                addReplyError(c,<span class="string">"Protocol error: invalid bulk length"</span>);</div><div class="line">                setProtocolError(c,pos);</div><div class="line">                <span class="keyword">return</span> REDIS_ERR;</div><div class="line">            &#125;</div><div class="line">            pos += newline-(c-&gt;querybuf+pos)+<span class="number">2</span>;</div><div class="line">            </div><div class="line">            <span class="comment">// 参数太长的特殊处理</span></div><div class="line">            <span class="keyword">if</span> (ll &gt;= REDIS_MBULK_BIG_ARG) &#123;</div><div class="line">                <span class="keyword">size_t</span> qblen;</div><div class="line"></div><div class="line">                <span class="comment">/* If we are going to read a large object from network</span></div><div class="line">                 * try to make it likely that it will start at c-&gt;querybuf</div><div class="line">                 * boundary so that we can optimize object creation</div><div class="line">                 * avoiding a large copy of data. */</div><div class="line">                sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</div><div class="line">                pos = <span class="number">0</span>;</div><div class="line">                qblen = sdslen(c-&gt;querybuf);</div><div class="line">                <span class="comment">/* Hint the sds library about the amount of bytes this string is</span></div><div class="line">                 * going to contain. */</div><div class="line">                <span class="keyword">if</span> (qblen &lt; (<span class="keyword">size_t</span>)ll+<span class="number">2</span>)</div><div class="line">                    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf,ll+<span class="number">2</span>-qblen);</div><div class="line">            &#125;</div><div class="line">            c-&gt;bulklen = ll;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 读取参数</span></div><div class="line">        <span class="keyword">if</span> (sdslen(c-&gt;querybuf)-pos &lt; (<span class="keyword">unsigned</span>)(c-&gt;bulklen+<span class="number">2</span>)) &#123;</div><div class="line">            <span class="comment">// 确认协议内容</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//复制参数</span></div><div class="line">            <span class="keyword">if</span> (pos == <span class="number">0</span> &amp;&amp;</div><div class="line">                c-&gt;bulklen &gt;= REDIS_MBULK_BIG_ARG &amp;&amp;</div><div class="line">                (<span class="keyword">signed</span>) sdslen(c-&gt;querybuf) == c-&gt;bulklen+<span class="number">2</span>)</div><div class="line">            &#123;</div><div class="line">                c-&gt;argv[c-&gt;argc++] = createObject(REDIS_STRING,c-&gt;querybuf);</div><div class="line">                sdsIncrLen(c-&gt;querybuf,<span class="number">-2</span>); <span class="comment">/* remove CRLF */</span></div><div class="line">                c-&gt;querybuf = sdsempty();</div><div class="line">                <span class="comment">/* Assume that if we saw a fat argument we'll see another one</span></div><div class="line">                 * likely... */</div><div class="line">                c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf,c-&gt;bulklen+<span class="number">2</span>);</div><div class="line">                pos = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                c-&gt;argv[c-&gt;argc++] =</div><div class="line">                    createStringObject(c-&gt;querybuf+pos,c-&gt;bulklen);</div><div class="line">                pos += c-&gt;bulklen+<span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">            c-&gt;bulklen = <span class="number">-1</span>;</div><div class="line">            c-&gt;multibulklen--; <span class="comment">// 继续读取</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清除已经读取的内容</span></div><div class="line">    <span class="keyword">if</span> (pos) sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 读取完毕返回</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;multibulklen == <span class="number">0</span>) <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">    <span class="comment">// 可能内容不符合协议返回失败</span></div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h2><p>processInputBuffer()在解析成功命令之后，调用processCommand()对命令进行执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInputBuffer</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">  		<span class="comment">// ....</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 命令参数为0，不需要执行</span></div><div class="line">            resetClient(c);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 执行命令，在成功执行之后重置客户端</span></div><div class="line">            <span class="keyword">if</span> (processCommand(c) == REDIS_OK)</div><div class="line">                resetClient(c);</div><div class="line">        &#125;</div><div class="line">  		<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命令的查找"><a href="#命令的查找" class="headerlink" title="命令的查找"></a>命令的查找</h3><p>在processCommand()执行的第一步就是查询命令表，找到对于的命令实现信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 命令的执行</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="comment">// quit命令特殊处理，异步关闭服务器</span></div><div class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</div><div class="line">        addReply(c,shared.ok);</div><div class="line">        c-&gt;flags |= REDIS_CLOSE_AFTER_REPLY;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 查找命令</span></div><div class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</div><div class="line">    <span class="keyword">if</span> (!c-&gt;cmd) &#123;</div><div class="line">        <span class="comment">// 没有查找倒</span></div><div class="line">        flagTransaction(c);</div><div class="line">        addReplyErrorFormat(c,<span class="string">"unknown command '%s'"</span>,</div><div class="line">            (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</div><div class="line">        <span class="keyword">return</span> REDIS_OK;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c-&gt;cmd-&gt;arity &gt; <span class="number">0</span> &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</div><div class="line">               (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</div><div class="line">        <span class="comment">// 命令实现与输入的参数数量不匹配</span></div><div class="line">        flagTransaction(c);</div><div class="line">        addReplyErrorFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>,</div><div class="line">            c-&gt;cmd-&gt;name);</div><div class="line">        <span class="keyword">return</span> REDIS_OK;</div><div class="line">    &#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>redis维护了一个命令表，该命令表为一个字典，键为命令名字，值是一个redisCommand结构，该结构记录了一个Redis的命令实现。</p>
<p>服务器启动时，调用初始化服务器配置函数initServerConfig()，该函数会进行命令表的初始化，保存在两个字典中commands、orig_commands。原始的命令表初始参数保存在redis.c文件中的redisCommandTable定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line"> 	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 命令表（受到 rename 配置选项的作用）</span></div><div class="line">    dict *commands;</div><div class="line">    <span class="comment">// 命令表（无 rename 配置选项的作用）</span></div><div class="line">    dict *orig_commands;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">    initServerConfig();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServerConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">  	</div><div class="line">    <span class="comment">// 初始化命令表</span></div><div class="line">  	<span class="comment">// 创建命令字典</span></div><div class="line">    server.commands = dictCreate(&amp;commandTableDictType,<span class="literal">NULL</span>);</div><div class="line">    server.orig_commands = dictCreate(&amp;commandTableDictType,<span class="literal">NULL</span>);</div><div class="line">    populateCommandTable(); <span class="comment">// 初始化命令表</span></div><div class="line">  </div><div class="line">  	<span class="comment">// 初始化常用命令快捷</span></div><div class="line">    server.delCommand = lookupCommandByCString(<span class="string">"del"</span>);</div><div class="line">    server.multiCommand = lookupCommandByCString(<span class="string">"multi"</span>);</div><div class="line">    server.lpushCommand = lookupCommandByCString(<span class="string">"lpush"</span>);</div><div class="line">    server.lpopCommand = lookupCommandByCString(<span class="string">"lpop"</span>);</div><div class="line">    server.rpopCommand = lookupCommandByCString(<span class="string">"rpop"</span>);</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">populateCommandTable</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="comment">// 命令数量</span></div><div class="line">    <span class="keyword">int</span> numcommands = <span class="keyword">sizeof</span>(redisCommandTable)/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> redisCommand);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numcommands; j++) &#123;</div><div class="line">        <span class="keyword">struct</span> redisCommand *c = redisCommandTable+j; <span class="comment">// 命令</span></div><div class="line">        <span class="keyword">char</span> *f = c-&gt;sflags;</div><div class="line">        <span class="keyword">int</span> retval1, retval2;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(*f != <span class="string">'\0'</span>) &#123;</div><div class="line">            <span class="keyword">switch</span>(*f) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'w'</span>: c-&gt;flags |= REDIS_CMD_WRITE; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'r'</span>: c-&gt;flags |= REDIS_CMD_READONLY; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'m'</span>: c-&gt;flags |= REDIS_CMD_DENYOOM; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'a'</span>: c-&gt;flags |= REDIS_CMD_ADMIN; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'p'</span>: c-&gt;flags |= REDIS_CMD_PUBSUB; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'s'</span>: c-&gt;flags |= REDIS_CMD_NOSCRIPT; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'R'</span>: c-&gt;flags |= REDIS_CMD_RANDOM; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'S'</span>: c-&gt;flags |= REDIS_CMD_SORT_FOR_SCRIPT; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'l'</span>: c-&gt;flags |= REDIS_CMD_LOADING; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'t'</span>: c-&gt;flags |= REDIS_CMD_STALE; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'M'</span>: c-&gt;flags |= REDIS_CMD_SKIP_MONITOR; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'k'</span>: c-&gt;flags |= REDIS_CMD_ASKING; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'F'</span>: c-&gt;flags |= REDIS_CMD_FAST; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>: redisPanic(<span class="string">"Unsupported command flag"</span>); <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            f++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 添加</span></div><div class="line">        retval1 = dictAdd(server.commands, sdsnew(c-&gt;name), c);</div><div class="line">        <span class="comment">/* Populate an additional dictionary that will be unaffected</span></div><div class="line">         * by rename-command statements in redis.conf. */</div><div class="line">        retval2 = dictAdd(server.orig_commands, sdsnew(c-&gt;name), c);</div><div class="line">        redisAssert(retval1 == DICT_OK &amp;&amp; retval2 == DICT_OK);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>redisCommandTable定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Redis 命令</span></div><div class="line"><span class="keyword">struct</span> redisCommand &#123;</div><div class="line">    <span class="keyword">char</span> *name; <span class="comment">// 命令名</span></div><div class="line">    redisCommandProc *proc; <span class="comment">// 实现函数</span></div><div class="line">    <span class="keyword">int</span> arity; <span class="comment">// 参数个数</span></div><div class="line">    <span class="keyword">char</span> *sflags; <span class="comment">// 字符串表示FLAG</span></div><div class="line">    <span class="keyword">int</span> flags;   <span class="comment">// 实际FLAG</span></div><div class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></div><div class="line">     * Used for Redis Cluster redirect. */</div><div class="line">    redisGetKeysProc *getkeys_proc;</div><div class="line">    <span class="comment">// 指定哪个参数为key</span></div><div class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></div><div class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></div><div class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls; <span class="comment">// 统计信息</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> redisCommand redisCommandTable[] = &#123;</div><div class="line">    &#123;<span class="string">"get"</span>,getCommand,<span class="number">2</span>,<span class="string">"r"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</div><div class="line">    &#123;<span class="string">"set"</span>,setCommand,<span class="number">-3</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样通过一个命令表，能够快捷的找到命令实现及相关参数。</p>
<h3 id="命令的执行-1"><a href="#命令的执行-1" class="headerlink" title="命令的执行"></a>命令的执行</h3><p>找到命令之后即可执行命令。继续看processCommand()函数。在经过一系列特殊情况处理之后，开始执行命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 命令的执行</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...查找命令</span></div><div class="line">  </div><div class="line">    <span class="comment">// 一系列特殊情况处理</span></div><div class="line"></div><div class="line">    <span class="comment">/* Exec the command */</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 事务状态下的特殊处理</span></div><div class="line">        queueMultiCommand(c);</div><div class="line">        addReply(c,shared.queued);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 执行命令</span></div><div class="line">        call(c,REDIS_CALL_FULL);</div><div class="line">        c-&gt;woff = server.master_repl_offset;</div><div class="line"></div><div class="line">        <span class="comment">// 处理那些解除阻塞的键</span></div><div class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</div><div class="line">            handleClientsBlockedOnLists();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 执行命令</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(redisClient *c, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty, start, duration;</div><div class="line">    <span class="keyword">int</span> client_old_flags = c-&gt;flags;</div><div class="line"></div><div class="line">    <span class="comment">// 命令发送倒MONITOR</span></div><div class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp;</div><div class="line">        !server.loading &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;flags &amp; (REDIS_CMD_SKIP_MONITOR|REDIS_CMD_ADMIN)))</div><div class="line">    &#123;</div><div class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 执行命令</span></div><div class="line">    c-&gt;flags &amp;= ~(REDIS_FORCE_AOF|REDIS_FORCE_REPL);</div><div class="line">    redisOpArrayInit(&amp;server.also_propagate);</div><div class="line">    dirty = server.dirty;</div><div class="line">    start = ustime();</div><div class="line">    c-&gt;cmd-&gt;proc(c); <span class="comment">// 命令实现函数</span></div><div class="line">    duration = ustime()-start; <span class="comment">// 执行时间</span></div><div class="line">    dirty = server.dirty-dirty; <span class="comment">// 命令执行dirty的数量</span></div><div class="line">    <span class="keyword">if</span> (dirty &lt; <span class="number">0</span>) dirty = <span class="number">0</span>;</div><div class="line">	<span class="comment">// ... 一系列附加操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用到setCommand(redisClient *c)函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* SET key value [NX] [XX] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;] */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    robj *expire = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</div><div class="line">    <span class="keyword">int</span> flags = REDIS_SET_NO_FLAGS;</div><div class="line"></div><div class="line">    <span class="comment">// 设置选项参数</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; c-&gt;argc; j++) &#123;</div><div class="line">        <span class="keyword">char</span> *a = c-&gt;argv[j]-&gt;ptr;</div><div class="line">        robj *next = (j == c-&gt;argc<span class="number">-1</span>) ? <span class="literal">NULL</span> : c-&gt;argv[j+<span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'n'</span> || a[<span class="number">0</span>] == <span class="string">'N'</span>) &amp;&amp;</div><div class="line">            (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span>) &#123;</div><div class="line">            flags |= REDIS_SET_NX;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'x'</span> || a[<span class="number">0</span>] == <span class="string">'X'</span>) &amp;&amp;</div><div class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span>) &#123;</div><div class="line">            flags |= REDIS_SET_XX;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'e'</span> || a[<span class="number">0</span>] == <span class="string">'E'</span>) &amp;&amp;</div><div class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp; next) &#123;</div><div class="line">            unit = UNIT_SECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'p'</span> || a[<span class="number">0</span>] == <span class="string">'P'</span>) &amp;&amp;</div><div class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp; next) &#123;</div><div class="line">            unit = UNIT_MILLISECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            addReply(c,shared.syntaxerr);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 尝试编码转换</span></div><div class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">    <span class="comment">// set命令通用的实现</span></div><div class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> flags, robj *key, robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply, robj *abort_reply)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> milliseconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></div><div class="line"></div><div class="line">    <span class="comment">// 取出过期时间 expire为过期时间参数</span></div><div class="line">    <span class="keyword">if</span> (expire) &#123;</div><div class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != REDIS_OK)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</div><div class="line">            addReplyErrorFormat(c,<span class="string">"invalid expire time in %s"</span>,c-&gt;cmd-&gt;name);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果REDIS_SET_NX REDIS_SET_XX 判断是否符合规范</span></div><div class="line">    <span class="keyword">if</span> ((flags &amp; REDIS_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>) ||</div><div class="line">        (flags &amp; REDIS_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>))</div><div class="line">    &#123;</div><div class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置键</span></div><div class="line">    setKey(c-&gt;db,key,val);</div><div class="line">    server.dirty++; <span class="comment">// 脏计数增加</span></div><div class="line">    <span class="keyword">if</span> (expire) setExpire(c-&gt;db,key,mstime()+milliseconds); <span class="comment">// 设置过期时间</span></div><div class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,<span class="string">"set"</span>,key,c-&gt;db-&gt;id); <span class="comment">// 发送事件通知</span></div><div class="line">    <span class="keyword">if</span> (expire) notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,</div><div class="line">        <span class="string">"expire"</span>,key,c-&gt;db-&gt;id);<span class="comment">// 发送事件通知</span></div><div class="line">    addReply(c, ok_reply ? ok_reply : shared.ok); <span class="comment">// 回复</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="回复客户端"><a href="#回复客户端" class="headerlink" title="回复客户端"></a>回复客户端</h2><p>在执行命令出错或者成功后使用addReply()生成回复信息，该函数将通过prepareClientToWrite()产生回复客户端的文件事件，同时将回复内容复制到回复缓存区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReply</span><span class="params">(redisClient *c, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != REDIS_OK) <span class="keyword">return</span>; <span class="comment">// 生成回复客户端的文件事件</span></div><div class="line"></div><div class="line">    <span class="comment">// 根据不同情况，生成回复内容,写入不同的缓冲区</span></div><div class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</div><div class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != REDIS_OK)</div><div class="line">            _addReplyObjectToList(c,obj);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == REDIS_ENCODING_INT) &#123;</div><div class="line">        <span class="comment">/* Optimization: if there is room in the static buffer for 32 bytes</span></div><div class="line">         * (more than the max chars a 64 bit integer can take as string) we</div><div class="line">         * avoid decoding the object and go for the lower level approach. */</div><div class="line">        <span class="keyword">if</span> (listLength(c-&gt;reply) == <span class="number">0</span> &amp;&amp; (<span class="keyword">sizeof</span>(c-&gt;buf) - c-&gt;bufpos) &gt;= <span class="number">32</span>) &#123;</div><div class="line">            <span class="keyword">char</span> buf[<span class="number">32</span>];</div><div class="line">            <span class="keyword">int</span> len;</div><div class="line"></div><div class="line">            len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="keyword">long</span>)obj-&gt;ptr);</div><div class="line">            <span class="keyword">if</span> (_addReplyToBuffer(c,buf,len) == REDIS_OK)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="comment">/* else... continue with the normal code path, but should never</span></div><div class="line">             * happen actually since we verified there is room. */</div><div class="line">        &#125;</div><div class="line">        obj = getDecodedObject(obj);</div><div class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != REDIS_OK)</div><div class="line">            _addReplyObjectToList(c,obj);</div><div class="line">        decrRefCount(obj);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        redisPanic(<span class="string">"Wrong obj-&gt;encoding in addReply()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="comment">// lua 脚本伪客户端</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_LUA_CLIENT) <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">    <span class="comment">// 客户端为REDIS_MASTER REDIS_MASTER_FORCE_REPLY</span></div><div class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; REDIS_MASTER_FORCE_REPLY)) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;fd &lt;= <span class="number">0</span>) <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Fake client for AOF loading. */</span></div><div class="line"></div><div class="line">    <span class="comment">// 一般的客户端生成写事件</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(c-&gt;reply) == <span class="number">0</span> &amp;&amp;</div><div class="line">        (c-&gt;replstate == REDIS_REPL_NONE ||</div><div class="line">         (c-&gt;replstate == REDIS_REPL_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)))</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* Try to install the write handler. */</span></div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE,</div><div class="line">                sendReplyToClient, c) == AE_ERR)</div><div class="line">        &#123;</div><div class="line">            freeClientAsync(c);</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Authorize the caller to queue in the output buffer of this client. */</span></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终文件事件调用sendReplyToClient()回复客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendReplyToClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    redisClient *c = privdata;</div><div class="line">    <span class="keyword">int</span> nwritten = <span class="number">0</span>, totwritten = <span class="number">0</span>, objlen;</div><div class="line">    <span class="keyword">size_t</span> objmem;</div><div class="line">    robj *o;</div><div class="line">    REDIS_NOTUSED(el);</div><div class="line">    REDIS_NOTUSED(mask);</div><div class="line"></div><div class="line">    <span class="comment">// 从缓存区获取数据，写入，直到写完</span></div><div class="line">    <span class="keyword">while</span>(c-&gt;bufpos &gt; <span class="number">0</span> || listLength(c-&gt;reply)) &#123;</div><div class="line">        <span class="keyword">if</span> (c-&gt;bufpos &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 先写入回复缓冲区数据</span></div><div class="line">            nwritten = write(fd,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);</div><div class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 出错跳出</span></div><div class="line"></div><div class="line">            <span class="comment">// 成功计数</span></div><div class="line">            c-&gt;sentlen += nwritten;</div><div class="line">            totwritten += nwritten;</div><div class="line"></div><div class="line">            <span class="comment">// 如果内容写完则清空两个计数器</span></div><div class="line">            <span class="keyword">if</span> (c-&gt;sentlen == c-&gt;bufpos) &#123;</div><div class="line">                c-&gt;bufpos = <span class="number">0</span>;</div><div class="line">                c-&gt;sentlen = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 回复缓冲区为空的话，在回复链表查找</span></div><div class="line">            o = listNodeValue(listFirst(c-&gt;reply));</div><div class="line">            objlen = sdslen(o-&gt;ptr);</div><div class="line">            objmem = getStringObjectSdsUsedMemory(o);</div><div class="line"></div><div class="line">            <span class="comment">// 跳过空对象</span></div><div class="line">            <span class="keyword">if</span> (objlen == <span class="number">0</span>) &#123;</div><div class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</div><div class="line">                c-&gt;reply_bytes -= objmem;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 写入</span></div><div class="line">            nwritten = write(fd, ((<span class="keyword">char</span>*)o-&gt;ptr)+c-&gt;sentlen,objlen-c-&gt;sentlen);</div><div class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 出错跳出</span></div><div class="line"></div><div class="line">            <span class="comment">// 计数</span></div><div class="line">            c-&gt;sentlen += nwritten;</div><div class="line">            totwritten += nwritten;</div><div class="line"></div><div class="line">            <span class="comment">// 如果汉冲去内容写入完毕，删除已经写入的节点</span></div><div class="line">            <span class="keyword">if</span> (c-&gt;sentlen == objlen) &#123;</div><div class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</div><div class="line">                c-&gt;sentlen = <span class="number">0</span>;</div><div class="line">                c-&gt;reply_bytes -= objmem;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 写入量超过限制 在最大内存没设或者最大内存没使用完的情况下跳出</span></div><div class="line">        server.stat_net_output_bytes += totwritten;</div><div class="line">        <span class="keyword">if</span> (totwritten &gt; REDIS_MAX_WRITE_PER_EVENT &amp;&amp;</div><div class="line">            (server.maxmemory == <span class="number">0</span> ||</div><div class="line">             zmalloc_used_memory() &lt; server.maxmemory)) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 写入出错</span></div><div class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</div><div class="line">            nwritten = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            redisLog(REDIS_VERBOSE,</div><div class="line">                <span class="string">"Error writing to client: %s"</span>, strerror(errno));</div><div class="line">            freeClient(c);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (totwritten &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/* For clients representing masters we don't count sending data</span></div><div class="line">         * as an interaction, since we always send REPLCONF ACK commands</div><div class="line">         * that take some time to just fill the socket output buffer.</div><div class="line">         * We just rely on data / pings received for timeout detection. */</div><div class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_MASTER)) c-&gt;lastinteraction = server.unixtime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(c-&gt;reply) == <span class="number">0</span>) &#123;</div><div class="line">        c-&gt;sentlen = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 写完了删除write handler</span></div><div class="line">        aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</div><div class="line"></div><div class="line">        <span class="comment">// 必要的话关闭客户端</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_CLOSE_AFTER_REPLY) freeClient(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>至此一个命令的旅程就结束了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis服务器会与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行的命令，并通过资源管理来维持整个服务器自身的运转。&lt;/p&gt;
&lt;p&gt;本文目的是为了理清楚服务器对于命令请求的整个处理过程，说明这个过程中服务器与客户端如何互相交互，服务器内部如何调用内部组件达到对命令的执行。&lt;/p&gt;
&lt;h2 id=&quot;命令的处理流程&quot;&gt;&lt;a href=&quot;#命令的处理流程&quot; class=&quot;headerlink&quot; title=&quot;命令的处理流程&quot;&gt;&lt;/a&gt;命令的处理流程&lt;/h2&gt;&lt;p&gt;之前在事务代码部分的阅读，已经对于服务器接收客户端的连接并创建命令请求处理器等待命令请求的过程。&lt;/p&gt;
&lt;p&gt;现在以一个简单的set命令为例子，看服务器在接收请求之后如何处理。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;redis&amp;gt; SET KEY VALUE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ok&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从客户端发送set key value命令到接收回复ok，都做了如下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送命令。&lt;/li&gt;
&lt;li&gt;服务器命令请求处理器接收，引发命令的执行，并产生命令回复处理器。&lt;/li&gt;
&lt;li&gt;命令回复处理器发送ok给客户端。&lt;/li&gt;
&lt;li&gt;客户端接收ok，并打印。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-事件</title>
    <link href="http://www.coderyang.com//blog/2017/07/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6.html"/>
    <id>http://www.coderyang.com//blog/2017/07/redis源码阅读-事件.html</id>
    <published>2017-07-16T14:24:01.000Z</published>
    <updated>2017-07-16T14:27:59.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis源码阅读-事件"><a href="#redis源码阅读-事件" class="headerlink" title="redis源码阅读-事件"></a>redis源码阅读-事件</h1><p>redis服务器是一个事件驱动程序。当触发一个事件时,redis会创建一个事件,放入到待处理的队列，依次进行处理。</p>
<p>redis事件分为文件时间和时间事件。</p>
<p>文件事件：文件事件是对套接字操作的抽象，当服务器与客户端进行通讯，会产生出各种文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通讯操作。</p>
<p>时间事件：redis一些操作是需要定时进行执行的，而时间事件就是对这类操作的抽象。</p>
<h2 id="事件的实现"><a href="#事件的实现" class="headerlink" title="事件的实现"></a>事件的实现</h2><p>以下是事件结构体定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* File event structure */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFileEvent &#123;</div><div class="line">    <span class="keyword">int</span> mask; <span class="comment">// one of AE_(READABLE|WRITABLE) 类型</span></div><div class="line">    aeFileProc *rfileProc; <span class="comment">// 读事件处理器</span></div><div class="line">    aeFileProc *wfileProc; <span class="comment">// 写事件处理器</span></div><div class="line">    <span class="keyword">void</span> *clientData; <span class="comment">// 多路复用库的私有数据</span></div><div class="line">&#125; aeFileEvent;</div><div class="line"></div><div class="line"><span class="comment">/* Time event structure */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeTimeEvent &#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;  <span class="comment">// 唯一标志</span></div><div class="line">    <span class="keyword">long</span> when_sec; <span class="comment">// 事件到达事件s</span></div><div class="line">    <span class="keyword">long</span> when_ms;  <span class="comment">// 事件到达事件ms</span></div><div class="line">    aeTimeProc *timeProc; <span class="comment">// 事件处理函数</span></div><div class="line">    aeEventFinalizerProc *finalizerProc; <span class="comment">// 事件释放函数</span></div><div class="line">    <span class="keyword">void</span> *clientData; <span class="comment">// 多路复用库的私有数据</span></div><div class="line">    <span class="keyword">struct</span> aeTimeEvent *next; <span class="comment">//　指向下一个时间事件结构，形成链表</span></div><div class="line">&#125; aeTimeEvent;</div><div class="line"></div><div class="line"><span class="comment">/* A fired event */</span></div><div class="line"><span class="comment">// 触发的事件结构体</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFiredEvent &#123;</div><div class="line">    <span class="keyword">int</span> fd; <span class="comment">// 文件事件描述符</span></div><div class="line">    <span class="keyword">int</span> mask;　<span class="comment">// one of AE_(READABLE|WRITABLE) 类型</span></div><div class="line">&#125; aeFiredEvent;</div><div class="line"></div><div class="line"><span class="comment">// 事件循环结构体</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeEventLoop &#123;</div><div class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">// 当前注册的最大描述符</span></div><div class="line">    <span class="keyword">int</span> setsize; <span class="comment">// 需要监听的描述符个数</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId; <span class="comment">// 下一个时间事件ID</span></div><div class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">// 上一次时间循环时间</span></div><div class="line">    aeFileEvent *events; <span class="comment">// 注册要使用的文件时间</span></div><div class="line">    aeFiredEvent *fired; <span class="comment">// 已准备好，待处理事件</span></div><div class="line">    aeTimeEvent *timeEventHead; <span class="comment">// 时间事件</span></div><div class="line">    <span class="keyword">int</span> stop; <span class="comment">// 事件处理器开关</span></div><div class="line">    <span class="keyword">void</span> *apidata; <span class="comment">// 处理多路服用库的私有数据</span></div><div class="line">    aeBeforeSleepProc *beforesleep; <span class="comment">// 处理事件前要执行的函数</span></div><div class="line">&#125; aeEventLoop;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="事件处理流程"><a href="#事件处理流程" class="headerlink" title="事件处理流程"></a>事件处理流程</h2><p>redis使用i/o多路复用程序同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。文件处理流程如图。时间事件则定时执行。</p>
<p><img src="/img/20170716.jpg" alt=""><br>图片(来自《Redis设计与实现》</p>
<h2 id="事件的API"><a href="#事件的API" class="headerlink" title="事件的API"></a>事件的API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Prototypes */</span></div><div class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span></span>; <span class="comment">// 初始化时间处理器状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteEventLoop</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 删除事件处理器</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeStop</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 停止事件处理器</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></div><div class="line">        aeFileProc *proc, <span class="keyword">void</span> *clientData); <span class="comment">// 根据mask参数，监听fd文件的状态，fd可用，执行proc函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>;<span class="comment">// 将fd从mask指定的监听队列中删除</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetFileEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 获取给定fd正在监听的事件类型</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aeCreateTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds,</span></span></div><div class="line">        aeTimeProc *proc, <span class="keyword">void</span> *clientData,</div><div class="line">        aeEventFinalizerProc *finalizerProc); <span class="comment">// 创建时间事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeDeleteTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id)</span></span>; <span class="comment">// 删除给定ID的时间事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 处理所有已经到达时间的事件，以及所有就绪的文件事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeWait</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> mask, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds)</span></span>; <span class="comment">// 指定时间等待fd变为可读、可写</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span></span>;<span class="comment">// 事件处理主循环</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">aeGetApiName</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 返回所使用的多路服用库的名字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeSetBeforeSleepProc</span><span class="params">(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)</span></span>; <span class="comment">// 设置事件前所需要执行的函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetSetSize</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 返回当前事件槽大小</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeResizeSetSize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span></span>; <span class="comment">// 调整事件槽大小</span></div></pre></td></tr></table></figure>
<h2 id="文件事件的创建"><a href="#文件事件的创建" class="headerlink" title="文件事件的创建"></a>文件事件的创建</h2><p>文件事件有三个方面需要创建：</p>
<ul>
<li>连接应答处理器，用来处理对连接服务器监听套接字的客户端进行应答。</li>
<li>命令请求处理器，用来处理从套接字读取客户端发送的命令请求内容。</li>
<li>命令回复处理器，用来处理执行命令后得到的命令回复通过套接字返回给客户端。</li>
</ul>
<h3 id="连接应答处理器"><a href="#连接应答处理器" class="headerlink" title="连接应答处理器"></a>连接应答处理器</h3><p>acceptTcpHandler是连接应答处理器，当监听套接字产生AE_READABLE事件时，就会引发连接应答处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	<span class="comment">// 为 TCP 连接关联连接应答（accept）处理器</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</div><div class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</div><div class="line">            &#123;</div><div class="line">                redisPanic(</div><div class="line">                    <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 为本地套接字关联应答处理器</span></div><div class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</div><div class="line">        acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) redisPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命令请求处理器"><a href="#命令请求处理器" class="headerlink" title="命令请求处理器"></a>命令请求处理器</h3><p>在连接应答处理器调用的函数acceptTcpHandler中，会在连接成功之后，创建命令请求处理器readQueryFromClient()，在客户端发送的命令请求时，调用命令请求处理器进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个 TCP 连接处理器</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</div><div class="line">    <span class="keyword">char</span> cip[REDIS_IP_STR_LEN];</div><div class="line">    REDIS_NOTUSED(el);</div><div class="line">    REDIS_NOTUSED(mask);</div><div class="line">    REDIS_NOTUSED(privdata);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(max--) &#123;</div><div class="line">        <span class="comment">// accept 客户端连接</span></div><div class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</div><div class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</div><div class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    <span class="string">"Accepting client connection: %s"</span>, server.neterr);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        redisLog(REDIS_VERBOSE,<span class="string">"Accepted %s:%d"</span>, cip, cport);</div><div class="line"></div><div class="line">      	<span class="comment">// 连接完成，创建一个客户端状态</span></div><div class="line">        acceptCommonHandler(cfd,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ACCEPTS_PER_CALL 1000</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 创建客户端</span></div><div class="line">    redisClient *c;</div><div class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,</div><div class="line">            <span class="string">"Error registering fd event for the new client: %s (fd=%d)"</span>,</div><div class="line">            strerror(errno),fd);</div><div class="line">        close(fd); <span class="comment">/* May be already closed, just ignore errors */</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 达到上限</span></div><div class="line">    <span class="keyword">if</span> (listLength(server.clients) &gt; server.maxclients) &#123;</div><div class="line">        <span class="keyword">char</span> *err = <span class="string">"-ERR max number of clients reached\r\n"</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (write(c-&gt;fd,err,<span class="built_in">strlen</span>(err)) == <span class="number">-1</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 更新拒绝连接数</span></div><div class="line">        server.stat_rejected_conn++;</div><div class="line">        freeClient(c);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    server.stat_numconnections++;</div><div class="line">    c-&gt;flags |= flags;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">redisClient *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">    redisClient *c = zmalloc(<span class="keyword">sizeof</span>(redisClient));</div><div class="line"></div><div class="line">    <span class="comment">// -1时使用的是无网络连接的伪客户端</span></div><div class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</div><div class="line">        anetNonBlock(<span class="literal">NULL</span>,fd); <span class="comment">// 非阻塞</span></div><div class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd); <span class="comment">// 关闭nagle算法，那个合并小报文的算法</span></div><div class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</div><div class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</div><div class="line"></div><div class="line">        <span class="comment">// 创建命令请求处理器</span></div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</div><div class="line">            readQueryFromClient, c) == AE_ERR)</div><div class="line">        &#123;</div><div class="line">            close(fd);</div><div class="line">            zfree(c);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 客户端的初始化</span></div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命令回复处理器"><a href="#命令回复处理器" class="headerlink" title="命令回复处理器"></a>命令回复处理器</h3><p>当服务器有命令回复需要传送给客户端时，服务器将客户端套接字的AE_WRITABLE事件与命令回复处理器关联，当客户端准备好接收时，就会执行AE_WRITABLE事件，触发命令回复处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_LUA_CLIENT) <span class="keyword">return</span> REDIS_OK;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; REDIS_MASTER_FORCE_REPLY)) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;fd &lt;= <span class="number">0</span>) <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Fake client */</span></div><div class="line"></div><div class="line">    <span class="comment">// 为客户端套接字安装写处理器到事件循环</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(c-&gt;reply) == <span class="number">0</span> &amp;&amp;</div><div class="line">        (c-&gt;replstate == REDIS_REPL_NONE ||</div><div class="line">         c-&gt;replstate == REDIS_REPL_ONLINE) &amp;&amp;</div><div class="line">        aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE,</div><div class="line">        sendReplyToClient, c) == AE_ERR) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间事件的创建"><a href="#时间事件的创建" class="headerlink" title="时间事件的创建"></a>时间事件的创建</h2><p>redis在初始化时创建时间时间，用来周期执行serverCron()。</p>
<p>serverCron()主要功能：</p>
<ul>
<li>更新服务器的各类统计信息</li>
<li>清理过期的键值对</li>
<li>关闭和清理连接失效的客户端</li>
<li>尝试AOF\RDB持久化</li>
<li>主服务器则定期同步</li>
<li>集群模式，对集群定期同步和连接测试</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 为 serverCron() 创建时间事件</span></div><div class="line">    <span class="keyword">if</span>(aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</div><div class="line">        redisPanic(<span class="string">"Can't create the serverCron time event."</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环主函数为aeMain()，该函数在redis的main()函数中被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 运行事件处理器，一直到服务器关闭为止</span></div><div class="line">    aeSetBeforeSleepProc(server.el,beforeSleep); <span class="comment">// 设置事件前调用函数</span></div><div class="line">    aeMain(server.el);</div><div class="line">  </div><div class="line">    <span class="comment">// 服务器关闭，停止事件循环</span></div><div class="line">    aeDeleteEventLoop(server.el);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">｝</div></pre></td></tr></table></figure>
<p>事件循环的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 事件处理器的主循环</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line"></div><div class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</div><div class="line">        <span class="comment">// 如果有需要在事件处理前执行的函数，那么运行它</span></div><div class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line"></div><div class="line">        <span class="comment">// 开始处理事件</span></div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 事件处理函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</div><div class="line"></div><div class="line">    <span class="comment">// 没有需要处理的事件则返回</span></div><div class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</div><div class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">struct</span> timeval tv, *tvp;</div><div class="line"></div><div class="line">        <span class="comment">// 获取最近的时间事件</span></div><div class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</div><div class="line">            shortest = aeSearchNearestTimer(eventLoop);</div><div class="line">        <span class="keyword">if</span> (shortest) &#123;</div><div class="line">            <span class="keyword">long</span> now_sec, now_ms;</div><div class="line"></div><div class="line">            <span class="comment">/* Calculate the time missing for the nearest</span></div><div class="line">             * timer to fire. */</div><div class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">            tvp = &amp;tv;</div><div class="line">            tvp-&gt;tv_sec = shortest-&gt;when_sec - now_sec;</div><div class="line">            <span class="keyword">if</span> (shortest-&gt;when_ms &lt; now_ms) &#123;</div><div class="line">                tvp-&gt;tv_usec = ((shortest-&gt;when_ms+<span class="number">1000</span>) - now_ms)*<span class="number">1000</span>;</div><div class="line">                tvp-&gt;tv_sec --;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tvp-&gt;tv_usec = (shortest-&gt;when_ms - now_ms)*<span class="number">1000</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 获取要执行事件事件，要等待的时间</span></div><div class="line">            <span class="keyword">if</span> (tvp-&gt;tv_sec &lt; <span class="number">0</span>) tvp-&gt;tv_sec = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (tvp-&gt;tv_usec &lt; <span class="number">0</span>) tvp-&gt;tv_usec = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 没有时间事件</span></div><div class="line">            <span class="comment">// 根据AE_DONT_WAIT参数来设置文件事件的阻塞、阻塞时间</span></div><div class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</div><div class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</div><div class="line">                tvp = &amp;tv;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* Otherwise we can block */</span></div><div class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 调用io复用函数获取准备好的事件，底层使用select或epoll或其他实现</span></div><div class="line">      	<span class="comment">// tvp阻塞时间</span></div><div class="line">        numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 获取所有能够执行的文件事件，并执行</span></div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</div><div class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</div><div class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</div><div class="line">            <span class="keyword">int</span> rfired = <span class="number">0</span>;</div><div class="line"></div><div class="line">	        <span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></div><div class="line">             * event removed an element that fired and we still didn't</div><div class="line">             * processed, so we check if the event is still valid. */</div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                <span class="comment">// 读事件</span></div><div class="line">                rfired = <span class="number">1</span>;</div><div class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 写事件</span></div><div class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</div><div class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            processed++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Check time events */</span></div><div class="line">    <span class="comment">// 执行时间事件，在阻塞等待一段时间之后，时间事件已经能够执行</span></div><div class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</div><div class="line">        processed += processTimeEvents(eventLoop);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>事件其实不算复杂，整个redis没有太多的事件。但是要理解IO多路服用和redis事件的调用逻辑。理清楚之后就比较好办了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis源码阅读-事件&quot;&gt;&lt;a href=&quot;#redis源码阅读-事件&quot; class=&quot;headerlink&quot; title=&quot;redis源码阅读-事件&quot;&gt;&lt;/a&gt;redis源码阅读-事件&lt;/h1&gt;&lt;p&gt;redis服务器是一个事件驱动程序。当触发一个事件时,redis会创建一个事件,放入到待处理的队列，依次进行处理。&lt;/p&gt;
&lt;p&gt;redis事件分为文件时间和时间事件。&lt;/p&gt;
&lt;p&gt;文件事件：文件事件是对套接字操作的抽象，当服务器与客户端进行通讯，会产生出各种文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通讯操作。&lt;/p&gt;
&lt;p&gt;时间事件：redis一些操作是需要定时进行执行的，而时间事件就是对这类操作的抽象。&lt;/p&gt;
&lt;h2 id=&quot;事件的实现&quot;&gt;&lt;a href=&quot;#事件的实现&quot; class=&quot;headerlink&quot; title=&quot;事件的实现&quot;&gt;&lt;/a&gt;事件的实现&lt;/h2&gt;&lt;p&gt;以下是事件结构体定义。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* File event structure */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; aeFileEvent &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mask; &lt;span class=&quot;comment&quot;&gt;// one of AE_(READABLE|WRITABLE) 类型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    aeFileProc *rfileProc; &lt;span class=&quot;comment&quot;&gt;// 读事件处理器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    aeFileProc *wfileProc; &lt;span class=&quot;comment&quot;&gt;// 写事件处理器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *clientData; &lt;span class=&quot;comment&quot;&gt;// 多路复用库的私有数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; aeFileEvent;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Time event structure */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; aeTimeEvent &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; id;  &lt;span class=&quot;comment&quot;&gt;// 唯一标志&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; when_sec; &lt;span class=&quot;comment&quot;&gt;// 事件到达事件s&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; when_ms;  &lt;span class=&quot;comment&quot;&gt;// 事件到达事件ms&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    aeTimeProc *timeProc; &lt;span class=&quot;comment&quot;&gt;// 事件处理函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    aeEventFinalizerProc *finalizerProc; &lt;span class=&quot;comment&quot;&gt;// 事件释放函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *clientData; &lt;span class=&quot;comment&quot;&gt;// 多路复用库的私有数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; aeTimeEvent *next; &lt;span class=&quot;comment&quot;&gt;//　指向下一个时间事件结构，形成链表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; aeTimeEvent;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* A fired event */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 触发的事件结构体&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; aeFiredEvent &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd; &lt;span class=&quot;comment&quot;&gt;// 文件事件描述符&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mask;　&lt;span class=&quot;comment&quot;&gt;// one of AE_(READABLE|WRITABLE) 类型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; aeFiredEvent;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 事件循环结构体&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; aeEventLoop &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxfd;   &lt;span class=&quot;comment&quot;&gt;// 当前注册的最大描述符&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; setsize; &lt;span class=&quot;comment&quot;&gt;// 需要监听的描述符个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeEventNextId; &lt;span class=&quot;comment&quot;&gt;// 下一个时间事件ID&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;time_t&lt;/span&gt; lastTime;     &lt;span class=&quot;comment&quot;&gt;// 上一次时间循环时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    aeFileEvent *events; &lt;span class=&quot;comment&quot;&gt;// 注册要使用的文件时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    aeFiredEvent *fired; &lt;span class=&quot;comment&quot;&gt;// 已准备好，待处理事件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    aeTimeEvent *timeEventHead; &lt;span class=&quot;comment&quot;&gt;// 时间事件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; stop; &lt;span class=&quot;comment&quot;&gt;// 事件处理器开关&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *apidata; &lt;span class=&quot;comment&quot;&gt;// 处理多路服用库的私有数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    aeBeforeSleepProc *beforesleep; &lt;span class=&quot;comment&quot;&gt;// 处理事件前要执行的函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; aeEventLoop;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-事务</title>
    <link href="http://www.coderyang.com//blog/2017/07/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1.html"/>
    <id>http://www.coderyang.com//blog/2017/07/redis源码阅读-事务.html</id>
    <published>2017-07-16T08:11:27.000Z</published>
    <updated>2017-07-16T08:12:26.169Z</updated>
    
    <content type="html"><![CDATA[<p>redis的事务提供了一种将单个命令请求打包，然后一次性、按照顺序执行多个命令的机制，这种方式服务器会一次性把命令执行完，中间不会执行其他客户端的命令。不过redis的命令不支持错误命令执行后的回滚机制，也就是命令设计者要对命令的正确性负责，即使多个命令中存在部分错误的命令，剩余命令也会继续执行下去。</p>
<h2 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h2><table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MULTI</td>
<td style="text-align:center">开始一个新的事务</td>
</tr>
<tr>
<td style="text-align:center">DISCARD</td>
<td style="text-align:center">放弃执行事务</td>
</tr>
<tr>
<td style="text-align:center">EXEC</td>
<td style="text-align:center">执行事务中的所有命令</td>
</tr>
<tr>
<td style="text-align:center">WATCH</td>
<td style="text-align:center">监视key，如果在exec之前被修改，则不执行事务</td>
</tr>
<tr>
<td style="text-align:center">UNWATCH</td>
<td style="text-align:center">取消对所有键的监视</td>
</tr>
</tbody>
</table>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>一个事务分为三个阶段：</p>
<ul>
<li>事务开始</li>
<li>命令入队</li>
<li>事务执行</li>
</ul>
<h3 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h3><p>使用multi开启事务，redis主要使用redisClient中flag成员记录状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 已经开启事务</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</div><div class="line">        addReplyError(c,<span class="string">"MULTI calls can not be nested"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 标记事务开启</span></div><div class="line">    c-&gt;flags |= REDIS_MULTI;</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="事务入队"><a href="#事务入队" class="headerlink" title="事务入队"></a>事务入队</h3><p>当客户端进入事务状态时，客户端不会立即执行命令EXEC、DISCARD、WATCH、MULTI之外的命令，这些命令先进入事务队列，在之后事务执行时候执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端结构体</span></div><div class="line"><span class="keyword">struct</span> redisClient &#123;</div><div class="line">  	<span class="comment">// ....</span></div><div class="line">  	multiState mstate; <span class="comment">// 事务状态</span></div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 事务状态</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> multiState &#123;</div><div class="line">    multiCmd *commands; <span class="comment">// 事务队列</span></div><div class="line">    <span class="keyword">int</span> count; <span class="comment">// 命令计数</span></div><div class="line">    <span class="keyword">int</span> minreplicas; <span class="comment">// 用于同步复制</span></div><div class="line">    <span class="keyword">time_t</span> minreplicas_timeout; <span class="comment">// 超时时间</span></div><div class="line">&#125; multiState;</div><div class="line"></div><div class="line"><span class="comment">// 事务命令</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> multiCmd &#123;</div><div class="line">    robj **argv; <span class="comment">// 参数</span></div><div class="line">    <span class="keyword">int</span> argc; <span class="comment">// 参数数量 </span></div><div class="line">    <span class="keyword">struct</span> redisCommand *cmd; <span class="comment">// 命令指针</span></div><div class="line">&#125; multiCmd;</div></pre></td></tr></table></figure>
<p>redis在执行客户端命令时，会判断事务是否开启，如果开启且不是上面提到的几个命令，那么就会将命令压入队列,在redis的命令处理函数processCommand()中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">    <span class="comment">/* Exec the command */</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 处在事务状态</span></div><div class="line">        <span class="comment">// 不是execCommand、discardCommand、multiCommand、watchCommand</span></div><div class="line">        <span class="comment">// 执行入队操作</span></div><div class="line">        queueMultiCommand(c);</div><div class="line">        addReply(c,shared.queued);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 命令直接执行</span></div><div class="line">        call(c,REDIS_CALL_FULL);</div><div class="line">        c-&gt;woff = server.master_repl_offset;</div><div class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</div><div class="line">            handleClientsBlockedOnLists();</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入队的实现:入队功能依靠queueMultiCommand()实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    multiCmd *mc;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="comment">// 重新分配足够的空间</span></div><div class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</div><div class="line">            <span class="keyword">sizeof</span>(multiCmd)*(c-&gt;mstate.count+<span class="number">1</span>));</div><div class="line">    mc = c-&gt;mstate.commands+c-&gt;mstate.count; <span class="comment">// 压入点</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化事务结构体</span></div><div class="line">    mc-&gt;cmd = c-&gt;cmd; </div><div class="line">    mc-&gt;argc = c-&gt;argc;</div><div class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</div><div class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv,c-&gt;argv,<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</div><div class="line">        incrRefCount(mc-&gt;argv[j]);</div><div class="line">    c-&gt;mstate.count++; <span class="comment">// 计数+1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="事务的执行"><a href="#事务的执行" class="headerlink" title="事务的执行"></a>事务的执行</h3><p>当处于事务状态的客户端向服务器发送EXEC命令时，这个命令被立即执行，具体见processCommand()函数。</p>
<p>最终命令调用execCommand()执行exec命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    robj **orig_argv;</div><div class="line">    <span class="keyword">int</span> orig_argc;</div><div class="line">    <span class="keyword">struct</span> redisCommand *orig_cmd;</div><div class="line">    <span class="keyword">int</span> must_propagate = <span class="number">0</span>; <span class="comment">/* Need to propagate MULTI/EXEC to AOF / slaves? */</span></div><div class="line"></div><div class="line">    <span class="comment">// 判断是否执行事务中</span></div><div class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_MULTI)) &#123;</div><div class="line">        addReplyError(c,<span class="string">"EXEC without MULTI"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断监视键是否被修改</span></div><div class="line">    <span class="comment">// 命令在入队时发送错误</span></div><div class="line">    <span class="comment">// 均不执行命令</span></div><div class="line">    <span class="comment">// 取消事务</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC)) &#123;</div><div class="line">        addReply(c, c-&gt;flags &amp; REDIS_DIRTY_EXEC ? shared.execaborterr :</div><div class="line">                                                  shared.nullmultibulk);</div><div class="line">        discardTransaction(c); <span class="comment">// 取消事务</span></div><div class="line">        <span class="keyword">goto</span> handle_monitor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 取消对键的监视</span></div><div class="line">    unwatchAllKeys(c); <span class="comment">/* Unwatch ASAP otherwise we'll waste CPU cycles */</span></div><div class="line"></div><div class="line">    <span class="comment">// 备份</span></div><div class="line">    orig_argv = c-&gt;argv;</div><div class="line">    orig_argc = c-&gt;argc;</div><div class="line">    orig_cmd = c-&gt;cmd;</div><div class="line">    addReplyMultiBulkLen(c,c-&gt;mstate.count);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历事务中的命令，执行</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 备份</span></div><div class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</div><div class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</div><div class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</div><div class="line"></div><div class="line">        <span class="comment">// 在事务中，发现了写命令，传播multi</span></div><div class="line">        <span class="keyword">if</span> (!must_propagate &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; REDIS_CMD_READONLY)) &#123;</div><div class="line">            execCommandPropagateMulti(c);</div><div class="line">            must_propagate = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 执行命令</span></div><div class="line">        call(c,REDIS_CALL_FULL);</div><div class="line"></div><div class="line">        <span class="comment">// 恢复</span></div><div class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</div><div class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</div><div class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 恢复</span></div><div class="line">    c-&gt;argv = orig_argv;</div><div class="line">    c-&gt;argc = orig_argc;</div><div class="line">    c-&gt;cmd = orig_cmd;</div><div class="line">    discardTransaction(c); <span class="comment">// 关闭事务状态</span></div><div class="line">    <span class="comment">/* Make sure the EXEC command will be propagated as well if MULTI</span></div><div class="line">     * was already propagated. */</div><div class="line">    <span class="keyword">if</span> (must_propagate) server.dirty++;</div><div class="line"></div><div class="line">handle_monitor:</div><div class="line">    <span class="comment">/* Send EXEC to clients waiting data from MONITOR. We do it here</span></div><div class="line">     * since the natural order of commands execution is actually:</div><div class="line">     * MUTLI, EXEC, ... commands inside transaction ...</div><div class="line">     * Instead EXEC is flagged as REDIS_CMD_SKIP_MONITOR in the command</div><div class="line">     * table, and we do it here with correct ordering. */</div><div class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp; !server.loading)</div><div class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="事务取消"><a href="#事务取消" class="headerlink" title="事务取消"></a>事务取消</h3><p>DISCARD函数取消客户端的事务状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// discardCommand命令处理函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 没有在事务状态</span></div><div class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_MULTI)) &#123;</div><div class="line">        addReplyError(c,<span class="string">"DISCARD without MULTI"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 取消事务状态</span></div><div class="line">    discardTransaction(c);</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 取消事务状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    freeClientMultiState(c); <span class="comment">// 释放事务</span></div><div class="line">    initClientMultiState(c); <span class="comment">// 初始化事务</span></div><div class="line"></div><div class="line">    <span class="comment">// 取消事务状态</span></div><div class="line">    c-&gt;flags &amp;= ~(REDIS_MULTI|REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC);</div><div class="line">    unwatchAllKeys(c); <span class="comment">// 取消键的监视</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeClientMultiState</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        multiCmd *mc = c-&gt;mstate.commands+j;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mc-&gt;argc; i++)</div><div class="line">            decrRefCount(mc-&gt;argv[i]);</div><div class="line">        zfree(mc-&gt;argv);</div><div class="line">    &#125;</div><div class="line">    zfree(c-&gt;mstate.commands);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initClientMultiState</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    c-&gt;mstate.commands = <span class="literal">NULL</span>;</div><div class="line">    c-&gt;mstate.count = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h3><p>WATCH命令用来监视键是否被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb &#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    dict *watched_keys; <span class="comment">// 监视键的字典，字典的键为数据库的键，值为链表，保存所有监视的客户端</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125; redisDb;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisClient &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="built_in">list</span> *watched_keys;  <span class="comment">// 保存该客户端所有被监视的键,保存watchedKey结构</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> watchedKey &#123;</div><div class="line">    robj *key;  <span class="comment">// 保存键</span></div><div class="line">    redisDb *db;  <span class="comment">// 保存键所在的数据库</span></div><div class="line">&#125; watchedKey;</div></pre></td></tr></table></figure>
<h4 id="WATCH的触发"><a href="#WATCH的触发" class="headerlink" title="WATCH的触发"></a>WATCH的触发</h4><p>所有的对数据库进行修改的命令，比如set、del等，在执行之后都会调用signalModifiedKey(redisDb <em>db, robj </em>key)，而该函数调用touchWatchedKey(redisDb <em>db, robj </em>key)。touchWatchedKey(redisDb <em>db, robj </em>key)查找监视字典，对被修改的键进行标记。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    touchWatchedKey(db,key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="built_in">list</span> *clients;</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line"></div><div class="line">    <span class="comment">// 字典为空</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 获取进行监视的客户端</span></div><div class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</div><div class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历所有客户端，进行标记</span></div><div class="line">    listRewind(clients,&amp;li);</div><div class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</div><div class="line">        redisClient *c = listNodeValue(ln);</div><div class="line"></div><div class="line">        c-&gt;flags |= REDIS_DIRTY_CAS;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="监视的开启"><a href="#监视的开启" class="headerlink" title="监视的开启"></a>监视的开启</h4><p>监视的开启就是在字典里添加键</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</div><div class="line">        addReplyError(c,<span class="string">"WATCH inside MULTI is not allowed"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">        watchForKey(c,c-&gt;argv[j]);</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 客户端C监视键Key</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(redisClient *c, robj *key)</span> </span>&#123;</div><div class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line">    watchedKey *wk;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否已经被监视了</span></div><div class="line">    <span class="comment">// 发现则直接返回</span></div><div class="line">    listRewind(c-&gt;watched_keys,&amp;li);</div><div class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</div><div class="line">        wk = listNodeValue(ln);</div><div class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key,wk-&gt;key))</div><div class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 检查key是否存在数据库的watched_keys字典力</span></div><div class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys,key);</div><div class="line">    <span class="keyword">if</span> (!clients) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 不存在就增加一个链表</span></div><div class="line">        clients = listCreate();</div><div class="line">        dictAdd(c-&gt;db-&gt;watched_keys,key,clients);</div><div class="line">        incrRefCount(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在链表末尾增加key</span></div><div class="line">    <span class="comment">// 前面已经保证没有被监视过，所以这里不需要再判断，直接插入到末尾</span></div><div class="line">    listAddNodeTail(clients,c);</div><div class="line">    <span class="comment">/* Add the new key to the list of keys watched by this client */</span></div><div class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</div><div class="line">    wk-&gt;key = key;</div><div class="line">    wk-&gt;db = c-&gt;db;</div><div class="line">    incrRefCount(key);</div><div class="line">    listAddNodeTail(c-&gt;watched_keys,wk);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="监视的关闭"><a href="#监视的关闭" class="headerlink" title="监视的关闭"></a>监视的关闭</h4><p>监视的关闭即将字典中键删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="comment">// 取消客户端对所有键的监视</span></div><div class="line">    unwatchAllKeys(c);</div><div class="line">    <span class="comment">// 重置状态</span></div><div class="line">    c-&gt;flags &amp;= (~REDIS_DIRTY_CAS);</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 清除所有监视</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchAllKeys</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line"></div><div class="line">    <span class="comment">// 没有键被监视，直接返回</span></div><div class="line">    <span class="keyword">if</span> (listLength(c-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历被监视的键</span></div><div class="line">    listRewind(c-&gt;watched_keys,&amp;li);</div><div class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</div><div class="line">        <span class="built_in">list</span> *clients;</div><div class="line">        watchedKey *wk;</div><div class="line"></div><div class="line">        wk = listNodeValue(ln); <span class="comment">// 键</span></div><div class="line">        clients = dictFetchValue(wk-&gt;db-&gt;watched_keys, wk-&gt;key); <span class="comment">// 数据库中查找</span></div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,clients != <span class="literal">NULL</span>);</div><div class="line">        listDelNode(clients,listSearchKey(clients,c)); <span class="comment">// 删除数据库中监视节点</span></div><div class="line">        </div><div class="line">        <span class="comment">// 如果链表为空，删除键</span></div><div class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>)</div><div class="line">            dictDelete(wk-&gt;db-&gt;watched_keys, wk-&gt;key);</div><div class="line">        </div><div class="line">        <span class="comment">// 删除客户端监视的节点key</span></div><div class="line">        listDelNode(c-&gt;watched_keys,ln);</div><div class="line">        decrRefCount(wk-&gt;key);</div><div class="line">        zfree(wk);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis的事务提供了一种将单个命令请求打包，然后一次性、按照顺序执行多个命令的机制，这种方式服务器会一次性把命令执行完，中间不会执行其他客户端的命令。不过redis的命令不支持错误命令执行后的回滚机制，也就是命令设计者要对命令的正确性负责，即使多个命令中存在部分错误的命令，剩余命令也会继续执行下去。&lt;/p&gt;
&lt;h2 id=&quot;主要命令&quot;&gt;&lt;a href=&quot;#主要命令&quot; class=&quot;headerlink&quot; title=&quot;主要命令&quot;&gt;&lt;/a&gt;主要命令&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;命令&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;MULTI&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;开始一个新的事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DISCARD&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;放弃执行事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;EXEC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;执行事务中的所有命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;WATCH&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;监视key，如果在exec之前被修改，则不执行事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;UNWATCH&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;取消对所有键的监视&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;事务的实现&quot;&gt;&lt;a href=&quot;#事务的实现&quot; class=&quot;headerlink&quot; title=&quot;事务的实现&quot;&gt;&lt;/a&gt;事务的实现&lt;/h2&gt;&lt;p&gt;一个事务分为三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务开始&lt;/li&gt;
&lt;li&gt;命令入队&lt;/li&gt;
&lt;li&gt;事务执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;事务开始&quot;&gt;&lt;a href=&quot;#事务开始&quot; class=&quot;headerlink&quot; title=&quot;事务开始&quot;&gt;&lt;/a&gt;事务开始&lt;/h3&gt;&lt;p&gt;使用multi开启事务，redis主要使用redisClient中flag成员记录状态。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;multiCommand&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(redisClient *c)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 已经开启事务&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (c-&amp;gt;flags &amp;amp; REDIS_MULTI) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        addReplyError(c,&lt;span class=&quot;string&quot;&gt;&quot;MULTI calls can not be nested&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 标记事务开启&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    c-&amp;gt;flags |= REDIS_MULTI;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    addReply(c,shared.ok);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码阅读-AOF持久化</title>
    <link href="http://www.coderyang.com//blog/2017/07/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-AOF%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>http://www.coderyang.com//blog/2017/07/Redis源码阅读-AOF持久化.html</id>
    <published>2017-07-16T04:52:43.000Z</published>
    <updated>2017-07-16T04:54:12.239Z</updated>
    
    <content type="html"><![CDATA[<p>之前看了RDB持久化，功能是把数据库的数据全部使用一种特定格式进行存储。恢复时一个一个数据库键恢复。</p>
<p>AOF持久化与RDB持久化不同，AOF通过保存Redis服务器执行的写命令来记录数据库的状态。</p>
<h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>AOF持久化功能分为命令追加、文件写入、文件同步三个步骤。</p>
<ul>
<li>命令追加：将命令数据写入aof_buf缓冲区</li>
<li>文件写入：将aof_buff缓冲区数据写入系统IO缓冲区</li>
<li>文件同步：将系统IO缓冲区的数据同步到磁盘文件</li>
</ul>
<h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>AOF持久化打开时，服务器在执行一个写命令之后，会以协议的格式将执行的命令追加倒服务器状态aof_buf缓冲区尾部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123; </div><div class="line">  <span class="comment">// ...</span></div><div class="line">  sds aof_buf;  <span class="comment">// aof缓冲区</span></div><div class="line">  <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>命令追加的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将命令追加到AOF缓冲区中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(<span class="keyword">struct</span> redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</div><div class="line">    sds buf = sdsempty();</div><div class="line">    robj *tmpargv[<span class="number">3</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 如果没切换到正确的数据库，则追加切换数据库命令</span></div><div class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</div><div class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</div><div class="line"></div><div class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid);</div><div class="line">        buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>,</div><div class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</div><div class="line">        server.aof_selected_db = dictid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据命令类型追加命令</span></div><div class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</div><div class="line">        cmd-&gt;proc == expireatCommand) &#123;</div><div class="line">        <span class="comment">// 追加过期键命令</span></div><div class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</div><div class="line">        <span class="comment">// 追加setexCommand或者psetexCommand</span></div><div class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">"SET"</span>,<span class="number">3</span>);</div><div class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</div><div class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</div><div class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv);</div><div class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</div><div class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 追加其他一般修改数据库命令</span></div><div class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将格式化的命令字符串追加到aof_buf缓冲区中</span></div><div class="line">    <span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON)</div><div class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</div><div class="line">        <span class="comment">// 如果在执行AOF重写，那么追加的新的AOF文件中</span></div><div class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</div><div class="line"></div><div class="line">    sdsfree(buf);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 根据参数，格式化命令</span></div><div class="line"><span class="function">sds <span class="title">catAppendOnlyGenericCommand</span><span class="params">(sds dst, <span class="keyword">int</span> argc, robj **argv)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</div><div class="line">    <span class="keyword">int</span> len, j;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    buf[<span class="number">0</span>] = <span class="string">'*'</span>;</div><div class="line">    len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,argc);</div><div class="line">    buf[len++] = <span class="string">'\r'</span>;</div><div class="line">    buf[len++] = <span class="string">'\n'</span>;</div><div class="line">    dst = sdscatlen(dst,buf,len);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历每一个参数，支架到AOF缓冲区中</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</div><div class="line">        o = getDecodedObject(argv[j]);</div><div class="line">        buf[<span class="number">0</span>] = <span class="string">'$'</span>;</div><div class="line">        len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,sdslen(o-&gt;ptr));</div><div class="line">        buf[len++] = <span class="string">'\r'</span>;</div><div class="line">        buf[len++] = <span class="string">'\n'</span>;</div><div class="line">        dst = sdscatlen(dst,buf,len);</div><div class="line">        dst = sdscatlen(dst,o-&gt;ptr,sdslen(o-&gt;ptr));</div><div class="line">        dst = sdscatlen(dst,<span class="string">"\r\n"</span>,<span class="number">2</span>);</div><div class="line">        decrRefCount(o);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dst;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="文件写入与同步"><a href="#文件写入与同步" class="headerlink" title="文件写入与同步"></a>文件写入与同步</h3><p>Redis服务器就是一个事件循环，这个循环中的文件时间负责接收客户端的命令请求，同时存在serverCron函数定时运行函数。</p>
<p>服务器每次结束事件循环之前，会调用flushAppendOnlyFile函数，执行文件写入操作。</p>
<p>调用write函数时，系统会将数据保存到一个内存缓冲区，等到填满时才进行写入，或者在指定时间之后才真正写入。虽然提高了效率，但是带来了数据安全问题。</p>
<p>redis提供了appendgsync选项来设置aof持久化怎么同步，三种方案：</p>
<ul>
<li>always，一直同步，安全性好，但是最慢。</li>
<li>everysec，当aof文件内容全部写入时，每隔一秒在子线程中对aof文件进行一次同步。</li>
<li>no，由操作系统决定什么时候同步。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</div><div class="line">    <span class="keyword">ssize_t</span> nwritten;</div><div class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</div><div class="line">    <span class="keyword">mstime_t</span> latency;</div><div class="line"></div><div class="line">    <span class="comment">// 缓冲区没有内容直接返回</span></div><div class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</div><div class="line">        sync_in_progress = bioPendingJobsOfType(REDIS_BIO_AOF_FSYNC) != <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</div><div class="line">        <span class="comment">/* With this append fsync policy we do background fsyncing.</span></div><div class="line">         * If the fsync is still in progress we can try to delay</div><div class="line">         * the write for a couple of seconds. */</div><div class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</div><div class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">/* No previous write postponing, remember that we are</span></div><div class="line">                 * postponing the flush and return. */</div><div class="line">                server.aof_flush_postponed_start = server.unixtime;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</div><div class="line">                <span class="comment">/* We were already waiting for fsync to finish, but for less</span></div><div class="line">                 * than two seconds this is still ok. Postpone again. */</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* Otherwise fall trough, and go write since we can't wait</span></div><div class="line">             * over two seconds. */</div><div class="line">            server.aof_delayed_fsync++;</div><div class="line">            redisLog(REDIS_NOTICE,<span class="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 调用write命令将缓冲区数据写入磁盘文件中，</span></div><div class="line">    latencyStartMonitor(latency);</div><div class="line">    nwritten = write(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</div><div class="line">    latencyEndMonitor(latency);</div><div class="line">    <span class="comment">/* We want to capture different events for delayed writes:</span></div><div class="line">     * when the delay happens with a pending fsync, or with a saving child</div><div class="line">     * active, and when the above two conditions are missing.</div><div class="line">     * We also use an additional event name to save all samples which is</div><div class="line">     * useful for graphing / monitoring purposes. */</div><div class="line"></div><div class="line">    <span class="comment">// ...部分同步功能</span></div><div class="line"></div><div class="line">    <span class="comment">// 重置aof写入的延迟时间</span></div><div class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 写入操作出现错误</span></div><div class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">signed</span>)sdslen(server.aof_buf)) &#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */</span></div><div class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</div><div class="line">            can_log = <span class="number">1</span>;</div><div class="line">            last_write_error_log = server.unixtime;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Log the AOF write error and record the error code. */</span></div><div class="line">        <span class="comment">// 写错误日志</span></div><div class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Error writing to the AOF file: %s"</span>,</div><div class="line">                    strerror(errno));</div><div class="line">                server.aof_last_write_errno = errno;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Short write while writing to "</span></div><div class="line">                                       <span class="string">"the AOF file: (nwritten=%lld, "</span></div><div class="line">                                       <span class="string">"expected=%lld)"</span>,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 尝试移除新追加的不完整内容</span></div><div class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                    redisLog(REDIS_WARNING, <span class="string">"Could not remove short write "</span></div><div class="line">                             <span class="string">"from the append-only file.  Redis may refuse "</span></div><div class="line">                             <span class="string">"to load the AOF the next time it starts.  "</span></div><div class="line">                             <span class="string">"ftruncate: %s"</span>, strerror(errno));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* If the ftruncate() succeeded we can set nwritten to</span></div><div class="line">                 * -1 since there is no longer partial data into the AOF. */</div><div class="line">                nwritten = <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line">            server.aof_last_write_errno = ENOSPC;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 处理写入时错误</span></div><div class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">            <span class="comment">/* We can't recover when the fsync policy is ALWAYS since the</span></div><div class="line">             * reply for the client is already in the output buffers, and we</div><div class="line">             * have the contract with the user that on acknowledged write data</div><div class="line">             * is synced on disk. */</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* Recover from failed write leaving data into the buffer. However</span></div><div class="line">             * set an error to stop accepting writes as long as the error</div><div class="line">             * condition is not cleared. */</div><div class="line">            server.aof_last_write_status = REDIS_ERR;</div><div class="line"></div><div class="line">            <span class="comment">/* Trim the sds buffer if there was a partial write, and there</span></div><div class="line">             * was no way to undo it with ftruncate(2). */</div><div class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</div><div class="line">                server.aof_current_size += nwritten;</div><div class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>; <span class="comment">/* We'll try again on the next call... */</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 写入成功</span></div><div class="line">        <span class="keyword">if</span> (server.aof_last_write_status == REDIS_ERR) &#123;</div><div class="line">            redisLog(REDIS_WARNING,</div><div class="line">                <span class="string">"AOF write error looks solved, Redis can write again."</span>);</div><div class="line">            server.aof_last_write_status = REDIS_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    server.aof_current_size += nwritten;</div><div class="line"></div><div class="line">    <span class="comment">// 当缓冲区使用很小时，考虑重用</span></div><div class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</div><div class="line">        sdsclear(server.aof_buf);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        sdsfree(server.aof_buf);</div><div class="line">        server.aof_buf = sdsempty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在no_fsync_on_rewrite开启并且BGSAVE或者BGREWRITE进行不执行fsync</span></div><div class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp;</div><div class="line">        (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">    <span class="comment">// 执行fsnyc,根据redis配置</span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">        <span class="comment">/* aof_fsync is defined as fdatasync() for Linux in order to avoid</span></div><div class="line">         * flushing metadata. */</div><div class="line">        latencyStartMonitor(latency);</div><div class="line">        aof_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></div><div class="line">        latencyEndMonitor(latency);</div><div class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-fsync-always"</span>,latency);</div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</div><div class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</div><div class="line">        <span class="keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd);</div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h2><p>数据存储在AOF文件中后，服务器只要读取并重新执行一遍AOF文件里保存的写命令，就可以还原服务器关闭之前的数据库状态。</p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>重写的目的主要是因为很多命令在执行多次后，可以进行合并，恢复时起始并不需要执行这么多命令。其实只要找到数据库的所有数据，生成相对应的命令即可，至于其他的命令完全不需要。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// aof重写的实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    dictIterator *di = <span class="literal">NULL</span>;</div><div class="line">    dictEntry *de;</div><div class="line">    rio aof;</div><div class="line">    FILE *fp;</div><div class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = mstime();</div><div class="line">    <span class="keyword">char</span> byte;</div><div class="line">    <span class="keyword">size_t</span> processed = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个零食文件</span></div><div class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-rewriteaof-%d.aof"</span>, (<span class="keyword">int</span>) getpid());</div><div class="line">    fp = fopen(tmpfile,<span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span> (!fp) &#123;</div><div class="line">        redisLog(REDIS_WARNING, <span class="string">"Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s"</span>, strerror(errno));</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server.aof_child_diff = sdsempty();</div><div class="line"></div><div class="line">    <span class="comment">// redis内部文件结构体初始化</span></div><div class="line">    rioInitWithFile(&amp;aof,fp);</div><div class="line">    <span class="keyword">if</span> (server.aof_rewrite_incremental_fsync)</div><div class="line">        rioSetAutoSync(&amp;aof,REDIS_AOF_AUTOSYNC_BYTES);</div><div class="line">    </div><div class="line">    <span class="comment">// 遍历数据库</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line">        <span class="keyword">char</span> selectcmd[] = <span class="string">"*2\r\n$6\r\nSELECT\r\n"</span>;</div><div class="line">        redisDb *db = server.db+j;</div><div class="line">        dict *d = db-&gt;dict;</div><div class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        di = dictGetSafeIterator(d);</div><div class="line">        <span class="keyword">if</span> (!di) &#123;</div><div class="line">            fclose(fp);</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 生成数据库选择语句</span></div><div class="line">        <span class="keyword">if</span> (rioWrite(&amp;aof,selectcmd,<span class="keyword">sizeof</span>(selectcmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">        <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,j) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">        <span class="comment">// 获取每一个键，生成命令</span></div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr;</div><div class="line">            robj key, *o;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expiretime;</div><div class="line"></div><div class="line">            keystr = dictGetKey(de);</div><div class="line">            o = dictGetVal(de);</div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line"></div><div class="line">            expiretime = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">// 跳过过期键</span></div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 根据类型保存</span></div><div class="line">            <span class="keyword">if</span> (o-&gt;type == REDIS_STRING) &#123;</div><div class="line">                <span class="comment">/* Emit a SET command */</span></div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$3\r\nSET\r\n"</span>;</div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="comment">/* Key and value */</span></div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_LIST) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteListObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_SET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_ZSET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSortedSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_HASH) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteHashObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                redisPanic(<span class="string">"Unknown object type"</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 保存过期时间</span></div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$9\r\nPEXPIREAT\r\n"</span>;</div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,expiretime) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* Read some diff from the parent process from time to time. */</span></div><div class="line">            <span class="keyword">if</span> (aof.processed_bytes &gt; processed+<span class="number">1024</span>*<span class="number">10</span>) &#123;</div><div class="line">                processed = aof.processed_bytes;</div><div class="line">                aofReadDiffFromParent();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dictReleaseIterator(di);</div><div class="line">        di = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* Read again a few times to get more data from the parent.</span></div><div class="line">     * We can't read forever (the server may receive data from clients</div><div class="line">     * faster than it is able to send data to the child), so we try to read</div><div class="line">     * some more data in a loop as soon as there is a good chance more data</div><div class="line">     * will come. If it looks like we are wasting time, we abort (this</div><div class="line">     * happens after 20 ms without new data). */</div><div class="line">    <span class="keyword">int</span> nodata = <span class="number">0</span>;</div><div class="line">    <span class="keyword">mstime_t</span> start = mstime();</div><div class="line">    <span class="keyword">while</span>(mstime()-start &lt; <span class="number">1000</span> &amp;&amp; nodata &lt; <span class="number">20</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="number">1</span>) &lt;= <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            nodata++;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        nodata = <span class="number">0</span>; <span class="comment">/* Start counting from zero, we stop on N *contiguous*</span></div><div class="line">                       timeouts. */</div><div class="line">        aofReadDiffFromParent();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Ask the master to stop sending diffs. */</span></div><div class="line">    <span class="keyword">if</span> (write(server.aof_pipe_write_ack_to_parent,<span class="string">"!"</span>,<span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,server.aof_pipe_read_ack_from_parent) != ANET_OK)</div><div class="line">        <span class="keyword">goto</span> werr;</div><div class="line">    <span class="comment">/* We read the ACK from the server using a 10 seconds timeout. Normally</span></div><div class="line">     * it should reply ASAP, but just in case we lose its reply, we are sure</div><div class="line">     * the child will eventually get terminated. */</div><div class="line">    <span class="keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,<span class="number">1</span>,<span class="number">5000</span>) != <span class="number">1</span> ||</div><div class="line">        byte != <span class="string">'!'</span>) <span class="keyword">goto</span> werr;</div><div class="line">    redisLog(REDIS_NOTICE,<span class="string">"Parent agreed to stop sending diffs. Finalizing AOF..."</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the final diff if any. */</span></div><div class="line">    aofReadDiffFromParent();</div><div class="line"></div><div class="line">    <span class="comment">/* Write the received diff to the file. */</span></div><div class="line">    redisLog(REDIS_NOTICE,</div><div class="line">        <span class="string">"Concatenating %.2f MB of AOF diff received from parent."</span>,</div><div class="line">        (<span class="keyword">double</span>) sdslen(server.aof_child_diff) / (<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">    <span class="keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// flush并关闭文件</span></div><div class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// 重命名aof文件</span></div><div class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Error moving temp append only file on the final destination: %s"</span>, strerror(errno));</div><div class="line">        unlink(tmpfile);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line">    redisLog(REDIS_NOTICE,<span class="string">"SYNC append only file rewrite performed"</span>);</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">werr:</div><div class="line">    fclose(fp);</div><div class="line">    unlink(tmpfile);</div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Write error writing append only file on disk: %s"</span>, strerror(errno));</div><div class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h2><p>与RDB一样，AOF也提供一个fork线程后台重写的功能，异步调用的实现类似与RDB。</p>
<p>在子线程完成重写之后(创建一个新文件)，调用backgroundRewriteDoneHandler()，再调用aofRewriteBufferWrite(),将子线程执行重写过程中产生的新AOF数据写入新文件，然后改名覆盖源文件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看了RDB持久化，功能是把数据库的数据全部使用一种特定格式进行存储。恢复时一个一个数据库键恢复。&lt;/p&gt;
&lt;p&gt;AOF持久化与RDB持久化不同，AOF通过保存Redis服务器执行的写命令来记录数据库的状态。&lt;/p&gt;
&lt;h2 id=&quot;AOF持久化的实现&quot;&gt;&lt;a href=&quot;#AOF持久化的实现&quot; class=&quot;headerlink&quot; title=&quot;AOF持久化的实现&quot;&gt;&lt;/a&gt;AOF持久化的实现&lt;/h2&gt;&lt;p&gt;AOF持久化功能分为命令追加、文件写入、文件同步三个步骤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令追加：将命令数据写入aof_buf缓冲区&lt;/li&gt;
&lt;li&gt;文件写入：将aof_buff缓冲区数据写入系统IO缓冲区&lt;/li&gt;
&lt;li&gt;文件同步：将系统IO缓冲区的数据同步到磁盘文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;命令追加&quot;&gt;&lt;a href=&quot;#命令追加&quot; class=&quot;headerlink&quot; title=&quot;命令追加&quot;&gt;&lt;/a&gt;命令追加&lt;/h3&gt;&lt;p&gt;AOF持久化打开时，服务器在执行一个写命令之后，会以协议的格式将执行的命令追加倒服务器状态aof_buf缓冲区尾部。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; redisServer &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  sds aof_buf;  &lt;span class=&quot;comment&quot;&gt;// aof缓冲区&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ....&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;命令追加的实现&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将命令追加到AOF缓冲区中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;feedAppendOnlyFile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; redisCommand *cmd, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; dictid, robj **argv, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sds buf = sdsempty();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    robj *tmpargv[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果没切换到正确的数据库，则追加切换数据库命令&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (dictid != server.aof_selected_db) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; seldb[&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;snprintf&lt;/span&gt;(seldb,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(seldb),&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,dictid);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        buf = sdscatprintf(buf,&lt;span class=&quot;string&quot;&gt;&quot;*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(seldb),seldb);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        server.aof_selected_db = dictid;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据命令类型追加命令&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cmd-&amp;gt;proc == expireCommand || cmd-&amp;gt;proc == pexpireCommand ||&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        cmd-&amp;gt;proc == expireatCommand) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 追加过期键命令&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],argv[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cmd-&amp;gt;proc == setexCommand || cmd-&amp;gt;proc == psetexCommand) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 追加setexCommand或者psetexCommand&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        tmpargv[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = createStringObject(&lt;span class=&quot;string&quot;&gt;&quot;SET&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        tmpargv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        tmpargv[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = argv[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        buf = catAppendOnlyGenericCommand(buf,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,tmpargv);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        decrRefCount(tmpargv[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],argv[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 追加其他一般修改数据库命令&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        buf = catAppendOnlyGenericCommand(buf,argc,argv);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将格式化的命令字符串追加到aof_buf缓冲区中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (server.aof_state == REDIS_AOF_ON)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (server.aof_child_pid != &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 如果在执行AOF重写，那么追加的新的AOF文件中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        aofRewriteBufferAppend((&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;*)buf,sdslen(buf));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sdsfree(buf);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 根据参数，格式化命令&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;sds &lt;span class=&quot;title&quot;&gt;catAppendOnlyGenericCommand&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(sds dst, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, robj **argv)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len, j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    robj *o;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    buf[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    len = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+ll2string(buf+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(buf)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,argc);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    buf[len++] = &lt;span class=&quot;string&quot;&gt;&#39;\r&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    buf[len++] = &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dst = sdscatlen(dst,buf,len);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历每一个参数，支架到AOF缓冲区中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; argc; j++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        o = getDecodedObject(argv[j]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        buf[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;$&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        len = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+ll2string(buf+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(buf)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,sdslen(o-&amp;gt;ptr));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        buf[len++] = &lt;span class=&quot;string&quot;&gt;&#39;\r&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        buf[len++] = &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        dst = sdscatlen(dst,buf,len);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        dst = sdscatlen(dst,o-&amp;gt;ptr,sdslen(o-&amp;gt;ptr));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        dst = sdscatlen(dst,&lt;span class=&quot;string&quot;&gt;&quot;\r\n&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        decrRefCount(o);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dst;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码阅读-订阅与发布</title>
    <link href="http://www.coderyang.com//blog/2017/07/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83.html"/>
    <id>http://www.coderyang.com//blog/2017/07/Redis源码阅读-订阅与发布.html</id>
    <published>2017-07-12T11:36:41.000Z</published>
    <updated>2017-07-12T11:38:05.660Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的发布与订阅主要是实现客户端订阅一个频道或者模式，当某客户端向一个频道发送消息时，该频道或者匹配模式订阅者都能够收到消息。</p>
<h2 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h2><p>Redis在服务器结构体中的pubsub_channels字典中保存了所有的频道订阅关系。pubsub_channels键为频道，值为订阅的客户端组成的链表。</p>
<p>客户端结构体的pubsub_channels保存了客户端订阅的所有频道，pubsub_channels的键为频道，值为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  dict *pubsub_channels;  <span class="comment">// 保存所有的频道订阅关系</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> redisClient &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  dict *pubsub_channels; <span class="comment">// 记录客户端订阅的频道</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 订阅命令处理函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历指令中的所有频道</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">        pubsubSubscribeChannel(c,c-&gt;argv[j]);</div><div class="line">    c-&gt;flags |= REDIS_PUBSUB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设置客户端c订阅频道channel</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(redisClient *c, robj *channel)</span> </span>&#123;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Add the channel to the client -&gt; channels hash table */</span></div><div class="line">    <span class="comment">// 将channels加倒c-&gt;c-&gt;pubsub_channels的字典里</span></div><div class="line">    <span class="keyword">if</span> (dictAdd(c-&gt;pubsub_channels,channel,<span class="literal">NULL</span>) == DICT_OK) &#123;</div><div class="line">        retval = <span class="number">1</span>;</div><div class="line">        incrRefCount(channel);</div><div class="line">        <span class="comment">/* Add the client to the channel -&gt; list of clients hash table */</span></div><div class="line">        <span class="comment">// 找出服务器中的频道</span></div><div class="line">        de = dictFind(server.pubsub_channels,channel);</div><div class="line">        </div><div class="line">        <span class="comment">// 不存在就添加一个频道</span></div><div class="line">        <span class="comment">// 获取客户端链表</span></div><div class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</div><div class="line">            clients = listCreate();</div><div class="line">            dictAdd(server.pubsub_channels,channel,clients);</div><div class="line">            incrRefCount(channel);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            clients = dictGetVal(de);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 添加到客户端链表尾部</span></div><div class="line">        listAddNodeTail(clients,c);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Notify the client */</span></div><div class="line">    <span class="comment">// 回复客户端</span></div><div class="line">    addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">    addReply(c,shared.subscribebulk);</div><div class="line">    addReplyBulk(c,channel);</div><div class="line">    addReplyLongLong(c,clientSubscriptionsCount(c));</div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="退订"><a href="#退订" class="headerlink" title="退订"></a>退订</h2><p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 退订所有频道</span></div><div class="line">        pubsubUnsubscribeAllChannels(c,<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历频道一一退订</span></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">            pubsubUnsubscribeChannel(c,c-&gt;argv[j],<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~REDIS_PUBSUB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 退订所有频道</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllChannels</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span> </span>&#123;</div><div class="line">    dictIterator *di = dictGetSafeIterator(c-&gt;pubsub_channels);</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历一一退订</span></div><div class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">        robj *channel = dictGetKey(de);</div><div class="line"></div><div class="line">        count += pubsubUnsubscribeChannel(c,channel,notify);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* We were subscribed to nothing? Still reply to the client. */</span></div><div class="line">    <span class="keyword">if</span> (notify &amp;&amp; count == <span class="number">0</span>) &#123;</div><div class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">        addReply(c,shared.unsubscribebulk);</div><div class="line">        addReply(c,shared.nullbulk);</div><div class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</div><div class="line">                       listLength(c-&gt;pubsub_patterns));</div><div class="line">    &#125;</div><div class="line">    dictReleaseIterator(di);</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 客户端退订频道</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeChannel</span><span class="params">(redisClient *c, robj *channel, <span class="keyword">int</span> notify)</span> </span>&#123;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="built_in">list</span> *clients;</div><div class="line">    listNode *ln;</div><div class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Remove the channel from the client -&gt; channels hash table */</span></div><div class="line">    incrRefCount(channel); <span class="comment">/* channel may be just a pointer to the same object</span></div><div class="line">                            we have in the hash tables. Protect it... */</div><div class="line"></div><div class="line">    <span class="comment">// 移除客户端字典中频道的订阅</span></div><div class="line">    <span class="keyword">if</span> (dictDelete(c-&gt;pubsub_channels,channel) == DICT_OK) &#123;</div><div class="line">        retval = <span class="number">1</span>;</div><div class="line">        <span class="comment">/* Remove the client from the channel -&gt; clients list hash table */</span></div><div class="line">        <span class="comment">// 找到服务器频道</span></div><div class="line">        de = dictFind(server.pubsub_channels,channel);</div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</div><div class="line">        clients = dictGetVal(de); <span class="comment">// 获取链表</span></div><div class="line">        ln = listSearchKey(clients,c); <span class="comment">// 寻找链表中的订阅</span></div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</div><div class="line">        listDelNode(clients,ln); <span class="comment">// 删除节点</span></div><div class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">/* Free the list and associated hash entry at all if this was</span></div><div class="line">             * the latest client, so that it will be possible to abuse</div><div class="line">             * Redis PUBSUB creating millions of channels. */</div><div class="line">            <span class="comment">// 删除节点后 链表为空 删除字典中的节点</span></div><div class="line">            dictDelete(server.pubsub_channels,channel);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Notify the client */</span></div><div class="line">    <span class="comment">// 回复客户端</span></div><div class="line">    <span class="keyword">if</span> (notify) &#123;</div><div class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">        addReply(c,shared.unsubscribebulk);</div><div class="line">        addReplyBulk(c,channel);</div><div class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</div><div class="line">                       listLength(c-&gt;pubsub_patterns));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    decrRefCount(channel); <span class="comment">/* it is finally safe to release it */</span></div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h2><p>Redis在服务器结构体中的pubsub_patterns链表中保存了所有订阅模式关系。使用pubsubPattern结构的数据作为节点。</p>
<p>客户端结构体的pubsub_patterns保存了客户端订阅的所有模式，节点使用pubsubPattern结构的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">// 所有订阅模式关系</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> redisClient &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">// 订阅模式关系</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> pubsubPattern &#123;</div><div class="line">    client *client; <span class="comment">// 订阅模式的客户端</span></div><div class="line">    robj *pattern;  <span class="comment">// 被订阅模式</span></div><div class="line">&#125; pubsubPattern;</div></pre></td></tr></table></figure>
<h2 id="订阅-1"><a href="#订阅-1" class="headerlink" title="订阅"></a>订阅</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 订阅模式</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">psubscribeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历命令中的模式</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">        pubsubSubscribePattern(c,c-&gt;argv[j]);</div><div class="line">    c-&gt;flags |= REDIS_PUBSUB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设置客户端c订阅模式pattern</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribePattern</span><span class="params">(redisClient *c, robj *pattern)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 客户端模式链表中查找模式</span></div><div class="line">    <span class="comment">// 为空则创建</span></div><div class="line">    <span class="keyword">if</span> (listSearchKey(c-&gt;pubsub_patterns,pattern) == <span class="literal">NULL</span>) &#123;</div><div class="line">        retval = <span class="number">1</span>;</div><div class="line">        pubsubPattern *pat;</div><div class="line">        <span class="comment">// 客户端模式链表尾部添加模式</span></div><div class="line">        listAddNodeTail(c-&gt;pubsub_patterns,pattern);</div><div class="line">        incrRefCount(pattern);</div><div class="line"></div><div class="line">        <span class="comment">// 服务端模式链表尾部添加模式</span></div><div class="line">        pat = zmalloc(<span class="keyword">sizeof</span>(*pat));</div><div class="line">        pat-&gt;pattern = getDecodedObject(pattern);</div><div class="line">        pat-&gt;client = c;</div><div class="line">        listAddNodeTail(server.pubsub_patterns,pat);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Notify the client */</span></div><div class="line">    addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">    addReply(c,shared.psubscribebulk);</div><div class="line">    addReplyBulk(c,pattern);</div><div class="line">    addReplyLongLong(c,clientSubscriptionsCount(c));</div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="退订-1"><a href="#退订-1" class="headerlink" title="退订"></a>退订</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 退订模式</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">punsubscribeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 退订所有模式</span></div><div class="line">        pubsubUnsubscribeAllPatterns(c,<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">        <span class="comment">// 退订命令中的模式</span></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">            pubsubUnsubscribePattern(c,c-&gt;argv[j],<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~REDIS_PUBSUB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 退订客户端c订阅的所有模式</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllPatterns</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span> </span>&#123;</div><div class="line">    listNode *ln;</div><div class="line">    listIter li;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历，一一退订</span></div><div class="line">    listRewind(c-&gt;pubsub_patterns,&amp;li);</div><div class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</div><div class="line">        robj *pattern = ln-&gt;value;</div><div class="line"></div><div class="line">        count += pubsubUnsubscribePattern(c,pattern,notify);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (notify &amp;&amp; count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/* We were subscribed to nothing? Still reply to the client. */</span></div><div class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">        addReply(c,shared.punsubscribebulk);</div><div class="line">        addReply(c,shared.nullbulk);</div><div class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</div><div class="line">                       listLength(c-&gt;pubsub_patterns));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 取消客户端c对模式pattern的订阅</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribePattern</span><span class="params">(redisClient *c, robj *pattern, <span class="keyword">int</span> notify)</span> </span>&#123;</div><div class="line">    listNode *ln;</div><div class="line">    pubsubPattern pat;</div><div class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">    incrRefCount(pattern); <span class="comment">/* Protect the object. May be the same we remove */</span></div><div class="line"></div><div class="line">    <span class="comment">// 订阅了才进行操作</span></div><div class="line">    <span class="keyword">if</span> ((ln = listSearchKey(c-&gt;pubsub_patterns,pattern)) != <span class="literal">NULL</span>) &#123;</div><div class="line">        retval = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 从客户端订阅中删除</span></div><div class="line">        listDelNode(c-&gt;pubsub_patterns,ln);</div><div class="line">        pat.client = c;</div><div class="line">        pat.pattern = pattern;</div><div class="line"></div><div class="line">        <span class="comment">// 从服务端订阅中删除</span></div><div class="line">        ln = listSearchKey(server.pubsub_patterns,&amp;pat);</div><div class="line">        listDelNode(server.pubsub_patterns,ln);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Notify the client */</span></div><div class="line">    <span class="keyword">if</span> (notify) &#123;</div><div class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">        addReply(c,shared.punsubscribebulk);</div><div class="line">        addReplyBulk(c,pattern);</div><div class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</div><div class="line">                       listLength(c-&gt;pubsub_patterns));</div><div class="line">    &#125;</div><div class="line">    decrRefCount(pattern);</div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发布消息</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> receivers = pubsubPublishMessage(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">    <span class="comment">// 暂时不考虑集群</span></div><div class="line">    <span class="keyword">if</span> (server.cluster_enabled)</div><div class="line">        clusterPropagatePublish(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        forceCommandPropagation(c,REDIS_PROPAGATE_REPL);</div><div class="line">    addReplyLongLong(c,receivers);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将消息发送到所有订阅了频道的客户端</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> receivers = <span class="number">0</span>;</div><div class="line">    dictEntry *de;</div><div class="line">    listNode *ln;</div><div class="line">    listIter li;</div><div class="line"></div><div class="line">    <span class="comment">/* Send to clients listening for that channel */</span></div><div class="line">    <span class="comment">// 先查找订阅了频道的</span></div><div class="line">    de = dictFind(server.pubsub_channels,channel);</div><div class="line">    <span class="keyword">if</span> (de) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 获取链表</span></div><div class="line">        <span class="built_in">list</span> *<span class="built_in">list</span> = dictGetVal(de);</div><div class="line">        listNode *ln;</div><div class="line">        listIter li;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历链表 发送消息</span></div><div class="line">        listRewind(<span class="built_in">list</span>,&amp;li);</div><div class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            redisClient *c = ln-&gt;value;</div><div class="line"></div><div class="line">            addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">            addReply(c,shared.messagebulk);</div><div class="line">            addReplyBulk(c,channel);</div><div class="line">            addReplyBulk(c,message);</div><div class="line">            receivers++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Send to clients listening to matching channels */</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (listLength(server.pubsub_patterns)) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历模式链表</span></div><div class="line">        listRewind(server.pubsub_patterns,&amp;li);</div><div class="line">        channel = getDecodedObject(channel);</div><div class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            pubsubPattern *pat = ln-&gt;value;</div><div class="line"></div><div class="line">            <span class="comment">// 匹配模式 发送消息</span></div><div class="line">            <span class="keyword">if</span> (stringmatchlen((<span class="keyword">char</span>*)pat-&gt;pattern-&gt;ptr,</div><div class="line">                                sdslen(pat-&gt;pattern-&gt;ptr),</div><div class="line">                                (<span class="keyword">char</span>*)channel-&gt;ptr,</div><div class="line">                                sdslen(channel-&gt;ptr),<span class="number">0</span>)) &#123;</div><div class="line">                addReply(pat-&gt;client,shared.mbulkhdr[<span class="number">4</span>]);</div><div class="line">                addReply(pat-&gt;client,shared.pmessagebulk);</div><div class="line">                addReplyBulk(pat-&gt;client,pat-&gt;pattern);</div><div class="line">                addReplyBulk(pat-&gt;client,channel);</div><div class="line">                addReplyBulk(pat-&gt;client,message);</div><div class="line">                receivers++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        decrRefCount(channel);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> receivers;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的发布与订阅主要是实现客户端订阅一个频道或者模式，当某客户端向一个频道发送消息时，该频道或者匹配模式订阅者都能够收到消息。&lt;/p&gt;
&lt;h2 id=&quot;频道的订阅与退订&quot;&gt;&lt;a href=&quot;#频道的订阅与退订&quot; class=&quot;headerlink&quot; title=&quot;频道的订阅与退订&quot;&gt;&lt;/a&gt;频道的订阅与退订&lt;/h2&gt;&lt;p&gt;Redis在服务器结构体中的pubsub_channels字典中保存了所有的频道订阅关系。pubsub_channels键为频道，值为订阅的客户端组成的链表。&lt;/p&gt;
&lt;p&gt;客户端结构体的pubsub_channels保存了客户端订阅的所有频道，pubsub_channels的键为频道，值为空。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; redisServer &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  dict *pubsub_channels;  &lt;span class=&quot;comment&quot;&gt;// 保存所有的频道订阅关系&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; redisClient &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  dict *pubsub_channels; &lt;span class=&quot;comment&quot;&gt;// 记录客户端订阅的频道&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;订阅&quot;&gt;&lt;a href=&quot;#订阅&quot; class=&quot;headerlink&quot; title=&quot;订阅&quot;&gt;&lt;/a&gt;订阅&lt;/h2&gt;&lt;p&gt;源码如下&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 订阅命令处理函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;subscribeCommand&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(redisClient *c)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历指令中的所有频道&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt; c-&amp;gt;argc; j++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        pubsubSubscribeChannel(c,c-&amp;gt;argv[j]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    c-&amp;gt;flags |= REDIS_PUBSUB;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 设置客户端c订阅频道channel&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pubsubSubscribeChannel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(redisClient *c, robj *channel)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictEntry *de;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt; *clients = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; retval = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Add the channel to the client -&amp;gt; channels hash table */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将channels加倒c-&amp;gt;c-&amp;gt;pubsub_channels的字典里&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (dictAdd(c-&amp;gt;pubsub_channels,channel,&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) == DICT_OK) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        retval = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        incrRefCount(channel);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* Add the client to the channel -&amp;gt; list of clients hash table */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 找出服务器中的频道&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        de = dictFind(server.pubsub_channels,channel);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 不存在就添加一个频道&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 获取客户端链表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (de == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            clients = listCreate();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            dictAdd(server.pubsub_channels,channel,clients);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            incrRefCount(channel);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            clients = dictGetVal(de);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 添加到客户端链表尾部&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        listAddNodeTail(clients,c);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Notify the client */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 回复客户端&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    addReply(c,shared.mbulkhdr[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    addReply(c,shared.subscribebulk);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    addReplyBulk(c,channel);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    addReplyLongLong(c,clientSubscriptionsCount(c));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retval;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-RDB持久化</title>
    <link href="http://www.coderyang.com//blog/2017/07/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-RDB%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>http://www.coderyang.com//blog/2017/07/redis源码阅读-RDB持久化.html</id>
    <published>2017-07-12T08:04:59.000Z</published>
    <updated>2017-07-12T08:06:22.145Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是一个内存数据库，数据存储在内存之中。有一个问题就是如果数据不存储到硬盘，那么在服务器进程退出之后，服务器中所有的数据库数据就会丢失。</p>
<p>Redis为了解决这个问题，提供了持久化功能，目前有两种一种是RDB持久化，一种是AOF持久化。</p>
<p>RDB持久化是生成一个RDB文件，该文件是一个经过压缩的二进制文件，通过该文件可以还原数据库的状态。</p>
<h2 id="RDB文件的保存命令"><a href="#RDB文件的保存命令" class="headerlink" title="RDB文件的保存命令"></a>RDB文件的保存命令</h2><p>Redis有两个命令可以生成RDB文件一个是SAVE，一个是BGSAVE。<br>SAVE命令调用saveCommand进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否正在执行BGSAVE，是则退出</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        addReplyError(c,<span class="string">"Background save already in progress"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//调用rdbSave生成RDB文件</span></div><div class="line">    <span class="keyword">if</span> (rdbSave(server.rdb_filename) == REDIS_OK) &#123;</div><div class="line">        addReply(c,shared.ok);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReply(c,shared.err);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BGSAVE调用bgsaveCommand进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgsaveCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否已经在执行BGSAVE</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        addReplyError(c,<span class="string">"Background save already in progress"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        </div><div class="line">    <span class="comment">// 判断是否在执行BGREWRIEAOF</span></div><div class="line">        addReplyError(c,<span class="string">"Can't BGSAVE while AOF log rewriting is in progress"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 执行rdbSaveBackground 生成RDB文件</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbSaveBackground(server.rdb_filename) == REDIS_OK) &#123;</div><div class="line">        addReplyStatus(c,<span class="string">"Background saving started"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReply(c,shared.err);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">pid_t</span> childpid;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</div><div class="line"></div><div class="line">    <span class="comment">// 如果BGSAVE正在执行直接返回</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 获取dirty数据 执行时间</span></div><div class="line">    server.dirty_before_bgsave = server.dirty;</div><div class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// fork() 开始前时间</span></div><div class="line">    start = ustime();</div><div class="line"></div><div class="line">    <span class="comment">// 调用fork，克隆该进程</span></div><div class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">        <span class="comment">/* Child */</span></div><div class="line">        closeListeningSockets(<span class="number">0</span>);</div><div class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 执行保存操作</span></div><div class="line">        retval = rdbSave(filename);</div><div class="line"></div><div class="line">        <span class="comment">// 打印 copy-on-write 时使用的内存数</span></div><div class="line">        <span class="keyword">if</span> (retval == REDIS_OK) &#123;</div><div class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (private_dirty) &#123;</div><div class="line">                redisLog(REDIS_NOTICE,</div><div class="line">                    <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</div><div class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 向父进程发送信号</span></div><div class="line">        exitFromChild((retval == REDIS_OK) ? <span class="number">0</span> : <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Parent */</span></div><div class="line"></div><div class="line">        <span class="comment">// 计算 fork() 执行的时间</span></div><div class="line">        server.stat_fork_time = ustime()-start;</div><div class="line">        server.stat_fork_rate = (<span class="keyword">double</span>) zmalloc_used_memory() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></div><div class="line">        latencyAddSampleIfNeeded(<span class="string">"fork"</span>,server.stat_fork_time/<span class="number">1000</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 执行fork()错误信息</span></div><div class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</div><div class="line">            server.lastbgsave_status = REDIS_ERR;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't save in background: fork: %s"</span>,</div><div class="line">                strerror(errno));</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line">        redisLog(REDIS_NOTICE,<span class="string">"Background saving started by pid %d"</span>,childpid);</div><div class="line">        </div><div class="line">        <span class="comment">// 记录数据库开始BGSAVE时间</span></div><div class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 子进程ID 类型</span></div><div class="line">        server.rdb_child_pid = childpid;</div><div class="line">        server.rdb_child_type = REDIS_RDB_CHILD_TYPE_DISK;</div><div class="line"></div><div class="line">        <span class="comment">// 关闭自动Rehash</span></div><div class="line">        updateDictResizePolicy();</div><div class="line">        <span class="keyword">return</span> REDIS_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> REDIS_OK; <span class="comment">/* unreached */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>那么怎么才能够知道BGSAVE执行完毕，BGSAVE执行完毕后使用exitFromChild((retval == REDIS_OK) ? 0 : 1);向父进程发送信号。父进程调用serverCron接收该信号。</p>
<p>以下是处理函数的部分代码，处理BGREWRITEAOF与BGSAVE的完成信号。最终调用backgroundSaveDoneHandler根据返回信号信息进行对应处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span> </span>&#123;</div><div class="line">\\ ...</div><div class="line">    <span class="comment">// 检查 BGSAVE 或者 BGREWRITEAOF 是否已经执行完毕</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> || server.aof_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">int</span> statloc;</div><div class="line">        <span class="keyword">pid_t</span> pid;</div><div class="line"></div><div class="line">        <span class="comment">// 接收子进程发来的信号</span></div><div class="line">        <span class="keyword">if</span> ((pid = wait3(&amp;statloc,WNOHANG,<span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> exitcode = WEXITSTATUS(statloc);</div><div class="line">            <span class="keyword">int</span> bysignal = <span class="number">0</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</div><div class="line"></div><div class="line">            <span class="comment">// BGSAVE 执行完毕</span></div><div class="line">            <span class="keyword">if</span> (pid == server.rdb_child_pid) &#123;</div><div class="line">                backgroundSaveDoneHandler(exitcode,bysignal);</div><div class="line"></div><div class="line">            <span class="comment">// BGREWRITEAOF 执行完毕</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.aof_child_pid) &#123;</div><div class="line">                backgroundRewriteDoneHandler(exitcode,bysignal);</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    <span class="string">"Warning, detected child with unmatched pid: %ld"</span>,</div><div class="line">                    (<span class="keyword">long</span>)pid);</div><div class="line">            &#125;</div><div class="line">            updateDictResizePolicy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">\\ ...</div><div class="line">  </div><div class="line"><span class="comment">/* A background saving child (BGSAVE) terminated its work. Handle this.</span></div><div class="line"> * This function covers the case of actual BGSAVEs. */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundSaveDoneHandlerDisk</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 成功</span></div><div class="line">    <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) &#123;</div><div class="line">        redisLog(REDIS_NOTICE,</div><div class="line">            <span class="string">"Background saving terminated with success"</span>);</div><div class="line">        server.dirty = server.dirty - server.dirty_before_bgsave;</div><div class="line">        server.lastsave = time(<span class="literal">NULL</span>);</div><div class="line">        server.lastbgsave_status = REDIS_OK;</div><div class="line"></div><div class="line">    <span class="comment">// 出错</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode != <span class="number">0</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING, <span class="string">"Background saving error"</span>);</div><div class="line">        server.lastbgsave_status = REDIS_ERR;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">mstime_t</span> latency;</div><div class="line"></div><div class="line">        redisLog(REDIS_WARNING,</div><div class="line">            <span class="string">"Background saving terminated by signal %d"</span>, bysignal);</div><div class="line">        latencyStartMonitor(latency);</div><div class="line">        rdbRemoveTempFile(server.rdb_child_pid);</div><div class="line">        latencyEndMonitor(latency);</div><div class="line">        latencyAddSampleIfNeeded(<span class="string">"rdb-unlink-temp-file"</span>,latency);</div><div class="line">        <span class="comment">/* SIGUSR1 is whitelisted, so we have a way to kill a child without</span></div><div class="line">         * tirggering an error conditon. */</div><div class="line">        <span class="keyword">if</span> (bysignal != SIGUSR1)</div><div class="line">            server.lastbgsave_status = REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新状态</span></div><div class="line">    server.rdb_child_pid = <span class="number">-1</span>;</div><div class="line">    server.rdb_child_type = REDIS_RDB_CHILD_TYPE_NONE;</div><div class="line">    server.rdb_save_time_last = time(<span class="literal">NULL</span>)-server.rdb_save_time_start;</div><div class="line">    server.rdb_save_time_start = <span class="number">-1</span>;</div><div class="line">    <span class="comment">/* Possibly there are slaves waiting for a BGSAVE in order to be served</span></div><div class="line">     * (the first stage of SYNC is a bulk transfer of dump.rdb) */</div><div class="line">    updateSlavesWaitingBgsave((!bysignal &amp;&amp; exitcode == <span class="number">0</span>) ? REDIS_OK : REDIS_ERR, REDIS_RDB_CHILD_TYPE_DISK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="rdbSave"><a href="#rdbSave" class="headerlink" title="rdbSave"></a>rdbSave</h3><p>int rdbSave(char *filename);是SAVE与BGSAVE命令执行时正在用来生成RDB文件的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line">    <span class="keyword">int</span> error;</div><div class="line"></div><div class="line">    <span class="comment">// 生成临时文件</span></div><div class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) getpid());</div><div class="line">    fp = fopen(tmpfile,<span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span> (!fp) &#123;</div><div class="line">        redisLog(REDIS_WARNING, <span class="string">"Failed opening .rdb for saving: %s"</span>,</div><div class="line">            strerror(errno));</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化I/O</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line">    </div><div class="line">    <span class="comment">// 生成RDB文件</span></div><div class="line">    <span class="keyword">if</span> (rdbSaveRio(&amp;rdb,&amp;error) == REDIS_ERR) &#123;</div><div class="line">        errno = error;</div><div class="line">        <span class="keyword">goto</span> werr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 确保缓存中没有数据</span></div><div class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// 使用RENAME改名</span></div><div class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Error moving temp DB file on the final destination: %s"</span>, strerror(errno));</div><div class="line">        unlink(tmpfile);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 日志 设置状态</span></div><div class="line">    redisLog(REDIS_NOTICE,<span class="string">"DB saved on disk"</span>);</div><div class="line">    server.dirty = <span class="number">0</span>;</div><div class="line">    server.lastsave = time(<span class="literal">NULL</span>);</div><div class="line">    server.lastbgsave_status = REDIS_OK;</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">werr:</div><div class="line"></div><div class="line">    <span class="comment">// 异常处理</span></div><div class="line">    fclose(fp);</div><div class="line">    unlink(tmpfile);</div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Write error saving DB on disk: %s"</span>, strerror(errno));</div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际是调用rdbSaveRio执行写入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error)</span> </span>&#123;</div><div class="line">    dictIterator *di = <span class="literal">NULL</span>;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = mstime();</div><div class="line">    <span class="keyword">uint64_t</span> cksum;</div><div class="line"></div><div class="line">    <span class="comment">// 设置校验和</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_checksum)</div><div class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</div><div class="line"></div><div class="line">    <span class="comment">// 写入REDIS版本号</span></div><div class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">"REDIS%04d"</span>,REDIS_RDB_VERSION);</div><div class="line">    <span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历数据库</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line">        redisDb *db = server.db+j;</div><div class="line">        dict *d = db-&gt;dict;</div><div class="line"></div><div class="line">        <span class="comment">// 跳过空数据库</span></div><div class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 键空间迭代器</span></div><div class="line">        di = dictGetSafeIterator(d);</div><div class="line">        <span class="keyword">if</span> (!di) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">        <span class="comment">/* Write the SELECT DB opcode */</span></div><div class="line">        <span class="comment">// 写入DB选择器</span></div><div class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,REDIS_RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">        <span class="comment">/* Iterate this DB writing every entry */</span></div><div class="line">      <span class="comment">// 遍历数据库，写入键值对</span></div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr = dictGetKey(de);</div><div class="line">            robj key, *o = dictGetVal(de);</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</div><div class="line"></div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line">            expire = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">// 写入键值对</span></div><div class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire,now) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        &#125;</div><div class="line">        dictReleaseIterator(di);</div><div class="line">    &#125;</div><div class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* EOF opcode */</span></div><div class="line">    <span class="comment">// 写入 EOF 代码</span></div><div class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,REDIS_RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></div><div class="line">     * loading code skips the check in this case. */</div><div class="line">    <span class="comment">// CRC64 校验和。</span></div><div class="line">    cksum = rdb-&gt;cksum;</div><div class="line">    memrev64ifbe(&amp;cksum);</div><div class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">werr:</div><div class="line">    <span class="keyword">if</span> (error) *error = errno;</div><div class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h2><p>redis能够配置自动保存条件，当满足的情况下执行BGSAVE。</p>
<p>依赖上次保存时间和dirty计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// serverCron函数</span></div><div class="line"><span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> || server.aof_child_pid != <span class="number">-1</span> ||</div><div class="line">    ldbPendingChildren())</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 为之前处理BGSAVE完成的部分的代码</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 检查所有保存条件</span></div><div class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.saveparamslen; j++) &#123;</div><div class="line">    <span class="keyword">struct</span> saveparam *sp = server.saveparams+j;</div><div class="line">    <span class="comment">// 检查某个保存条件是否符合</span></div><div class="line">    <span class="keyword">if</span> (server.dirty &gt;= sp-&gt;changes &amp;&amp;</div><div class="line">        server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</div><div class="line">        (server.unixtime-server.lastbgsave_try &gt;</div><div class="line">         CONFIG_BGSAVE_RETRY_DELAY ||</div><div class="line">         server.lastbgsave_status == C_OK))</div><div class="line">    &#123;</div><div class="line">      serverLog(LL_NOTICE,<span class="string">"%d changes in %d seconds. Saving..."</span>,</div><div class="line">                sp-&gt;changes, (<span class="keyword">int</span>)sp-&gt;seconds);</div><div class="line">      </div><div class="line">      <span class="comment">// 保存</span></div><div class="line">      rdbSaveBackground(server.rdb_filename);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RDB的文件载入"><a href="#RDB的文件载入" class="headerlink" title="RDB的文件载入"></a>RDB的文件载入</h2><p>rdbload()用于将RDB文件从硬盘载入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> dbid;</div><div class="line">    <span class="keyword">int</span> type, rdbver;</div><div class="line">    redisDb *db = server.db+<span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> expiretime, now = mstime();</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line"></div><div class="line">    <span class="comment">// 打开rdb文件</span></div><div class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">"r"</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化rio</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line">    rdb.update_cksum = rdbLoadProgressCallback;</div><div class="line">    rdb.max_processing_chunk = server.loading_process_events_interval_bytes;</div><div class="line">    <span class="keyword">if</span> (rioRead(&amp;rdb,buf,<span class="number">9</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">    buf[<span class="number">9</span>] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 校验版本号</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(buf,<span class="string">"REDIS"</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Wrong signature trying to load DB from file"</span>);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line">    rdbver = atoi(buf+<span class="number">5</span>);</div><div class="line">    <span class="keyword">if</span> (rdbver &lt; <span class="number">1</span> || rdbver &gt; REDIS_RDB_VERSION) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Can't handle RDB format version %d"</span>,rdbver);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 标记开始载入</span></div><div class="line">    startLoading(fp);</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        robj *key, *val;</div><div class="line">        expiretime = <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Read type. */</span></div><div class="line">        <span class="comment">// 读取类型</span></div><div class="line">        <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">// 过期时间 秒为单位</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 过期时间</span></div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again. */</span></div><div class="line"></div><div class="line">            <span class="comment">// 键值对</span></div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">            <span class="comment">/* the EXPIRETIME opcode specifies time in seconds, so convert</span></div><div class="line">             * into milliseconds. */</div><div class="line">            expiretime *= <span class="number">1000</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME_MS) &#123;</div><div class="line">            <span class="comment">/* Milliseconds precision expire times introduced with RDB</span></div><div class="line">             * version 3. */</div><div class="line">             <span class="comment">// 过期时间 毫秒但闻</span></div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadMillisecondTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again. */</span></div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// EOF</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EOF)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Handle SELECT DB opcode as a special case */</span></div><div class="line">        <span class="comment">// 读取切换数据库指示</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_SELECTDB) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 数据库号</span></div><div class="line">            <span class="keyword">if</span> ((dbid = rdbLoadLen(&amp;rdb,<span class="literal">NULL</span>)) == REDIS_RDB_LENERR)</div><div class="line">                <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">// 校验</span></div><div class="line">            <span class="keyword">if</span> (dbid &gt;= (<span class="keyword">unsigned</span>)server.dbnum) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\n"</span>, server.dbnum);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 切换数据库</span></div><div class="line">            db = server.db+dbid;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* Read key */</span></div><div class="line">        <span class="comment">// 读取键</span></div><div class="line">        <span class="keyword">if</span> ((key = rdbLoadStringObject(&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        <span class="comment">/* Read value */</span></div><div class="line">        <span class="comment">// 读取值</span></div><div class="line">        <span class="keyword">if</span> ((val = rdbLoadObject(type,&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        <span class="comment">/* Check if the key already expired. This function is used when loading</span></div><div class="line">         * an RDB file from disk, either at startup, or when an RDB was</div><div class="line">         * received from the master. In the latter case, the master is</div><div class="line">         * responsible for key expiry. If we would expire keys here, the</div><div class="line">         * snapshot taken by the master may not be reflected on the slave. */</div><div class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</div><div class="line">            decrRefCount(key);</div><div class="line">            decrRefCount(val);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* Add the new object in the hash table */</span></div><div class="line">        <span class="comment">// 将键值关联到数据库内</span></div><div class="line">        dbAdd(db,key,val);</div><div class="line"></div><div class="line">        <span class="comment">/* Set the expire time if needed */</span></div><div class="line">        <span class="comment">// 设置过期时间</span></div><div class="line">        <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) setExpire(db,key,expiretime);</div><div class="line"></div><div class="line">        decrRefCount(key);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Verify the checksum if RDB version is &gt;= 5 */</span></div><div class="line">    <span class="comment">// 校验和比较</span></div><div class="line">    <span class="keyword">if</span> (rdbver &gt;= <span class="number">5</span> &amp;&amp; server.rdb_checksum) &#123;</div><div class="line">        <span class="keyword">uint64_t</span> cksum, expected = rdb.cksum;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (rioRead(&amp;rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        memrev64ifbe(&amp;cksum);</div><div class="line">        <span class="keyword">if</span> (cksum == <span class="number">0</span>) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"RDB file was saved with checksum disabled: no check performed."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != expected) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Wrong RDB checksum. Aborting now."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 结束</span></div><div class="line">    fclose(fp);</div><div class="line">    stopLoading();</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">eoferr: <span class="comment">/* unexpected end of file is handled here with a fatal exit */</span></div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Short read or OOM loading DB. Unrecoverable error, aborting now."</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Just to avoid warning */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis是一个内存数据库，数据存储在内存之中。有一个问题就是如果数据不存储到硬盘，那么在服务器进程退出之后，服务器中所有的数据库数据就会丢失。&lt;/p&gt;
&lt;p&gt;Redis为了解决这个问题，提供了持久化功能，目前有两种一种是RDB持久化，一种是AOF持久化。&lt;/p&gt;
&lt;p&gt;RDB持久化是生成一个RDB文件，该文件是一个经过压缩的二进制文件，通过该文件可以还原数据库的状态。&lt;/p&gt;
&lt;h2 id=&quot;RDB文件的保存命令&quot;&gt;&lt;a href=&quot;#RDB文件的保存命令&quot; class=&quot;headerlink&quot; title=&quot;RDB文件的保存命令&quot;&gt;&lt;/a&gt;RDB文件的保存命令&lt;/h2&gt;&lt;p&gt;Redis有两个命令可以生成RDB文件一个是SAVE，一个是BGSAVE。&lt;br&gt;SAVE命令调用saveCommand进行处理&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;saveCommand&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(redisClient *c)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 判断是否正在执行BGSAVE，是则退出&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (server.rdb_child_pid != &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        addReplyError(c,&lt;span class=&quot;string&quot;&gt;&quot;Background save already in progress&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//调用rdbSave生成RDB文件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rdbSave(server.rdb_filename) == REDIS_OK) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        addReply(c,shared.ok);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        addReply(c,shared.err);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;BGSAVE调用bgsaveCommand进行处理&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;85&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bgsaveCommand&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(redisClient *c)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 判断是否已经在执行BGSAVE&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (server.rdb_child_pid != &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        addReplyError(c,&lt;span class=&quot;string&quot;&gt;&quot;Background save already in progress&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (server.aof_child_pid != &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 判断是否在执行BGREWRIEAOF&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        addReplyError(c,&lt;span class=&quot;string&quot;&gt;&quot;Can&#39;t BGSAVE while AOF log rewriting is in progress&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 执行rdbSaveBackground 生成RDB文件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rdbSaveBackground(server.rdb_filename) == REDIS_OK) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        addReplyStatus(c,&lt;span class=&quot;string&quot;&gt;&quot;Background saving started&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        addReply(c,shared.err);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rdbSaveBackground&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *filename)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pid_t&lt;/span&gt; childpid;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; start;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果BGSAVE正在执行直接返回&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (server.rdb_child_pid != &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; REDIS_ERR;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 获取dirty数据 执行时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    server.dirty_before_bgsave = server.dirty;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    server.lastbgsave_try = time(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// fork() 开始前时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    start = ustime();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 调用fork，克隆该进程&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((childpid = fork()) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; retval;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* Child */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        closeListeningSockets(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        redisSetProcTitle(&lt;span class=&quot;string&quot;&gt;&quot;redis-rdb-bgsave&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 执行保存操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        retval = rdbSave(filename);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 打印 copy-on-write 时使用的内存数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (retval == REDIS_OK) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; private_dirty = zmalloc_get_private_dirty();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (private_dirty) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                redisLog(REDIS_NOTICE,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;string&quot;&gt;&quot;RDB: %zu MB of memory used by copy-on-write&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    private_dirty/(&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 向父进程发送信号&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        exitFromChild((retval == REDIS_OK) ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* Parent */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 计算 fork() 执行的时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        server.stat_fork_time = ustime()-start;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        server.stat_fork_rate = (&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;) zmalloc_used_memory() * &lt;span class=&quot;number&quot;&gt;1000000&lt;/span&gt; / server.stat_fork_time / (&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;/* GB per second. */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        latencyAddSampleIfNeeded(&lt;span class=&quot;string&quot;&gt;&quot;fork&quot;&lt;/span&gt;,server.stat_fork_time/&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 执行fork()错误信息&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (childpid == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            server.lastbgsave_status = REDIS_ERR;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            redisLog(REDIS_WARNING,&lt;span class=&quot;string&quot;&gt;&quot;Can&#39;t save in background: fork: %s&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                strerror(errno));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; REDIS_ERR;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        redisLog(REDIS_NOTICE,&lt;span class=&quot;string&quot;&gt;&quot;Background saving started by pid %d&quot;&lt;/span&gt;,childpid);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 记录数据库开始BGSAVE时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        server.rdb_save_time_start = time(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 子进程ID 类型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        server.rdb_child_pid = childpid;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        server.rdb_child_type = REDIS_RDB_CHILD_TYPE_DISK;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 关闭自动Rehash&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        updateDictResizePolicy();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; REDIS_OK;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; REDIS_OK; &lt;span class=&quot;comment&quot;&gt;/* unreached */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-服务器</title>
    <link href="http://www.coderyang.com//blog/2017/07/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93.html"/>
    <id>http://www.coderyang.com//blog/2017/07/redis源码阅读-数据库.html</id>
    <published>2017-07-10T08:21:21.000Z</published>
    <updated>2017-07-10T08:22:07.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>redis运行存在一个redis服务器结构，一个服务器中保存着n个数据库。</p>
<p>dbnum由服务器配置决定，默认值为16。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">    redisDb *db;  <span class="comment">// Redis的数据库</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">int</span> dbnum;  <span class="comment">// 表明数据库的数量</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb &#123;</div><div class="line">    dict *dict;                 <span class="comment">/* 数据库键字典 */</span></div><div class="line">    dict *expires;              <span class="comment">/* 键过期时间字典 */</span></div><div class="line">    dict *blocking_keys;        <span class="comment">/* 处于阻塞状态的键 */</span></div><div class="line">    dict *ready_keys;           <span class="comment">/* 可以解除阻塞的键 */</span></div><div class="line">    dict *watched_keys;         <span class="comment">/* 被watch的键 */</span></div><div class="line">    <span class="keyword">struct</span> evictionPoolEntry *eviction_pool;    <span class="comment">/* Eviction pool of keys */</span></div><div class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* 数据库编号 */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 数据库键的平均时间*/</span></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>每个redis客户端都有自己的目标数据库，当客户端执行数据库读写命令，目标数据库是这些命令的操作对象。</p>
<p>redis提供select命令来切换数据库，redisClient</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisClient &#123; </div><div class="line">    <span class="keyword">int</span> fd;  <span class="comment">// 套接字描述符</span></div><div class="line">    redisDb *db; <span class="comment">// 当前正在使用的数据库</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(redisClient *c, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 校验id</span></div><div class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= server.dbnum)</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 切换客户端数据库</span></div><div class="line">    c-&gt;db = &amp;server.db[id];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><p>Redis数据库存放的数据都是以键值对形式存在，redisDB结构的dict字典保存数据库中的所有键值对，这个字典被成为键空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb &#123;</div><div class="line">    dict *dict;                 <span class="comment">/* 数据库键字典 */</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>键空间的键就是数据库的键，每个键都是一个字符串对象。</p>
<p>键空间的值就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象、有序集合对象中任意一种。</p>
<h2 id="键空间的操作"><a href="#键空间的操作" class="headerlink" title="键空间的操作"></a>键空间的操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/* db.c -- Keyspace access API */</div><div class="line">int removeExpire(redisDb *db, robj *key);// 移除键的过期时间</div><div class="line">void propagateExpire(redisDb *db, robj *key); // </div><div class="line">int expireIfNeeded(redisDb *db, robj *key); // 检查是否过期，是则删除键</div><div class="line">long long getExpire(redisDb *db, robj *key); // 获取过期时间</div><div class="line">void setExpire(redisDb *db, robj *key, long long when); // 设定过期时间</div><div class="line">robj *lookupKey(redisDb *db, robj *key); // 从db中取出键key的值</div><div class="line">robj *lookupKeyRead(redisDb *db, robj *key); // 从db中取出键key的值</div><div class="line">robj *lookupKeyWrite(redisDb *db, robj *key); // 从db中取出键key的值</div><div class="line">robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply); // 从db中取出键key的值</div><div class="line">robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply);// 从db中取出键key的值</div><div class="line">void dbAdd(redisDb *db, robj *key, robj *val);// 尝试将键值对key\val添加到数据库中</div><div class="line">void dbOverwrite(redisDb *db, robj *key, robj *val); // 重写指定键的值,键不存在的话终止</div><div class="line">void setKey(redisDb *db, robj *key, robj *val);// 设定指定键的值，不管存不存在</div><div class="line">int dbExists(redisDb *db, robj *key); // 判断指定键是否存在  </div><div class="line">robj *dbRandomKey(redisDb *db); // 随机从数据库中取出一个键，并以字符串对象的方式返回这个键</div><div class="line">int dbDelete(redisDb *db, robj *key); // 从数据库中删除给定的键</div><div class="line">robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);</div><div class="line">long long emptyDb(void(callback)(void*));// 情况所有数据</div><div class="line">int selectDb(redisClient *c, int id); // 切换db</div><div class="line">void signalModifiedKey(redisDb *db, robj *key);</div><div class="line">void signalFlushedDb(int dbid);</div><div class="line">unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);</div><div class="line">unsigned int countKeysInSlot(unsigned int hashslot);</div><div class="line">unsigned int delKeysInSlot(unsigned int hashslot);</div><div class="line">int verifyClusterConfigWithData(void);</div><div class="line">void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor);</div><div class="line">int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="键空间的初始化"><a href="#键空间的初始化" class="headerlink" title="键空间的初始化"></a>键空间的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Db-&gt;dict, keys are sds strings, vals are Redis objects. */</span></div><div class="line"><span class="comment">// 键空间的类型</span></div><div class="line">dictType dbDictType = &#123;</div><div class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></div><div class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></div><div class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></div><div class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></div><div class="line">    dictSdsDestructor,          <span class="comment">/* key destructor */</span></div><div class="line">    dictRedisObjectDestructor   <span class="comment">/* val destructor */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 服务器初始化的同时初始化键空间</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">/* Create the Redis databases, and initialize other internal state. */</span></div><div class="line">    <span class="comment">// 创建并初始化数据库结构</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line">        server.db[j].dict = dictCreate(&amp;dbDictType,<span class="literal">NULL</span>);</div><div class="line">		<span class="comment">// ...</span></div><div class="line">        server.db[j].id = j;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>有五个和查找相关的接口，代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function">robj *<span class="title">lookupKeyWriteOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span> </span>&#123;</div><div class="line"></div><div class="line">    robj *o = lookupKeyWrite(c-&gt;db, key);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!o) addReply(c,reply);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="function">robj *<span class="title">lookupKeyReadOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 查找</span></div><div class="line">    robj *o = lookupKeyRead(c-&gt;db, key);</div><div class="line"></div><div class="line">    <span class="comment">// 发送信息</span></div><div class="line">    <span class="keyword">if</span> (!o) addReply(c,reply);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 删除过期键</span></div><div class="line">    expireIfNeeded(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 查找并返回对象</span></div><div class="line">    <span class="keyword">return</span> lookupKey(db,key);</div><div class="line">&#125;</div><div class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    robj *val;</div><div class="line"></div><div class="line">    <span class="comment">// 删除过期键</span></div><div class="line">    expireIfNeeded(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 查找对象</span></div><div class="line">    val = lookupKey(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 更新命中/不命中信息</span></div><div class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</div><div class="line">        server.stat_keyspace_misses++;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        server.stat_keyspace_hits++;</div><div class="line"></div><div class="line">    <span class="comment">// 返回值</span></div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">&#125;</div><div class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 查找</span></div><div class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (de) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 取出值</span></div><div class="line">        robj *val = dictGetVal(de);</div><div class="line"></div><div class="line">        <span class="comment">// 更新时间信息</span></div><div class="line">        <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</div><div class="line">            val-&gt;lru = LRU_CLOCK();</div><div class="line"></div><div class="line">        <span class="comment">// 返回值</span></div><div class="line">        <span class="keyword">return</span> val;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</div><div class="line">    sds copy = sdsdup(key-&gt;ptr); <span class="comment">// 复制键名</span></div><div class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val); <span class="comment">// 尝试添加</span></div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,retval == REDIS_OK); <span class="comment">// 已经存在则停止</span></div><div class="line">    <span class="keyword">if</span> (val-&gt;type == REDIS_LIST) signalListAsReady(db, key);</div><div class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(key);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="修改键"><a href="#修改键" class="headerlink" title="修改键"></a>修改键</h3><p>两种方式一种重写，一种设定不管存不存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 重写指定键的值,键不存在的话终止</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>;<span class="comment">// 设定指定键的值，不管存不存在</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</div><div class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr); <span class="comment">// 查找</span></div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,de != <span class="literal">NULL</span>); <span class="comment">// 不存在，终止</span></div><div class="line">    dictReplace(db-&gt;dict, key-&gt;ptr, val); <span class="comment">// 修改旧值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lookupKeyWrite(db,key) == <span class="literal">NULL</span>) &#123;</div><div class="line">        dbAdd(db,key,val); <span class="comment">// 找不到就添加</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dbOverwrite(db,key,val); <span class="comment">// 找到就重写</span></div><div class="line">    &#125;</div><div class="line">    incrRefCount(val); <span class="comment">// 增加引用计数</span></div><div class="line">    removeExpire(db,key); <span class="comment">// 移除过期时间</span></div><div class="line">    signalModifiedKey(db,key); <span class="comment">// 发送键修改通知</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></div><div class="line">     * the key, because it is shared with the main dictionary. */</div><div class="line">    <span class="comment">// 删除键的过期时间</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 删除键值对</span></div><div class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</div><div class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="键的生存时间或过期时间"><a href="#键的生存时间或过期时间" class="headerlink" title="键的生存时间或过期时间"></a>键的生存时间或过期时间</h2><p>与键空间类似redis建立了一个字典，存放每个键的对应的过期时间。在初始化的时候创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dictType keyptrDictType = &#123;</div><div class="line">    dictSdsHash,               <span class="comment">/* hash function */</span></div><div class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key dup */</span></div><div class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* val dup */</span></div><div class="line">    dictSdsKeyCompare,         <span class="comment">/* key compare */</span></div><div class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key destructor */</span></div><div class="line">    <span class="literal">NULL</span>                       <span class="comment">/* val destructor */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 创建并初始化数据库结构</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line">        server.db[j].expires = dictCreate(&amp;keyptrDictType,<span class="literal">NULL</span>);</div><div class="line">		<span class="comment">// ...</span></div><div class="line">        server.db[j].id = j;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="设定键的过期时间"><a href="#设定键的过期时间" class="headerlink" title="设定键的过期时间"></a>设定键的过期时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    dictEntry *kde, *de;</div><div class="line"></div><div class="line">    kde = dictFind(db-&gt;dict,key-&gt;ptr); <span class="comment">// 查找键</span></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,kde != <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">// 在过期时间字典中查找，没有则添加</span></div><div class="line">    de = dictReplaceRaw(db-&gt;expires,dictGetKey(kde));</div><div class="line">    dictSetSignedIntegerVal(de,when); <span class="comment">// 设置过期时间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取键的过期时间"><a href="#获取键的过期时间" class="headerlink" title="获取键的过期时间"></a>获取键的过期时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    dictEntry *de;</div><div class="line"></div><div class="line">    <span class="comment">//  如果不存在直接返回</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</div><div class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 返回过期时间</span></div><div class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除键的过期时间"><a href="#删除键的过期时间" class="headerlink" title="删除键的过期时间"></a>删除键的过期时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">     <span class="comment">// 确保键有过期时间</span></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">return</span> dictDelete(db-&gt;expires,key-&gt;ptr) == DICT_OK; <span class="comment">// 删除</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h3><p>三种策略：</p>
<ul>
<li>定时删除。定时删除占用cpu，可能使服务器长期无响应。但是对内存友好。</li>
<li>惰性删除，对键进行操作时，才删除。缺点是对内存不友好，过期键过多的话，没有及时清理。</li>
<li>定期删除。间隔依据算法确定。两者结合，主要看算法选择。</li>
</ul>
<p>redis采用定期和惰性两种删除方式。</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>redis在很多操作前都会调用expireIfNeeded进行惰性删除。例如lookupKeyRead。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</div><div class="line">    <span class="keyword">mstime_t</span> now;</div><div class="line"></div><div class="line">    <span class="comment">// 无过期时间</span></div><div class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></div><div class="line"></div><div class="line">    <span class="comment">// 正在加载不删除</span></div><div class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></div><div class="line">     * blocked to when the Lua script started. This way a key can expire</div><div class="line">     * only the first time it is accessed and not in the middle of the</div><div class="line">     * script execution, making propagation to slaves / AOF consistent.</div><div class="line">     * See issue #1525 on Github for more information. */</div><div class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</div><div class="line"></div><div class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></div><div class="line">     * the slave key expiration is controlled by the master that will</div><div class="line">     * send us synthesized DEL operations for expired keys.</div><div class="line">     *</div><div class="line">     * Still we try to return the right information to the caller,</div><div class="line">     * that is, 0 if we think the key should be still valid, 1 if</div><div class="line">     * we think the key is expired at this time. */</div><div class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</div><div class="line"></div><div class="line">    <span class="comment">// 没过期，返回0</span></div><div class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 删除</span></div><div class="line">    server.stat_expiredkeys++;</div><div class="line">    propagateExpire(db,key);</div><div class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</div><div class="line">    <span class="keyword">return</span> dbDelete(db,key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>redis服务器周期性操作serverCron函数执行时，activeExpireCycle被调用，它在规定时间内分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务器&quot;&gt;&lt;a href=&quot;#服务器&quot; class=&quot;headerlink&quot; title=&quot;服务器&quot;&gt;&lt;/a&gt;服务器&lt;/h2&gt;&lt;p&gt;redis运行存在一个redis服务器结构，一个服务器中保存着n个数据库。&lt;/p&gt;
&lt;p&gt;dbnum由服务器配置决定，默认值为16。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; redisServer &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    redisDb *db;  &lt;span class=&quot;comment&quot;&gt;// Redis的数据库&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; dbnum;  &lt;span class=&quot;comment&quot;&gt;// 表明数据库的数量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; redisDb &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dict *dict;                 &lt;span class=&quot;comment&quot;&gt;/* 数据库键字典 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dict *expires;              &lt;span class=&quot;comment&quot;&gt;/* 键过期时间字典 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dict *blocking_keys;        &lt;span class=&quot;comment&quot;&gt;/* 处于阻塞状态的键 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dict *ready_keys;           &lt;span class=&quot;comment&quot;&gt;/* 可以解除阻塞的键 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dict *watched_keys;         &lt;span class=&quot;comment&quot;&gt;/* 被watch的键 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; evictionPoolEntry *eviction_pool;    &lt;span class=&quot;comment&quot;&gt;/* Eviction pool of keys */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; id;                     &lt;span class=&quot;comment&quot;&gt;/* 数据库编号 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; avg_ttl;          &lt;span class=&quot;comment&quot;&gt;/* 数据库键的平均时间*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; redisDb;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;切换数据库&quot;&gt;&lt;a href=&quot;#切换数据库&quot; class=&quot;headerlink&quot; title=&quot;切换数据库&quot;&gt;&lt;/a&gt;切换数据库&lt;/h2&gt;&lt;p&gt;每个redis客户端都有自己的目标数据库，当客户端执行数据库读写命令，目标数据库是这些命令的操作对象。&lt;/p&gt;
&lt;p&gt;redis提供select命令来切换数据库，redisClient&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; redisClient &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd;  &lt;span class=&quot;comment&quot;&gt;// 套接字描述符&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    redisDb *db; &lt;span class=&quot;comment&quot;&gt;// 当前正在使用的数据库&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectDb&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(redisClient *c, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 校验id&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (id &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || id &amp;gt;= server.dbnum)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; REDIS_ERR;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 切换客户端数据库&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    c-&amp;gt;db = &amp;amp;server.db[id];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; REDIS_OK;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;数据库键空间&quot;&gt;&lt;a href=&quot;#数据库键空间&quot; class=&quot;headerlink&quot; title=&quot;数据库键空间&quot;&gt;&lt;/a&gt;数据库键空间&lt;/h2&gt;&lt;p&gt;Redis数据库存放的数据都是以键值对形式存在，redisDB结构的dict字典保存数据库中的所有键值对，这个字典被成为键空间。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; redisDb &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dict *dict;                 &lt;span class=&quot;comment&quot;&gt;/* 数据库键字典 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; redisDb;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;键空间的键就是数据库的键，每个键都是一个字符串对象。&lt;/p&gt;
&lt;p&gt;键空间的值就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象、有序集合对象中任意一种。&lt;/p&gt;
&lt;h2 id=&quot;键空间的操作&quot;&gt;&lt;a href=&quot;#键空间的操作&quot; class=&quot;headerlink&quot; title=&quot;键空间的操作&quot;&gt;&lt;/a&gt;键空间的操作&lt;/h2&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/* db.c -- Keyspace access API */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int removeExpire(redisDb *db, robj *key);// 移除键的过期时间&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void propagateExpire(redisDb *db, robj *key); // &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int expireIfNeeded(redisDb *db, robj *key); // 检查是否过期，是则删除键&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;long long getExpire(redisDb *db, robj *key); // 获取过期时间&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void setExpire(redisDb *db, robj *key, long long when); // 设定过期时间&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;robj *lookupKey(redisDb *db, robj *key); // 从db中取出键key的值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;robj *lookupKeyRead(redisDb *db, robj *key); // 从db中取出键key的值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;robj *lookupKeyWrite(redisDb *db, robj *key); // 从db中取出键key的值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply); // 从db中取出键key的值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply);// 从db中取出键key的值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void dbAdd(redisDb *db, robj *key, robj *val);// 尝试将键值对key\val添加到数据库中&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void dbOverwrite(redisDb *db, robj *key, robj *val); // 重写指定键的值,键不存在的话终止&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void setKey(redisDb *db, robj *key, robj *val);// 设定指定键的值，不管存不存在&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int dbExists(redisDb *db, robj *key); // 判断指定键是否存在  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;robj *dbRandomKey(redisDb *db); // 随机从数据库中取出一个键，并以字符串对象的方式返回这个键&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int dbDelete(redisDb *db, robj *key); // 从数据库中删除给定的键&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;long long emptyDb(void(callback)(void*));// 情况所有数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int selectDb(redisClient *c, int id); // 切换db&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void signalModifiedKey(redisDb *db, robj *key);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void signalFlushedDb(int dbid);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;unsigned int countKeysInSlot(unsigned int hashslot);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;unsigned int delKeysInSlot(unsigned int hashslot);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int verifyClusterConfigWithData(void);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-对象</title>
    <link href="http://www.coderyang.com//blog/2017/07/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1.html"/>
    <id>http://www.coderyang.com//blog/2017/07/redis源码阅读-对象.html</id>
    <published>2017-07-09T14:55:14.000Z</published>
    <updated>2017-07-10T04:14:50.813Z</updated>
    
    <content type="html"><![CDATA[<p>之前阅读了redis用到的主要的数据结构，这些数据结构是redis对象基础。redis在这些基础数据结构之上创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象五种类型的对象。</p>
<p>redis执行命令前，先判断命令是否能够执行给定命令。根据不同场合选择使用不同的数据结构。</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>redis使用对象来表示数据库中的键值，创建一个键值对时，会创建至少两个对象，一个对象用作键值对的键，一个对象用作键值对的值。</p>
<h3 id="对象的结构体"><a href="#对象的结构体" class="headerlink" title="对象的结构体"></a>对象的结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 编码</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></div><div class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 值</span></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>redis结构体使用位段结构节省空间</p>
<h4 id="类型type"><a href="#类型type" class="headerlink" title="类型type"></a>类型type</h4><p>记录redis对象类型，五种类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0 <span class="comment">// 字符串对象</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1 <span class="comment">// 列表对象</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2 <span class="comment">// 哈希对象</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3 <span class="comment">// 集合对象</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4 <span class="comment">// 有序集合对象</span></span></div></pre></td></tr></table></figure>
<h4 id="编码encoding"><a href="#编码encoding" class="headerlink" title="编码encoding"></a>编码encoding</h4><p>记录redis对象的编码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象编码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* 简单动态字符串 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* long类型的整数 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* 字典 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3  <span class="comment">/* zipmap 3.2.5不再使用 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* 双端队列 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* 压缩列表 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* 整数集合 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* 跳跃表 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8  <span class="comment">/* EMBSTR编码的简单字符串 */</span></span></div></pre></td></tr></table></figure>
<p>每种类型对应至少两种不同的编码。</p>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>编码方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW ,REDIS_ENCODING_INT ,REDIS_ENCODING_EMBSTR</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST ,REDIS_ENCODING_ZIPLIST</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET ,REDIS_ENCODING_HT</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_SKIPLIST</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_HT</td>
</tr>
</tbody>
</table>
<h4 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h4><p>表示对象的最后一次访问时间。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>常见的管理方式，引用计数为0时回收。</p>
<a id="more"></a>
<h2 id="对象的API"><a href="#对象的API" class="headerlink" title="对象的API"></a>对象的API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span></span>; <span class="comment">// 引用计数-1，降为0时释放对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCountVoid</span><span class="params">(<span class="keyword">void</span> *o)</span></span>; <span class="comment">// 用于特定数据结构的释放</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span></span>; <span class="comment">// 引用计数+1</span></div><div class="line"><span class="function">robj *<span class="title">resetRefCount</span><span class="params">(robj *obj)</span></span>; <span class="comment">// 设置引用计数为0</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放字符串对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放列表对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span></span>;  <span class="comment">// 释放集合对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放有序集合对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放hash对象</span></div><div class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 创建一个新robj对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建一个字符串对象，根据大小选择编码</span></div><div class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;<span class="comment">// 创建一个 REDIS_ENCODING_RAW 编码的字符对象</span></div><div class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;<span class="comment">// 创建一个 REDIS_ENCODING_EMBSTR 编码的字符对象</span></div><div class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 复制一个字符串对象</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isObjectRepresentableAsLongLong</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *llongval)</span></span>; <span class="comment">// 检查对象的值是否为Long long</span></div><div class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span></span>; <span class="comment">// 尝试对字符串对象编码，以节约内存</span></div><div class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 返回一个对象的编码版本</span></div><div class="line"><span class="keyword">size_t</span> stringObjectLen(robj *o); <span class="comment">// 返回字符串对象的字符串值的长度</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>; <span class="comment">// 根据传入的值，创建一个字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value, <span class="keyword">int</span> humanfriendly)</span></span>; <span class="comment">// 根据传入的值，创建一个字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个linkedlist编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个ziplist编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个ht编码的集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个intset编码的集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个ziplist编码的哈希对象</span></div><div class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个skiplist编码的有序集合</span></div><div class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个ziplist编码的有序集合</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// 尝试从对象中获取Long类型值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkType</span><span class="params">(redisClient *c, robj *o, <span class="keyword">int</span> type)</span></span>; <span class="comment">// 检查对象0的类型是否和type相同</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// 尝试从对象中取出整数值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// 尝试从对象中取出double值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target)</span></span>; <span class="comment">// 尝试从对象中获取整数值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongDoubleFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">double</span> *target)</span></span>; <span class="comment">// 尝试从对象获取long double值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongDoubleFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// 尝试从对象获取long double值</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strEncoding</span><span class="params">(<span class="keyword">int</span> encoding)</span></span>; <span class="comment">// 返回编码的字符串表示</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 二进制方式比较两个字符串对象</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">collateStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 以collation方式比较两个字符串对象</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">equalStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 判断是否相同两个字符串对象</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span></span>; <span class="comment">// 计算对象的闲置时间</span></div></pre></td></tr></table></figure>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>对象的创建都比较类似，一般创建底层数据结构，然后创建对象。然后初始化。</p>
<p>以string对象为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="comment">// 长度小于39时使用EMBSTR</span></div><div class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</div><div class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 创建一个embstr编码的字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="comment">// 直接分配一个连续空间长度为redis和字符串结构+字符串保存内存</span></div><div class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+len+<span class="number">1</span>);</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*)(o+<span class="number">1</span>); <span class="comment">// 找到字符串的起始位置</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化字符串</span></div><div class="line">    o-&gt;type = REDIS_STRING;</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_EMBSTR;</div><div class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</div><div class="line">    o-&gt;refcount = <span class="number">1</span>;</div><div class="line">    o-&gt;lru = LRU_CLOCK();</div><div class="line"></div><div class="line">    sh-&gt;len = len;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (ptr) &#123;</div><div class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</div><div class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个 REDIS_ENCODING_RAW 编码的字符对象</span></div><div class="line"><span class="comment">// 对象的指针指向一个 sds 结构</span></div><div class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">  	<span class="comment">// sdsnewlen新建字符串</span></div><div class="line">    <span class="keyword">return</span> createObject(REDIS_STRING,sdsnewlen(ptr,len));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个新对象</span></div><div class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"></div><div class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</div><div class="line"></div><div class="line">    o-&gt;type = type;</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_RAW;</div><div class="line">    o-&gt;ptr = ptr;</div><div class="line">    o-&gt;refcount = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution). */</span></div><div class="line">    o-&gt;lru = LRU_CLOCK();</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象的释放"><a href="#对象的释放" class="headerlink" title="对象的释放"></a>对象的释放</h3><p>以字符串对象为例子，redis采用引用计数进行对象的释放，当对象不再使用时调用decrRefCount减少引用计数，在引用计数减到0后，释放对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</div><div class="line">        <span class="comment">// 根据类型释放 各个函数会调用各自的释放函数释放</span></div><div class="line">        <span class="keyword">case</span> REDIS_STRING: freeStringObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_LIST: freeListObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_SET: freeSetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_HASH: freeHashObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>: redisPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        zfree(o); <span class="comment">// 释放对象内存</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        o-&gt;refcount--;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果时RAW编码调用sdsfree释放，否则在释放robj时就释放了，因为采用了embstr编码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</div><div class="line">        sdsfree(o-&gt;ptr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>字符串编码可以是Int、raw或者embstr。</p>
<p>字符串对象为整数值，可以用long long类型表示，则为int编码。</p>
<p>字符串对象为浮点数，能够用long double类型表示，使用embstr还是raw根据长度来定。</p>
<p>如果一个字符串对象小于等于REDIS_ENCODING_EMBSTR_SIZE_LIMIT则用embstr编码。</p>
<p>大于REDIS_ENCODING_EMBSTR_SIZE_LIMIT采用raw编码。</p>
<p>int编码在执行一个会将int转变为字符串值时，编码变为raw。</p>
<p>embstr为只读的，当尝试修改时会转换为raw。</p>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象编码是ziplist或者linkedlist。</p>
<p>满足以下两个条件使用ziplist：</p>
<ul>
<li>保存的字符串长度都小于64</li>
<li>元素数量小于512</li>
</ul>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象编码是ziplist或者hashtable。</p>
<p>如果采用的是ziplist那么添加键值时，先将键推入压缩列表表尾部，再将值推入压缩列表表尾。</p>
<p>如果采用hashtable编码，那么字典的键就是键值对的键的字符串对象，字典的值时键值对的值。</p>
<p>满足以下两个条件使用ziplist：</p>
<ul>
<li>保存的字符串长度都小于64</li>
<li>元素数量小于512</li>
</ul>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合的编码是inset或者hashtable</p>
<p>满足以下条件使用intset编码：</p>
<ul>
<li>集合对象保存的值都为整数</li>
<li>集合对象保存的元素不超过512个</li>
</ul>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合编码是ziplist或者skiplist。</p>
<p>skiplist编码使用一个zskiplist和dict作为底层实现。zskiplist按照分值从大到小保存集合元素。dict保存从成员到分值的映射。</p>
<p>满足以下条件使用ziplist编码：</p>
<ul>
<li>有序集合保存的元素小于128个。</li>
<li>有序集合保存的所有元素成员的长度都小于64字节。</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>对象的命令处理在redis.h中。<br>执行命令之前会检查对象的类型，是否能够执行该命令。<br>如果能就调用对象的命令处理函数,否则返回错误。</p>
<p>在调用了对象的命令处理函数之后，则根据命令具体的编码，去选择使用什么底层数据结构的接口来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* Commands prototypes */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">authCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pingCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">echoCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">psetexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">delCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">existsCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbitCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getbitCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrbyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyfloatCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomkeyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">keysCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbsizeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lastsaveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgsaveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgrewriteaofCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdownCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">renameCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">renamenxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linsertCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lindexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltrimCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">typeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sremCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sismemberCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scardCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">srandmemberCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sscanCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushdbCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushallCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lremCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpoplpushCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">infoCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mgetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireatCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pexpireCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pexpireatCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ttlCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pttlCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">persistCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slaveofCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">debugCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetnxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincrbyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebyscoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebyscoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebylexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebylexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcountCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlexcountCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcardCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyscoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebylexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">blpopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpoplpushCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">strlenCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrankCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrankCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetnxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmsetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmgetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdelCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hlenCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyrankCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zunionstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zinterstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscanCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hkeysCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hvalsCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetallCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexistsCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hscanCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">configCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hincrbyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hincrbyfloatCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">psubscribeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">punsubscribeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pubsubCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">migrateCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">askingCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readonlyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readwriteCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">evalCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">evalShaCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scriptCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitcountCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitposCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">replconfCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfselftestCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfaddCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfcountCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfmergeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfdebugCommand</span><span class="params">(redisClient *c)</span></span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前阅读了redis用到的主要的数据结构，这些数据结构是redis对象基础。redis在这些基础数据结构之上创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象五种类型的对象。&lt;/p&gt;
&lt;p&gt;redis执行命令前，先判断命令是否能够执行给定命令。根据不同场合选择使用不同的数据结构。&lt;/p&gt;
&lt;h2 id=&quot;对象的类型与编码&quot;&gt;&lt;a href=&quot;#对象的类型与编码&quot; class=&quot;headerlink&quot; title=&quot;对象的类型与编码&quot;&gt;&lt;/a&gt;对象的类型与编码&lt;/h2&gt;&lt;p&gt;redis使用对象来表示数据库中的键值，创建一个键值对时，会创建至少两个对象，一个对象用作键值对的键，一个对象用作键值对的值。&lt;/p&gt;
&lt;h3 id=&quot;对象的结构体&quot;&gt;&lt;a href=&quot;#对象的结构体&quot; class=&quot;headerlink&quot; title=&quot;对象的结构体&quot;&gt;&lt;/a&gt;对象的结构体&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; redisObject &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; type:&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 类型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; encoding:&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 编码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; lru:REDIS_LRU_BITS; &lt;span class=&quot;comment&quot;&gt;/* lru time (relative to server.lruclock) */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; refcount; &lt;span class=&quot;comment&quot;&gt;// 引用计数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *ptr; &lt;span class=&quot;comment&quot;&gt;// 值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; robj;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;redis结构体使用位段结构节省空间&lt;/p&gt;
&lt;h4 id=&quot;类型type&quot;&gt;&lt;a href=&quot;#类型type&quot; class=&quot;headerlink&quot; title=&quot;类型type&quot;&gt;&lt;/a&gt;类型type&lt;/h4&gt;&lt;p&gt;记录redis对象类型，五种类型&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_STRING 0 &lt;span class=&quot;comment&quot;&gt;// 字符串对象&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_LIST 1 &lt;span class=&quot;comment&quot;&gt;// 列表对象&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_SET 2 &lt;span class=&quot;comment&quot;&gt;// 哈希对象&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ZSET 3 &lt;span class=&quot;comment&quot;&gt;// 集合对象&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_HASH 4 &lt;span class=&quot;comment&quot;&gt;// 有序集合对象&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;编码encoding&quot;&gt;&lt;a href=&quot;#编码encoding&quot; class=&quot;headerlink&quot; title=&quot;编码encoding&quot;&gt;&lt;/a&gt;编码encoding&lt;/h4&gt;&lt;p&gt;记录redis对象的编码&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 对象编码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ENCODING_RAW 0     &lt;span class=&quot;comment&quot;&gt;/* 简单动态字符串 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ENCODING_INT 1     &lt;span class=&quot;comment&quot;&gt;/* long类型的整数 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ENCODING_HT 2      &lt;span class=&quot;comment&quot;&gt;/* 字典 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ENCODING_ZIPMAP 3  &lt;span class=&quot;comment&quot;&gt;/* zipmap 3.2.5不再使用 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ENCODING_LINKEDLIST 4 &lt;span class=&quot;comment&quot;&gt;/* 双端队列 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ENCODING_ZIPLIST 5 &lt;span class=&quot;comment&quot;&gt;/* 压缩列表 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ENCODING_INTSET 6  &lt;span class=&quot;comment&quot;&gt;/* 整数集合 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ENCODING_SKIPLIST 7  &lt;span class=&quot;comment&quot;&gt;/* 跳跃表 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; REDIS_ENCODING_EMBSTR 8  &lt;span class=&quot;comment&quot;&gt;/* EMBSTR编码的简单字符串 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每种类型对应至少两种不同的编码。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对象类型&lt;/th&gt;
&lt;th&gt;编码方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_RAW ,REDIS_ENCODING_INT ,REDIS_ENCODING_EMBSTR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_LIST&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_LINKEDLIST ,REDIS_ENCODING_ZIPLIST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_SET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_INTSET ,REDIS_ENCODING_HT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_ZSET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_SKIPLIST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_HASH&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_HT&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;访问时间&quot;&gt;&lt;a href=&quot;#访问时间&quot; class=&quot;headerlink&quot; title=&quot;访问时间&quot;&gt;&lt;/a&gt;访问时间&lt;/h4&gt;&lt;p&gt;表示对象的最后一次访问时间。&lt;/p&gt;
&lt;h4 id=&quot;引用计数&quot;&gt;&lt;a href=&quot;#引用计数&quot; class=&quot;headerlink&quot; title=&quot;引用计数&quot;&gt;&lt;/a&gt;引用计数&lt;/h4&gt;&lt;p&gt;常见的管理方式，引用计数为0时回收。&lt;/p&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-整数集合</title>
    <link href="http://www.coderyang.com//blog/2017/07/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88.html"/>
    <id>http://www.coderyang.com//blog/2017/07/redis源码阅读-整数集合.html</id>
    <published>2017-07-08T07:45:11.000Z</published>
    <updated>2017-07-08T07:46:00.710Z</updated>
    
    <content type="html"><![CDATA[<p>创建一个只包含整数值元素的集合，同时元素数量不多时，redis会使用整数集合作为键的底层实现。</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> intset &#123;</div><div class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 元素数量</span></div><div class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">// 保存元素的数组</span></div><div class="line">&#125; intset;</div></pre></td></tr></table></figure>
<p>encoding表示整数集合的编码模式，目前提供三种模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>整数集合有三种编码模式，为了能够节省空间，一般采用能够符合所有元素要求的编码。</p>
<p>当新添加元素比整数集合中现有元素类型都长，那么就需要进行升级，将编码位数提升，负荷新添加元素类型长度。</p>
<p>步骤：</p>
<ol>
<li><p>根据新元素的类型，扩展整数集合底层数组空间大小，并为新元素分配空间。</p>
</li>
<li><p>将底层数组现有的所有元素都转换为新元素相同的类型，并将类型转换后的元素放置到正确的位置上。</p>
</li>
<li><p>将新元素添加到数组中。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding); <span class="comment">// 当前编码</span></div><div class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value); <span class="comment">// 获取编码</span></div><div class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length); <span class="comment">// 元素数量</span></div><div class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 根据情况判断添加到数组的最前还是最后（要升级只有这种可能）</span></div><div class="line"></div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc); <span class="comment">// 更新编码方式</span></div><div class="line">    <span class="comment">// 重新分配空间</span></div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 从后往前重新编码</span></div><div class="line">    <span class="keyword">while</span>(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    <span class="comment">// 根据情况添加到尾部后者头部</span></div><div class="line">    <span class="keyword">if</span> (prepend)</div><div class="line">        _intsetSet(is,<span class="number">0</span>,value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配空间</span></div><div class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</div><div class="line">    <span class="comment">// 设置初始编码</span></div><div class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);</div><div class="line">    <span class="comment">// 初始化元素数量</span></div><div class="line">    is-&gt;length = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>判断数据大小，如果超出现有编码的范围，升级。</p>
<p>如果没有，则插入到指定位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value); <span class="comment">// 计算新插入值编码</span></div><div class="line">    <span class="keyword">uint32_t</span> pos;</div><div class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果需要则升级</span></div><div class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</div><div class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 查找，如果存在返回失败信息</span></div><div class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> is;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 重新分配空间</span></div><div class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">        <span class="comment">// 如果插入中间位置，则将该位置之后的值移动到尾部</span></div><div class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置值</span></div><div class="line">    _intsetSet(is,pos,value);</div><div class="line"></div><div class="line">    <span class="comment">// 计数器增加</span></div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="移除数据"><a href="#移除数据" class="headerlink" title="移除数据"></a>移除数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value); <span class="comment">// 计算编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> pos;</div><div class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 查找值，并删除</span></div><div class="line">    <span class="keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">        <span class="keyword">uint32_t</span> len = intrev32ifbe(is-&gt;length);</div><div class="line">        <span class="comment">// 删除成功标志</span></div><div class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</div><div class="line">        <span class="comment">// 删除数据</span></div><div class="line">        <span class="keyword">if</span> (pos &lt; (len<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</div><div class="line">        <span class="comment">// 调整内存大小</span></div><div class="line">        is = intsetResize(is,len<span class="number">-1</span>);</div><div class="line">        <span class="comment">// 更新length值</span></div><div class="line">        is-&gt;length = intrev32ifbe(len<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><ol>
<li>intsetFind 判断值是否在集合中</li>
<li>intsetRandom 随机返回整数集合中的一个数</li>
<li>intsetGet 取出底层数组在给定索引上的元素</li>
<li>intsetLen 返回整数集合中的元素个数</li>
<li>intsetloblen 返回整数集合占用的内存字节数</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建一个只包含整数值元素的集合，同时元素数量不多时，redis会使用整数集合作为键的底层实现。&lt;/p&gt;
&lt;h2 id=&quot;整数集合的实现&quot;&gt;&lt;a href=&quot;#整数集合的实现&quot; class=&quot;headerlink&quot; title=&quot;整数集合的实现&quot;&gt;&lt;/a&gt;整数集合的实现&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; intset &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; encoding; &lt;span class=&quot;comment&quot;&gt;// 编码方式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; length; &lt;span class=&quot;comment&quot;&gt;// 元素数量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int8_t&lt;/span&gt; contents[]; &lt;span class=&quot;comment&quot;&gt;// 保存元素的数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; intset;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;encoding表示整数集合的编码模式，目前提供三种模式&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; INTSET_ENC_INT16 (sizeof(int16_t))&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; INTSET_ENC_INT32 (sizeof(int32_t))&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; INTSET_ENC_INT64 (sizeof(int64_t))&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-跳跃表</title>
    <link href="http://www.coderyang.com//blog/2017/07/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8.html"/>
    <id>http://www.coderyang.com//blog/2017/07/redis源码阅读-跳跃表.html</id>
    <published>2017-07-08T06:29:58.000Z</published>
    <updated>2017-07-08T06:31:07.373Z</updated>
    
    <content type="html"><![CDATA[<p>跳跃表一种有序数据结构，每个节点维护多个指向其他节点的指针，达到快速访问节点的目的。</p>
<p>大部分情况下跳跃表的效率可以和平衡数媲美，实现比平衡树简单，不少程序使用跳跃表来代替平衡树。</p>
<p>跳跃表有时会作为有序集合的实现。以分值排序。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳跃表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</div><div class="line">    robj *obj; <span class="comment">// 保存的对象</span></div><div class="line">    <span class="keyword">double</span> score; <span class="comment">// 分值 跳跃表按照分值进行排序</span></div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward; <span class="comment">// 上一节点</span></div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;</div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward; <span class="comment">// 前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span; <span class="comment">// 跨度 记录两个节点之间的距离</span></div><div class="line">    &#125; level[]; <span class="comment">// 层</span></div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line"><span class="comment">// 跳跃表</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail; <span class="comment">// 头、尾指针</span></div><div class="line">    PORT_ULONG length; <span class="comment">// 跳跃表长度</span></div><div class="line">    <span class="keyword">int</span> level; <span class="comment">// 层数最大节点层数</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<h2 id="跳跃表的创建"><a href="#跳跃表的创建" class="headerlink" title="跳跃表的创建"></a>跳跃表的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建节点</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// 申请内存</span></div><div class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zskiplistLevel));</div><div class="line">    zn-&gt;score = score; <span class="comment">// 赋值分数</span></div><div class="line">    zn-&gt;obj = obj; <span class="comment">// 设定成员对象</span></div><div class="line">    <span class="keyword">return</span> zn;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建跳跃表</span></div><div class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    <span class="comment">// 申请内存</span></div><div class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</div><div class="line">    zsl-&gt;level = <span class="number">1</span>; <span class="comment">// 设置层数初始为1</span></div><div class="line">    zsl-&gt;length = <span class="number">0</span>; <span class="comment">// 设置长度初始为0</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建头节点 层数为32 分数为0</span></div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 将每层的forward指针指向null，跨度0</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</div><div class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设定backward指向null</span></div><div class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</div><div class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>逻辑是先找到节点插入位置，插入位置前一个节点的信息。<br>插入，并更新前一节点信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个成员为obj，分值为score的新节点</span></div><div class="line"><span class="comment">// 将新节点插入到跳跃表中</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// updata[]数组记录每一层位于插入节点的前一个节点</span></div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="comment">// rank[]记录每一层位于插入节点的前一个节点的排名</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    <span class="keyword">int</span> i, level;</div><div class="line"></div><div class="line">    redisAssert(!isnan(score));</div><div class="line">    x = zsl-&gt;header; <span class="comment">// 表头节点</span></div><div class="line">    <span class="comment">// 从最高层开始查找</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">// i == (zsl-&gt;level-1) 为0</span></div><div class="line">        <span class="comment">//否则第i层起始rank值为i+1的rank值</span></div><div class="line">        <span class="comment">// 最终rank[0]的值+1就是新节点的前置节点排位</span></div><div class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</div><div class="line">        <span class="comment">// 沿着前几指针遍历跳跃表</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            <span class="comment">// 比对分值</span></div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                <span class="comment">// 比对成员</span></div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 记录沿途跨越多少节点</span></div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            <span class="comment">// 移动到下一个指针</span></div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 记录将要和新节点相连接的节点</span></div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">       *</div><div class="line">    <span class="comment">// zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</span></div><div class="line">    <span class="comment">// 所以这里不需要进一步进行检查，可以直接创建新元素。</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取一个随机值作为新节点的层数</span></div><div class="line">    level = zslRandomLevel();</div><div class="line"></div><div class="line">    <span class="comment">// 如果新节点的层数比其他节点层数大</span></div><div class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</div><div class="line">        <span class="comment">// 初始化未使用层</span></div><div class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = <span class="number">0</span>;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 创建新节点</span></div><div class="line">    x = zslCreateNode(level,score,obj);</div><div class="line"></div><div class="line">    <span class="comment">// 将前面记录的指针指向新节点，并做相应的设置</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 设置新节点的前进指针</span></div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        update[i]-&gt;level[i].forward = x; <span class="comment">// 将沿途记录的各个节点的前进指针指向新节点</span></div><div class="line"></div><div class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></div><div class="line">        <span class="comment">// 计算新节点跨越的节点数量</span></div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</div><div class="line">        <span class="comment">// 更新新节点插入后，沿途节点的span值</span></div><div class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* increment span for untouched levels */</span></div><div class="line">    <span class="comment">// 未接触的节点的span值也需要增加1，这些节点从表头指向新节点</span></div><div class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置新节点的后退指针</span></div><div class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        zsl-&gt;tail = x;</div><div class="line"></div><div class="line">    <span class="comment">// 长度+1</span></div><div class="line">    zsl-&gt;length++;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>Redis提供三种删除跳跃表节点的方式：</p>
<ol>
<li><p>根据给定分值和成员来删除节点，zslDelete。</p>
</li>
<li><p>根据给定分值来删除节点，zslDeleteByScore。</p>
</li>
<li><p>根据给定排名来删除节点，zslDeleteByRank。</p>
</li>
</ol>
<p>删除操作均由zslDeleteNode执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 更新所有和被删除节点x有关的节点指针，解除它们之间的关系</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新被删除节点x的前进后退指针</span></div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新跳跃表的最大层数</span></div><div class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</div><div class="line">        zsl-&gt;level--;</div><div class="line"></div><div class="line">    <span class="comment">// 计数器-1</span></div><div class="line">    zsl-&gt;length--;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据节点的分值和成员删除节点,其余两种情况只是查找方法与判断方式不同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历跳跃表，查找目标节点，并记录所有沿途及节点</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 分值和对象相同时，将其删除</span></div><div class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</div><div class="line">        zslDeleteNode(zsl, x, update);</div><div class="line">        zslFreeNode(x);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查找给定分值和成员对象的节点在跳跃表中的排位"><a href="#查找给定分值和成员对象的节点在跳跃表中的排位" class="headerlink" title="查找给定分值和成员对象的节点在跳跃表中的排位"></a>查找给定分值和成员对象的节点在跳跃表中的排位</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历整个跳跃表</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历节点并对比元素</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                <span class="comment">// 比对分值</span></div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                <span class="comment">// 比对成员对象</span></div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 累积跨越的节点数量</span></div><div class="line">            rank += x-&gt;level[i].span;</div><div class="line"></div><div class="line">            <span class="comment">// 沿着前进指针遍历跳跃表</span></div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 必须确保不仅分值相等，而且成员对象也要相等</span></div><div class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</div><div class="line">            <span class="keyword">return</span> rank;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 没找到</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跳跃表一种有序数据结构，每个节点维护多个指向其他节点的指针，达到快速访问节点的目的。&lt;/p&gt;
&lt;p&gt;大部分情况下跳跃表的效率可以和平衡数媲美，实现比平衡树简单，不少程序使用跳跃表来代替平衡树。&lt;/p&gt;
&lt;p&gt;跳跃表有时会作为有序集合的实现。以分值排序。&lt;/p&gt;
&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 跳跃表节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistNode &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    robj *obj; &lt;span class=&quot;comment&quot;&gt;// 保存的对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; score; &lt;span class=&quot;comment&quot;&gt;// 分值 跳跃表按照分值进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistNode *backward; &lt;span class=&quot;comment&quot;&gt;// 上一节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistLevel &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistNode *forward; &lt;span class=&quot;comment&quot;&gt;// 前进指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; span; &lt;span class=&quot;comment&quot;&gt;// 跨度 记录两个节点之间的距离&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; level[]; &lt;span class=&quot;comment&quot;&gt;// 层&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; zskiplistNode;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 跳跃表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplist &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistNode *header, *tail; &lt;span class=&quot;comment&quot;&gt;// 头、尾指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    PORT_ULONG length; &lt;span class=&quot;comment&quot;&gt;// 跳跃表长度&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; level; &lt;span class=&quot;comment&quot;&gt;// 层数最大节点层数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; zskiplist;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;跳跃表的创建&quot;&gt;&lt;a href=&quot;#跳跃表的创建&quot; class=&quot;headerlink&quot; title=&quot;跳跃表的创建&quot;&gt;&lt;/a&gt;跳跃表的创建&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;zskiplistNode *&lt;span class=&quot;title&quot;&gt;zslCreateNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; level, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; score, robj *obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 申请内存&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zskiplistNode *zn = zmalloc(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(*zn)+level*&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; zskiplistLevel));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zn-&amp;gt;score = score; &lt;span class=&quot;comment&quot;&gt;// 赋值分数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zn-&amp;gt;obj = obj; &lt;span class=&quot;comment&quot;&gt;// 设定成员对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; zn;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建跳跃表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;zskiplist *&lt;span class=&quot;title&quot;&gt;zslCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zskiplist *zsl;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 申请内存&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl = zmalloc(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(*zsl));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;level = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 设置层数初始为1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;length = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 设置长度初始为0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建头节点 层数为32 分数为0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将每层的forward指针指向null，跨度0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; ZSKIPLIST_MAXLEVEL; j++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        zsl-&amp;gt;header-&amp;gt;level[j].forward = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        zsl-&amp;gt;header-&amp;gt;level[j].span = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设定backward指向null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;header-&amp;gt;backward = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    zsl-&amp;gt;tail = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; zsl;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-字典</title>
    <link href="http://www.coderyang.com//blog/2017/06/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8.html"/>
    <id>http://www.coderyang.com//blog/2017/06/redis源码阅读-字典.html</id>
    <published>2017-06-30T07:09:34.000Z</published>
    <updated>2017-07-08T04:30:39.031Z</updated>
    
    <content type="html"><![CDATA[<p>Redis字典由哈希表实现的保存键值对的抽象数据结构。</p>
<p>实现文件在dict.h\dict.c中。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>Redis字典结构体定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</div><div class="line">    <span class="keyword">void</span> *key;<span class="comment">// key 键</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">        <span class="keyword">double</span> d;</div><div class="line">    &#125; v;<span class="comment">// 值，支持多种类型,使用联合。</span></div><div class="line">    <span class="keyword">struct</span> dictEntry *next;<span class="comment">// 下一个点 采用链式来解决索引冲突问题</span></div><div class="line">&#125; dictEntry;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictType &#123;</div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;<span class="comment">// hash函数</span></div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">// key复制函数</span></div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);<span class="comment">// value复制函数</span></div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);<span class="comment">// key比较函数</span></div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);<span class="comment">// key释放函数</span></div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);<span class="comment">// value释放函数</span></div><div class="line">&#125; dictType;</div><div class="line"></div><div class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></div><div class="line"> * implement incremental rehashing, for the old to the new table. */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</div><div class="line">    dictEntry **table;<span class="comment">// 指针的数组头的指针</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;<span class="comment">// 大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">// 大小的掩码 总是等于size-1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;<span class="comment">// 被使用的节点数</span></div><div class="line">&#125; dictht;<span class="comment">// hash表</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</div><div class="line">    dictType *type;<span class="comment">// 绑定的函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;<span class="comment">// 私有数据</span></div><div class="line">    dictht ht[<span class="number">2</span>];<span class="comment">// hash表，一般只使用[0]，在rehash的时候使用[1]</span></div><div class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">// 记录rehash的进度，不进行rehash的时候为-1</span></div><div class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></div><div class="line">&#125; dict;<span class="comment">// 字典</span></div><div class="line"></div><div class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></div><div class="line"> * dictAdd, dictFind, and other functions against the dictionary even while</div><div class="line"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</div><div class="line"> * should be called while iterating. */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictIterator &#123;</div><div class="line">    dict *d;</div><div class="line">    <span class="keyword">long</span> index;</div><div class="line">    <span class="keyword">int</span> table, safe;</div><div class="line">    dictEntry *entry, *nextEntry;</div><div class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</div><div class="line">&#125; dictIterator;<span class="comment">// 迭代器</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>确认一个键值插入到字典的位置是哪，需要调用hash算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算key的hash值</span></div><div class="line">hash = dict-&gt;type-&gt;hashFunction(key);</div><div class="line"><span class="comment">//按位与确认在hash表中的位置</span></div><div class="line"><span class="comment">//根据情况，可能是ht[0]或者ht[1]</span></div><div class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</div></pre></td></tr></table></figure>
<p>字典在redis中使用MurmurHash2算法进行计算键的哈希值。有点在于计算速度非常快，即使输入的键有规律也能够很好的给出一个随机分布。</p>
<h2 id="键的冲突解决"><a href="#键的冲突解决" class="headerlink" title="键的冲突解决"></a>键的冲突解决</h2><p>在key获取的index相同的情况下，产生了键的冲突。redis采用链式解决冲突，新的键值放在链的头部。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着hash表不断插入删除数据，hash表的负载因子会不断变化。当负载因子在一个不合理的范围内，则redis的会对hash表进行rehash。</p>
<h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><p>渐进式rehash的目的是为了防止一次性rehash的情况下，服务器停止响应。</p>
<p>redis渐进式rehash的步骤:</p>
<p>1）为ht[1]分配空间，让字典同时持有 ht[0]和ht[1]两个哈希表</p>
<p>2）在字典位置一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</p>
<p>3）在rehash进行期间，每次对字典执行删除、添加、查找或者更新操作时候，程序除了执行指定的操作外，还顺便将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后将rehashidx属性的值增加1</p>
<p>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehsh至ht[1]，这时程序将rehashidx属性值设为-1，表示rehash操作已完成。</p>
<p>渐进式rehash过程中，字典会同时对ht[0]和ht[1]两个哈希表进行操作，字典在删除、查找、更新等操作会在两个哈希表进行。</p>
<p>在渐进式rehash执行期间，新添加到字典的键值对一律会被保存在ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减少不增加，并随着rehash操作的执行最终变为空。</p>
<p>rehash有两种方式，一种是单步，在字典没有安全迭代器的情况下能够执行。一种是执行一段时间跳出。两种方法均调用int dictRehash(dict *d, int n) 完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</div><div class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</div><div class="line">    <span class="comment">// 开始时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</div><div class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</div><div class="line">        rehashes += <span class="number">100</span>;</div><div class="line">        <span class="comment">// 时间到达，跳出</span></div><div class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rehashes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>int dictRehash(dict *d, int n) 算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//执行N步渐进式rehash操作，rehash之后如果旧表还存在数据，则返回1，不存在返回0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">// 最大允许访问的空桶值</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 判断是否允许rehash</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        <span class="comment">// rehashidx不能大于哈希表的大小</span></div><div class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</div><div class="line">        <span class="comment">// 跳过空节点</span></div><div class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            <span class="comment">// 超过空节点最大值，直接跳出</span></div><div class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取需要rehash的节点</span></div><div class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</div><div class="line">        <span class="comment">// 将该桶下所有节点移动到新表</span></div><div class="line">        <span class="keyword">while</span>(de) &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            <span class="comment">// 获取新表中hash索引</span></div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div><div class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</div><div class="line">            d-&gt;ht[<span class="number">0</span>].used--;</div><div class="line">            d-&gt;ht[<span class="number">1</span>].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否都迁移完成，完成返回0</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 释放旧表,将rehashidx设置为-1</span></div><div class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</div><div class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</div><div class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 未完成返回1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="dict部分API"><a href="#dict部分API" class="headerlink" title="dict部分API"></a>dict部分API</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dict *dictCreate(dictType *type, void *privDataPtr); // 创建一个新字典</div><div class="line">int dictExpand(dict *d, unsigned long size); // 在字典中创建一个新hash表</div><div class="line">int dictAdd(dict *d, void *key, void *val); // 尝试将给定键值添加到字典中</div><div class="line">dictEntry *dictAddRaw(dict *d, void *key); // 尝试将给定键插入到字典中，键已经存在则返回null</div><div class="line">int dictReplace(dict *d, void *key, void *val); // 将给定键值添加到字典中，如果已经存在就替换</div><div class="line">dictEntry *dictReplaceRaw(dict *d, void *key); // 将给定键值添加到字典中，如果已经存在则不添加，返回已经存在的值</div><div class="line">int dictDelete(dict *d, const void *key); // 删除字典中给定键的节点</div><div class="line">int dictDeleteNoFree(dict *d, const void *key);// 删除包含给定键的及诶单，但是不释放</div><div class="line">void dictRelease(dict *d); // 删除并释放整个字典</div><div class="line">dictEntry * dictFind(dict *d, const void *key); // 查找节点</div><div class="line">void *dictFetchValue(dict *d, const void *key); // 获取包含给定键的节点值</div><div class="line">int dictResize(dict *d); // 缩小字典，使得已用节点和字典大小比率接近1:1</div><div class="line">dictIterator *dictGetIterator(dict *d); // 创建并返回给定字典的不安全迭代器</div><div class="line">dictIterator *dictGetSafeIterator(dict *d); // 创建并返回给定节点的安全迭代器</div><div class="line">dictEntry *dictNext(dictIterator *iter); // 返回当前节点，指向下个节点</div><div class="line">void dictReleaseIterator(dictIterator *iter); // 释放迭代器</div><div class="line">dictEntry *dictGetRandomKey(dict *d); // 随机返回字典中一个节点</div><div class="line">void dictEmpty(dict *d, void(callback)(void*)); // 清空字典中所有哈希表节点，并重置属性</div><div class="line">void dictEnableResize(void); // 开启自动rehash</div><div class="line">void dictDisableResize(void); // 关闭自动rehash</div></pre></td></tr></table></figure>
<h3 id="创建dict"><a href="#创建dict" class="headerlink" title="创建dict"></a>创建dict</h3><p>使用dictCreate创建字典。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建字典</span></div><div class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type,</span></span></div><div class="line">        <span class="keyword">void</span> *privDataPtr)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 分配空间</span></div><div class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</div><div class="line"></div><div class="line">    <span class="comment">// 初始化字典</span></div><div class="line">    _dictInit(d,type,privDataPtr);</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</div><div class="line">&#123;</div><div class="line">    ht-&gt;table = <span class="literal">NULL</span>;</div><div class="line">    ht-&gt;size = <span class="number">0</span>;</div><div class="line">    ht-&gt;sizemask = <span class="number">0</span>;</div><div class="line">    ht-&gt;used = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化字典</span></div><div class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</div><div class="line">        <span class="keyword">void</span> *privDataPtr)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 重置hash表</span></div><div class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</div><div class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">    d-&gt;type = type; <span class="comment">// 设置字典类型</span></div><div class="line">    d-&gt;privdata = privDataPtr;</div><div class="line">    d-&gt;rehashidx = <span class="number">-1</span>; <span class="comment">// 初始为-1，表明没有进行rehash</span></div><div class="line">    d-&gt;iterators = <span class="number">0</span>; <span class="comment">//正在使用的迭代器数量</span></div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h3><p>使用int dictAdd(dict <em>d, void </em>key, void *val)添加键值对</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加一个键值对到dict中</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 往字典中添加一个只有key的键值对</span></div><div class="line">    dictEntry *entry = dictAddRaw(d,key);</div><div class="line"></div><div class="line">    <span class="comment">// 添加失败，则返回错误</span></div><div class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</div><div class="line">    <span class="comment">//使用宏，添加成功则设置key键值对的值</span></div><div class="line">    dictSetVal(d, entry, val);</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 添加键到字典中</span></div><div class="line"> <span class="comment">// 键存在则返回null</span></div><div class="line"> <span class="comment">// 不存在则创建节点，与键关联，并返回节点</span></div><div class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    dictEntry *entry;</div><div class="line">    dictht *ht;</div><div class="line"></div><div class="line">    <span class="comment">// 尝试进行单步式rehash</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    <span class="comment">// 尝试获取hash表中的索引值，返回-1表示键已经存在</span></div><div class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// rehash使用1号哈希表，不在rehash使用0号</span></div><div class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 分配空间，将节点添加到链表表头</span></div><div class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</div><div class="line">    entry-&gt;next = ht-&gt;table[index];</div><div class="line">    ht-&gt;table[index] = entry;</div><div class="line">    ht-&gt;used++;</div><div class="line"></div><div class="line">    <span class="comment">// 使用宏，设置新节点的键</span></div><div class="line">    dictSetKey(d, entry, key);</div><div class="line">    <span class="keyword">return</span> entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="替换键值对"><a href="#替换键值对" class="headerlink" title="替换键值对"></a>替换键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 如果键值不存在，返回1</span></div><div class="line"> <span class="comment">//存在，更新键值，返回0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></div><div class="line">&#123;</div><div class="line">    dictEntry *entry, auxentry;</div><div class="line"></div><div class="line">    <span class="comment">// 添加成功返回1</span></div><div class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 查找键</span></div><div class="line">    entry = dictFind(d, key);</div><div class="line">    </div><div class="line">    <span class="comment">// 更新键值</span></div><div class="line">    auxentry = *entry;</div><div class="line">    dictSetVal(d, entry, val);</div><div class="line"></div><div class="line">    <span class="comment">// 释放原值</span></div><div class="line">    dictFreeVal(d, &amp;auxentry);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找键值对"><a href="#查找键值对" class="headerlink" title="查找键值对"></a>查找键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></div><div class="line">&#123;</div><div class="line">    dictEntry *he;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</div><div class="line"></div><div class="line">    <span class="comment">// hash表大小为0，表名无值</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* We don't have a table at all */</span></div><div class="line">    <span class="comment">// 如果在rehash，则单步rehash</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    <span class="comment">// 查找索引</span></div><div class="line">    h = dictHashKey(d, key);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历索引下的键</span></div><div class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                <span class="keyword">return</span> he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果没有进行rehash，则不再查找ht[1]</span></div><div class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 删除该键值对，并释放键和值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除该键值对，不释放键和值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 查找并删除对应的键值对</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx;</div><div class="line">    dictEntry *he, *prevHe;</div><div class="line">    <span class="keyword">int</span> table;</div><div class="line"></div><div class="line">    <span class="comment">// 空则直接返回错误信息</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR; <span class="comment">/* d-&gt;ht[0].table is NULL */</span></div><div class="line"></div><div class="line">    <span class="comment">// rehash时，进行一次rehash</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line">    h = dictHashKey(d, key); <span class="comment">// 获取hash索引</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        prevHe = <span class="literal">NULL</span>;</div><div class="line">        <span class="comment">// 查找，遍历整个链表</span></div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key)) &#123;</div><div class="line">                <span class="comment">/* Unlink the element from the list */</span></div><div class="line">                <span class="keyword">if</span> (prevHe)</div><div class="line">                    prevHe-&gt;next = he-&gt;next;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</div><div class="line">                <span class="keyword">if</span> (!nofree) &#123;</div><div class="line">                    <span class="comment">// 根据传入参数是否释放键值</span></div><div class="line">                    dictFreeKey(d, he);</div><div class="line">                    dictFreeVal(d, he);</div><div class="line">                &#125;</div><div class="line">                zfree(he);</div><div class="line">                d-&gt;ht[table].used--;</div><div class="line">                <span class="keyword">return</span> DICT_OK;</div><div class="line">            &#125;</div><div class="line">            prevHe = he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没有进行rehash则不查找ht[1]</span></div><div class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字典删除"><a href="#字典删除" class="headerlink" title="字典删除"></a>字典删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清理释放整个字典</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 释放ht[0]</span></div><div class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>],<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 释放ht[1]</span></div><div class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>],<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 释放字典</span></div><div class="line">    zfree(d);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _dictClear(dict *d, dictht *ht, <span class="keyword">void</span>(callback)(<span class="keyword">void</span> *)) &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 释放所有元素</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; <span class="number">0</span>; i++) &#123;</div><div class="line">        dictEntry *he, *nextHe;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (callback &amp;&amp; (i &amp; <span class="number">65535</span>) == <span class="number">0</span>) callback(d-&gt;privdata);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((he = ht-&gt;table[i]) == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            nextHe = he-&gt;next;</div><div class="line">            <span class="comment">// 释放键值对</span></div><div class="line">            dictFreeKey(d, he);</div><div class="line">            dictFreeVal(d, he);</div><div class="line">            zfree(he);</div><div class="line">            ht-&gt;used--;</div><div class="line">            he = nextHe;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 释放hash表</span></div><div class="line">    zfree(ht-&gt;table);</div><div class="line">    </div><div class="line">    <span class="comment">// 重置hsh表</span></div><div class="line">    _dictReset(ht);</div><div class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">/* never fails */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis字典由哈希表实现的保存键值对的抽象数据结构。&lt;/p&gt;
&lt;p&gt;实现文件在dict.h\dict.c中。&lt;/p&gt;
&lt;h2 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h2&gt;&lt;p&gt;Redis字典结构体定义。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictEntry &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key;&lt;span class=&quot;comment&quot;&gt;// key 键&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *val;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;uint64_t&lt;/span&gt; u64;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int64_t&lt;/span&gt; s64;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; d;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; v;&lt;span class=&quot;comment&quot;&gt;// 值，支持多种类型,使用联合。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictEntry *next;&lt;span class=&quot;comment&quot;&gt;// 下一个点 采用链式来解决索引冲突问题&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictEntry;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictType &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(*hashFunction)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// hash函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*keyDup)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key);&lt;span class=&quot;comment&quot;&gt;// key复制函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*valDup)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *obj);&lt;span class=&quot;comment&quot;&gt;// value复制函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (*keyCompare)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key1, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key2);&lt;span class=&quot;comment&quot;&gt;// key比较函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*keyDestructor)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key);&lt;span class=&quot;comment&quot;&gt;// key释放函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*valDestructor)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *obj);&lt;span class=&quot;comment&quot;&gt;// value释放函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictType;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* This is our hash table structure. Every dictionary has two of this as we&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * implement incremental rehashing, for the old to the new table. */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictht &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictEntry **table;&lt;span class=&quot;comment&quot;&gt;// 指针的数组头的指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size;&lt;span class=&quot;comment&quot;&gt;// 大小&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; sizemask;&lt;span class=&quot;comment&quot;&gt;// 大小的掩码 总是等于size-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; used;&lt;span class=&quot;comment&quot;&gt;// 被使用的节点数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictht;&lt;span class=&quot;comment&quot;&gt;// hash表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dict &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictType *type;&lt;span class=&quot;comment&quot;&gt;// 绑定的函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *privdata;&lt;span class=&quot;comment&quot;&gt;// 私有数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictht ht[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;// hash表，一般只使用[0]，在rehash的时候使用[1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; rehashidx; &lt;span class=&quot;comment&quot;&gt;// 记录rehash的进度，不进行rehash的时候为-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; iterators; &lt;span class=&quot;comment&quot;&gt;/* number of iterators currently running */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dict;&lt;span class=&quot;comment&quot;&gt;// 字典&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* If safe is set to 1 this is a safe iterator, that means, you can call&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * dictAdd, dictFind, and other functions against the dictionary even while&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * iterating. Otherwise it is a non safe iterator, and only dictNext()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * should be called while iterating. */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dictIterator &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dict *d;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; index;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; table, safe;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictEntry *entry, *nextEntry;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* unsafe iterator fingerprint for misuse detection. */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; fingerprint;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictIterator;&lt;span class=&quot;comment&quot;&gt;// 迭代器&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书摘录-编程大师访谈录</title>
    <link href="http://www.coderyang.com//blog/2017/05/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95.html"/>
    <id>http://www.coderyang.com//blog/2017/05/读书摘录-编程大师访谈录.html</id>
    <published>2017-05-04T00:48:08.000Z</published>
    <updated>2017-05-04T00:49:55.025Z</updated>
    
    <content type="html"><![CDATA[<p>【美】Susan Lammers</p>
<p>第1篇　查尔斯•西蒙尼<br>2017-04-30<br>采访者：编程是一种技巧或技能吗？ 西蒙尼：什么是编程？人们对此一直各持己见。有人说它是科学，有人说它是艺术，还有人称之为技能或手艺。我认为这三方面兼而有之。我们喜欢说它蕴含大量艺术成分，但是我们都知道它里面更多的是科学。 孩子们在学校里学习数学，高中毕业时，他们会以为数学就是加法和乘法，甚或代数和微积分。其实，算术，即使简单如加法的运算，背后也有令人难以置信的科学理论作支持。 计算机编程背后也有大量科学理论作支持。例如，哥德尔定理的数学证明冗长而复杂，但是如果借用计算机科学的图灵定理，证明起来不费吹灰之力。信息理论和计算机科学其他领域对数学影响巨大，反之亦然。 编程包含有大量科学，同时，它也有点像手艺。实际上，在许多人看来，编程是一项复杂的技能，这跟工具制造很像，需要精雕细琢。我认为，只要将科学、艺术和技能这三者拿捏得恰到好处，你就能取得一些引人瞩目的成绩。<br>2017-04-30<br>别人读几段你的源代码，有没有可能断定“这代码是查尔斯·西蒙尼写的”？ 西蒙尼：噢，是的，毫无疑问。是不是我本人写的可能很难分辨，但有一点是确定无疑的：只要看了代码，你就能知道它是不是我的团队写的，或者是不是受我的影响写的。这是因为我从1972年起写的代码都遵循特定的命名规范，许多人称之为“匈牙利命名法”。你一眼就能分辨出哪些代码是受我的影响写出来的，包括Microsoft Word、Multiplan和Bravo，以及其他许多遵循这些规范写成的程序。<br>註: 原来是他<br>2017-04-30<br>进入公司第一天，程序员就会拿到几本书。其中一本是数学家乔治·波利亚写的《怎样解题》。（西蒙尼边说边从他办公桌旁的书柜里取出那本书，翻到某一页。）这两页很重要。这本书的其余内容就是基于这两页展开的。这就像一张问题求解的检查单。这是起飞前、起飞和着陆检查单。它不会教你如何飞行，但是如果不照做，即使你已经懂得怎么飞行，也有可能会坠机身亡。 求解问题时，我们遵循以下四个步骤：首先理解问题，然后拟定计划，接着执行计划，最后回顾整个过程。这样的书我们大概有四本，我觉得我们能使程序员比刚加入公司时变得更加优秀。</p>
<a id="more"></a>
<p>第2篇　巴特勒•兰普森<br>2017-04-30<br>但是我坚持认为，如果你打算在研究生院攻读计算机科学，那么本科学习计算机科学就是犯了大忌。 采访者：为什么？ 兰普森：因为从长远来看，你学的内容大部分都没什么价值。你学不到施展聪明才智的新方法，而这些方法对你来说，要比学习如何编写编译器的细枝末节有 用得多，尽管后者可能是你本科念计算机科学时的学习内容。我认为，要是所有计算机科学研究生院联合起来，一致决定不接受本科念计算机科学的毕业生，世界会变得更好。学校应当要求这些人补习一年，学习数学或历史等科目，才能继续攻读计算机科学的研究生。不过，我还没看到有学校这么做的。<br>2017-04-30<br>举例来说，鲍勃·斯普劳尔（Bob Sproull）和我花了大量时间设计Interpress项目，那是一种印刷标准。我为此投入了很大精力，原本衷心希望施乐公司接受并促使所有人采纳。相反，他们完全把它搞砸了。结果，参与开发的部分人员离职并创办了Adobe系统公司，开发出一种类似的产品PostScript。很显然，后者成了大家现在都会采用的标准。这种事情很恼人，但是研究实验室的主要产品就是创意。<br>註: 这不就和盛大研究院一样<br>2017-04-30<br>：程序员需要具备什么样的素质才能写出成功的程序？ 兰普森：最重要的素质是能够把问题的解决方案组织成容易操控的结构，其中每个组件都可以用简单的方式说明。有时，成功的程序员可以做到这一点，但他们无法解释自己做了什么，因为他们看不到那个结构。有些人之所以成为出色的程序员，是因为他们可以比多数人处理更多的细节。<br>2017-04-30<br>你有没有看到20年后每个指尖上都有一台计算机会出现什么问题？ 兰普森：我不觉得那有什么问题。显然每只手腕上都会有计算机。计算机的存在是予人帮助，我希望它们会给人们带来正面的影响。<br>註: 手机</p>
<p>第3篇　约翰•沃诺克<br>2017-05-01<br>你编程有什么诀窍？ 沃诺克：我不知道能不能归结到几点上。我前面提到过一些。不要早作绑定，尽可能推迟决定时间。眼界放宽一些，设计要比你自认为需要的程度更加灵活，因为从长远看你最终会需要这样。快速让某样东西工作起来，然后还能弃之不用。 从小的开始实验而不是大的入手学习。不要一头扎进周期长达两年且中间不出什么成果的开发当中。最好每两个月就要出点成果，这样你才能进行评估、重组和重新开始。程序员经常在一开始时过度定义他们的方法。他们可能会从一个中心构思着手，从第一天就开始编码。然后他们发现自己陷入重围，每件东西都开始膨胀，因为它们依赖于太多其他因素。应当反其道而行之，如果让过程较为宽松，保持一定的自由度，并在最后阶段加快速度，长远来说，你会做出更好的产品。</p>
<p>第4篇　加里•基尔代尔<br>2017-05-01<br>你说编程对很多人来说也是一种宗教体验，这是什么意思呢？ 基尔代尔：嗯，如果你和一群使用相同编程语言的程序员谈论编程的话，他们几乎可以成为那种编程语言的传教士。他们组成了一个紧密结合的社群，坚持一定的信念，在编程时遵循一定的规则。就像是一个把编程语言当作是圣经的教会。 FORTH是一个很好的例子，它是一种编程语言，对于很多人来说，可能很接近宗教的体验。当FORTH刚出来的时候，其信徒就声称它做任何算法都能快上十倍。这是一个典型的宣言。如果你在这点或其他任何方面有异议，你会发现自己是对牛弹琴，而且你是绝对不会被容许加入“教会”的。我并不想贬低使用这一种语言的人。那是一个非常能给人帮助的团体，所用的也是一种非常有效的语言，但他们没有基于理性去讨论问题，他们是基于信仰的。说过这句话，我可能会收到一千封有关FORTH及人们对其宗教体验的邮件。但是就算我能整天鼓吹LISP的神奇，我也不会把自己归到一个特殊的派别中。<br>註: 哈哈。php</p>
<p>第5篇　比尔•盖茨<br>2017-05-01<br>不，我认为在过了最初的三四年后，就会非常明显地显现出你是否是一个优秀的程序员。刚开始的几年中，你可能会更多地知道怎样去管理大型项目和不同个性的人，但在三四年后，就能很清楚地看出你会成为什么样的程序员了。在微软没有哪个程序员是在平庸了几年之后突然间一鸣惊人的。我和一个人谈谈他的程序，马上就能知道他是否是个好程序员。如果他真的很棒，每个细节他都会脱口而出。 就像下棋的人一样。如果你特别喜欢下棋，会很容易记住10盘棋中的每一步，因为你已置身其中了。其他人看到国际象棋选手或程序员能记住每个细节时，觉得他们像个怪物。其实这很正常。即使到了今天，在我写了微软的BASIC程序10年后，我仍可以在黑板上大段大段写出当时的源代码。<br>2017-05-01<br>编程需要非常大量的精力，所以大多数程序员都比较年轻。这就会带来一个问题，因为编程需要很多的训练。在年轻时，目标不是很持久，可能会被这样那样的事分心。但是年轻的程序员应当坚持下去，他们会变得更出色。作为程序员，我认为自己在1975年到1980年之间的提高是最明显的。在1975年，我会说：“嘿，看看，我什么事情都能做。”我真的认为自己可以，因为我读了大量代码，从来没有发现哪段代码是我无法快速读懂的。今天我仍旧认为检验编程能力的最好方法之一就是给程序员一本30来页的代码，看看他阅读和理解的速度有多快</p>
<p>第6篇　约翰•佩奇<br>2017-05-01<br>从一个计算机程序员转变到运营一个庞大的公司，你觉得困难吗？ 佩奇：这个角色转换是一个非常平缓的过程，因为我已经做了二十多年的管理人员，我可以告诉你真相，最难的是从管理者重新变成程序员。在创办公司前，我 在惠普已经习惯于领导很多人了。再回到编程工作时，我被迫完全依靠自己。真是让人一震。事实上这有点儿可怕——我不知道自己是否还能编程。但是，就像骑自行车一样——你永远都不会忘记的，只要一踏脚蹬，车就奔着夕阳去了。<br>2017-05-01<br>独自一人编程和一个团队合作编程有什么不同？ 佩奇：如果一个产品需要四到五个人开发，那和你自己一个人编程时采取的方法是不同的。我坚信只能由一个人来做产品和高层结构的设计，最多不能超过两个人。所有的设计出于一个头脑，才能够实现和谐与一致。如果试图取悦于所有人，让一个委员会来做设计，你的方向就错了。那绝对是致命的。 所以我在定义阶段会用一个人数非常少的团队来工作，然后如果有必要，再扩大团队来实施编程设计。实施设计方案所需要的队伍越大，就越必须严格地把整个系统划分成可管理的模块，并定义好相互间的接 口。除非一个程序大到必须由两三个人以上来做，否则不必编写很多结构化程序报告，也不用为每个步骤都编写文档。 有些系统，例如设计一个控制航天飞机的程序，需要上百名程序员。那就必须严格地把结构划分成可管理的模块才行。一个小系统的架构可能会过于大，一个大系统的架构可能会过于小——使用的技术必须与问题的规模相匹配。我就是这样做的。<br>2017-05-01<br>有些人觉得完成项目真是太过瘾了，他们做完一个项目就接着又做另一个了。这样会把自己累垮的。如果连续开始新的项目，情况会变得很糟。 另外，当你在复杂的程序上艰苦工作时，锻炼身体是很重要的。大部分程序员都缺乏身体锻炼，这样会失去敏锐的思维。往往在连续完成了第二个或第三个工作后，身体就虚弱了，以至于你会产生幻灭感，你会对着镜子说：“上帝啊，看看我，我为什么要这样做呢？</p>
<p>第7篇　C.韦恩•莱特莱夫<br>2017-05-01<br>另一方面，非常有意思的是专家系统。我的预测是，在两三年之内，专家系统不必再和人工智能牵扯在一起。这就是人工智能的历史：当某件东西开始变得众所周知时，它就独立出来了。模式识别曾经被当作是人工智能，但现在这是一个独立的领域。这也正是专家系统当下的命运。我认为专家系统在我们产业里将变得非常重要，就像垂直应用一样。<br>註: 和现在一样</p>
<p>第11篇　雷•奥奇<br>2017-05-02<br>我推崇严谨、一致而清晰的结构。另外，我认为软件应该高度模块化和分层，非常灵活地运用大量文件和目录。如果你必须分别构建不同组件，那么接口自然就会更加凸显出来，要求你规范这些接口。<br>当许多人共同开发一个程序时，在项目早期确立全局的错误处理、参数传递和子程序命名规范（虽然不见得所有人都会同意），显得非常重要。不过，对于代码该怎么注释、大括号怎么用或者代码该怎么缩进，我觉得你绝不应该对别人指手画脚。在修改别人的模块时，你最好还是按照他的惯例编写代码。这是学会与他人共事的必修课。<br>交流想法的环境应该是开放的。设计会议上允许非常激烈和紧张的讨论。我发现许多优秀设计师往往固执己见，但只要他们觉得是对的，就会毫不客气地坚持，但他们也知道什么时候应该怎么让步。优秀设计师不会有“非此创造”综合征。<br>2017-05-02<br>我过去常想，个人时间管理程序应该会非常便利。结果现在却得在公文包里装一台计算机随身携带，打开并启动计算机，就只为了查看我的会面安排，远不及我那口袋大小的通讯记事簿来得方便。我想要一本通讯记事簿，让我的秘书和我可以同时写入，这非常有用，因为我们俩都能便捷地安排我的时间。我希望哪个聪明的家伙能发明这种记事簿。<br>註: 手机日程管理软件</p>
<p>第14篇　杰夫•拉斯金<br>2017-05-03<br>1979年，苹果公司正致力于开发Lisa。不管你信不信，它最初的目标是开发一款字符界面的机器。我在苹果公司担任高级系统经理，对Lisa很不满。它非常昂贵，我认为苹果公司不够理智，居然以小型机的价格去跟DEC、通用数据公司和IBM比拼。<br>70年代初，我在斯坦福大学人工智能实验室做访问学者期间，在施乐PARC度过了大量时光。在我看来，施乐PARC在位图屏幕、通用键盘和图形方面的研究真是不可思议。因此，我极力游说，说服苹果公司把Lisa改成位图机器。我把施乐和苹果公司撮合到一起。施乐一度持有苹果公司10%的股票。<br>我提议开发一款容易使用并融合文字和图形的电脑，售价在1000美元左右。乔布斯认为这想法太疯狂了，这种机器不会有销路，我们绝不要这种玩意。他试图否决这个项目。<br>因此，我越过乔布斯直接找到当时的董事长迈克·马库拉（Mike Markkula），和他探讨我的想法。幸运的是，马库拉和时任总裁迈克·斯科特（Mike Scott）叮嘱乔布斯别管我。<br>我招揽了早期成员：巴德·特里伯（Bud Tribble）、布里安·霍华德（Brian Howard）和布雷尔·史密斯（Burrell Smith）。我们搬到另一栋大楼，打造Macintosh及其软件的原型，搭建并让它运行起来。后来，乔布斯接手后，他还编了个故事，把Mac项目称为“海盗行动”。我们并未像他后来说的那样，试图让这个项目远离苹果公司。我们跟苹果公司其他部门的联系十分紧密，我们只是尽量不让乔布斯干预这个项目。在头两年，乔布斯总想着要毙掉这个项目，因为他不明白它到底是怎么回事。<br>最初的Macintosh设计得既精心又合理。最后，苹果公司所有人都意识到，这是公司继Apple II后推出新产品的希望所在。随后，乔布斯接管了这个项目。他径直走进来，对我说：“我接手Macintosh硬件，你可以负责软件和出版物。”他抛出软件设计，要求Macintosh软件与Lisa保持兼容，并坚持使用鼠标。机器变得更大、更复杂，也昂贵得多。现在它跑起来黏糊糊的。你有没有用过MacWrite？我们这里把它叫做MacWait。又过了几个月，乔布斯对我说：“我来接手软件，你可以负责出版物。”于是我回答：“你也可以接手出版物。”说完便离开了。那是1982年5月。他和马库拉对我说：“请别走。再过一个月，我们会提供一份你无法拒绝的薪酬。”于是我给了他们一个月时间，他们开了一份薪酬，我没接受。<br>2017-05-03<br>近期《新闻周刊》上的一篇文章把我逗乐了，他说：“我还有几个不错的设计。”他从来没做过什么设计，他一款产品都没设计过。沃兹（Steve Wozniak）设计了Apple II。肯·罗斯穆勒（Ken Rothmuller）等人设计了Lisa。我和我的团队设计了Macintosh。温德尔·桑德斯（Wendell Sanders）设计了Apple III。乔布斯设计了什么？什么也没有。<br>註: 哈哈，乔布斯<br>2017-05-03<br>人工智能教会了我们大量关于我们自身以及知识的内容。非常廉价的机器上用不了靠谱的人工智能程序，至少目前行不通。<br>真正的人工智能有点像宗教。从前人们都说天空上面就是天堂和天使。然后你搭乘火箭飞船到了那里，发现并不是那么回事。于是你知道原来的理解有误。一旦你实现了某样东西，它就不再是人工智能。<br>曾几何时，国际象棋博弈程序一度被认为包含人工智能的成分。当我还在念研究生时，只要学会编写国际象棋博弈程序，你就可以拿到人工智能博士学位。现在你花上29.95美元就能买到国际象棋博弈程序，没有人称之为人工智能。它只是个会下棋的小算法。<br>首先，有个定义的问题。然后，它变得更加复杂。人们认为程序应该理解自然语言，但我们的话语方式对电脑或别人来说太不精确，无法弄清楚要做什么。这正是我们创造编程语言的原因。只要试过以英文写成的规格为基础开展工作，他们就会知道自己无法借此编写程序，因为它不够精确。因此，如果人类都不能做到这一点，基本上就不可能指望还能让机器做到。当你面对所谓的人工智能程序时，电脑必须已经掌握一个词汇表。比方说，你有5个命令，你想让机器理解与之等价的所有可能的英文表述，但是它理解不了所有等价的英文表述。有人可能会说：“拿个工号。”而英国绅士可能会说：“劳烦你给我们的员工派个数字编号。”这正是搞AI的人试图解决的大麻烦。<br>人工智能相关的许多承诺都被误解了。人工智能已经教导我们的有关语言的东西是美好的。那么，我是否认为人工智能值得做？绝对是。我是否认为这会转化出很棒的产品？会有一些。我是否认为这会实现你在大众传媒上了解到的承诺？根本不会。我会投很多钱到人工智能领域吗？没门</p>
<p>第15篇　安迪•赫兹菲尔德<br>2017-05-03<br>有个故事是关于沃兹的。沃兹是公司创始人之一，不用说，他分到了大量股票。有些人一点股票都没有，而有的人却拥有这么多股票，对此他觉得很不公平。于是他拿出自己的股票，宣布只要是在苹果公司工作满一定年限的员工，都可以从他那里买到2500股。沃兹的用意无疑是最好的，但结果这反倒让那些坏心肠的人欢天喜地。事情是这样的，许多不在乎钱财的雇员并没有行使股票购买权，于是那些贪心的家伙就对他们说：“好吧，我给你钱，我来买你的股份。”有些人不再认真工作，反而成了股票买手；他们令人生厌，个性糟糕，是不够格的工程师，毛孔里都滴着贪婪。在一个月内，有个家伙光靠这个捞了几十万美元。这实质上是在窃取沃兹的钱财。但这也是苹果公司上市时发生的故事的一部分。<br>到了1980年年底，在苹果公司工作不再那么有趣。通常你的头儿是从另一家公司挖过来的，对产品一无所知。最后，迈克·斯科特意识到苹果公司聘请的管理人员都是些眼高手低的家伙，1981年2月，他在一天之内把这些人都给解雇了。工程部门一共有90人，他解雇了其中40人。这一天在苹果历史上被称为“黑色星期三”。人们都惊呆了。<br>2017-05-03<br>就在Mac发布之后，Mac团队开始组建管理层的时候，我离开了苹果公司。我跟新来的技术经理有矛盾，他最初是我面试和同意录用的，没想到他是个控制和权力狂。这家伙认为我太傲慢，自以为可以通过考核给我差评打击我。我很震惊。我掏心掏肺地为这家公司卖命，尽我所能做到最好，每天工作15个小时开发这个项目。Macintosh本不该是这样的，但是这家伙却进来把它搞成了这样。因此我不得不选择离开，但是我把自己生命中整整两年献给了Macintosh，它是我最在意的。所以我一直待到Mac发布之后才离开苹果公司，开始自己单干。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【美】Susan Lammers&lt;/p&gt;
&lt;p&gt;第1篇　查尔斯•西蒙尼&lt;br&gt;2017-04-30&lt;br&gt;采访者：编程是一种技巧或技能吗？ 西蒙尼：什么是编程？人们对此一直各持己见。有人说它是科学，有人说它是艺术，还有人称之为技能或手艺。我认为这三方面兼而有之。我们喜欢说它蕴含大量艺术成分，但是我们都知道它里面更多的是科学。 孩子们在学校里学习数学，高中毕业时，他们会以为数学就是加法和乘法，甚或代数和微积分。其实，算术，即使简单如加法的运算，背后也有令人难以置信的科学理论作支持。 计算机编程背后也有大量科学理论作支持。例如，哥德尔定理的数学证明冗长而复杂，但是如果借用计算机科学的图灵定理，证明起来不费吹灰之力。信息理论和计算机科学其他领域对数学影响巨大，反之亦然。 编程包含有大量科学，同时，它也有点像手艺。实际上，在许多人看来，编程是一项复杂的技能，这跟工具制造很像，需要精雕细琢。我认为，只要将科学、艺术和技能这三者拿捏得恰到好处，你就能取得一些引人瞩目的成绩。&lt;br&gt;2017-04-30&lt;br&gt;别人读几段你的源代码，有没有可能断定“这代码是查尔斯·西蒙尼写的”？ 西蒙尼：噢，是的，毫无疑问。是不是我本人写的可能很难分辨，但有一点是确定无疑的：只要看了代码，你就能知道它是不是我的团队写的，或者是不是受我的影响写的。这是因为我从1972年起写的代码都遵循特定的命名规范，许多人称之为“匈牙利命名法”。你一眼就能分辨出哪些代码是受我的影响写出来的，包括Microsoft Word、Multiplan和Bravo，以及其他许多遵循这些规范写成的程序。&lt;br&gt;註: 原来是他&lt;br&gt;2017-04-30&lt;br&gt;进入公司第一天，程序员就会拿到几本书。其中一本是数学家乔治·波利亚写的《怎样解题》。（西蒙尼边说边从他办公桌旁的书柜里取出那本书，翻到某一页。）这两页很重要。这本书的其余内容就是基于这两页展开的。这就像一张问题求解的检查单。这是起飞前、起飞和着陆检查单。它不会教你如何飞行，但是如果不照做，即使你已经懂得怎么飞行，也有可能会坠机身亡。 求解问题时，我们遵循以下四个步骤：首先理解问题，然后拟定计划，接着执行计划，最后回顾整个过程。这样的书我们大概有四本，我觉得我们能使程序员比刚加入公司时变得更加优秀。&lt;/p&gt;
    
    </summary>
    
      <category term="摘录" scheme="http://www.coderyang.com/categories/%E6%91%98%E5%BD%95/"/>
    
    
      <category term="杂谈" scheme="http://www.coderyang.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>读书摘录-调试九法：软硬件错误的排查之道</title>
    <link href="http://www.coderyang.com//blog/2017/04/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%EF%BC%9A%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B9%8B%E9%81%93.html"/>
    <id>http://www.coderyang.com//blog/2017/04/读书摘录-调试九法：软硬件错误的排查之道.html</id>
    <published>2017-04-30T08:54:08.000Z</published>
    <updated>2017-04-30T08:55:07.674Z</updated>
    
    <content type="html"><![CDATA[<p>【美】阿甘斯</p>
<p>第3章 理解系统<br>2017-04-07<br>你必须掌握系统的工作原理以及它是如何设计的。在某些情况下，还要知道为什么这样设计。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方。（这不仅仅是“墨菲定律”的问题，如果你不能理解你所设计的系统，你的工作可能会变得一团糟。）</p>
<p>3.1 阅读手册<br>2017-04-07<br>如果你是一位工程师，正在调试自己公司的产品，那么你需要读一读内部手册。工程师们设计它是用来做什么的？读一下功能说明以及所有的设计规范，研究一下图表、时序图和状态机。分析它们的代码，还要读一下注释。（是的，读一下注释，这非常重要。）一定要检查产品的设计。查明构建它的工程师们打算用它来做什么（除了用它来赚钱买辆宝马车以外）。<br>注意，手册上的信息也不可全信。手册（以及那些只想着赚钱买宝马车的工程师们）可能也是错的，很多难以发现的bug就出现在这里。但你仍需要了解他们的想法，哪怕其中有些信息是很难接受的。</p>
<p>3.2 逐字逐句阅读整个手册<br>2017-04-07<br>参考设计和样本程序给出了产品的一种使用方式，有时这些就是能获得的全部文档了。但是，在使用这些设计时一定要注意，创建它们的人往往只了解他们的产品，而没有遵循好的设计实践，或者不是为真实应用而设计的（最常见的缺点是不能进行错误恢复）。不要照搬这些设计，如果你没有在开始的时候发现bug，那么将来也会发现。此外，即使是最好的参考设计可能也不会完全符合应用程序的特定需求，而不符合的地方可能就是出问题的地方。当我照搬了朋友的微处理器设计时，就发生了问题，因为他的设计无法处理中<br><a id="more"></a><br>3.3 知道什么是正常的<br>2017-04-07<br>当你检查系统时，必须知道系统的正常工作状态。如果你不知道低位字节首先由使用了Intel芯片的PC程序来处理，那么你会认为所有长字（longword）都是随意处理的。如果你不知道缓存是干什么的，就会非常奇怪有些数据为什么没有马上写入内存。如果你不了解三态（tri-state）数据总线的工作原理，你将会认为它们可能是主板上的故障信号。如果你从未听说过电锯，你可能会认为那个发出讨厌的嗡嗡声的东西一定是出了什么毛病。知道什么是正常的可以帮助你注意到什么是不正常的。<br>你必须掌握一些你所工作的技术领域的基础知识。如果我不知道时钟选通脉冲和地址线是做什么的，那么即使我读了手册之后也无法理解中断问题。本书中几乎所有的（即使不是全部的话）示例都假定人们已经掌握了系统工具原理的一些基本知识。（如果我在前面使你误认为读完本书就可以调试任何技术领域的bug，那么请恕我无心之过。如果你是一位游戏编程人员，最好不要去管核电厂的调试。如果你不是医生，那么就不要试图诊断你手臂上的灰绿色斑点是什么。如果你是一位政客，那么就不要介入任何有关bug的事情。）</p>
<p>3.7 小结<br>2017-04-07<br>理解系统<br>这是第一条规则，因为它是最重要的。<br>阅读手册。它会告诉你在使用除草机时，要在除草头上涂润滑油，这样除草绳就不会被烧化。<br>仔细阅读每个细节。有关微处理器如何处理中断的详细信息就隐藏在数据手册的第37页。<br>掌握基础知识。电锯本来就会发出很大的噪声。<br>了解工作流程。引擎的转速可能与轮胎的转速不同，这是由传动轴造成的。<br>了解工具。弄清楚体温计的哪一端才是用来测量体温的，弄清楚Glitch-O-Matic逻辑分析器的强大功能是如何使用的。<br>查阅细节。连爱因斯坦都会去查阅细节，而Kneejerk却盲目相信自己的记忆力</p>
<p>第4章 制造失败<br>2017-04-09<br>“当你发现一个故障时该怎么办？”他会回答说：“试着让它再次发生。”（Charlie是一位训练有素的调试人员）。这样做有3个原因。<br>可以观察它。要观察错误（下一节将更详细地讨论这个问题），就必须使它发生。我们必须尽可能有规律地制造失败。在前面讲的电视游戏的例子中，当问题发生时我可以集中注意力观察示波器（虽然当时我已经很疲倦）。<br>可以专心查找原因。准确地知道问题在什么条件下会发生，有助于集中精力查找原因（但是请注意，有时这会产生误导，例如，“烤箱只有在你把面包放进去的时候才会把面包烤焦，因此问题就出在面包上。”这个问题后文也会详细讨论。）<br>可以判断是否已修复问题。当你认为已经修复了问题时，如何才能确信它确实已被修复呢？那就是明确知道问题是如何发生的。当问题没有修复时，如果你执行X操作，失败率为100%；在修复问题后，再执行X操作，如果失败率为0，那么你知道bug确实已被修复。（我这么说并不多余。很多时候，开发人员在修复bug时会修改软件，然后在一个与当初发现bug的不同条件下测试新软件。软件当然能运行，即使他在代码中输入一行打油诗，而他也高兴地回家了。然而，几星期后，在测试过程中，或者更糟，在客户现场，软件再次失败。后文将讨论更多这方面的内容。</p>
<p>4.4 不要模拟失败<br>2017-04-09<br>记住，这并不意味着不能用自动化过程来引发失败，也不意味着在这个过程中不能采用一些起到放大效果的措施。自动测试能够使间歇性的问题更快发生，例如电视游戏的例子。放大效果可以使得细微的问题更明显，例如在修窗户的例子中，我可以用喷水管来找到漏雨的窗户，而不用等待偶尔才有的暴风雨来检查。这两种技术都有助于引发失败，而不是模拟失败的机理。所做的改变应该是一些高层次的改变，只影响错误发生的频率，而不影响错误的发生方式。<br>此外，还要注意不要画蛇添足，引发新的问题。不要因为假设芯片的问题是由于热量引起的，就用热风枪来给芯片加热以模拟错误，这样只会把芯片烧化，然后你会误认为bug完全就是电路板上那堆被烧化的塑料。如果我用消防用的水龙来检查漏雨问题，可能会断定问题显然就是出在被击碎的窗子上。</p>
<p>4.9 小结<br>2017-04-10<br>制造失败<br>虽然看起来很简单，但如果不制造失败的话，调试就会变得很困难。<br>制造失败。目的是为了观察它，找到原因，并检查是否已修复。<br>从头开始。修车工需要知道汽车车窗在被冻结之前你洗过车。<br>引发失败。用喷水管向漏雨的那扇窗子喷水。<br>但不要模拟失败。用喷水管向漏雨的那扇窗子喷水，而不要向另一扇不同的、“类似的”窗子喷水。<br>查找不受你控制的条件（正是它导致了间歇性失败）。改变能够改变的每件事情，振动、摇晃、扭曲，直到再现失败。<br>记录每件事情，并找到间歇性bug的特征。我们的绑定系统总是只在呼叫顺序错乱时才会失败。<br>不要过于相信统计数据。绑定问题看起来与时间段有关，但实际上真正的原因是当地的年轻人占用了电话线路。<br>要认识到“那”是可能会发生的。甚至冰淇淋的口味也会影响汽车的发动。<br>永远不要丢掉一个调试工具。自动击球板可能在某一天就会派上用场。</p>
<p>5.6 猜测只是为了确定搜索的重点目标<br>2017-04-11<br>不要想，而要看”并不意味着不能做任何猜想。事实上猜测是好事，特别是当你理解了系统之后。你的猜测可能很接近事实，但猜测只是为了确定搜索的重点。在尝试修复问题之前，仍需要再次看到失败，以便确认你的猜测是正确的。</p>
<p>5.7 小结<br>2017-04-11<br>不要想，而要看<br>凭空想象，问题可能有几千条原因。而实际的原因只有去看了才能发现。<br>观察失败。高级工程师看到了真实的问题，并且能够找到原因。而初级工程师们认为他们知道错误发生在哪里，结果他们修复的地方根本没有出错。<br>查看细节。听到水泵似乎发出声音时不要停下来。到地下室查明是哪个水泵。<br>植入插装工具。使用源代码调试器、调试日志、状态消息、信号灯和臭鸡蛋的气味。<br>添加外部插装工具。使用分析器、示波器、量表、金属检测仪、心电图仪和肥皂泡。<br>不要害怕深入研究。虽然它是软件成品，但它出问题了，你必须打开并修复它。<br>注意海森堡效应。不要让仪器影响了系统。<br>猜测只是为了确定搜索的重点。大胆地猜测内存时序发生了错误，但在修复之前应该先查看它。</p>
<p>6.4 修复已知bug<br>2017-04-12<br>有时，我们很难相信一个系统中会有多个bug，就像在旅店预订的例子中一样。这使得用“分而治之”原则隔离每个bug变得更加困难。因此，如果同时出现了多个问题，当你确实查明了其中的一个问题时，应该立即修复它，然后再查找其他问题。我总听人们说“那里出问题了，但它不可能影响我们正在查找的问题。”事实上，它确实（而且经常）会产生影响。如果你修复了已知的错误，就可以专心致志地查找其他问题。在旅店预订系统中，技术人员只有在修复了转接盒中的双向电阻阻值过高的问题之后，才能够发现速度最慢的那台终端的接线问题。<br>有时修复了一个问题，另一个问题也解决了，两个问题实际上是同一个bug。<br>此外，如果修复某个问题对其他的问题有影响，一定要首先修复它之后再测试其他的问题。如果修复了一个问题后将会引发新的问题，那么你可以尽早发现，并有更多时间处理新的问题。</p>
<p>6.5 首先消除噪声干扰<br>2017-04-12<br>人们也很容易成为一个“完美主义者”，为了达到全面的高质量把你发现的所有不好的设计都“修复”一遍。你可能只是因为先前的程序员编写的GOTO语句看起来很差劲就删掉它们，但是，如果它们并没有实际引起问题，最好还是保留它们吧。</p>
<p>6.6 小结<br>2017-04-12<br>分而治之<br>当bug的藏身之地不断被缩小一半时，它将很难再隐藏下去。<br>通过逐次逼近缩小搜索范围。猜测1～100内的一个数字，只需7次。<br>确定范围。如果数字是135而你却认为它在1～100内，那么你必须扩大范围。<br>确定你位于bug的哪一侧。如果你所在的位置有排放物，则排放管就在上游。如果没有排放物，则排放管就在下游。<br>使用易于查看的测试模式。从干净、清澈的水开始，以便当排放物进入河流中时很容易看到它。<br>从有问题的一端开始搜索。如果你验证的是正确的部分，那么需要验证的地方太多了。应该从有问题的地方开始，然后向后追查原因。<br>修复已知bug。bug互相保护，互相隐藏。因此一旦找到，立即修复它们。<br>首先消除噪声干扰。注意那些导致系统问题的干扰因素。但对一些无足轻重的问题不要过于极端，也不要为了追求完美而去修改所有地方。</p>
<p>第7章 一次只改一个地方<br>2017-04-12<br>我们的软件工程师为了修复问题而更改了一个地方，但这个修改并没有解决问题，而他认为这不会产生什么影响。这是一个非常错误的假设。它确实有影响，它使得音频数据发生错误，只是两次错误与一次错误也没有什么太大的区别。当原来的错误被修复后，他犯的错误仍然存在，因此声音的质量仍很差。当他的修改没有解决问题时，应该立即把它改回来。<br>註: 经常遇到</p>
<p>7.2 用双手抓住黄铜杆<br>2017-04-23<br>在很多情况下，你可能想改变系统的不同部分，以便看看它们是否对问题有影响。这往往是一个危险的信号，说明你正在猜测，而不是使用插装工具来观察正在发生什么。你正在改变条件，而不是捕捉错误的自然发生。这可能会把最初的错误隐藏起来，而且引起更多错误。</p>
<p>7.5 自从上一次能够正常工作以来你更改了什么<br>2017-04-23<br>有时，正常的系统和错误的系统之间的区别是由于一项更改造成的。做了更改之后，正常的系统开始出现故障。一种非常有效的办法是找出第一个导致系统出错的版本，尽管这可能需要连续测试原来的版本，直到找到没有故障的版本。一旦找到了这个版本，再前进到下一个版本，验证故障是否再次出现。做完这一步之后，至少可以把问题的范围限定到两个版本之间所做的修改。<br>2017-04-23<br>问题已经存在了很长时间，但只是某个地方（例如时序或数据库大小）被改变之后，它才显露出来</p>
<p>7.6 小结<br>2017-04-23<br>一次只改一个地方<br>我们在生活中要有一点先见之明。如果你所做的更改没有起到预期的作用，那么就把它改回来。它们可能会产生无法预料的影响。<br>隔离关键因素。如果你在检查日照时间的影响，就不要改变灌溉方案。<br>用双手抓住黄铜杆。如果你在不知道具体发生了什么问题的情况下就试图去修理核潜艇，可能会引发一次水下的切尔诺贝利爆炸。<br>一次只改一个测试。我之所以知道我的VGA采集相位被破坏了，就是因为其他东西都没有发生改变。<br>与正常情况进行比较。如果所有出错的情况都有一些特征，而这些特征是正常情况所没有的，那么<br>你就找到了问题所在。<br>确定自从上一次正常工作以来你改变了什么地方。我的工友改变了唱机转盘上的唱头，因此这是一个很好的调试起点。</p>
<p>8.6 小结<br>2017-04-23<br>保持审计跟踪<br>不要只是在心里记住“保持审计跟踪”这条规则，而要把它写下来。<br>把你的操作、操作的顺序和结果全部记录下来。你上一次喝咖啡是什么时候？你的头痛是从什么时候开始的？<br>要知道，任何细节都可能是重要的。视频压缩芯片的崩溃是由于格子衬衫造成的。<br>把事件关联到一起。“它发出噪声，从21:04:53开始，持续4秒”比仅仅说“它发出噪声”要好得多。<br>用于设计的审计跟踪在测试中也非常有用。软件配置控制工具可以告诉你哪次修订引入了bug。<br>把事情记录下来！无论那个时刻多么恐怖，都要把它记到备忘录中，这样你才不会忘记。</p>
<p>9.4 小结<br>2017-04-23<br>检查插头<br>一些显而易见的假设往往是错误的。请恕我赘述，假设错误通常是最容易修复的错误。<br>置疑你的假设。是否运行了正确的代码？是不是燃气用完了？插头是否已插好？<br>从头开始。是否正确地对内存进行了初始化？是否按了除草机上的“primer bulb”按钮？开关是否已打开？<br>对工具进行测试。是否运行了正确的编译器？燃料油表是否被粘住了？量表是不是没电了？</p>
<p>10.5 小结<br>2017-04-23<br>获得全新观点<br>不管怎样，你都需要休息一下，喝杯咖啡。<br>征求别人的意见。甚至一个不说话的人体模特也能帮助你认识到你先前没有注意到的事情。<br>获取专业知识。只有VGA视频采集卡的厂商才能够肯定相位功能发生了错误。<br>听取别人的经验。别人会告诉你车内顶灯的线被挤压出来了。<br>帮助无处不在。同事、供应商、网络，还有书店，都在等待着为你提供帮助。<br>放下面子。bug发生了。以除掉bug为自豪，而不要非得以自己除掉bug才为自豪。<br>报告症状，而不要讲你的理论。不要把别人拖进你的思维定式中。<br>你提出的问题不必十分肯定。甚至连“穿了格子衬衫”这样的事情也可以提出来。</p>
<p>11.6 小结<br>2017-04-23<br>如果你不修复bug，它将依然存在<br>现在你已经掌握了所有的技术，没有理由再让bug存在了。<br>查证问题确实已被修复。不要假设是电路的问题，而仍然让汽车带着脏的滤油嘴上路。<br>查证确实是你的修复措施解决了问题。口中大喊“Wubba!”并不是使计算机打开的窍门。<br>要知道，bug从来不会自己消失。使用最初导致它失败的方法再次制造失败。如果必须交付产品，那么就在产品中设计一个用于捕捉bug的“陷阱”，以便产品在客户现场发生失败时，把它捉住。<br>从根本上解决问题。在烧坏另一台变压器之前，先把无用的8音轨磁带卡座扔掉。<br>对过程进行修复。不要只是擦掉地上的油，而要纠正设计机器的方式。</p>
<p>14.3 小结<br>2017-04-25<br>从帮助台得到的观点是不明确的<br>只能通过远程方式了解问题，眼睛和耳朵接收到的信息并不十分准确，而且关键是时间紧迫。<br>遵循规则。无论用户多么糊涂，都必须找到应用规则的途径。<br>对行动和结果加以确认。用户会误解你的意思，同时会犯错误。通过确认他们所说和所做的一切可以及早发现这些问题。<br>使用自动工具。不要让用户参与系统生成的日志和远程监控与控制工具。<br>即使是最简单的假设也需要确认。是的，有些人就是不知道有电才能使用字处理器。<br>使用可用的故障检修指南。要处理的很可能就是已知的、好的设计。不要忽略历史。<br>帮助完善故障检修指南。如果找到了某个已知系统的一个新问题，将解决问题的所有内容进行归档可以帮助下一位支持人员。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【美】阿甘斯&lt;/p&gt;
&lt;p&gt;第3章 理解系统&lt;br&gt;2017-04-07&lt;br&gt;你必须掌握系统的工作原理以及它是如何设计的。在某些情况下，还要知道为什么这样设计。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方。（这不仅仅是“墨菲定律”的问题，如果你不能理解你所设计的系统，你的工作可能会变得一团糟。）&lt;/p&gt;
&lt;p&gt;3.1 阅读手册&lt;br&gt;2017-04-07&lt;br&gt;如果你是一位工程师，正在调试自己公司的产品，那么你需要读一读内部手册。工程师们设计它是用来做什么的？读一下功能说明以及所有的设计规范，研究一下图表、时序图和状态机。分析它们的代码，还要读一下注释。（是的，读一下注释，这非常重要。）一定要检查产品的设计。查明构建它的工程师们打算用它来做什么（除了用它来赚钱买辆宝马车以外）。&lt;br&gt;注意，手册上的信息也不可全信。手册（以及那些只想着赚钱买宝马车的工程师们）可能也是错的，很多难以发现的bug就出现在这里。但你仍需要了解他们的想法，哪怕其中有些信息是很难接受的。&lt;/p&gt;
&lt;p&gt;3.2 逐字逐句阅读整个手册&lt;br&gt;2017-04-07&lt;br&gt;参考设计和样本程序给出了产品的一种使用方式，有时这些就是能获得的全部文档了。但是，在使用这些设计时一定要注意，创建它们的人往往只了解他们的产品，而没有遵循好的设计实践，或者不是为真实应用而设计的（最常见的缺点是不能进行错误恢复）。不要照搬这些设计，如果你没有在开始的时候发现bug，那么将来也会发现。此外，即使是最好的参考设计可能也不会完全符合应用程序的特定需求，而不符合的地方可能就是出问题的地方。当我照搬了朋友的微处理器设计时，就发生了问题，因为他的设计无法处理中&lt;br&gt;
    
    </summary>
    
      <category term="摘录" scheme="http://www.coderyang.com/categories/%E6%91%98%E5%BD%95/"/>
    
    
      <category term="杂谈" scheme="http://www.coderyang.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>vs2017与vs2005冲突解决</title>
    <link href="http://www.coderyang.com//blog/2017/04/vs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3.html"/>
    <id>http://www.coderyang.com//blog/2017/04/vs2017与vs2005冲突解决.html</id>
    <published>2017-04-16T06:24:59.000Z</published>
    <updated>2017-04-16T07:13:28.695Z</updated>
    
    <content type="html"><![CDATA[<p>先安装vs2005，后安装vs2017，vs2017无法运行<br>原因：vs2005注册了Microsoft.VisualStudio.Shell.Interop.8.0.dll，优先于vs2017需要的dll。导致运行错误。</p>
<p>解决方法：</p>
<p>复制<br>C:\Program<em>Files</em>(x86)\Microsoft_Visual Studio\2017\Enterprise\Common7\IDE\PublicAssemblies\Microsoft.VisualStudio.Shell.Interop.8.0.dll<br>到<br>C:\Windows\assembly\GAC\Microsoft.VisualStudio.Shell.Interop.8.0\8.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualStudio.Shell.Interop.8.0.dll</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先安装vs2005，后安装vs2017，vs2017无法运行&lt;br&gt;原因：vs2005注册了Microsoft.VisualStudio.Shell.Interop.8.0.dll，优先于vs2017需要的dll。导致运行错误。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;复制
    
    </summary>
    
      <category term="技巧" scheme="http://www.coderyang.com/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="http://www.coderyang.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-链表</title>
    <link href="http://www.coderyang.com//blog/2017/03/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8.html"/>
    <id>http://www.coderyang.com//blog/2017/03/redis源码阅读-链表.html</id>
    <published>2017-03-26T12:14:40.000Z</published>
    <updated>2017-03-26T12:15:17.520Z</updated>
    
    <content type="html"><![CDATA[<p>C语言程序由于没有标准库的存在，各种造轮子。Redis为了满足需求，同样写了一个链表。</p>
<p>实现文件在adlist.h/adlist.c中。</p>
<h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>和普通的C写的双向链表差不多。没有什么特点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</div><div class="line">    <span class="keyword">struct</span> listNode *prev; <span class="comment">// 前节点</span></div><div class="line">    <span class="keyword">struct</span> listNode *next; <span class="comment">// 后节点</span></div><div class="line">    <span class="keyword">void</span> *value; <span class="comment">// 值</span></div><div class="line">&#125; listNode;</div><div class="line"></div><div class="line"><span class="comment">// 迭代器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listIter &#123;</div><div class="line">    listNode *next;<span class="comment">// 下一个节点</span></div><div class="line">    <span class="keyword">int</span> direction;<span class="comment">// 方向</span></div><div class="line">&#125; listIter;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</div><div class="line">    listNode *head; <span class="comment">// 头</span></div><div class="line">    listNode *tail; <span class="comment">// 尾</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr); <span class="comment">// 自定义节点复制函数</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr); <span class="comment">// 自定义节点释放函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 自定义节点匹配函数</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">// 链表长度</span></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>定义了一些快速操作的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* Functions implemented as macros */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len) <span class="comment">// 获取list长度</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head) <span class="comment">// 获取list头节点指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail) <span class="comment">// 获取list尾节点指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev) <span class="comment">// 获取当前节点前一个节点</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next) <span class="comment">// 获取当前节点后一个节点</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value) <span class="comment">// 获取当前节点的值</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m)) <span class="comment">// 设定节点值复制函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m)) <span class="comment">// 设定节点值释放函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m)) <span class="comment">// 设定节点值匹配函数</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup) <span class="comment">// 获取节点值赋值函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free) <span class="comment">// 获取节点值释放函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match) <span class="comment">// 获取节点值匹配函数</span></span></div></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>都是些链表常用的API，比较有特点的是迭代器的C语言实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Prototypes */</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;</div><div class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;</div><div class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;</div><div class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</div><div class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言程序由于没有标准库的存在，各种造轮子。Redis为了满足需求，同样写了一个链表。&lt;/p&gt;
&lt;p&gt;实现文件在adlist.h/adlist.c中。&lt;/p&gt;
&lt;h2 id=&quot;结构体定义&quot;&gt;&lt;a href=&quot;#结构体定义&quot; class=&quot;headerlink&quot; title=&quot;结构体定义&quot;&gt;&lt;/a&gt;结构体定义&lt;/h2&gt;&lt;p&gt;和普通的C写的双向链表差不多。没有什么特点。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; listNode &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; listNode *prev; &lt;span class=&quot;comment&quot;&gt;// 前节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; listNode *next; &lt;span class=&quot;comment&quot;&gt;// 后节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *value; &lt;span class=&quot;comment&quot;&gt;// 值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; listNode;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 迭代器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; listIter &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    listNode *next;&lt;span class=&quot;comment&quot;&gt;// 下一个节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; direction;&lt;span class=&quot;comment&quot;&gt;// 方向&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; listIter;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    listNode *head; &lt;span class=&quot;comment&quot;&gt;// 头&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    listNode *tail; &lt;span class=&quot;comment&quot;&gt;// 尾&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*dup)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *ptr); &lt;span class=&quot;comment&quot;&gt;// 自定义节点复制函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *ptr); &lt;span class=&quot;comment&quot;&gt;// 自定义节点释放函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (*match)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *ptr, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key); &lt;span class=&quot;comment&quot;&gt;// 自定义节点匹配函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; len; &lt;span class=&quot;comment&quot;&gt;// 链表长度&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-动态字符串sds</title>
    <link href="http://www.coderyang.com//blog/2017/03/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds.html"/>
    <id>http://www.coderyang.com//blog/2017/03/redis源码阅读-动态字符串sds.html</id>
    <published>2017-03-26T11:45:58.000Z</published>
    <updated>2017-03-26T11:49:53.240Z</updated>
    
    <content type="html"><![CDATA[<p>Redis没有使用c语言的字符串结构，自己设计了一个简单的动态字符串。特点是：修改时大小不足则扩容，大小足够直接使用不缩小。末尾使用‘\0’，与c语言字符串兼容。</p>
<p>sds的源代码在sds.h与sds.c中。</p>
<h2 id="sds的定义"><a href="#sds的定义" class="headerlink" title="sds的定义"></a>sds的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;<span class="comment">// 兼容C</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> sdshdr &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;<span class="comment">// 字符串长度</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;<span class="comment">// 未分配的空间</span></div><div class="line">    <span class="keyword">char</span> buf[];<span class="comment">// 末尾'/0'的C风格字符串</span></div><div class="line">&#125;;<span class="comment">// SDS的实际结构，兼容char*则返回buf地址</span></div></pre></td></tr></table></figure>
<h2 id="SDS这样设计的优点："><a href="#SDS这样设计的优点：" class="headerlink" title="SDS这样设计的优点："></a>SDS这样设计的优点：</h2><ol>
<li>重用部分C字符串库函数的函数。</li>
<li>在常数复杂度的情况下获取字符串长度(以下代码)。</li>
<li>杜绝缓冲区溢出，通过获取空余空间函数，来进行处理(sdscat函数)。</li>
<li>减少字符串内存的重分配。不足则分配更大的空间，足够也不减少空间，而是记录新的len、free值。</li>
<li>二进制兼容。C字符串以空字符结尾，而某些二进制数据中间可能存在空字符。SDS兼容该种数据。</li>
</ol>
<a id="more"></a>
<h2 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h2><h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 获取字符串长度</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">return</span> sh-&gt;len;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取空余空间</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SDS创建"><a href="#SDS创建" class="headerlink" title="SDS创建"></a>SDS创建</h3><p>有两个函数，一个定长创建，一个是不定长创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (init) &#123;</div><div class="line">        <span class="comment">//为空则使用malloc</span></div><div class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//不为空使用calloc分配</span></div><div class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 分配失败处理</span></div><div class="line">    <span class="comment">//设定sds的参数</span></div><div class="line">    sh-&gt;len = initlen;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="comment">//值的复制</span></div><div class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</div><div class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</div><div class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;<span class="comment">// 尾部结束符</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制一个char*</span></div><div class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</div><div class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成一个空sd</span></div><div class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制一个sds</span></div><div class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds释放函数"><a href="#sds释放函数" class="headerlink" title="sds释放函数"></a>sds释放函数</h3><p>先获取sdshdr的首地址，使用zfree释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">  	<span class="comment">// 获取真实首地址释放</span></div><div class="line">    zfree(s-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds动态空间调整"><a href="#sds动态空间调整" class="headerlink" title="sds动态空间调整"></a>sds动态空间调整</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 空间增长</span></div><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh, *newsh;</div><div class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;<span class="comment">// 空间足够直接返回</span></div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    newlen = (len+addlen);<span class="comment">// 新的长度</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)<span class="comment">// 不足1MB直接翻倍分配</span></div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span><span class="comment">// 超过1MB，多分配1MB空余空间</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);<span class="comment">// 分配空间</span></div><div class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 分配失败</span></div><div class="line">    <span class="comment">// 设置参数</span></div><div class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line">    <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 空间的重分配</span></div><div class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line"></div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    sh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+sh-&gt;len+<span class="number">1</span>);</div><div class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> sh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds连接操作"><a href="#sds连接操作" class="headerlink" title="sds连接操作"></a>sds连接操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line">    <span class="keyword">size_t</span> curlen = sdslen(s); <span class="comment">// 获取字符串长度</span></div><div class="line"></div><div class="line">    s = sdsMakeRoomFor(s,len);<span class="comment">// 扩展字符串</span></div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);<span class="comment">// 连接字符串到末尾</span></div><div class="line">    sh-&gt;len = curlen+len;<span class="comment">// 设置长度</span></div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</div><div class="line">    s[curlen+len] = <span class="string">'\0'</span>;<span class="comment">// 设置尾部</span></div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds复制"><a href="#sds复制" class="headerlink" title="sds复制"></a>sds复制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</div><div class="line"></div><div class="line">    <span class="comment">// 空间不足，分配空间</span></div><div class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;</div><div class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</div><div class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 复制</span></div><div class="line">    <span class="built_in">memcpy</span>(s, t, len);</div><div class="line">    s[len] = <span class="string">'\0'</span>;</div><div class="line">    sh-&gt;len = len;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一些其他接口"><a href="#一些其他接口" class="headerlink" title="一些其他接口"></a>一些其他接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;<span class="comment">// 格式化输出</span></div><div class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>; <span class="comment">// 去除cset中所含字符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;<span class="comment">// 获取指定区间字符串</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>; <span class="comment">// 更新字符串长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>; <span class="comment">// 清空字符串</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span></span>; <span class="comment">// 字符串比较</span></div><div class="line"><span class="comment">// 依据sep将s分割，返回 一个二维数组</span></div><div class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span>;</div><div class="line"><span class="comment">// 释放由sdssplitlen函数解析的二维数组 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>; <span class="comment">// 转小写</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>; <span class="comment">// 转大写</span></div><div class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;<span class="comment">// ll转sds</span></div><div class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span></span>; <span class="comment">// 以分隔符连接字符串子数组构成新的字符串</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis没有使用c语言的字符串结构，自己设计了一个简单的动态字符串。特点是：修改时大小不足则扩容，大小足够直接使用不缩小。末尾使用‘\0’，与c语言字符串兼容。&lt;/p&gt;
&lt;p&gt;sds的源代码在sds.h与sds.c中。&lt;/p&gt;
&lt;h2 id=&quot;sds的定义&quot;&gt;&lt;a href=&quot;#sds的定义&quot; class=&quot;headerlink&quot; title=&quot;sds的定义&quot;&gt;&lt;/a&gt;sds的定义&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *sds;&lt;span class=&quot;comment&quot;&gt;// 兼容C&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; sdshdr &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len;&lt;span class=&quot;comment&quot;&gt;// 字符串长度&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// 未分配的空间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; buf[];&lt;span class=&quot;comment&quot;&gt;// 末尾&#39;/0&#39;的C风格字符串&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;span class=&quot;comment&quot;&gt;// SDS的实际结构，兼容char*则返回buf地址&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;SDS这样设计的优点：&quot;&gt;&lt;a href=&quot;#SDS这样设计的优点：&quot; class=&quot;headerlink&quot; title=&quot;SDS这样设计的优点：&quot;&gt;&lt;/a&gt;SDS这样设计的优点：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;重用部分C字符串库函数的函数。&lt;/li&gt;
&lt;li&gt;在常数复杂度的情况下获取字符串长度(以下代码)。&lt;/li&gt;
&lt;li&gt;杜绝缓冲区溢出，通过获取空余空间函数，来进行处理(sdscat函数)。&lt;/li&gt;
&lt;li&gt;减少字符串内存的重分配。不足则分配更大的空间，足够也不减少空间，而是记录新的len、free值。&lt;/li&gt;
&lt;li&gt;二进制兼容。C字符串以空字符结尾，而某些二进制数据中间可能存在空字符。SDS兼容该种数据。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书摘录-程序员的思维方式</title>
    <link href="http://www.coderyang.com//blog/2017/03/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F.html"/>
    <id>http://www.coderyang.com//blog/2017/03/读书摘录-程序员的思维方式.html</id>
    <published>2017-03-26T04:26:05.000Z</published>
    <updated>2017-03-26T04:58:09.151Z</updated>
    
    <content type="html"><![CDATA[<p>2.2 德雷福斯模型的5个阶段</p>
<p>2017-01-24</p>
<p>但是，如果给新手提供与情境无关的规则去参照，他们就会变得能干起来。也就是说，需要这种形式的规则：“当X发生时，执行Y。”换言之，需要一份指令清单。<br>图2-2　玉米饼食谱，不过你知道需要烹饪多长时间吗<br>这就是呼叫中心的工作原理。你可以雇用一大批对当前技术没有很多经验的人，然后让他们按照一个决策树按部就班地执行下去。</p>
<p>3.3 L型和R型的特征</p>
<p>2017-02-06</p>
<p>事实上，综合是一项非常强大的学习技术，以至于麻省理工学院媒体实验室的尼葛洛庞蒂在Don’t Dissect the Frog, Build It [Neg94]中建议，真正想要了解一只青蛙，传统的解剖不是办法，更好的方式是构造一只青蛙。<br>也就是说，要求学生构造一个具有青蛙特征的生物。这是一种伟大的方式，可以真正了解到，什么使青蛙成之为青蛙，以及青蛙如何适应其特定环境。这是一个综合学习的绝佳例子。</p>
<p>4.4 收获R型线索</p>
<p>2017-02-08</p>
<p>这种方法为什么会起作用？我认为这是因为晨写让毫无防备的大脑倾倒想法。早上刚起床时，你还没有像你想的那样清醒。潜意识仍然占主角。你还没有提起所有防备，也还未适应有限的现实世界。你可以直接连通R型，至少一小会儿。</p>
<p>2017-02-08</p>
<p>你需要培养一种非目标驱动的思维方式。正如庞加莱所做，把一切都写在纸上（或者编辑器中，如果你必须得这么做的话），然后不去管它。不要试图思考。记住它，如布朗所说，不要关注它。只要简单地记住它。让事实和问题自由地搅和、浸泡（我们将在8.2节讨论这一话题）</p>
<a id="more"></a>
<p>4.5 收获模式</p>
<p>2017-02-08</p>
<p>“在开始练习武术之后，我感觉到我的注意力持续时间和控制能力（比如在糟糕的环境下集中注意力）都有了提高。我一直在向软件开发人员和其他知识工作者推荐我的实践经验。它就是气功，它既有武术的一面，也包含太极、冥想和呼吸的方面。</p>
<p>注</p>
<p>跑步应该也行的。</p>
<p>6.2 瞄准SMART目标</p>
<p>2017-03-05</p>
<p>使用SMART方法实现你的目标。<br>在这里，SMART代表具体的、可度量的、可实现的、相关的和时间可控的（Specific, Measurable, Achievable, Relevant, and Time-boxed）。对于任何目标（减肥、炒老板鱿鱼、征服世界等），你都需要制定一个计划，定出一系列帮助你实现目标的任务（objective）。每一个任务都应该具有SMART特性。</p>
<p>6.3 建立一个务实的投资计划</p>
<p>2017-03-05</p>
<p>就像任何投资一样——无论是金融还是艺术上的——都必须时刻进行管理。<br>很多年来，戴维·托马斯（Dave Thomas）和我一直把实用投资计划作为咨询实践的一部分，在这里我简单地介绍一下这些内容。实用投资计划基于一种非常简单但是有效的理念：像管理你的金融投资一样小心管理你的知识投资。</p>
<p>6.4 使用你的原生学习模式</p>
<p>2017-03-05</p>
<p>很多教育家把学习者分为三大类：视觉型、听觉型和动觉型。<br>视觉型学习者需要看到学习资料和老师。图片和图表对视觉型学习者都很有效，他们对肢体语言和面部表情也很敏感。<br>听觉型学习者必须听到学习材料。讲座、研讨会和播客都很有效。他们对语气、语速和其他细节都很敏感。<br>动觉型学习者通过活动和触摸来学习。他们需要亲身感受学习材料。特别是对运动、艺术和<br>工艺等领域，你都需要通过动手来学习。</p>
<p>6.9 利用文档的真正力量</p>
<p>2017-03-05</p>
<p>创建低层次的设计文档，简单地反映代码的细节（几乎很快就会过时）对任何人都没有意义。但是其他形式的文档可能是有价值的，即使没有明确的读者。</p>
<p>6.10 以教代学</p>
<p>2017-03-05</p>
<p>为了省掉你的同事过来，我们建议你在桌子上摆一只黄色橡皮鸭作替身，当你遇到问题时，先和它<br>聊聊。<br>另一种有用的办法是尝试向一个孩子或者你所在领域之外的人解释你的东西。诀窍就是用他们能理解的话语进行解释。这是一个向你的Edna大婶解释你的工作的好机会，也是一个练习从听众角度观察问题并创建隐喻的好机会，这些隐喻有助于解释、阐明你的工作。你可能会在这个过程中惊奇地发现一些新的收获和领悟。</p>
<p>第7章 积累经验</p>
<p>2017-03-05</p>
<p>我们应该小心翼翼地从实践中获得智慧并适可而止，否则我们就会像不慎坐在热炉子上的猫一样，它再也不会坐在热炉子上——这还好，但是它也再也不会坐在冷炉子上。<br>——马克·吐温</p>
<p>7.3 正确对待实践中的失败</p>
<p>2017-03-05</p>
<p>你可以在公司范围之外尝试，比如在家里做开源项目。这起码会减少产生负面结果的风险。但是仅仅这样不足以为你建立一个积极的学习环境。不论是在公司团队还是在黑夜里偷偷进行的独自实验，你都需要做到以下几点。</p>
<p>7.4 了解内在诀窍</p>
<p>2017-03-05</p>
<p>在采取纠正行动之前完全知道“这是什么”对于调试非常重要。太多程序员（包括我自己）往往在没有完全明白真正的错误是什么之前就着急修正它。匆忙地作出判断或者过早地进行修补。你需要首先完全明白系统的原理，然后再判断哪部分错了，最后提供解决方案。也就说，不要动手做，而是要袖手旁观。琼·金姆介绍下述方法来帮助大家充分了解。</p>
<p>8.2 通过分散注意力来集中注意力</p>
<p>2017-03-05</p>
<p>怎么区分你是在浸泡思想还是在拖延、浪费时间呢？<br>我总是把拖延称为“做纸娃娃”。一个密友（姓名保密）第二天有一门重要的考试，但是前一天晚上，她并不学习，而是坐在沙发上剪纸娃娃。当时这在我看来就是典型的耗费时间：一个无关的非生产性的活动阻碍了你需要做的真正工作。<br>但也许我错了。也许这不是拖延。这是一个高级触觉练习，也许是她浸泡思想的方法。她通过了测验并以优异成绩毕业。<br>如果某个任务你真的不想做，那么任何分散注意力的努力都很可能只是耗费时间。如果你仍然有兴趣，但感觉“困难”，那么思想其实是在继<br>续发酵，这当然没问题。</p>
<p>8.6 保持足够大的情境</p>
<p>2017-03-05</p>
<p>事实上，保持情境中任务相关的东西很有益处。不论你如何衡量生产力，仅仅多使用一台显示器就可以让你的生产力提升20%~30%。<br>这是为什么？<br>适合你的不是桌面隐喻，而是Frederick Brooks在几年前描述的拥挤的飞机座位隐喻。在一个大桌面上，你可以展开你的工作，看到你在做什么——同时看到所有的。在拥挤的飞机座位上，你没有足够的空间同时看两份以上的文档（或者文档的一部分）。你必须来回地切换文档。<br>我敢打赌，让你去Staples或者Office Depot等办公用品店寻找一张17英寸的办公桌，你找不到，因为这个尺寸实在是太小了。然而，大多数显示器都是17到21英寸。这点空间就是我们办公的地方。你不得不在活动窗口和应用程序之间切换，因为你无法在如此小的空间里保持足够的情境。<br>你知道Alt-Tab组合键（Mac上的Command-Tab）称为什么吗?情境切换。正如我们看到的，情景切换扼杀生产力。即使是类似使用Alt-Tab切换不同窗口的小动作也会花费时间、短期记忆力和精力。</p>
<p>2017-03-05</p>
<p>在最先进的操作系统上你可以使用虚拟桌面切换器，允许你拥有很多不同的屏幕，你可以使用特殊键随意切换。每一个屏幕都是独立的，称为工作空间。秘诀在于你如何在工作空间中分配应用。</p>
<p>9.2 明天上午做什么</p>
<p>2017-03-05</p>
<p>现在就开始吧！你选择开始做什么并不特别重要，重要的是主动尝试本书中提到的知识，这是你明天一大早要做的第一件事。<br>下面是对第一步的一些建议。<br>开始承担责任，不要害怕问“为什么”，也不要害怕问“你怎么知道的”或者“我怎么知道的”，同样要大方地回答“我目前还不知道”。<br>挑两件帮助你维持情境、免受干扰的事情，立即实施。<br>创建一个实用投资计划，设定SMART目标。<br>弄清楚你在所属专业领域中所处的位置（从新手到专家）和你期望的位置。保证诚实。你需要更多的诀窍还是更多的情境？更多规则还是更多直觉？<br>实践。某段代码遇到问题了吗？尝试用五种不同的方式编写。<br>允许犯更多错误——错误是许可的，要从中学习教训。<br>携带一个笔记本（最好不带横线）。涂鸦，做思维导图，记笔记。让你的思想自由地流动。<br>打开心扉接收美感和其他的感官输入。不论是<br>你的房间、桌面还是代码，关注它们是多么地赏心悦目。<br>开始在私人wiki上记录你感兴趣的事情。<br>开始写博客。为你读过的书写评论。阅读更多书，你会有更多可写的东西。使用SQ3R和思维导图。<br>让散步成为你每天生活的一部分。<br>启动一个读书小组。<br>再拿一个显示器，开始使用虚拟桌面。<br>回顾每章的“实践单元”，尝试去做。</p>
<p>9.3 超越专家</p>
<p>2017-03-05</p>
<p>达芬奇在600年前抱怨说：“人们看却没有看见，听却没有听见，吃却没有味觉，接触却没有触觉，说话却没有思考。”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2.2 德雷福斯模型的5个阶段&lt;/p&gt;
&lt;p&gt;2017-01-24&lt;/p&gt;
&lt;p&gt;但是，如果给新手提供与情境无关的规则去参照，他们就会变得能干起来。也就是说，需要这种形式的规则：“当X发生时，执行Y。”换言之，需要一份指令清单。&lt;br&gt;图2-2　玉米饼食谱，不过你知道需要烹饪多长时间吗&lt;br&gt;这就是呼叫中心的工作原理。你可以雇用一大批对当前技术没有很多经验的人，然后让他们按照一个决策树按部就班地执行下去。&lt;/p&gt;
&lt;p&gt;3.3 L型和R型的特征&lt;/p&gt;
&lt;p&gt;2017-02-06&lt;/p&gt;
&lt;p&gt;事实上，综合是一项非常强大的学习技术，以至于麻省理工学院媒体实验室的尼葛洛庞蒂在Don’t Dissect the Frog, Build It [Neg94]中建议，真正想要了解一只青蛙，传统的解剖不是办法，更好的方式是构造一只青蛙。&lt;br&gt;也就是说，要求学生构造一个具有青蛙特征的生物。这是一种伟大的方式，可以真正了解到，什么使青蛙成之为青蛙，以及青蛙如何适应其特定环境。这是一个综合学习的绝佳例子。&lt;/p&gt;
&lt;p&gt;4.4 收获R型线索&lt;/p&gt;
&lt;p&gt;2017-02-08&lt;/p&gt;
&lt;p&gt;这种方法为什么会起作用？我认为这是因为晨写让毫无防备的大脑倾倒想法。早上刚起床时，你还没有像你想的那样清醒。潜意识仍然占主角。你还没有提起所有防备，也还未适应有限的现实世界。你可以直接连通R型，至少一小会儿。&lt;/p&gt;
&lt;p&gt;2017-02-08&lt;/p&gt;
&lt;p&gt;你需要培养一种非目标驱动的思维方式。正如庞加莱所做，把一切都写在纸上（或者编辑器中，如果你必须得这么做的话），然后不去管它。不要试图思考。记住它，如布朗所说，不要关注它。只要简单地记住它。让事实和问题自由地搅和、浸泡（我们将在8.2节讨论这一话题）&lt;/p&gt;
    
    </summary>
    
      <category term="摘录" scheme="http://www.coderyang.com/categories/%E6%91%98%E5%BD%95/"/>
    
    
      <category term="杂谈" scheme="http://www.coderyang.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-内存分配</title>
    <link href="http://www.coderyang.com//blog/2017/03/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html"/>
    <id>http://www.coderyang.com//blog/2017/03/redis源码阅读-内存分配.html</id>
    <published>2017-03-21T02:21:33.000Z</published>
    <updated>2017-04-16T07:12:34.561Z</updated>
    
    <content type="html"><![CDATA[<p>redis的内存分配主要就是对malloc和free进行了一层简单的封装。具体的实现在zmalloc.h和zmalloc.c中。</p>
<h2 id="内存分配器的选择"><a href="#内存分配器的选择" class="headerlink" title="内存分配器的选择"></a>内存分配器的选择</h2><p>redis支持多种内存分配器，可以选择的分配器tcmalloc、jemalloc、dlmalloc、malloc/malloc.h(apple)，这几个分配器自带内存大小的记录。如果不进行设置，则默认使用malloc进行分配。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// zmalloc.h</span></div><div class="line"><span class="comment">// 选择使用的内存分配器，分别为tcmalloc、jemalloc、dlmalloc、malloc/malloc.h</span></div><div class="line"><span class="comment">// 同时设置HAVE_MALLOC_SIZE为真，内存分配器自带大小统计。</span></div><div class="line"><span class="comment">// 如果不选择内存分配器，则使用默认的malloc，同时同时设置HAVE_MALLOC_SIZE为假。</span></div><div class="line"><span class="comment">// 指定zmalloc_size</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"tcmalloc-"</span> __xstr(TC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(TC_VERSION_MINOR))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6) || (TC_VERSION_MAJOR &gt; 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) tc_malloc_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of tcmalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"jemalloc-"</span> __xstr(JEMALLOC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_MINOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_BUGFIX))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jemalloc/jemalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (JEMALLOC_VERSION_MAJOR == 2 &amp;&amp; JEMALLOC_VERSION_MINOR &gt;= 1) || (JEMALLOC_VERSION_MAJOR &gt; 2)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) je_malloc_usable_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of jemalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) malloc_size(p)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_DLMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Win32_Interop/win32_dlmalloc.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"dlmalloc-"</span> __xstr(2) <span class="meta-string">"."</span> __xstr(8) )</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p)  g_msize(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ZMALLOC_LIB</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB <span class="meta-string">"libc"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// zmalloc.c</span></div><div class="line"><span class="comment">// 依据选择的内存分配器，设定好宏定义，否则使用系统默认分配。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) tc_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) tc_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) tc_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) tc_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) je_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) je_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) je_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) je_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_DLMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) g_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) g_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) g_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) g_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h2 id="功能函数一栏"><a href="#功能函数一栏" class="headerlink" title="功能函数一栏"></a>功能函数一栏</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void *zmalloc(size_t size);// 调用malloc，分配size大小的空间</div><div class="line">void *zcalloc(size_t size);// 调用calloc，分配size大小的空间</div><div class="line">void *zrealloc(void *ptr, size_t size);// 调用realloc，重新分配size大小的空间</div><div class="line">void zfree(void *ptr);// 释放ptr</div><div class="line">char *zstrdup(const char *s);// c风格字符串copy</div><div class="line">size_t zmalloc_used_memory(void); // 获取当前占用的内存大小</div><div class="line">void zmalloc_enable_thread_safeness(void); // 设置线程安全</div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)); // 设置内存分配失败的处理方法</div><div class="line">float zmalloc_get_fragmentation_ratio(size_t rss);// 获取所给内存和已经使用的内存大小之比</div><div class="line">size_t zmalloc_get_rss(void); // 获取RSS信息（Resident Set Size）</div><div class="line">size_t zmalloc_get_private_dirty(void);// 获取实际内存大小</div><div class="line">size_t zmalloc_get_smap_bytes_by_field(char *field);// 获取/proc/self/smaps字段的字节数</div><div class="line">void zlibc_free(void *ptr); // 获取物理内存大小</div><div class="line">WIN32_ONLY(void zmalloc_free_used_memory_mutex(void);) //原始系统free的释放方法</div></pre></td></tr></table></figure>
<h2 id="统计使用的内存总数"><a href="#统计使用的内存总数" class="headerlink" title="统计使用的内存总数"></a>统计使用的内存总数</h2><p>redis每次分配内存、释放内存都会进行记录。用来统计redis使用的总内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;<span class="comment">// 获取使用的内存，直接获取used_memory的变量的值。</span></div><div class="line">    <span class="keyword">size_t</span> um;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123;<span class="comment">// 线程安全</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC)</span></div><div class="line">        um = update_zmalloc_stat_add(<span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        pthread_mutex_lock(&amp;used_memory_mutex);</div><div class="line">        um = used_memory;</div><div class="line">        pthread_mutex_unlock(&amp;used_memory_mutex);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 非线程安全</span></div><div class="line">        um = used_memory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> um;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;<span class="comment">// 定义了一个全局变量，用来记录使用的内存数量。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;<span class="comment">// 默认不线程安全，调用zmalloc_enable_thread_safeness进行设置为线程安全。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32<span class="comment">// 根据系统选择多线程锁。</span></span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// __ATOMIC_RELAXED提供原子加减操作</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) __atomic_add_fetch(&amp;used_memory, (__n), __ATOMIC_RELAXED)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) __atomic_sub_fetch(&amp;used_memory, (__n), __ATOMIC_RELAXED)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAVE_ATOMIC)<span class="comment">// GCC提供的原子加减操作</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) __sync_add_and_fetch(&amp;used_memory, (__n))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) __sync_sub_and_fetch(&amp;used_memory, (__n))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">// 使用多线程锁来实现多线程加减操作</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory += (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; while(0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory -= (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; while(0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// 增加redis内存计数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="meta-keyword">if</span> (_n&amp;(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&amp;(sizeof(PORT_LONG)-1)); \ <span class="comment">// 将n调整为sizeof(PORT_LONG)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \ <span class="comment">// 开启线程安全</span></div><div class="line">        update_zmalloc_stat_add(_n); \</div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory += _n; \ <span class="comment">// 不开启线程安全</span></div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment">// 减少redis内存计数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="meta-keyword">if</span> (_n&amp;(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&amp;(sizeof(PORT_LONG)-1)); \ <span class="comment">// 将n调整为sizeof(PORT_LONG)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_sub(_n); \<span class="comment">// 开启线程安全</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory -= _n; \<span class="comment">// 不开启线程安全</span></div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h2 id="内存管理函数"><a href="#内存管理函数" class="headerlink" title="内存管理函数"></a>内存管理函数</h2><h3 id="异常处理函数"><a href="#异常处理函数" class="headerlink" title="异常处理函数"></a>异常处理函数</h3><p>异常处理函数, 在内存分配失败时进行调用。</p>
<p>默认使用zmalloc_default_oom，也可以通过zmalloc_set_oom_handler进行设置异常处理方式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;</div><div class="line"></div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) &#123;</div><div class="line">    zmalloc_oom_handler = oom_handler;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void zmalloc_default_oom(size_t size) &#123;</div><div class="line">    fprintf(stderr, "zmalloc: Out of memory trying to allocate %Iu bytes\n",    WIN_PORT_FIX /* %zu -&gt; %Iu */</div><div class="line">        size);// 打印日志</div><div class="line">    fflush(stderr);</div><div class="line">    abort();// 中断退出</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zmalloc"><a href="#zmalloc" class="headerlink" title="zmalloc"></a>zmalloc</h3><p>zmalloc用来分配指定大小的内存。实际上对malloc进行了一层封装，加入了异常处理和内存统计。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用malloc进行内存分配</span></div><div class="line">    <span class="comment">// 多出的PREFIX_SIZE大内存用来记录该段内存大小。</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 分配失败的异常处理</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 统计内存使用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line"></div><div class="line">    <span class="comment">// 内存分配器自带内存大小</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zcalloc"><a href="#zcalloc" class="headerlink" title="zcalloc"></a>zcalloc</h3><p>calloc是分配内存，并初始化为0。封装的和zmalloc类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配内存</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 分配失败的异常处理</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 统计内存使用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zrealloc"><a href="#zrealloc" class="headerlink" title="zrealloc"></a>zrealloc</h3><p>zrealloc用来重新调整分配的内存大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line">    <span class="keyword">void</span> *newptr;</div><div class="line"></div><div class="line">    <span class="comment">// ptr为空，直接使用zmalloc进行分配size大小内存。</span></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    oldsize = zmalloc_size(ptr); <span class="comment">// 获取ptr指向的内存大小</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(ptr,size); <span class="comment">// 重新分配内存</span></div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size); <span class="comment">// 异常处理</span></div><div class="line"></div><div class="line">    update_zmalloc_stat_free(oldsize);<span class="comment">// 先减</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));<span class="comment">// 后加</span></div><div class="line">    <span class="keyword">return</span> newptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);<span class="comment">// 获取ptr指向的内存大小</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);<span class="comment">// 重新分配内存</span></div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);<span class="comment">// 异常处理</span></div><div class="line"></div><div class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</div><div class="line">    update_zmalloc_stat_free(oldsize);<span class="comment">// 先减</span></div><div class="line">    update_zmalloc_stat_alloc(size);<span class="comment">// 后加</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zfree"><a href="#zfree" class="headerlink" title="zfree"></a>zfree</h3><p>释放函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">// 空直接返回</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));<span class="comment">// 减少统计数量</span></div><div class="line">    <span class="built_in">free</span>(ptr);<span class="comment">// 释放</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE; <span class="comment">// 获取真实的指针</span></div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);<span class="comment">// 获取大小</span></div><div class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);<span class="comment">// 减少统计数量</span></div><div class="line">    <span class="built_in">free</span>(realptr);<span class="comment">// 释放</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zmalloc-size"><a href="#zmalloc-size" class="headerlink" title="zmalloc_size"></a>zmalloc_size</h3><p>获取指针指向内存大小，在内存分配器不自带该函数时定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// zmalloc.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">// zmalloc.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</div><div class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(PORT_LONG) by</span></div><div class="line">     * the underlying allocator. */</div><div class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(PORT_LONG)-(size&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>));</div><div class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis的内存分配主要就是对malloc和free进行了一层简单的封装。具体的实现在zmalloc.h和zmalloc.c中。&lt;/p&gt;
&lt;h2 id=&quot;内存分配器的选择&quot;&gt;&lt;a href=&quot;#内存分配器的选择&quot; class=&quot;headerlink&quot; title=&quot;内存分配器的选择&quot;&gt;&lt;/a&gt;内存分配器的选择&lt;/h2&gt;&lt;p&gt;redis支持多种内存分配器，可以选择的分配器tcmalloc、jemalloc、dlmalloc、malloc/malloc.h(apple)，这几个分配器自带内存大小的记录。如果不进行设置，则默认使用malloc进行分配。&lt;/p&gt;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-开始</title>
    <link href="http://www.coderyang.com//blog/2017/03/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B.html"/>
    <id>http://www.coderyang.com//blog/2017/03/redis源码阅读-开始.html</id>
    <published>2017-03-21T02:21:21.000Z</published>
    <updated>2017-07-18T07:34:45.757Z</updated>
    
    <content type="html"><![CDATA[<p>自本博客之后的文章大概都是依照《Redis设计与实现》对Redis的源码进行阅读的记录。目的是为了对于Redis有一个了解，同时对之后需要使用Redis的项目上能够有所帮助。</p>
<h2 id="Redis的介绍"><a href="#Redis的介绍" class="headerlink" title="Redis的介绍"></a>Redis的介绍</h2><p>redis是一个使用C编写的key-value数据库。性能极高且支持丰富的数据类型。它所有的操作都是原子性的。代码精简，只有3w行不到，利于阅读。</p>
<h2 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h2><p><a href="http://blog.huangz.me/diary/2014/how-to-read-redis-source-code.html" target="_blank" rel="external">如何阅读Redis源码？</a>阅读的顺序主要还是按照黄建宏老师所建议的顺序进行阅读,暂时不看多机部分的实现。</p>
<ol>
<li>阅读数据结构的实现。</li>
<li>阅读内存编码数据结构的实现。</li>
<li>阅读数据类型的实现。</li>
<li>阅读数据库实现相关代码。</li>
<li>阅读客户端和服务端相关代码。</li>
</ol>
<p>至此将Redis阅读完毕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自本博客之后的文章大概都是依照《Redis设计与实现》对Redis的源码进行阅读的记录。目的是为了对于Redis有一个了解，同时对之后需要使用Redis的项目上能够有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;Redis的介绍&quot;&gt;&lt;a href=&quot;#Redis的介绍&quot; class=&quot;
    
    </summary>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="redis" scheme="http://www.coderyang.com/tags/redis/"/>
    
      <category term="源码阅读" scheme="http://www.coderyang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
