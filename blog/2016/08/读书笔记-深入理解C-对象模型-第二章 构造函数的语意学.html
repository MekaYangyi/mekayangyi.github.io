<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学 | 鉴心</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第二章：构造函数语意学由于C++的编译器在程序员之外做了太多事情，导致会产生很多意料之外的错误。例子 Conversion运算符。123456789//为了支持if(cin);//定义了一个perator int()//但是导致了以下错误的代码能够正常运行int inVal;cin &amp;lt;&amp;lt; inVal;//此处&amp;lt;&amp;lt;被解释为左移操作符int temp = cin.operato">
<meta property="og:type" content="article">
<meta property="og:title" content="[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学">
<meta property="og:url" content="http://yoursite.com/child/blog/2016/08/读书笔记-深入理解C-对象模型-第二章 构造函数的语意学.html">
<meta property="og:site_name" content="鉴心">
<meta property="og:description" content="第二章：构造函数语意学由于C++的编译器在程序员之外做了太多事情，导致会产生很多意料之外的错误。例子 Conversion运算符。123456789//为了支持if(cin);//定义了一个perator int()//但是导致了以下错误的代码能够正常运行int inVal;cin &amp;lt;&amp;lt; inVal;//此处&amp;lt;&amp;lt;被解释为左移操作符int temp = cin.operato">
<meta property="og:updated_time" content="2016-10-16T06:35:48.495Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学">
<meta name="twitter:description" content="第二章：构造函数语意学由于C++的编译器在程序员之外做了太多事情，导致会产生很多意料之外的错误。例子 Conversion运算符。123456789//为了支持if(cin);//定义了一个perator int()//但是导致了以下错误的代码能够正常运行int inVal;cin &amp;lt;&amp;lt; inVal;//此处&amp;lt;&amp;lt;被解释为左移操作符int temp = cin.operato">
  
    <link rel="alternate" href="/atom.xml" title="鉴心" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">鉴心</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com/child"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-读书笔记-深入理解C-对象模型-第二章 构造函数的语意学" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/08/读书笔记-深入理解C-对象模型-第二章 构造函数的语意学.html" class="article-date">
  <time datetime="2016-08-07T10:36:20.000Z" itemprop="datePublished">2016-08-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [读书笔记]深入理解C++对象模型 第二章 构造函数的语意学
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第二章：构造函数语意学"><a href="#第二章：构造函数语意学" class="headerlink" title="第二章：构造函数语意学"></a>第二章：构造函数语意学</h1><p>由于C++的编译器在程序员之外做了太多事情，导致会产生很多意料之外的错误。<br>例子 Conversion运算符。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为了支持</span></div><div class="line"><span class="keyword">if</span>(<span class="built_in">cin</span>);</div><div class="line"><span class="comment">//定义了一个perator int()</span></div><div class="line"><span class="comment">//但是导致了以下错误的代码能够正常运行</span></div><div class="line"><span class="keyword">int</span> inVal;</div><div class="line"><span class="built_in">cin</span> &lt;&lt; inVal;</div><div class="line"><span class="comment">//此处&lt;&lt;被解释为左移操作符</span></div><div class="line"><span class="keyword">int</span> temp = <span class="built_in">cin</span>.<span class="keyword">operator</span> <span class="keyword">int</span>();</div><div class="line">temp &lt;&lt; intVal;</div></pre></td></tr></table></figure></p>
<h1 id="Default-Constructor的构建操作"><a href="#Default-Constructor的构建操作" class="headerlink" title="Default Constructor的构建操作"></a>Default Constructor的构建操作</h1><p>默认构造函数只在编译器认为需要的时候才创建。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo&#123;<span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    Foo test;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>这种情况实际没有默认构造函数，编译器什么都没做。<br><a id="more"></a></p>
<h2 id="带有Default-Constructor的-Member-class-Object"><a href="#带有Default-Constructor的-Member-class-Object" class="headerlink" title="带有Default Constructor的 Member class Object"></a>带有Default Constructor的 Member class Object</h2><p>如果一个Class没有任何构造函数，但是包含一个member object，而后者又有default constructor，那么会在constructor真正被调用时合成出一个默认构造函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">classFoo &#123;<span class="keyword">public</span>: Foo(),Foo(<span class="keyword">int</span>);...&#125;;</div><div class="line">classBar &#123;<span class="keyword">public</span>: Foofoo; <span class="keyword">char</span> *str;&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</div><div class="line">   Bar bar; <span class="comment">//Bar::foo应在此处被初始化</span></div><div class="line">   <span class="keyword">if</span>(str)&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时的Bar合成默认构造函数会调用Foo的默认构造函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Bar::Bar()</div><div class="line">&#123; </div><div class="line">    foo.Foo::Foo(); <span class="comment">//合成出的</span></div><div class="line">    <span class="comment">//但是str等成员是不会管的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果已经写了一个默认构造函数，那么就会扩张该函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Bar::Bar()</div><div class="line">&#123; </div><div class="line">    foo.Foo::Foo(); <span class="comment">//扩展的</span></div><div class="line">    str=<span class="number">0</span>;<span class="comment">//程序员代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C++会以member objects在class中声明的次序来调用各个构造函数，由编译器完成。如果成员没有默认构造函数的话，就不会有扩张。</p>
<h2 id="带有Default-Constructor的-Base-Class"><a href="#带有Default-Constructor的-Base-Class" class="headerlink" title="带有Default Constructor的 Base Class"></a>带有Default Constructor的 Base Class</h2><p>一个没有任何构造函数的类派生子一个带有默认构造函数的基类，那么会合成出一个一个默认构造函数，调用上一层的默认构造函数（根据声明次序）。<br>如果是一个有多个构造函数的类，但是没有默认构造函数，则会扩张每一个构造函数，加入有必要的基类部分的默认构造。<br>但是不会合成默认构造函数，因为已经存在了程序员编写的构造函数。<br>如果也存在带有构造函数的成员，那么会在基类的部分构造之后，调用这些成员的构造函数。</p>
<h2 id="带有一个Virtual-Function的-Class"><a href="#带有一个Virtual-Function的-Class" class="headerlink" title="带有一个Virtual Function的 Class"></a>带有一个Virtual Function的 Class</h2><p>另有两种情况，也需要合成出default constructor</p>
<blockquote>
<ul>
<li>class声明（或者继承）一个virtual function</li>
<li>class派生自一个继承串链，其中有一个或者更多的virtual base classes</li>
</ul>
</blockquote>
<p>如果程序员没有声明自己的构造函数，编译器就会详细记录合成一个default constructor的必要信息。<br>编译器需要做以下的几个功能：</p>
<blockquote>
<ul>
<li>一个virtual function table会被编译器产生出来，内放class的virtual function地址。</li>
<li>在每一个class object中，一个额外的pointer member会被编译器合成，内含相关的classs vtbl的地址。</li>
</ul>
</blockquote>
<p>此外如果必要，虚函数表的部分会被重写，以改变为需要的情况。<br>为了支持这种功能，编译器必须为每个w对象设置它的vptr（这是成员变量，此时需要指向合适的vtbl），因此编译器需要在default ctor中安插一些代码来完成这种工作。</p>
<h2 id="带有一个Virtual-Base-Class-的Class"><a href="#带有一个Virtual-Base-Class-的Class" class="headerlink" title="带有一个Virtual Base Class 的Class"></a>带有一个Virtual Base Class 的Class</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">classX &#123; <span class="keyword">public</span>: inti; &#125;;</div><div class="line">classA : publicvirtualX   &#123; <span class="keyword">public</span>: intj; &#125;;</div><div class="line">classB : publicvirtualX   &#123; <span class="keyword">public</span>: doubled; &#125;;</div><div class="line">classC : publicA, publicB &#123; <span class="keyword">public</span>: intk; &#125;;</div><div class="line"><span class="comment">//无法在编译期间解析出 pa-&gt;i 的位置（给一个pa无法确定i的地址）。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( constA* pa )</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</div><div class="line">main() &#123;</div><div class="line">   foo( <span class="keyword">new</span> A );</div><div class="line">   foo( <span class="keyword">new</span> C );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//由于pa的真正类型不确定，所以某些编译器会记录一个指针例（如 __vbcX）来记录X，然后通过这个指针来定位pa指向的i。</span></div><div class="line"><span class="comment">//上述</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( constA* pa )</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</div><div class="line"><span class="comment">//变成了：</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( constA* pa )</span> </span>&#123; pa-&gt; __vbcX -&gt;i = <span class="number">1024</span>; &#125;</div></pre></td></tr></table></figure>
<p>其中<strong>vbcX标示编译器产生的指针，指向 virtual base class X。
</strong>vbcX需要在每一个构造函数按错那么“允许每一个 virtual base class的执行期间存取操作“的码。如果class没有声明任何构造函数，就需要合成一个默认构造函数。</p>
<h1 id="Copy-Constructor的构建操作"><a href="#Copy-Constructor的构建操作" class="headerlink" title="Copy Constructor的构建操作"></a>Copy Constructor的构建操作</h1><p>有三种情况会执行拷贝构造函数：</p>
<blockquote>
<ul>
<li>显式的使用 =</li>
<li>传参</li>
<li>返回</li>
</ul>
</blockquote>
<h2 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h2><p>一个class没有提供显式的拷贝构造函数的话，那么利用Memberwise Initialization(对每一个成员将源对象所有的member复制给目标对象)</p>
<h2 id="非逐位拷贝"><a href="#非逐位拷贝" class="headerlink" title="非逐位拷贝"></a>非逐位拷贝</h2><blockquote>
<ul>
<li>这个类的某个member object有拷贝构造函数。（不管成员的拷贝构造函数是合成的还是显式的定义的，都需要合成一个拷贝构造函数）。</li>
<li>这个类继承自某个有copy ctor的base class。（同上）。</li>
<li>这个类声明了若干个virtual function。（如果继承的基类有virtual function那么一定有拷贝构造函数，符合第二条。）</li>
<li>这个类派生自的继承链中有virtual base class。</li>
</ul>
</blockquote>
<p>第三四种情况需要合成的复制构造函数构建正确的虚表指针给每一个对象。<br>因为复制构造函数可以 派生类赋值给基类。那么派生类的虚表指针是没法用逐位拷贝来赋值，需要一个合成的复制构造函数正确的设定虚表指针。</p>
<h1 id="程序转化语意学"><a href="#程序转化语意学" class="headerlink" title="程序转化语意学"></a>程序转化语意学</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    X xx;</div><div class="line">    <span class="keyword">return</span> xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个人可能会做出以下假设：</p>
<blockquote>
<ul>
<li>每次foo()调用，就会传回xx的值.</li>
<li>如果class X定义了一个拷贝构造函数，那么每次调用foo()，保证该拷贝构造函数也会被调用。</li>
</ul>
</blockquote>
<p>均不一定。move语意和外面没有接收的可能导致以上假设不一定。</p>
<h2 id="明确的初始化操作"><a href="#明确的初始化操作" class="headerlink" title="明确的初始化操作"></a>明确的初始化操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">X x0;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;             <span class="comment">//定义了x1</span></div><div class="line">   X x2 = x0;           <span class="comment">//定义了x2</span></div><div class="line">   X x3 = X(x0);       <span class="comment">//定义了x3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//转化的两个动作<br>//即变成了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</div><div class="line">   X x1;    <span class="comment">//定义被重写，初始化操作被剥除</span></div><div class="line">   X x2;    <span class="comment">//定义被重写，初始化操作被剥除</span></div><div class="line">   X x3;    <span class="comment">//定义被重写，初始化操作被剥除</span></div><div class="line"></div><div class="line">   <span class="comment">//编译器安插X copy ctor。</span></div><div class="line">   x1.X::X( x0 );</div><div class="line">   x2.X::X( x0 );</div><div class="line">   x3.X::X( x0 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中:<br>x1.X::X( x0 );<br>会表现为对拷贝构造函数的调用：<br> X::X( constX&amp; xx);）</p>
<h2 id="参数的初始化"><a href="#参数的初始化" class="headerlink" title="参数的初始化"></a>参数的初始化</h2><p> 如下代码的变化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x0)</span></span>;</div><div class="line"><span class="comment">//...</span></div><div class="line">X xx;</div><div class="line">foo(xx)</div></pre></td></tr></table></figure></p>
<p>这种方式把函数的参数变成了引用，然后将拷贝构造函数构造的参数传入。<br>变成了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X&amp; x0)</span></span>;</div><div class="line"><span class="comment">//...</span></div><div class="line">X __tmp;</div><div class="line">__tmp.X::X( XX );</div><div class="line">foo(__tmp);</div></pre></td></tr></table></figure></p>
<p>其中X声明了destructor，它在foo调用完成后销毁暂时性的对象。</p>
<h2 id="返回初始值"><a href="#返回初始值" class="headerlink" title="返回初始值"></a>返回初始值</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="function">X <span class="title">bar</span><span class="params">()</span></span>&#123;</div><div class="line">   X xx;</div><div class="line">   <span class="comment">//...</span></div><div class="line">   <span class="keyword">return</span> xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先添加一个额外的引用参数，然后在返回之前调用一个复制构造函数构造这个返回对象。<br>于是变成了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X&amp; _result)</span></span>&#123;</div><div class="line">   X xx;</div><div class="line">   <span class="comment">//...</span></div><div class="line">   _result.X::X(xx);</div><div class="line">   <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">X xx = bar();</div><div class="line"><span class="comment">//转换为</span></div><div class="line">X xx;</div><div class="line">bar(xx);</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bar().memfunc();</div><div class="line"><span class="comment">//可能转换为</span></div><div class="line">X _temp0;</div><div class="line">(bar(_temp0), _temp0).memfunc();</div></pre></td></tr></table></figure>
<h2 id="在使用者层面的优化"><a href="#在使用者层面的优化" class="headerlink" title="在使用者层面的优化"></a>在使用者层面的优化</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">X <span class="title">bar</span><span class="params">(<span class="keyword">const</span> T &amp;y,  <span class="keyword">const</span> T &amp;z)</span></span></div><div class="line">&#123;</div><div class="line">    X xx;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而是定义一个新的构造函数，这样在转换之后效率更高<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">X <span class="title">bar</span><span class="params">(<span class="keyword">const</span> T &amp;y,  <span class="keyword">const</span> T &amp;z)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> X(y , z);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 转换后<br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result, <span class="keyword">const</span> T &amp;y,  <span class="keyword">const</span> T &amp;z)</span></span></div><div class="line">&#123;</div><div class="line">    _result X::X(y, z);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="在编译器层面优化"><a href="#在编译器层面优化" class="headerlink" title="在编译器层面优化"></a>在编译器层面优化</h2><p>  就是上面那个转换代码</p>
<p>  理论上合成的拷贝构造函数就能够正常的工作了。某些情况不会有合成的拷贝构造函数，而是直接逐位拷贝。这样的情况下，就没法实施，上面的编译器层面的优化。<br>那么我们应该预见这个类是不是有很多传值的操作，比如上面的函数的参数，返回值。如果有，那么提供一个，编译器才能够实施优化。</p>
<p>  <strong>成员们的初始化队伍</strong><br>构造函数初始化列表</p>
<blockquote>
<ul>
<li>初始化一个引用成员（不这样做出错）</li>
<li>初始化一个const成员（不这样做出错）</li>
<li>调用一个base class的构造函数，而它拥有一组参数时（不这样做出错）</li>
<li>调用一个member class的构造函数，而它拥有一组参数时（比赋值更有效率）</li>
</ul>
</blockquote>
<p>编译器会一一操作初始化列表，以适当次序（成员的声明次序）在构造函数之内安插初始化操作，并且在任何显式写的代码之前完成操作。<br>初始化列表能够使用成员函数来初始化一个成员。（这里如果比较复杂的初始化能够使用这种方式提高初始化的效率，但是要注意该函数使用的变量是不是在调用前都被初始化了。合法的原因是此时this指针已经创建好了。）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/child//blog/2016/08/读书笔记-深入理解C-对象模型-第二章 构造函数的语意学.html" data-id="civke9ize0009e6kaiys2nf6z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2016/08/读书笔记-深入探索C-对象模型-第三章-Data语意学.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          [读书笔记] 深入探索C++对象模型 第三章 Data语意学
        
      </div>
    </a>
  
  
    <a href="/blog/2016/08/读书笔记-深入探索C-对象模型-第一章-关于对象.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">[读书笔记]深入探索C++ 对象模型 第一章 关于对象</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/开发环境/">开发环境</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/摘录/">摘录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/游戏/">游戏</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PS4/">PS4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPG/">RPG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/google/">google</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sicp/">sicp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl源码剖析/">stl源码剖析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂书/">杂书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂谈/">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏/">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/理论/">理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程规范/">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机程序的构造与解释/">计算机程序的构造与解释</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 16.67px;">C++</a> <a href="/tags/PS4/" style="font-size: 10px;">PS4</a> <a href="/tags/RPG/" style="font-size: 10px;">RPG</a> <a href="/tags/google/" style="font-size: 10px;">google</a> <a href="/tags/sicp/" style="font-size: 16.67px;">sicp</a> <a href="/tags/stl源码剖析/" style="font-size: 10px;">stl源码剖析</a> <a href="/tags/windows/" style="font-size: 10px;">windows</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/杂书/" style="font-size: 10px;">杂书</a> <a href="/tags/杂谈/" style="font-size: 13.33px;">杂谈</a> <a href="/tags/游戏/" style="font-size: 10px;">游戏</a> <a href="/tags/环境搭建/" style="font-size: 10px;">环境搭建</a> <a href="/tags/理论/" style="font-size: 16.67px;">理论</a> <a href="/tags/编程规范/" style="font-size: 10px;">编程规范</a> <a href="/tags/计算机程序的构造与解释/" style="font-size: 16.67px;">计算机程序的构造与解释</a> <a href="/tags/读书笔记/" style="font-size: 20px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2016/11/读书笔记-stl源码剖析 -第一章、第二章.html">[读书笔记] stl源码剖析 第一章、第二章</a>
          </li>
        
          <li>
            <a href="/blog/2016/11/阅读谷歌编程规范.html">阅读谷歌编程规范</a>
          </li>
        
          <li>
            <a href="/blog/2016/10/windows下Pyqt-guiqwt环境的搭建.html">windows下Pyqt + guiqwt环境的搭建</a>
          </li>
        
          <li>
            <a href="/blog/2016/09/读书笔记-sicp-第三章-模块化-对象和状态.html">[读书笔记] sicp 第三章 模块化 对象和状态</a>
          </li>
        
          <li>
            <a href="/blog/2016/09/读书笔记-sicp-第二章-带有通用型操作的系统.html">[读书笔记] sicp 第二章 带有通用型操作的系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 YangYi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>