<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>理论 - Tag - 鉴心</title>
        <link>http://coderyang.com/tags/%E7%90%86%E8%AE%BA/</link>
        <description>理论 - Tag - 鉴心</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 20 Aug 2016 09:15:53 &#43;0000</lastBuildDate><atom:link href="http://coderyang.com/tags/%E7%90%86%E8%AE%BA/" rel="self" type="application/rss+xml" /><item>
    <title>[读书笔记] 深入探索C&#43;&#43;对象模型 第六章 执行期语意学</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/</link>
    <pubDate>Sat, 20 Aug 2016 09:15:53 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/</guid>
    <description><![CDATA[<h1 id="执行期语意学">执行期语意学</h1>
<p>以下一个简单的式子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="n">yy</span> <span class="o">==</span> <span class="n">xx</span><span class="p">.</span><span class="n">getValue</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>xx  yy定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">X</span> <span class="n">xx</span><span class="p">;</span>
<span class="n">Y</span> <span class="n">yy</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Y</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Y</span><span class="p">();</span>
 <span class="o">~</span><span class="n">Y</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="o">&amp;</span> <span class="n">Y</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">X</span><span class="p">();</span>
  <span class="o">~</span><span class="n">X</span><span class="p">();</span>
  <span class="k">operator</span> <span class="nf">Y</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">X</span> <span class="nf">getValue</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>那么编译器在我们之后做了什么呢</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span><span class="p">(</span><span class="n">yy</span> <span class="o">==</span> <span class="n">xx</span><span class="p">.</span><span class="n">getValue</span><span class="p">())</span>

<span class="c1">//转换为
</span><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">yy</span><span class="p">.</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">xx</span><span class="p">.</span><span class="n">getValue</span><span class="p">())</span>

<span class="c1">//接着转换
</span><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">yy</span><span class="p">.</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">xx</span><span class="p">.</span><span class="n">getValue</span><span class="p">().</span><span class="k">operator</span> <span class="n">Y</span><span class="p">()))</span>

<span class="c1">//接着转换
</span><span class="c1"></span><span class="n">X</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">xx</span><span class="p">.</span><span class="n">getValue</span><span class="p">();</span>
<span class="n">Y</span> <span class="n">temp2</span> <span class="o">=</span> <span class="n">temp1</span><span class="p">.</span><span class="k">operator</span> <span class="n">Y</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">temp3</span> <span class="o">=</span> <span class="p">(</span><span class="n">yy</span><span class="p">.</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">temp2</span><span class="p">));</span>
<span class="k">if</span><span class="p">(</span><span class="n">temp3</span><span class="p">)</span>

<span class="n">temp2</span><span class="p">.</span><span class="n">y</span><span class="o">::~</span><span class="n">Y</span><span class="p">();</span>
<span class="n">temp1</span><span class="p">.</span><span class="n">x</span><span class="o">::~</span><span class="n">X</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="对象的构造与析构">对象的构造与析构</h2>
<h3 id="局部对象">局部对象</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="p">{</span>
 <span class="n">Point</span> <span class="n">p</span><span class="p">;</span>
 <span class="c1">// p.Point::Point();
</span><span class="c1"></span> <span class="p">...</span>
 <span class="c1">//p.Point::~Point();
</span><span class="c1"></span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果一个函数拥有多个离开点，那么会在每一个离开点之前对对象进行析构。</p>
<h3 id="全局对象">全局对象</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Matrix</span> <span class="n">identity</span><span class="p">;</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Matrix</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">identity</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>C++ 保证一定会在main()中第一次用到identity之前把 didentity构造出来，在main()函数结束之前销毁。
C++程序中所有全局对象都被防止在程序的data segment中，如果明确指定给它一个值,object将以该值为初值。否咋object所配置到的内存内容为0。</p>
<blockquote>
<ul>
<li>class object在编译器可以被放置与data sement中并且为0,但是它的构造函数需要在程序激活的时候才会被实施。(也就是说全局对象的初始化的问题，对于类对象的有些门道。)</li>
</ul>
</blockquote>

￼
（还是不是很清楚全局对象是如何初始化的）
### 局部静态对象
```cpp
const Matrix&
identity()
{
    static Matrix mat_identity;
    ...
    return mat_identity;
}
```
对于局部静态的变量，他们的构造和析构必须只施行一次。
编译器的策略是，导入一个临时性的对象以保护mat_identity的初始化操作。第一次处理identity()时候，这临时对象被评估为false，于是构造函数被调用，然后临时对象改为true。同理析构也是如此。
（但是具体现代编译器怎么操作的我还是不清楚。）。
### 对象数组
```cpp
Point knots[10];
```
需要做什么。如果是一个没有构造函数的，也没有析构函数的。那么工作不会比建立一个内建类型所组成的数组更多。
如果有的话，那么整齐的操作必须施行与每一个元素上。
在cfront中，使用一个命名为vec_new()的函数，产生以class objects构造而成的数组。
```cpp
void* 
ver_new(
    void *array,                            //数组的起始位置
    size_t elem_size,                       //一个对象的大小
    int elem_count,                         //数组的元素个数
    void (*constructor)( void*),
    void (*destructor)(void*, char)
)
```
调用操作
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Point</span> <span class="n">knots</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">ver_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knots</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Point</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Point</span><span class="o">::</span><span class="n">Point</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>同样如果Point有一个析构函数会有一个类似ver_delete()的函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span><span class="o">*</span> 
<span class="n">ver_delete</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span>                            <span class="c1">//数组的起始位置
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">elem_size</span><span class="p">,</span>                       <span class="c1">//一个对象的大小
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">elem_count</span><span class="p">,</span>                         <span class="c1">//数组的元素个数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">char</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>不同的编译器会有不同的实现。
如果数组部分被赋予了初值的，那么会产生什么转换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Point</span> <span class="n">knots</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Point</span><span class="p">(),</span>
    <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
    <span class="o">-</span><span class="mf">1.0</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>对于有了初值的元素ver_new不必要，但是未被初始化的部分会调用vec_new。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Point</span> <span class="n">knots</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Point</span><span class="p">(),</span>
    <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
    <span class="o">-</span><span class="mf">1.0</span>
<span class="p">};</span>

<span class="c1">//明确的初始化前三个
</span><span class="c1"></span><span class="n">Point</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">Point</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knots</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
<span class="n">Point</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knots</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="n">ver_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knots</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Point</span><span class="p">),</span> <span class="mi">7</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Point</span><span class="o">::</span><span class="n">Point</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="default-constructors和数组">default Constructors和数组</h3>
<p>为了支持</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">complex</span><span class="o">::</span> <span class="n">complex</span><span class="p">(</span><span class="kt">double</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kt">double</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="n">complext</span> <span class="n">c_array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="c1">//编译器最终调用
</span><span class="c1"></span><span class="n">vec_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_array</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">complex</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">complex</span><span class="o">::</span><span class="n">complex</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">//cfront采用如下方法支持
</span><span class="c1">//产生一个默认构造函数 调用带默认参数的构造函数
</span><span class="c1"></span><span class="n">complex</span><span class="o">::</span><span class="n">complex</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">complex</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//来完成调用
</span></code></pre></td></tr></table>
</div>
</div><p>（有一个问题，那么这个不就是产生了两个不带参数的构造函数吗，虽然一个有参数，但是都用默认的。怎么解决的。不过大部分构造过程都是在编译期间，那么都是静态指定调用的话，还是解决掉了的。不是很清楚这个问题。）</p>
<h2 id="new-delete运算符">new delete运算符</h2>
<p>运算符new的使用，之前的几章一直都有。
会转换成两步，一步是使用适当的函数，分配内存。
后一步是给对象设置初值，类对象的话，调用的对应的构造函数等等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span> <span class="n">size_t</span> <span class="n">size</span> <span class="p">)</span>   
<span class="p">{</span>   
    <span class="k">if</span><span class="p">(</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>   
    <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 这里保证像 new T[0] 这样得语句也是可行的   
</span><span class="c1"></span>   
    <span class="kt">void</span> <span class="o">*</span><span class="n">last_alloc</span><span class="p">;</span>   
    <span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">last_alloc</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">size</span> <span class="p">))</span> <span class="p">)</span>   
    <span class="p">{</span>   
       <span class="k">if</span><span class="p">(</span> <span class="n">_new_handler</span> <span class="p">)</span>   
           <span class="p">(</span> <span class="o">*</span><span class="n">_new_handler</span> <span class="p">)();</span> <span class="c1">//调用handler函数  
</span><span class="c1"></span>        <span class="k">else</span>   
           <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
    <span class="p">}</span>   
    <span class="k">return</span> <span class="n">last_alloc</span><span class="p">;</span>         
<span class="p">}</span>   
<span class="k">extern</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">)</span>   
<span class="p">{</span>   
    <span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="c1">// 从这里可以看出，删除一个空指针是安全的   
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="p">);</span>   
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><h3 id="针对数组的new语意">针对数组的new语意</h3>
<p>内建的或者没有默认构造函数的，直接默认的new就能完成任务。
对于有默认构造函数的，某些版本的vec_new()就会被调用。</p>
<h2 id="临时性对象">临时性对象</h2>
<p>很多简短的代码实际上都会产生一些临时对象。
是不是真的产生，需要看编译器的具体实现了。</p>
<h3 id="临时性对象的迷思">临时性对象的迷思</h3>]]></description>
</item><item>
    <title>[读书笔记]深入探索C&#43;&#43;对象模型 第五章 构造 解构 拷贝语意学</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/</link>
    <pubDate>Tue, 16 Aug 2016 21:22:40 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/</guid>
    <description><![CDATA[<h1 id="构造解构拷贝语意学">构造、解构、拷贝语意学</h1>
<h3 id="纯虚函数的存在">纯虚函数的存在</h3>
<p>纯虚函数能够被静态的调用，不能经过虚拟机制调用。
虚析构函数不能定义为纯虚的，一定要有定义，否则即使可以编译，但是链接的时候会有错误。因为其子类会静态调用上一层的析构函数。如果说上一层的析构函数是一个纯虚函数的话，那么链接的时候会失败。</p>
<h3 id="虚拟规格的存在">虚拟规格的存在</h3>
<p>不应该把所有的函数都声明为虚函数，然后靠编译器去优化操作吧virtual invocation去除。</p>
<h3 id="虚拟规格中的const的存在">虚拟规格中的const的存在</h3>
<p>实际上你很难知道一个类的子类对于这个函数是不是应该定义为const，因为即使现在你不需要修改类的内容，但子类可能需要修改，你没法预料到。那么最好不要定义一个有const函数的基类了。</p>
<h2 id="无继承情况下的对象构造">“无继承”情况下的对象构造</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Point</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>编译器会分析声明，贴上Plaint OI' Data的卷标，被贴上该卷标的类，不会有构造函数或者析构函数的调用了。直接使用C的方式。</p>
<h2 id="继承体系下的对象构造">继承体系下的对象构造</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">T</span> <span class="n">object</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>定义一个object如上时候，实际会发生什么。如果T有一个construct，它会被调用。
Constructor可能带有大量 隐藏码，因为编译器会扩充每一个constructor，扩充程度视class T的继承体系而定，一般而言编译器所做的扩充操作大约如下：</p>
<ol>
<li>记录在member initialization list中的data members初始化操作会被放进constructor函数本身，并以members的声明顺序为顺序。</li>
<li>如果有一个member没有出现在member initialization list中，但是它有一个default constructor, 那么该default construtor必须被调用。</li>
<li>在那之前，如果class object有virtual table pointer(s)，它们必须被设定初值。指向适合的virtual table(s)</li>
<li>在那之前，所有上一层的base class constructirs必须被调用，以base class的声明顺序为顺序</li>
</ol>
<blockquote>
<ul>
<li>如果base class被列于初始化列表中，那么任何明确的指定参数都应该传递过去</li>
<li>如果base class 没有被列于初始化列表中，而它有默认构造函数，那么调用之</li>
<li>如果base class 是多重继承下的第二或者后继的base class那么this指针必须被调整</li>
</ul>
</blockquote>
<ol start="5">
<li>在那之前，所有的virtual base class constructor必须被调用，从左到右，从最深到最浅</li>
</ol>
<blockquote>
<ul>
<li>如果class被列于初始化列表中，那么如果有任何明确指定的参数，都应该传递过去。若没有在list中，而class有默认构造函数，也应该调用</li>
<li>此外，class中的每一个virtual base class subobject的偏移量必须在执行期间可被存取</li>
<li>如果class object是最底层的class，其构造函数可能被调用。某些用以支持这个行为的机制被加入</li>
</ul>
</blockquote>
<p>虚函数不见得一定有运行期绑定，如果能够编译期确定的，编译期乐于去进行静态的调用。</p>
<h3 id="虚拟继承">虚拟继承</h3>

￼
有如上图的继承结构。
Vertex的构造函数必须调用Point的构造函数。但是Vertex和P哦Point3d同为Vertex3d的 subobjects的时候，它们对Point的构造函数的调用操作一定不可以发生，取而代之的是，作为底层的class，Vertex3d有责任将Point初始化，而更往后的继承，则由PVertex,而不是Vertex3d来负责完成共享的Point subobject的构造.
```cpp
Point3d*
Point3d::Point3d(Point3d *this, bool __most__derived,
                            float x, float y, float z)
{
    if(__most_derived != false)
        this->Point::Point(x,y);
    this->__vptr_Point3d = __vtbl_Pint3d;
    this->__vptr_Point3d__Point = __vtbl_Point3d__Point;
    this->_z = rhs._z;
    return this;
}
```
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Vertex3d</span><span class="o">*</span>
<span class="n">Vertex3d</span><span class="o">::</span><span class="n">Vertex3d</span><span class="p">(</span> <span class="n">Vertex3d</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">__most_deriver</span><span class="p">,</span>
                                <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">__most_derived</span> <span class="o">!=</span> <span class="nb">false</span><span class="p">)</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">Point</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Point3d</span><span class="o">::</span><span class="n">Point3d</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Vertex</span><span class="o">::</span><span class="n">Vertex</span> <span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="c1">//设定vptrs
</span><span class="c1"></span>    <span class="c1">//安插USER CODE
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>##vptr 初始化语意学
当我们定义一个PVertex object的时候，构造函数的调用顺序是</p>
<blockquote>
<ul>
<li>Point()</li>
<li>Point3d()</li>
<li>Vertex()</li>
<li>Vertex3d()</li>
<li>PVertex()</li>
</ul>
</blockquote>
<p>构造函数调用成员函数会决议为静态的，不会使用多态机制。主要是考虑到构造函数中对象可能是不完整的，编译器需要找到合适的函数对象来调用，只能调用到此时能够起作用的函数。</p>
<ol>
<li>在派生类的构造函数中，所有的Virtual base classes以及上一层base class的constructors会被调用</li>
<li>上述完成之后，对象的vptr(s)被初始化，指向相关的虚表</li>
<li>如果有初始化列表的话，将在构造函数内扩展开来，这必须在vptr设定之后进行，以免一个virtual member function调用</li>
<li>最后执行程序员所提供的的代码</li>
</ol>
<p>构造函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">PVertex</span><span class="o">::</span><span class="n">PVertex</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">)</span> <span class="o">:</span> <span class="n">_next</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Vertex3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">spyOn</span><span class="p">)</span>
       <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;within Point3d::Point3d()&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>会被编译器扩展为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">PVertex</span><span class="o">*</span> <span class="n">PVertex</span><span class="o">::</span><span class="n">PVertex</span><span class="p">(</span> <span class="n">Pvertex</span><span class="o">*</span> <span class="k">this</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">__most_derived</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span> <span class="p">)</span>  <span class="p">{</span>
    <span class="c1">//有条件地调用virtual base class的ctor
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span> <span class="n">__most_derived</span> <span class="o">!=</span> <span class="nb">false</span> <span class="p">)</span>
       <span class="k">this</span><span class="o">-&gt;</span><span class="n">Point</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">);</span>
    <span class="c1">//无条件地调用上一层的base class的ctor
</span><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Vertex3d</span><span class="o">::</span><span class="n">Vertex3d</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">);</span>
    <span class="c1">//初始化vptr
</span><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__vptr__PVertex</span> <span class="o">=</span> <span class="n">__vtbl__PVertex</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__vptr__Point__PVertex</span> <span class="o">=</span> <span class="n">__vtbl__Point__PVertex</span><span class="p">;</span>
    <span class="c1">//显式的用户代码
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span> <span class="n">spyOn</span> <span class="p">)</span>
        <span class="c1">// 虚拟机制调用size()函数
</span><span class="c1"></span>       <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;within Point3d::Point3d()&#34;</span><span class="o">&lt;&lt;</span> <span class="s">&#34; size: &#34;</span>
             <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">__vptr__PVertex</span><span class="p">[</span> <span class="mi">3</span> <span class="p">].</span><span class="n">faddr</span><span class="p">)(</span><span class="k">this</span><span class="p">)</span>
             <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="对象复制语意学">对象复制语意学</h2>
<p>bitwise copy不够的情况和之前几章记录的一致。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kr">inline</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Point</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_x</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">_x</span><span class="p">;</span>
    <span class="n">_y</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">_y</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//派生一个类
</span><span class="c1"></span><span class="nl">classPoint3d</span> <span class="p">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">Point</span>
 <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
       <span class="n">Point3d</span><span class="p">(</span> <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="p">);</span>
       <span class="p">...</span>
    <span class="k">protected</span><span class="o">:</span>
       <span class="kt">float</span> <span class="n">_z</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//编译器会合成一个
</span><span class="c1"></span><span class="kr">inline</span> <span class="n">Point3d</span><span class="o">&amp;</span> <span class="n">Point3d</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">Point3d</span> <span class="o">*</span><span class="n">constthis</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point3d</span> <span class="o">&amp;</span><span class="n">p</span> <span class="p">)</span> <span class="p">{</span>
   <span class="c1">//调用base class的operator=
</span><span class="c1"></span>   <span class="k">this</span><span class="o">-&gt;</span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">p</span> <span class="p">);</span>
   <span class="c1">// memberwise copy the derived class members
</span><span class="c1"></span>   <span class="n">_z</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">_z</span><span class="p">;</span>
   <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是考虑到上面那个虚拟继承层次的结构的话。
怎么在虚拟继承中去处理复制这个问题。
事实上，copy assignment operator在虚拟继承的情况下行为不佳，需要小心的设计和说明，许多编译器甚至不尝试取得正取的语意，造成多次调用虚拟基类的copy assignment operator的多个实体被调用。（我的话，好像多次调用并不会产生大的问题，只是重复复制罢了，实际上没产生什么错误，效率貌似有下降。）</p>
<h2 id="析构语意学">析构语意学</h2>
<p>如果class没有定义析构函数，那么只有在class内带的成员对象有析构函数的情况下，编译器才会自动合成析构函数，否则析构函数视为不需要的。即使它拥有一个虚函数等。
也就是构造函数和析构函数并不是一定要成对的出现，没必要定义了构造函数，就定义出析构函数。</p>
<p>析构函数的扩展</p>
<ol>
<li>析构函数的本身被执行，user code</li>
<li>如果class拥有成员类对象，而后者拥有析构函数，声明顺序的相反顺序调用其析构函数</li>
<li>如果对象有vptr需要重新被设定，指向合适的base class的vtbl</li>
<li>如果任何一个直接的nonvirtual base classes拥有析构函数，它们会以声明次序的相反顺序被调用</li>
<li>如果任何virtual base classes拥有析构 函数，而当前讨论的这个class是最尾端的class,那么会以其原来的构造函数相反的顺序被调用</li>
</ol>]]></description>
</item><item>
    <title>[读书笔记]深入探索C&#43;&#43;对象模型 第四章 Function语意学</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/</link>
    <pubDate>Sun, 14 Aug 2016 23:44:43 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/</guid>
    <description><![CDATA[<h1 id="第三章function语意学">第三章：Function语意学</h1>
<h2 id="member的各种调用方式">Member的各种调用方式</h2>
<h3 id="nonstatic-member-functions">Nonstatic Member Functions</h3>
<p>C++的设计准则之一就是:nonstatic member function 至少必须和一般的nonmember function有相同的效率。
nonstatic member function会转换为nonmember形式。</p>
<ol>
<li>改写函数原型，安插一个额外的参数，也就是this指针。</li>
<li>将每一个对“nonstatic data member的存取操作&quot;改为经由this指针来存取。</li>
<li>将member function重写成一个外部函数，对函数名称进行“mangling&quot;处理，使它在程序中成为一个独一无二的词汇。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">normalize__7Point3dFv</span><span class="p">(</span><span class="k">register</span> <span class="k">const</span> <span class="n">Point3d</span> <span class="o">*</span><span class="k">const</span> <span class="k">this</span><span class="p">,</span>
                                                <span class="n">Point3d</span> <span class="o">&amp;</span><span class="n">__result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="kt">float</span> <span class="n">mag</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">magnitude</span><span class="p">();</span>
    <span class="n">__result</span><span class="p">.</span><span class="n">Point3d</span><span class="o">::</span><span class="n">Point3d</span><span class="p">();</span>
    
    <span class="n">__result</span><span class="p">.</span><span class="n">_x</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_x</span><span class="o">/</span><span class="n">mag</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="名称的特殊处理">名称的特殊处理</h3>
<p>一般而言，member的名称前面会加上class名称，形成独一无二的命名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Bar</span><span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">ival</span><span class="p">;</span> <span class="p">...};</span>
<span class="c1">//其中ival有可能变成这样
</span><span class="c1"></span><span class="n">ival__3Bar</span>
</code></pre></td></tr></table>
</div>
</div><p>主要考虑是存在继承的问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//防止函数的重名
</span><span class="c1">//加入类名
</span><span class="c1">//加入参数链，使得支持重载
</span><span class="c1">//cfront采用的编码方式
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Point</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">x__5PointFf</span><span class="p">(</span><span class="kt">float</span> <span class="n">newX</span><span class="p">);</span>
    <span class="kt">float</span> <span class="nf">x__5PointFv</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="virtual-member-functions">Virtual Member Functions</h3>
<p>如果normalize()是virtual member function</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//函数会变成
</span><span class="c1"></span><span class="n">ptr</span><span class="o">-&gt;</span> <span class="n">normalize</span><span class="p">()</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">vptr</span><span class="p">[</span><span class="mi">1</span><span class="p">])(</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">//1为vtbl slot的索引值，关联到normalize
</span></code></pre></td></tr></table>
</div>
</div><h3 id="static-member-function">Static Member Function</h3>
<p>你可能会看到形如以下的调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="p">((</span><span class="n">Point3d</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">test</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>这种调用在test中没有对类对象的数据成员存储时候是不会出错的。
因为根据之前的转化形式看，没有是还用this指针进行操作。
这个式子的功能实际上就是实现static 成员函数的功能。在static member function成为c++的标准之前。
函数的转化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">Point3d</span><span class="o">::</span><span class="n">object_cout</span><span class="p">()</span>
<span class="p">{</span>

<span class="p">}</span>
<span class="c1">//转化为
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">object_cout__5Point3dSFv</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="virtual-member-functions-1">Virtual Member Functions</h2>
<p>对于多态的class object身上增加两个members</p>
<ol>
<li>一个字符串或者数字，表示class的类型</li>
<li>一个指针，指向某表格，表格中带有程序的virtual functions的执行地址</li>
</ol>
<p>一个class只会有一个virtual table，每个table内含其对应的class object中所有active virtual functions函数实体地址。这些active virtual functions包括：</p>
<blockquote>
<ul>
<li>这个class所定义的函数实体。它会改写一个可能存在的Base class virtual function函数实体</li>
<li>继承自base class的函数实体。这是派生类不改写的部分</li>
<li>一个Pure_virtual_called()函数实体，它既扮演pure virtual function的空间保卫者角色，也可以作为执行期异常处理函数（有时候会用到）</li>
</ul>
</blockquote>

￼
### 多重继承下的Virtual Functions
在多重继承中支持virtual functions，其复杂度围绕在第二个以及后继的base classes中，以及必须在执行期间调整的this指针这一点。
```cpp
class C : public A,B...
A* pA = new C;
<p>B* pB = new C;
//
C* pC = new C;
B* pB = pC;</p>
<p>//转化
B* pB = pB ? pB + sizeof(A) : 0;
//
delete pB;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">delete 操作会要求调用合适的虚析构函数，那么就要求指针再一次被调整。使得指针再次指向C对象的头。

thunk是小段assembly代码，来完成这个工作。
```cpp
pbase2_dtor_thunk:
    this += sizeof(base1);
    Derived::~Derived(this);
</code></pre></td></tr></table>
</div>
</div><h3 id="多重继承下的virtual-functions">多重继承下的Virtual Functions</h3>
<p>没讲明白</p>
<h2 id="函数的效能">函数的效能</h2>
<h2 id="指向member-function的指针">指向Member Function的指针</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//指向成员函数的指针声明
</span><span class="c1"></span><span class="kt">double</span> <span class="p">(</span><span class="n">Point</span> <span class="o">::</span> <span class="o">*</span><span class="n">coord</span><span class="p">)</span> <span class="p">()</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Point</span> <span class="o">::</span> <span class="n">x</span><span class="p">;</span>
<span class="n">coord</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Point</span><span class="o">::</span><span class="n">y</span><span class="p">;</span>

<span class="c1">//要想要调用，需要
</span><span class="c1"></span><span class="p">(</span><span class="n">origin</span><span class="p">.</span><span class="o">*</span><span class="n">coord</span><span class="p">)();</span>
<span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;*</span><span class="n">coord</span><span class="p">)();</span>
<span class="c1">//操作会自动被编译器转化
</span><span class="c1"></span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">origin</span><span class="p">);</span>
<span class="p">(</span><span class="n">coord</span><span class="p">)(</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>指向member function的指针的声明语法，以及指向member selection运算符的指针，其作用是作为this指针的空间保留者。这就是为什么static member functions的类型是函数指针，而不是指向member function指针的原因。
利用上述方式去获取一个虚函数的指针，一样能够支持多态。因为实际上获取的是一个索引值，指向虚表的内容。</p>
<h3 id="在多重继承下指向member-funcitons的指针">在多重继承下，指向member funcitons的指针</h3>
<p>为了让指向member funcitons的指针能够支持多重继承和虚拟继承，Stroustrup设计了下面一个机构体</p>
<p>index faddr分别带有virtual table和nonvirtual member function地址（为了方便，index不指向virtual table时候会被设为-1）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">__mpter</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">delta</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">ptrtofunc</span> <span class="n">faddr</span><span class="p">;</span>
        <span class="kt">int</span>            <span class="n">v_offset</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//在该模型之下，像这样的操作
</span><span class="c1"></span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;*</span><span class="n">pmf</span><span class="p">)();</span>
<span class="c1">//转变为
</span><span class="c1"></span><span class="p">(</span><span class="n">pmf</span><span class="p">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">?</span> <span class="p">(</span><span class="o">*</span><span class="n">pmf</span><span class="p">.</span><span class="n">faddr</span><span class="p">)(</span><span class="n">ptr</span><span class="p">)</span><span class="c1">// nonvirtual invocation
</span><span class="c1"></span>    <span class="o">:</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">vptr</span><span class="p">[</span><span class="n">pmf</span><span class="p">.</span><span class="n">index</span><span class="p">](</span><span class="n">ptr</span><span class="p">));</span><span class="c1">//virtual invocation
</span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>[读书笔记] 深入探索C&#43;&#43;对象模型 第三章 Data语意学</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/</link>
    <pubDate>Sun, 14 Aug 2016 20:35:34 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/</guid>
    <description><![CDATA[<h1 id="第三章data语意学">第三章：Data语意学</h1>
<p>class的大小：
内存对齐
空Class需要1byte来占位，说明是独一无二的存在
有虚函数时候会有虚表指针
static 成员不属于类对象，不占空间</p>
<h2 id="data-member的绑定">Data Member的绑定</h2>
<p>早期的编译器可能看不到Class后面的内容，导致数据成员的用了外层的同名的。现在已经没有这种情况了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Point3d</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">length</span> <span class="n">x</span><span class="p">;</span><span class="c1">//是long long
</span><span class="c1"></span>    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>    
    <span class="n">length</span> <span class="n">y</span><span class="p">;</span><span class="c1">//是 int
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="data-member的布局">Data Member的布局</h2>
<p>Nonstatic data members在class object中的排列顺序是和声明顺序一致的。
但是没有规定多个access sections中的数据成员的排列，可以自由排列。实际上的编译器处理来看，还是按照顺序来的。这些顺序成员依靠声明次序在一个连续的区域里。
虚表也有强制的规定放在尾部还是头部等位置。</p>
<h2 id="data-member的存取">Data Member的存取</h2>
<p>下面的一段代码中的x的存取成本</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="n">Point3d</span> <span class="n">origin</span><span class="p">;</span>
    <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>需要视x和Point3d如何声明而定。</p>
<h2 id="static-data-member的存取">Static Data Member的存取</h2>
<p>Static Data Member实际上是一种全局变量，放在类对象之外。每一个Static Data Member对象的存取操作都会转化为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Point3d</span><span class="o">::</span><span class="n">x</span> <span class="o">==</span> <span class="mi">250</span><span class="p">;</span><span class="c1">//不论是. 或者-&gt;来存取
</span></code></pre></td></tr></table>
</div>
</div><p>不论该class是单一的类还是继承有虚函数的类或者多重继承，Static Data Member的路径仍然是这么直接。</p>
<p>编译器会给每一个Static Data Member暗中编码指定独一无二的名字。</p>
<h2 id="nonstatic-data-member的存取">NonStatic Data Member的存取</h2>
<p>NonStatic Data Member是存放在每一个类对象中的，除非经由明确的或者暗喻的类对象，否则么有办法直接存取它们。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">Point3d</span><span class="o">::</span><span class="n">translate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>实际上都会转化为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">Point3d</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">Point3d</span> <span class="o">*</span><span class="k">const</span> <span class="k">this</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>欲对一个NonStatic Data Member访问必须在类对象的起始地址加上一个数据成员的偏移值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">origin</span><span class="p">.</span><span class="n">_y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="c1">//origin._y的地址实际上等于
</span><span class="c1"></span><span class="o">&amp;</span><span class="n">origin</span> <span class="o">+</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">Point3d</span><span class="o">::</span><span class="n">_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>存取这种数据成员和一个struct的成员是一致的。除了虚拟继承，此种情况下会引入一层间接性。</p>
<h2 id="继承与data-member">继承与Data Member</h2>
<p>在C++中的继承模型中，一个derived class object所表现出来的东西，是其自己的members加上其base lass members的总和。</p>
<h3 id="只要继承不要多态">只要继承不要多态</h3>
<p>base class的padding也会随之而来。这种设计是为了防止把派生类赋值给基类对象的时候导致基类对象的后面部位有数据而不是0（如果不保留padding的话，而是直接接上去）</p>

<h3 id="加上多态">加上多态</h3>
<p>加上多态的额外负担：</p>
<blockquote>
<ul>
<li>导入一个相关的virtual table,用来存放它所声明的每一个虚函数的地址。这个table元素的数目一般而言是被声明的虚函数的数目，再加上一个或者两个slots（用来支持runtime type idetification）。</li>
<li>在每一个类对象中导入一个vptr，提供执行器的连接，使每一个对象能够找到对应的vittual table。</li>
<li>加强构造函数</li>
<li>加强虚构函数</li>
</ul>
</blockquote>
<p>vptr的放置没有强制规定。</p>
<h3 id="多重继承">多重继承</h3>
<p>多重继承实际上对于第一继承没什么影响，主要是对于第二或者后继的base class</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Vertex3d</span> <span class="n">v3d</span><span class="p">;</span>
<span class="n">Vertex</span> <span class="o">*</span><span class="n">pv</span><span class="p">;</span>
<span class="n">Point2d</span> <span class="o">*</span><span class="n">p2d</span><span class="p">;</span>
<span class="n">Point3d</span> <span class="o">*</span><span class="n">p3d</span><span class="p">;</span>

<span class="n">pv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v3d</span><span class="p">;</span>
<span class="c1">//需要这样的内部转化
</span><span class="c1"></span><span class="n">pv</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="p">)(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">v3d</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Point3d</span><span class="p">));</span>
<span class="c1">//下面的只要简单的拷贝地址就行
</span><span class="c1"></span><span class="n">p2d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v3d</span><span class="p">;</span>

<span class="n">pv</span> <span class="o">=</span> <span class="n">pv3d</span><span class="p">;</span>
<span class="c1">//要考虑pv3d位0的情况
</span><span class="c1"></span><span class="n">pv</span> <span class="o">=</span> <span class="n">pv3d</span>
        <span class="o">?</span> <span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="p">)(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">v3d</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="nl">Point3d</span>
        <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>多重继承的存储模型，没有规定怎么存储，但是大部分编译器都是采用下面的方式存储的。</p>

<h3 id="虚拟继承">虚拟继承</h3>
<p>一般的实现方法：class如果含有一个或者多个virtual base class，分割为亮哥部分:一个是不变的局部，一个是共享的局部。不变的局部中的数据，不管后继如何衍化，总有固定的offset，所以这一部分数据可以被直接存取。至于共享局部，所表现的是virtual base class suboject.这一部分的数据，其位置会因为每次的派生操作而变化，所以它们只可以被间接存取。</p>

<p>例子继承体系
微软的解决方案：引入所谓的virtual base class table.每一个类对象如果有一个或者多个virtual base classes就会由编译器安插一个指针，指向virtual base class table。至于真正的virtual base class指针，被安放在这个表格中。
第二种解决方案</p>

<p>在virtula function table中放置 virtula base class的offset。
如同虚函数的指针，虚函数指针的在虚表中是正的offset，负的部分就给了虚基类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="p">(</span><span class="k">this</span> <span class="o">+</span><span class="n">__vptr__Point3d</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">_x</span> <span class="o">+=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span> <span class="o">+</span> <span class="o">+</span><span class="n">__vptr__Point3d</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">_x</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Point3d</span> <span class="o">*</span><span class="n">p2d</span> <span class="o">=</span> <span class="n">pv3d</span><span class="p">;</span>
<span class="c1">//转换为
</span><span class="c1"></span><span class="n">Point3d</span> <span class="o">*</span><span class="n">p2d</span> <span class="o">=</span> <span class="n">pv3d</span> <span class="o">?</span> <span class="n">pv3d</span> <span class="o">+</span><span class="n">__vptr__Point3d</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>一般而言，virtual base class 最有效的一种运行形势是：一个抽象的virtual base class，没有任何data members。</p>
<h2 id="对象成员的效率">对象成员的效率</h2>
<h2 id="指向data-members的指针">指向Data Members的指针</h2>
<p>&amp; Point3d::z;的值为z在class object中的偏移量。</p>
<p>书上的代码试了在VS2015，并没有偏移量增加1的出现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">Point3d</span><span class="o">::</span><span class="n">x</span><span class="p">));</span><span class="c1">//4
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">Point3d</span><span class="o">::</span><span class="n">y</span><span class="p">));</span><span class="c1">//8
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">Point3d</span><span class="o">::</span><span class="n">z</span><span class="p">));</span><span class="c1">//c
</span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>[读书笔记]深入理解C&#43;&#43;对象模型 第二章 构造函数的语意学</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/</link>
    <pubDate>Sun, 07 Aug 2016 18:36:20 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/</guid>
    <description><![CDATA[<h1 id="第二章构造函数语意学">第二章：构造函数语意学</h1>
<p>由于C++的编译器在程序员之外做了太多事情，导致会产生很多意料之外的错误。
例子 Conversion运算符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//为了支持
</span><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span>
<span class="c1">//定义了一个perator int()
</span><span class="c1">//但是导致了以下错误的代码能够正常运行
</span><span class="c1"></span><span class="kt">int</span> <span class="n">inVal</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&lt;&lt;</span> <span class="n">inVal</span><span class="p">;</span>
<span class="c1">//此处&lt;&lt;被解释为左移操作符
</span><span class="c1"></span><span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">cin</span><span class="p">.</span><span class="k">operator</span> <span class="kt">int</span><span class="p">();</span>
<span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="n">intVal</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="default-constructor的构建操作">Default Constructor的构建操作</h1>
<p>默认构造函数只在编译器认为需要的时候才创建。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Foo</span><span class="p">{</span><span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span> <span class="n">Foo</span> <span class="o">*</span><span class="n">pnext</span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">test</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>这种情况实际没有默认构造函数，编译器什么都没做。</p>
<h2 id="带有default-constructor的-member-class-object">带有Default Constructor的 Member class Object</h2>
<p>如果一个Class没有任何构造函数，但是包含一个member object，而后者又有default constructor，那么会在constructor真正被调用时合成出一个默认构造函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">classFoo</span> <span class="p">{</span><span class="k">public</span><span class="o">:</span> <span class="n">Foo</span><span class="p">(),</span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);...};</span>
<span class="n">classBar</span> <span class="p">{</span><span class="k">public</span><span class="o">:</span> <span class="n">Foofoo</span><span class="p">;</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;};</span>
<span class="kt">void</span> <span class="nf">foo_bar</span><span class="p">(){</span>
   <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">//Bar::foo应在此处被初始化
</span><span class="c1"></span>   <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">){...}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>此时的Bar合成默认构造函数会调用Foo的默认构造函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Bar</span><span class="o">::</span><span class="n">Bar</span><span class="p">()</span>
<span class="p">{</span> 
    <span class="n">foo</span><span class="p">.</span><span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">();</span> <span class="c1">//合成出的
</span><span class="c1"></span>    <span class="c1">//但是str等成员是不会管的
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果已经写了一个默认构造函数，那么就会扩张该函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Bar</span><span class="o">::</span><span class="n">Bar</span><span class="p">()</span>
<span class="p">{</span> 
    <span class="n">foo</span><span class="p">.</span><span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">();</span> <span class="c1">//扩展的
</span><span class="c1"></span>    <span class="n">str</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//程序员代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>C++会以member objects在class中声明的次序来调用各个构造函数，由编译器完成。如果成员没有默认构造函数的话，就不会有扩张。</p>
<h2 id="带有default-constructor的-base-class">带有Default Constructor的 Base Class</h2>
<p>一个没有任何构造函数的类派生子一个带有默认构造函数的基类，那么会合成出一个一个默认构造函数，调用上一层的默认构造函数（根据声明次序）。
如果是一个有多个构造函数的类，但是没有默认构造函数，则会扩张每一个构造函数，加入有必要的基类部分的默认构造。
但是不会合成默认构造函数，因为已经存在了程序员编写的构造函数。
如果也存在带有构造函数的成员，那么会在基类的部分构造之后，调用这些成员的构造函数。</p>
<h2 id="带有一个virtual-function的-class">带有一个Virtual Function的 Class</h2>
<p>另有两种情况，也需要合成出default constructor</p>
<blockquote>
<ul>
<li>class声明（或者继承）一个virtual function</li>
<li>class派生自一个继承串链，其中有一个或者更多的virtual base classes</li>
</ul>
</blockquote>
<p>如果程序员没有声明自己的构造函数，编译器就会详细记录合成一个default constructor的必要信息。
编译器需要做以下的几个功能：</p>
<blockquote>
<ul>
<li>一个virtual function table会被编译器产生出来，内放class的virtual function地址。</li>
<li>在每一个class object中，一个额外的pointer member会被编译器合成，内含相关的classs vtbl的地址。</li>
</ul>
</blockquote>
<p>此外如果必要，虚函数表的部分会被重写，以改变为需要的情况。
为了支持这种功能，编译器必须为每个w对象设置它的vptr（这是成员变量，此时需要指向合适的vtbl），因此编译器需要在default ctor中安插一些代码来完成这种工作。</p>
<h2 id="带有一个virtual-base-class-的class">带有一个Virtual Base Class 的Class</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">classX</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="n">inti</span><span class="p">;</span> <span class="p">};</span>
<span class="nl">classA</span> <span class="p">:</span> <span class="n">publicvirtualX</span>   <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="n">intj</span><span class="p">;</span> <span class="p">};</span>
<span class="nl">classB</span> <span class="p">:</span> <span class="n">publicvirtualX</span>   <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="n">doubled</span><span class="p">;</span> <span class="p">};</span>
<span class="nl">classC</span> <span class="p">:</span> <span class="n">publicA</span><span class="p">,</span> <span class="n">publicB</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="n">intk</span><span class="p">;</span> <span class="p">};</span>
<span class="c1">//无法在编译期间解析出 pa-&gt;i 的位置（给一个pa无法确定i的地址）。
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span> <span class="n">constA</span><span class="o">*</span> <span class="n">pa</span> <span class="p">)</span> <span class="p">{</span> <span class="n">pa</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="p">}</span>
<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">foo</span><span class="p">(</span> <span class="k">new</span> <span class="n">A</span> <span class="p">);</span>
   <span class="n">foo</span><span class="p">(</span> <span class="k">new</span> <span class="n">C</span> <span class="p">);</span>
   <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//由于pa的真正类型不确定，所以某些编译器会记录一个指针例（如 __vbcX）来记录X，然后通过这个指针来定位pa指向的i。
</span><span class="c1">//上述
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span> <span class="n">constA</span><span class="o">*</span> <span class="n">pa</span> <span class="p">)</span> <span class="p">{</span> <span class="n">pa</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">//变成了：
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span> <span class="n">constA</span><span class="o">*</span> <span class="n">pa</span> <span class="p">)</span> <span class="p">{</span> <span class="n">pa</span><span class="o">-&gt;</span> <span class="n">__vbcX</span> <span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中__vbcX标示编译器产生的指针，指向 virtual base class X。
__vbcX需要在每一个构造函数按错那么“允许每一个 virtual base class的执行期间存取操作“的码。如果class没有声明任何构造函数，就需要合成一个默认构造函数。</p>
<h1 id="copy-constructor的构建操作">Copy Constructor的构建操作</h1>
<p>有三种情况会执行拷贝构造函数：</p>
<blockquote>
<ul>
<li>显式的使用 =</li>
<li>传参</li>
<li>返回</li>
</ul>
</blockquote>
<h2 id="default-memberwise-initialization">Default Memberwise Initialization</h2>
<p>一个class没有提供显式的拷贝构造函数的话，那么利用Memberwise Initialization(对每一个成员将源对象所有的member复制给目标对象)</p>
<h2 id="非逐位拷贝">非逐位拷贝</h2>
<blockquote>
<ul>
<li>这个类的某个member object有拷贝构造函数。（不管成员的拷贝构造函数是合成的还是显式的定义的，都需要合成一个拷贝构造函数）。</li>
<li>这个类继承自某个有copy ctor的base class。（同上）。</li>
<li>这个类声明了若干个virtual function。（如果继承的基类有virtual function那么一定有拷贝构造函数，符合第二条。）</li>
<li>这个类派生自的继承链中有virtual base class。</li>
</ul>
</blockquote>
<p>第三四种情况需要合成的复制构造函数构建正确的虚表指针给每一个对象。
因为复制构造函数可以 派生类赋值给基类。那么派生类的虚表指针是没法用逐位拷贝来赋值，需要一个合成的复制构造函数正确的设定虚表指针。</p>
<h1 id="程序转化语意学">程序转化语意学</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">X</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">X</span> <span class="n">xx</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">xx</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>一个人可能会做出以下假设：</p>
<blockquote>
<ul>
<li>每次foo()调用，就会传回xx的值.</li>
<li>如果class X定义了一个拷贝构造函数，那么每次调用foo()，保证该拷贝构造函数也会被调用。</li>
</ul>
</blockquote>
<p>均不一定。move语意和外面没有接收的可能导致以上假设不一定。</p>
<h2 id="明确的初始化操作">明确的初始化操作</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">X</span> <span class="n">x0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">foo_bar</span><span class="p">(){</span>
   <span class="n">X</span> <span class="n">x1</span><span class="p">(</span><span class="n">x0</span><span class="p">);</span>             <span class="c1">//定义了x1
</span><span class="c1"></span>   <span class="n">X</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x0</span><span class="p">;</span>           <span class="c1">//定义了x2
</span><span class="c1"></span>   <span class="n">X</span> <span class="n">x3</span> <span class="o">=</span> <span class="n">X</span><span class="p">(</span><span class="n">x0</span><span class="p">);</span>       <span class="c1">//定义了x3
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>//转化的两个动作
//即变成了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">foo_bar</span><span class="p">(){</span>
   <span class="n">X</span> <span class="n">x1</span><span class="p">;</span>    <span class="c1">//定义被重写，初始化操作被剥除
</span><span class="c1"></span>   <span class="n">X</span> <span class="n">x2</span><span class="p">;</span>    <span class="c1">//定义被重写，初始化操作被剥除
</span><span class="c1"></span>   <span class="n">X</span> <span class="n">x3</span><span class="p">;</span>    <span class="c1">//定义被重写，初始化操作被剥除
</span><span class="c1"></span>
   <span class="c1">//编译器安插X copy ctor。
</span><span class="c1"></span>   <span class="n">x1</span><span class="p">.</span><span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">(</span> <span class="n">x0</span> <span class="p">);</span>
   <span class="n">x2</span><span class="p">.</span><span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">(</span> <span class="n">x0</span> <span class="p">);</span>
   <span class="n">x3</span><span class="p">.</span><span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">(</span> <span class="n">x0</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中:
x1.X::X( x0 );
会表现为对拷贝构造函数的调用：
X::X( constX&amp; xx);）</p>
<h2 id="参数的初始化">参数的初始化</h2>
<p>如下代码的变化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">X</span> <span class="n">x0</span><span class="p">);</span>
<span class="c1">//...
</span><span class="c1"></span><span class="n">X</span> <span class="n">xx</span><span class="p">;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这种方式把函数的参数变成了引用，然后将拷贝构造函数构造的参数传入。
变成了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">x0</span><span class="p">);</span>
<span class="c1">//...
</span><span class="c1"></span><span class="n">X</span> <span class="n">__tmp</span><span class="p">;</span>
<span class="n">__tmp</span><span class="p">.</span><span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">(</span> <span class="n">XX</span> <span class="p">);</span>
<span class="n">foo</span><span class="p">(</span><span class="n">__tmp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>其中X声明了destructor，它在foo调用完成后销毁暂时性的对象。</p>
<h2 id="返回初始值">返回初始值</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">X</span> <span class="nf">bar</span><span class="p">(){</span>
  <span class="n">X</span> <span class="n">xx</span><span class="p">;</span>
  <span class="c1">//...
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">xx</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>先添加一个额外的引用参数，然后在返回之前调用一个复制构造函数构造这个返回对象。
于是变成了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">_result</span><span class="p">){</span>
   <span class="n">X</span> <span class="n">xx</span><span class="p">;</span>
   <span class="c1">//...
</span><span class="c1"></span>   <span class="n">_result</span><span class="p">.</span><span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">(</span><span class="n">xx</span><span class="p">);</span>
   <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">X</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">bar</span><span class="p">();</span>
<span class="c1">//转换为
</span><span class="c1"></span><span class="n">X</span> <span class="n">xx</span><span class="p">;</span>
<span class="n">bar</span><span class="p">(</span><span class="n">xx</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">bar</span><span class="p">().</span><span class="n">memfunc</span><span class="p">();</span>
<span class="c1">//可能转换为
</span><span class="c1"></span><span class="n">X</span> <span class="n">_temp0</span><span class="p">;</span>
<span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">_temp0</span><span class="p">),</span> <span class="n">_temp0</span><span class="p">).</span><span class="n">memfunc</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="在使用者层面的优化">在使用者层面的优化</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">X</span> <span class="nf">bar</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span>  <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">X</span> <span class="n">xx</span><span class="p">;</span>
   <span class="c1">//...
</span><span class="c1"></span>   <span class="k">return</span> <span class="n">xx</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>而是定义一个新的构造函数，这样在转换之后效率更高</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">X</span> <span class="nf">bar</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span>  <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">X</span><span class="p">(</span><span class="n">y</span> <span class="p">,</span> <span class="n">z</span><span class="p">);</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>转换后</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">X</span> <span class="o">&amp;</span><span class="n">_result</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span>  <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_result</span> <span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="在编译器层面优化">在编译器层面优化</h2>
<p>就是上面那个转换代码</p>
<p>理论上合成的拷贝构造函数就能够正常的工作了。某些情况不会有合成的拷贝构造函数，而是直接逐位拷贝。这样的情况下，就没法实施，上面的编译器层面的优化。
那么我们应该预见这个类是不是有很多传值的操作，比如上面的函数的参数，返回值。如果有，那么提供一个，编译器才能够实施优化。</p>
<p><strong>成员们的初始化队伍</strong>
构造函数初始化列表</p>
<blockquote>
<ul>
<li>初始化一个引用成员（不这样做出错）</li>
<li>初始化一个const成员（不这样做出错）</li>
<li>调用一个base class的构造函数，而它拥有一组参数时（不这样做出错）</li>
<li>调用一个member class的构造函数，而它拥有一组参数时（比赋值更有效率）</li>
</ul>
</blockquote>
<p>编译器会一一操作初始化列表，以适当次序（成员的声明次序）在构造函数之内安插初始化操作，并且在任何显式写的代码之前完成操作。
初始化列表能够使用成员函数来初始化一个成员。（这里如果比较复杂的初始化能够使用这种方式提高初始化的效率，但是要注意该函数使用的变量是不是在调用前都被初始化了。合法的原因是此时this指针已经创建好了。）</p>]]></description>
</item><item>
    <title>[读书笔记]深入探索C&#43;&#43; 对象模型 第一章 关于对象</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/</link>
    <pubDate>Sun, 07 Aug 2016 11:14:03 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/</guid>
    <description><![CDATA[<h1 id="阅读的目的">阅读的目的</h1>
<p>在阅读《C++ primer》的时候，书里面写了各种各样的情况下，C++的处理方式。囫囵吞枣的记下后，也就不求甚解了。而C++在工作中的使用已经有了那么一段时间。但是对于C++的很多现象，却依旧是只知道是这样，却不知道为什么是这样。
那么阅读这本同样是 Lippman的书籍，就是为了解惑，为什么C++会导致我们看到的现象，而不是其他情况。
我希望，通过这么本书，能够解答我的一部分疑问。</p>
<h1 id="序">序</h1>
<p>工作里常听到的对于C++的抱怨是C++的编译器为程序员做了太多的服务，导致很多情况不受控制。不像C,大部分都需要手动去执行，可以明确的知道，什么时候做了什么。
我想这部分抱怨一方面来源于对于C++的不熟悉，一方面又来源于C++的特性。那么当对C++怎么实现各种特性了解后，对于编译器的行为有了概念后，我相信我应该能够解答很多疑问了。
就像Lippman在本书贴出的一封信件一般
</p>
<p>他希望这本书是这些问题的解答。</p>
<h1 id="第一章关于对象">第一章：关于对象</h1>
<p>本章主要是对于对象模型的一个大概浏览，但是对多重继承和虚拟继承等情况没有太多的观察
C语言，数据和处理数据操作是分开声明的，语言本身没有支持数据和函数的关联性。由一组分布在各个以功能为导向的函数中的算法所驱动，它们的处理的是共同的外部数据。
C++的实现使用的是ADT</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">classPoint</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">float</span> <span class="n">_x</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>这种形式将数据和函数相关联，数据封装。
那么这样的数据封装有成本吗？没有
所有的Class只会生成出一个函数实体。data members则是直接包含在class object中与C的struct一致。
C++的布局和存储时间的额外负担是由virtual引起的：</p>
<blockquote>
<ul>
<li>virtual function机制 用来支持一个有效率的“执行期绑定”。</li>
<li>virtual base class 用来实现“多次出现在继承体系中的base class,有一个单一而被共享的实体”。</li>
</ul>
</blockquote>
<p>此外，还有一些多重继承下的额外负担。</p>
<h1 id="c的对象模型">C++的对象模型</h1>
<p>C++中存在两种数据成员 static、nostatic，三种成员函数 static、nostatic、virtual。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">classPoint</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">float</span> <span class="n">xval</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Point</span><span class="p">();</span>
    <span class="kt">float</span> <span class="nf">x</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">staticint</span> <span class="nf">PointCount</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span>
    <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">float_x</span><span class="p">;</span>
    <span class="n">staticint_point_count</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
<p>上图为C++的对象模型：</p>
<blockquote>
<ul>
<li>nostatic data members 被配置在每一个class object之内。</li>
<li>static data members 被存放在所有的class object之外。</li>
<li>staitic 和 nostatic function members存放在class object之外。</li>
<li>virtual functions以两个步骤支持：</li>
<li>①每一个class产生出一堆指向virtual functions 的指针，放在表格之中。也就是虚表。</li>
<li>②每一个class object被添加了一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设和重置由每一个classd constructor destructor 和 copy assignmemt运算符自动完成。每一个class所关联的type_info object用意支持runtiome tyoe identification，rtti也经由virtual table被指出来，通常是放在第一个slot处。</li>
</ul>
</blockquote>
<h2 id="加上继承">加上继承</h2>
<p>c++支持单一继承、多重继承、虚拟继承。
</p>
<p>具体的讨论需要3.4中见到。</p>
<h2 id="对象模型如何影响程序">对象模型如何影响程序</h2>
<p>class X定义了一个拷贝构造函数，一个虚析构函数，一个虚函数foo();</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">X</span> <span class="nf">foobar</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">X</span> <span class="n">xx</span><span class="p">;</span>
    <span class="n">X</span> <span class="o">*</span><span class="n">px</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">;</span>
    <span class="n">xx</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>
    <span class="n">px</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">px</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数可能在内部转换为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//可能的内部转换结果
</span><span class="c1">//虚拟C++码
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">foobar</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">_result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//使用引用返回，属于编译器的优化了。
</span><span class="c1"></span>    <span class="c1">//构造
</span><span class="c1"></span>    <span class="n">_result</span><span class="p">.</span><span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">();</span>

    <span class="c1">//申请内存
</span><span class="c1"></span>    <span class="n">px</span> <span class="o">=</span> <span class="n">_new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">));</span>
    <span class="c1">//调用构造函数
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">px</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">px</span><span class="o">-&gt;</span><span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">();</span>

    <span class="c1">//成员函数的形式的转换，成员函数就是普通函数不过有一个this指针
</span><span class="c1"></span>    <span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_result</span><span class="p">);</span>

    <span class="c1">//虚函数的基本调用方式，通过vptr来调用
</span><span class="c1"></span>    <span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="o">-&gt;</span><span class="n">vtbl</span><span class="p">[</span><span class="mi">2</span><span class="p">])(</span><span class="n">px</span><span class="p">);</span>

    <span class="c1">//调用虚析构函数
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">px</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="o">-&gt;</span><span class="n">vtbl</span><span class="p">[</span><span class="mi">1</span><span class="p">])(</span><span class="n">px</span><span class="p">);</span>
        <span class="n">_delete</span><span class="p">(</span><span class="n">px</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//不需要使用named return statement
</span><span class="c1"></span>    <span class="c1">//不需要摧毁Local object xx
</span><span class="c1"></span>    <span class="c1">//而是使用了传入参数_result
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="关键词所带来的差异">关键词所带来的差异</h1>
<h2 id="策略性正确的struct">策略性正确的struct</h2>
<p>把单一元素的数组放在一个struct的尾端，于是每个 struct objects 可以拥有可变大小的数组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">mumble</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="c1">//获取一个字符串，然后为struct本身和该字符串配置足够的内存
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">mumble</span> <span class="o">*</span><span class="n">pmumbl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">mumble</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span>
<span class="nc">mumble</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">pmumbl</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>这在C++中是很有问题的。不一定在pc后面就没有存放数据。</p>
<h1 id="对象的差异">对象的差异</h1>
<p>C++支持多种程序设计典范：程序模型、抽象数据类型模型、面向对象模型</p>]]></description>
</item></channel>
</rss>
