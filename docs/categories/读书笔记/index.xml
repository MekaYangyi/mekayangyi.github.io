<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>读书笔记 - Category - 鉴心</title>
        <link>http://coderyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <description>读书笔记 - Category - 鉴心</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 29 Dec 2018 08:31:58 &#43;0000</lastBuildDate><atom:link href="http://coderyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="self" type="application/rss+xml" /><item>
    <title>读书摘录-存在主义心理治疗</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97/</link>
    <pubDate>Sat, 29 Dec 2018 08:31:58 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97/</guid>
    <description><![CDATA[<p>本书涉及四个终极关怀:死亡、自由、孤独和无意义。个体与这些生命真相的正面交锋，构成了存在主义动力性冲突的内容。</p>
<p>死亡。最显而易见的、最容易理解的终极关怀就是死亡。我们现在存在，但是总有一天，这种存在会终止。死亡将如期而至，没有逃脱之路。这是一个恐怖的真相，能引发我们巨大的恐惧。用斯宾诺莎的话来说，“每一事物都在尽力维持自身的存在”；而存在的一个核心冲突就是，对死亡必然性的意识与继续生存下去的愿望之间的张力。</p>
<p>自由。另一个相对来说不太容易理解的终极关怀是自由。一般来说我们都认为自由是一个毋庸置疑的积极概念。有史以来，人类不是一直在渴望并为自由而奋斗吗？然而从终极层面来看，自由是与忧惧偶联在一起的。在存在的意义上，“自由”意味着外部结构的空白。与日常经验相反的是，人类并不是进入（和离开）一个拥有内在设计、高度结构化的宇宙。实际上，个体对他自己的世界、生活设计、选择以及行为负有全部责任——也就是说，个体是自己世界的创造者。“自由”在这种含义上，带有一种可怕的暗示:它意味着在我们所站立的地方并不坚实一什么都没有，是空的，无底深渊。所以，存在主义一个关键的动力性冲突就是，们无根基的处境与我们对根基与结构的渴望之间的冲突。</p>
<p>存在性孤独。第三个终极关怀是孤独不是伴随着寂寞的人际性孤独，也不是个人内心的孤独（与自身的其他部分隔离），而是一种根本性孤独既与生命隔绝，也与世界隔绝—隔绝在所有其他孤独之下。无论我们之间变得有多么亲密无间，仍然存在一个最终无法逾越的鸿沟；我们每个人都是独自一人进入这种存在，同时也注定要独自离开。一方面是我们对自身绝对孤独的意识，另一方面是对接触、保护的渴望，以及成为一个更大整体的一部分的愿望在性冲突就是这两个方面之间的张力。</p>
<p>无意义。第四个终极关怀或存在的既定事实是无意义。如果我们注定得死，如果我们构建我们自己的世界，如果每一个人最终都是独自一人身处于一个无关紧要的世界之中，那么生命有什么意义我们为什么要活着？我们应该怎样活着？如果并不存在为我们预先设计的蓝图，那么我们每个人就必须构建自己的生命意义。然而，个人自己创造出来的意义能否坚强到令其能容忍生活？人类这种寻找意义的生物，却被投入到本身毫无意义的宇宙之中，于是，存在的动力性冲突便从进退维谷的境地中滋生出来。</p>
]]></description>
</item><item>
    <title>clean code读书笔记</title>
    <link>http://coderyang.com/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Mon, 23 Jul 2018 08:31:58 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[<p>命名，很多人戏称为编程中最难的事情。从实践经验出发来看，一个好的命名能够让代码阅读者迅速的知道代码的实际用途，而坏的命名不仅仅是让人摸不着头脑，而且可能误导他人。</p>
<p>本文主要是clean code第二章有意义的命名的笔记，该章节系统的讲述了什么才是一个好的名字。</p>
<ol>
<li>
<p>名副其实</p>
<blockquote>
<p>如果命名需要注释，则不是一个好的命名。</p>
<p>命名需要表达出准确的含义，不应该使用magic num或者i、j、k这类无意义的变量名。</p>
</blockquote>
</li>
<li>
<p>避免误导</p>
<blockquote>
<p>0和O、1、I和l。这类视觉上容易混淆的名字不需要使用。</p>
<p>假设存在一个vector，里面存储这actor_rid，但是你命名为actor_list，导致阅读者误认为是用链表实现的。</p>
</blockquote>
</li>
<li>
<p>做有意义的区分</p>
<blockquote>
<p>类似a1、a2、a3不能够带来任何信息的变量命名</p>
<p>类似thexx、xxdata、xxinfo、xxobject这类没有意义的前缀、后缀</p>
<p>不使用匈牙利命名法带上类型信息，现在ide随时可以看到类型</p>
<p>变量的命名需要带有含义，不要带上冗余的无效的信息。</p>
</blockquote>
</li>
<li>
<p>使用读得出来的名称</p>
<blockquote>
<p>如果变量难易阅读的话，对阅读者总是负担，难以记住也难易和他人交流</p>
</blockquote>
</li>
<li>
<p>使用可搜索的名称</p>
<blockquote>
<p>作用域越大变量名越长，便于搜索同时不会重复。</p>
</blockquote>
</li>
<li>
<p>避免使用编码</p>
<blockquote>
<p>匈牙利命名法在现代ide没有必要，同时影响ide的自动补全，修改类型名同时需要修改变量名</p>
<p>类似m_的前缀没有必要</p>
</blockquote>
</li>
<li>
<p>避免翻译</p>
<blockquote>
<p>缩写</p>
</blockquote>
</li>
<li>
<p>类名</p>
<blockquote>
<p>类名应该是名词或者名词短语，不应该是动词</p>
</blockquote>
</li>
<li>
<p>方法名</p>
<blockquote>
<p>方法名应该是动词或者动词短语，类似set_xx、is_xx</p>
</blockquote>
</li>
<li>
<p>别扮可爱</p>
<blockquote>
<p>不要使用难以联想到的词，即使你认为很精妙，直接了当的命名。</p>
</blockquote>
</li>
<li>
<p>每个概念对应一个词</p>
<blockquote>
<p>controller、manager、driver。英语中有很多语义相似的词语，代码中统一使用一个词来描述。</p>
</blockquote>
</li>
<li>
<p>不使用双关</p>
<blockquote>
<p>双关代表者二义性。比如add，有可能是insert的意思，有可能是append的意思。</p>
</blockquote>
</li>
<li>
<p>使用解决方案领域名称</p>
<blockquote>
<p>计算机科学属于、算法名、模式名。使用领域内专有名词利于有共同经验的人理解程序</p>
</blockquote>
</li>
<li>
<p>使用源自所涉问题领域名称</p>
<blockquote>
<p>我们是游戏编程，有很多游戏专有名词。比如exp、level、dps等，更业务的代码使用这些名词易于理解</p>
</blockquote>
</li>
<li>
<p>添加有意义的语境</p>
<blockquote>
<p>将相关的变量设置统一的前缀、后缀，建立语境。</p>
</blockquote>
</li>
<li>
<p>不要添加没用的语境</p>
<blockquote>
<p>比如给同一个项目里的所有类添加上项目名称。</p>
</blockquote>
</li>
</ol>
]]></description>
</item><item>
    <title>读书摘录-编程大师访谈录</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95/</link>
    <pubDate>Thu, 04 May 2017 08:48:08 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95/</guid>
    <description><![CDATA[<p>【美】Susan Lammers</p>
<p>第1篇　查尔斯•西蒙尼
2017-04-30
采访者：编程是一种技巧或技能吗？ 西蒙尼：什么是编程？人们对此一直各持己见。有人说它是科学，有人说它是艺术，还有人称之为技能或手艺。我认为这三方面兼而有之。我们喜欢说它蕴含大量艺术成分，但是我们都知道它里面更多的是科学。 孩子们在学校里学习数学，高中毕业时，他们会以为数学就是加法和乘法，甚或代数和微积分。其实，算术，即使简单如加法的运算，背后也有令人难以置信的科学理论作支持。 计算机编程背后也有大量科学理论作支持。例如，哥德尔定理的数学证明冗长而复杂，但是如果借用计算机科学的图灵定理，证明起来不费吹灰之力。信息理论和计算机科学其他领域对数学影响巨大，反之亦然。 编程包含有大量科学，同时，它也有点像手艺。实际上，在许多人看来，编程是一项复杂的技能，这跟工具制造很像，需要精雕细琢。我认为，只要将科学、艺术和技能这三者拿捏得恰到好处，你就能取得一些引人瞩目的成绩。
2017-04-30
别人读几段你的源代码，有没有可能断定“这代码是查尔斯·西蒙尼写的”？ 西蒙尼：噢，是的，毫无疑问。是不是我本人写的可能很难分辨，但有一点是确定无疑的：只要看了代码，你就能知道它是不是我的团队写的，或者是不是受我的影响写的。这是因为我从1972年起写的代码都遵循特定的命名规范，许多人称之为“匈牙利命名法”。你一眼就能分辨出哪些代码是受我的影响写出来的，包括Microsoft Word、Multiplan和Bravo，以及其他许多遵循这些规范写成的程序。
註: 原来是他
2017-04-30
进入公司第一天，程序员就会拿到几本书。其中一本是数学家乔治·波利亚写的《怎样解题》。（西蒙尼边说边从他办公桌旁的书柜里取出那本书，翻到某一页。）这两页很重要。这本书的其余内容就是基于这两页展开的。这就像一张问题求解的检查单。这是起飞前、起飞和着陆检查单。它不会教你如何飞行，但是如果不照做，即使你已经懂得怎么飞行，也有可能会坠机身亡。 求解问题时，我们遵循以下四个步骤：首先理解问题，然后拟定计划，接着执行计划，最后回顾整个过程。这样的书我们大概有四本，我觉得我们能使程序员比刚加入公司时变得更加优秀。</p>
<p>第2篇　巴特勒•兰普森
2017-04-30
但是我坚持认为，如果你打算在研究生院攻读计算机科学，那么本科学习计算机科学就是犯了大忌。 采访者：为什么？ 兰普森：因为从长远来看，你学的内容大部分都没什么价值。你学不到施展聪明才智的新方法，而这些方法对你来说，要比学习如何编写编译器的细枝末节有 用得多，尽管后者可能是你本科念计算机科学时的学习内容。我认为，要是所有计算机科学研究生院联合起来，一致决定不接受本科念计算机科学的毕业生，世界会变得更好。学校应当要求这些人补习一年，学习数学或历史等科目，才能继续攻读计算机科学的研究生。不过，我还没看到有学校这么做的。
2017-04-30
举例来说，鲍勃·斯普劳尔（Bob Sproull）和我花了大量时间设计Interpress项目，那是一种印刷标准。我为此投入了很大精力，原本衷心希望施乐公司接受并促使所有人采纳。相反，他们完全把它搞砸了。结果，参与开发的部分人员离职并创办了Adobe系统公司，开发出一种类似的产品PostScript。很显然，后者成了大家现在都会采用的标准。这种事情很恼人，但是研究实验室的主要产品就是创意。
註: 这不就和盛大研究院一样
2017-04-30
：程序员需要具备什么样的素质才能写出成功的程序？ 兰普森：最重要的素质是能够把问题的解决方案组织成容易操控的结构，其中每个组件都可以用简单的方式说明。有时，成功的程序员可以做到这一点，但他们无法解释自己做了什么，因为他们看不到那个结构。有些人之所以成为出色的程序员，是因为他们可以比多数人处理更多的细节。
2017-04-30
你有没有看到20年后每个指尖上都有一台计算机会出现什么问题？ 兰普森：我不觉得那有什么问题。显然每只手腕上都会有计算机。计算机的存在是予人帮助，我希望它们会给人们带来正面的影响。
註: 手机</p>
<p>第3篇　约翰•沃诺克
2017-05-01
你编程有什么诀窍？ 沃诺克：我不知道能不能归结到几点上。我前面提到过一些。不要早作绑定，尽可能推迟决定时间。眼界放宽一些，设计要比你自认为需要的程度更加灵活，因为从长远看你最终会需要这样。快速让某样东西工作起来，然后还能弃之不用。 从小的开始实验而不是大的入手学习。不要一头扎进周期长达两年且中间不出什么成果的开发当中。最好每两个月就要出点成果，这样你才能进行评估、重组和重新开始。程序员经常在一开始时过度定义他们的方法。他们可能会从一个中心构思着手，从第一天就开始编码。然后他们发现自己陷入重围，每件东西都开始膨胀，因为它们依赖于太多其他因素。应当反其道而行之，如果让过程较为宽松，保持一定的自由度，并在最后阶段加快速度，长远来说，你会做出更好的产品。</p>
<p>第4篇　加里•基尔代尔
2017-05-01
你说编程对很多人来说也是一种宗教体验，这是什么意思呢？ 基尔代尔：嗯，如果你和一群使用相同编程语言的程序员谈论编程的话，他们几乎可以成为那种编程语言的传教士。他们组成了一个紧密结合的社群，坚持一定的信念，在编程时遵循一定的规则。就像是一个把编程语言当作是圣经的教会。 FORTH是一个很好的例子，它是一种编程语言，对于很多人来说，可能很接近宗教的体验。当FORTH刚出来的时候，其信徒就声称它做任何算法都能快上十倍。这是一个典型的宣言。如果你在这点或其他任何方面有异议，你会发现自己是对牛弹琴，而且你是绝对不会被容许加入“教会”的。我并不想贬低使用这一种语言的人。那是一个非常能给人帮助的团体，所用的也是一种非常有效的语言，但他们没有基于理性去讨论问题，他们是基于信仰的。说过这句话，我可能会收到一千封有关FORTH及人们对其宗教体验的邮件。但是就算我能整天鼓吹LISP的神奇，我也不会把自己归到一个特殊的派别中。
註: 哈哈。php</p>
<p>第5篇　比尔•盖茨
2017-05-01
不，我认为在过了最初的三四年后，就会非常明显地显现出你是否是一个优秀的程序员。刚开始的几年中，你可能会更多地知道怎样去管理大型项目和不同个性的人，但在三四年后，就能很清楚地看出你会成为什么样的程序员了。在微软没有哪个程序员是在平庸了几年之后突然间一鸣惊人的。我和一个人谈谈他的程序，马上就能知道他是否是个好程序员。如果他真的很棒，每个细节他都会脱口而出。 就像下棋的人一样。如果你特别喜欢下棋，会很容易记住10盘棋中的每一步，因为你已置身其中了。其他人看到国际象棋选手或程序员能记住每个细节时，觉得他们像个怪物。其实这很正常。即使到了今天，在我写了微软的BASIC程序10年后，我仍可以在黑板上大段大段写出当时的源代码。
2017-05-01
编程需要非常大量的精力，所以大多数程序员都比较年轻。这就会带来一个问题，因为编程需要很多的训练。在年轻时，目标不是很持久，可能会被这样那样的事分心。但是年轻的程序员应当坚持下去，他们会变得更出色。作为程序员，我认为自己在1975年到1980年之间的提高是最明显的。在1975年，我会说：“嘿，看看，我什么事情都能做。”我真的认为自己可以，因为我读了大量代码，从来没有发现哪段代码是我无法快速读懂的。今天我仍旧认为检验编程能力的最好方法之一就是给程序员一本30来页的代码，看看他阅读和理解的速度有多快</p>
<p>第6篇　约翰•佩奇
2017-05-01
从一个计算机程序员转变到运营一个庞大的公司，你觉得困难吗？ 佩奇：这个角色转换是一个非常平缓的过程，因为我已经做了二十多年的管理人员，我可以告诉你真相，最难的是从管理者重新变成程序员。在创办公司前，我 在惠普已经习惯于领导很多人了。再回到编程工作时，我被迫完全依靠自己。真是让人一震。事实上这有点儿可怕——我不知道自己是否还能编程。但是，就像骑自行车一样——你永远都不会忘记的，只要一踏脚蹬，车就奔着夕阳去了。
2017-05-01
独自一人编程和一个团队合作编程有什么不同？ 佩奇：如果一个产品需要四到五个人开发，那和你自己一个人编程时采取的方法是不同的。我坚信只能由一个人来做产品和高层结构的设计，最多不能超过两个人。所有的设计出于一个头脑，才能够实现和谐与一致。如果试图取悦于所有人，让一个委员会来做设计，你的方向就错了。那绝对是致命的。 所以我在定义阶段会用一个人数非常少的团队来工作，然后如果有必要，再扩大团队来实施编程设计。实施设计方案所需要的队伍越大，就越必须严格地把整个系统划分成可管理的模块，并定义好相互间的接 口。除非一个程序大到必须由两三个人以上来做，否则不必编写很多结构化程序报告，也不用为每个步骤都编写文档。 有些系统，例如设计一个控制航天飞机的程序，需要上百名程序员。那就必须严格地把结构划分成可管理的模块才行。一个小系统的架构可能会过于大，一个大系统的架构可能会过于小——使用的技术必须与问题的规模相匹配。我就是这样做的。
2017-05-01
有些人觉得完成项目真是太过瘾了，他们做完一个项目就接着又做另一个了。这样会把自己累垮的。如果连续开始新的项目，情况会变得很糟。 另外，当你在复杂的程序上艰苦工作时，锻炼身体是很重要的。大部分程序员都缺乏身体锻炼，这样会失去敏锐的思维。往往在连续完成了第二个或第三个工作后，身体就虚弱了，以至于你会产生幻灭感，你会对着镜子说：“上帝啊，看看我，我为什么要这样做呢？</p>
<p>第7篇　C.韦恩•莱特莱夫
2017-05-01
另一方面，非常有意思的是专家系统。我的预测是，在两三年之内，专家系统不必再和人工智能牵扯在一起。这就是人工智能的历史：当某件东西开始变得众所周知时，它就独立出来了。模式识别曾经被当作是人工智能，但现在这是一个独立的领域。这也正是专家系统当下的命运。我认为专家系统在我们产业里将变得非常重要，就像垂直应用一样。
註: 和现在一样</p>
<p>第11篇　雷•奥奇
2017-05-02
我推崇严谨、一致而清晰的结构。另外，我认为软件应该高度模块化和分层，非常灵活地运用大量文件和目录。如果你必须分别构建不同组件，那么接口自然就会更加凸显出来，要求你规范这些接口。
当许多人共同开发一个程序时，在项目早期确立全局的错误处理、参数传递和子程序命名规范（虽然不见得所有人都会同意），显得非常重要。不过，对于代码该怎么注释、大括号怎么用或者代码该怎么缩进，我觉得你绝不应该对别人指手画脚。在修改别人的模块时，你最好还是按照他的惯例编写代码。这是学会与他人共事的必修课。
交流想法的环境应该是开放的。设计会议上允许非常激烈和紧张的讨论。我发现许多优秀设计师往往固执己见，但只要他们觉得是对的，就会毫不客气地坚持，但他们也知道什么时候应该怎么让步。优秀设计师不会有“非此创造”综合征。
2017-05-02
我过去常想，个人时间管理程序应该会非常便利。结果现在却得在公文包里装一台计算机随身携带，打开并启动计算机，就只为了查看我的会面安排，远不及我那口袋大小的通讯记事簿来得方便。我想要一本通讯记事簿，让我的秘书和我可以同时写入，这非常有用，因为我们俩都能便捷地安排我的时间。我希望哪个聪明的家伙能发明这种记事簿。
註: 手机日程管理软件</p>
<p>第14篇　杰夫•拉斯金
2017-05-03
1979年，苹果公司正致力于开发Lisa。不管你信不信，它最初的目标是开发一款字符界面的机器。我在苹果公司担任高级系统经理，对Lisa很不满。它非常昂贵，我认为苹果公司不够理智，居然以小型机的价格去跟DEC、通用数据公司和IBM比拼。
70年代初，我在斯坦福大学人工智能实验室做访问学者期间，在施乐PARC度过了大量时光。在我看来，施乐PARC在位图屏幕、通用键盘和图形方面的研究真是不可思议。因此，我极力游说，说服苹果公司把Lisa改成位图机器。我把施乐和苹果公司撮合到一起。施乐一度持有苹果公司10%的股票。
我提议开发一款容易使用并融合文字和图形的电脑，售价在1000美元左右。乔布斯认为这想法太疯狂了，这种机器不会有销路，我们绝不要这种玩意。他试图否决这个项目。
因此，我越过乔布斯直接找到当时的董事长迈克·马库拉（Mike Markkula），和他探讨我的想法。幸运的是，马库拉和时任总裁迈克·斯科特（Mike Scott）叮嘱乔布斯别管我。
我招揽了早期成员：巴德·特里伯（Bud Tribble）、布里安·霍华德（Brian Howard）和布雷尔·史密斯（Burrell Smith）。我们搬到另一栋大楼，打造Macintosh及其软件的原型，搭建并让它运行起来。后来，乔布斯接手后，他还编了个故事，把Mac项目称为“海盗行动”。我们并未像他后来说的那样，试图让这个项目远离苹果公司。我们跟苹果公司其他部门的联系十分紧密，我们只是尽量不让乔布斯干预这个项目。在头两年，乔布斯总想着要毙掉这个项目，因为他不明白它到底是怎么回事。
最初的Macintosh设计得既精心又合理。最后，苹果公司所有人都意识到，这是公司继Apple II后推出新产品的希望所在。随后，乔布斯接管了这个项目。他径直走进来，对我说：“我接手Macintosh硬件，你可以负责软件和出版物。”他抛出软件设计，要求Macintosh软件与Lisa保持兼容，并坚持使用鼠标。机器变得更大、更复杂，也昂贵得多。现在它跑起来黏糊糊的。你有没有用过MacWrite？我们这里把它叫做MacWait。又过了几个月，乔布斯对我说：“我来接手软件，你可以负责出版物。”于是我回答：“你也可以接手出版物。”说完便离开了。那是1982年5月。他和马库拉对我说：“请别走。再过一个月，我们会提供一份你无法拒绝的薪酬。”于是我给了他们一个月时间，他们开了一份薪酬，我没接受。
2017-05-03
近期《新闻周刊》上的一篇文章把我逗乐了，他说：“我还有几个不错的设计。”他从来没做过什么设计，他一款产品都没设计过。沃兹（Steve Wozniak）设计了Apple II。肯·罗斯穆勒（Ken Rothmuller）等人设计了Lisa。我和我的团队设计了Macintosh。温德尔·桑德斯（Wendell Sanders）设计了Apple III。乔布斯设计了什么？什么也没有。
註: 哈哈，乔布斯
2017-05-03
人工智能教会了我们大量关于我们自身以及知识的内容。非常廉价的机器上用不了靠谱的人工智能程序，至少目前行不通。
真正的人工智能有点像宗教。从前人们都说天空上面就是天堂和天使。然后你搭乘火箭飞船到了那里，发现并不是那么回事。于是你知道原来的理解有误。一旦你实现了某样东西，它就不再是人工智能。
曾几何时，国际象棋博弈程序一度被认为包含人工智能的成分。当我还在念研究生时，只要学会编写国际象棋博弈程序，你就可以拿到人工智能博士学位。现在你花上29.95美元就能买到国际象棋博弈程序，没有人称之为人工智能。它只是个会下棋的小算法。
首先，有个定义的问题。然后，它变得更加复杂。人们认为程序应该理解自然语言，但我们的话语方式对电脑或别人来说太不精确，无法弄清楚要做什么。这正是我们创造编程语言的原因。只要试过以英文写成的规格为基础开展工作，他们就会知道自己无法借此编写程序，因为它不够精确。因此，如果人类都不能做到这一点，基本上就不可能指望还能让机器做到。当你面对所谓的人工智能程序时，电脑必须已经掌握一个词汇表。比方说，你有5个命令，你想让机器理解与之等价的所有可能的英文表述，但是它理解不了所有等价的英文表述。有人可能会说：“拿个工号。”而英国绅士可能会说：“劳烦你给我们的员工派个数字编号。”这正是搞AI的人试图解决的大麻烦。
人工智能相关的许多承诺都被误解了。人工智能已经教导我们的有关语言的东西是美好的。那么，我是否认为人工智能值得做？绝对是。我是否认为这会转化出很棒的产品？会有一些。我是否认为这会实现你在大众传媒上了解到的承诺？根本不会。我会投很多钱到人工智能领域吗？没门</p>
<p>第15篇　安迪•赫兹菲尔德
2017-05-03
有个故事是关于沃兹的。沃兹是公司创始人之一，不用说，他分到了大量股票。有些人一点股票都没有，而有的人却拥有这么多股票，对此他觉得很不公平。于是他拿出自己的股票，宣布只要是在苹果公司工作满一定年限的员工，都可以从他那里买到2500股。沃兹的用意无疑是最好的，但结果这反倒让那些坏心肠的人欢天喜地。事情是这样的，许多不在乎钱财的雇员并没有行使股票购买权，于是那些贪心的家伙就对他们说：“好吧，我给你钱，我来买你的股份。”有些人不再认真工作，反而成了股票买手；他们令人生厌，个性糟糕，是不够格的工程师，毛孔里都滴着贪婪。在一个月内，有个家伙光靠这个捞了几十万美元。这实质上是在窃取沃兹的钱财。但这也是苹果公司上市时发生的故事的一部分。
到了1980年年底，在苹果公司工作不再那么有趣。通常你的头儿是从另一家公司挖过来的，对产品一无所知。最后，迈克·斯科特意识到苹果公司聘请的管理人员都是些眼高手低的家伙，1981年2月，他在一天之内把这些人都给解雇了。工程部门一共有90人，他解雇了其中40人。这一天在苹果历史上被称为“黑色星期三”。人们都惊呆了。
2017-05-03
就在Mac发布之后，Mac团队开始组建管理层的时候，我离开了苹果公司。我跟新来的技术经理有矛盾，他最初是我面试和同意录用的，没想到他是个控制和权力狂。这家伙认为我太傲慢，自以为可以通过考核给我差评打击我。我很震惊。我掏心掏肺地为这家公司卖命，尽我所能做到最好，每天工作15个小时开发这个项目。Macintosh本不该是这样的，但是这家伙却进来把它搞成了这样。因此我不得不选择离开，但是我把自己生命中整整两年献给了Macintosh，它是我最在意的。所以我一直待到Mac发布之后才离开苹果公司，开始自己单干。</p>]]></description>
</item><item>
    <title>读书摘录-调试九法：软硬件错误的排查之道</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B9%8B%E9%81%93/</link>
    <pubDate>Sun, 30 Apr 2017 16:54:08 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B9%8B%E9%81%93/</guid>
    <description><![CDATA[<p>【美】阿甘斯</p>
<p>第3章 理解系统
2017-04-07
你必须掌握系统的工作原理以及它是如何设计的。在某些情况下，还要知道为什么这样设计。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方。（这不仅仅是“墨菲定律”的问题，如果你不能理解你所设计的系统，你的工作可能会变得一团糟。）</p>
<p>3.1 阅读手册
2017-04-07
如果你是一位工程师，正在调试自己公司的产品，那么你需要读一读内部手册。工程师们设计它是用来做什么的？读一下功能说明以及所有的设计规范，研究一下图表、时序图和状态机。分析它们的代码，还要读一下注释。（是的，读一下注释，这非常重要。）一定要检查产品的设计。查明构建它的工程师们打算用它来做什么（除了用它来赚钱买辆宝马车以外）。
注意，手册上的信息也不可全信。手册（以及那些只想着赚钱买宝马车的工程师们）可能也是错的，很多难以发现的bug就出现在这里。但你仍需要了解他们的想法，哪怕其中有些信息是很难接受的。</p>
<p>3.2 逐字逐句阅读整个手册
2017-04-07
参考设计和样本程序给出了产品的一种使用方式，有时这些就是能获得的全部文档了。但是，在使用这些设计时一定要注意，创建它们的人往往只了解他们的产品，而没有遵循好的设计实践，或者不是为真实应用而设计的（最常见的缺点是不能进行错误恢复）。不要照搬这些设计，如果你没有在开始的时候发现bug，那么将来也会发现。此外，即使是最好的参考设计可能也不会完全符合应用程序的特定需求，而不符合的地方可能就是出问题的地方。当我照搬了朋友的微处理器设计时，就发生了问题，因为他的设计无法处理中</p>
<p>3.3 知道什么是正常的
2017-04-07
当你检查系统时，必须知道系统的正常工作状态。如果你不知道低位字节首先由使用了Intel芯片的PC程序来处理，那么你会认为所有长字（longword）都是随意处理的。如果你不知道缓存是干什么的，就会非常奇怪有些数据为什么没有马上写入内存。如果你不了解三态（tri-state）数据总线的工作原理，你将会认为它们可能是主板上的故障信号。如果你从未听说过电锯，你可能会认为那个发出讨厌的嗡嗡声的东西一定是出了什么毛病。知道什么是正常的可以帮助你注意到什么是不正常的。
你必须掌握一些你所工作的技术领域的基础知识。如果我不知道时钟选通脉冲和地址线是做什么的，那么即使我读了手册之后也无法理解中断问题。本书中几乎所有的（即使不是全部的话）示例都假定人们已经掌握了系统工具原理的一些基本知识。（如果我在前面使你误认为读完本书就可以调试任何技术领域的bug，那么请恕我无心之过。如果你是一位游戏编程人员，最好不要去管核电厂的调试。如果你不是医生，那么就不要试图诊断你手臂上的灰绿色斑点是什么。如果你是一位政客，那么就不要介入任何有关bug的事情。）</p>
<p>3.7 小结
2017-04-07
理解系统
这是第一条规则，因为它是最重要的。
阅读手册。它会告诉你在使用除草机时，要在除草头上涂润滑油，这样除草绳就不会被烧化。
仔细阅读每个细节。有关微处理器如何处理中断的详细信息就隐藏在数据手册的第37页。
掌握基础知识。电锯本来就会发出很大的噪声。
了解工作流程。引擎的转速可能与轮胎的转速不同，这是由传动轴造成的。
了解工具。弄清楚体温计的哪一端才是用来测量体温的，弄清楚Glitch-O-Matic逻辑分析器的强大功能是如何使用的。
查阅细节。连爱因斯坦都会去查阅细节，而Kneejerk却盲目相信自己的记忆力</p>
<p>第4章 制造失败
2017-04-09
“当你发现一个故障时该怎么办？”他会回答说：“试着让它再次发生。”（Charlie是一位训练有素的调试人员）。这样做有3个原因。
可以观察它。要观察错误（下一节将更详细地讨论这个问题），就必须使它发生。我们必须尽可能有规律地制造失败。在前面讲的电视游戏的例子中，当问题发生时我可以集中注意力观察示波器（虽然当时我已经很疲倦）。
可以专心查找原因。准确地知道问题在什么条件下会发生，有助于集中精力查找原因（但是请注意，有时这会产生误导，例如，“烤箱只有在你把面包放进去的时候才会把面包烤焦，因此问题就出在面包上。”这个问题后文也会详细讨论。）
可以判断是否已修复问题。当你认为已经修复了问题时，如何才能确信它确实已被修复呢？那就是明确知道问题是如何发生的。当问题没有修复时，如果你执行X操作，失败率为100%；在修复问题后，再执行X操作，如果失败率为0，那么你知道bug确实已被修复。（我这么说并不多余。很多时候，开发人员在修复bug时会修改软件，然后在一个与当初发现bug的不同条件下测试新软件。软件当然能运行，即使他在代码中输入一行打油诗，而他也高兴地回家了。然而，几星期后，在测试过程中，或者更糟，在客户现场，软件再次失败。后文将讨论更多这方面的内容。</p>
<p>4.4 不要模拟失败
2017-04-09
记住，这并不意味着不能用自动化过程来引发失败，也不意味着在这个过程中不能采用一些起到放大效果的措施。自动测试能够使间歇性的问题更快发生，例如电视游戏的例子。放大效果可以使得细微的问题更明显，例如在修窗户的例子中，我可以用喷水管来找到漏雨的窗户，而不用等待偶尔才有的暴风雨来检查。这两种技术都有助于引发失败，而不是模拟失败的机理。所做的改变应该是一些高层次的改变，只影响错误发生的频率，而不影响错误的发生方式。
此外，还要注意不要画蛇添足，引发新的问题。不要因为假设芯片的问题是由于热量引起的，就用热风枪来给芯片加热以模拟错误，这样只会把芯片烧化，然后你会误认为bug完全就是电路板上那堆被烧化的塑料。如果我用消防用的水龙来检查漏雨问题，可能会断定问题显然就是出在被击碎的窗子上。</p>
<p>4.9 小结
2017-04-10
制造失败
虽然看起来很简单，但如果不制造失败的话，调试就会变得很困难。
制造失败。目的是为了观察它，找到原因，并检查是否已修复。
从头开始。修车工需要知道汽车车窗在被冻结之前你洗过车。
引发失败。用喷水管向漏雨的那扇窗子喷水。
但不要模拟失败。用喷水管向漏雨的那扇窗子喷水，而不要向另一扇不同的、“类似的”窗子喷水。
查找不受你控制的条件（正是它导致了间歇性失败）。改变能够改变的每件事情，振动、摇晃、扭曲，直到再现失败。
记录每件事情，并找到间歇性bug的特征。我们的绑定系统总是只在呼叫顺序错乱时才会失败。
不要过于相信统计数据。绑定问题看起来与时间段有关，但实际上真正的原因是当地的年轻人占用了电话线路。
要认识到“那”是可能会发生的。甚至冰淇淋的口味也会影响汽车的发动。
永远不要丢掉一个调试工具。自动击球板可能在某一天就会派上用场。</p>
<p>5.6 猜测只是为了确定搜索的重点目标
2017-04-11
不要想，而要看”并不意味着不能做任何猜想。事实上猜测是好事，特别是当你理解了系统之后。你的猜测可能很接近事实，但猜测只是为了确定搜索的重点。在尝试修复问题之前，仍需要再次看到失败，以便确认你的猜测是正确的。</p>
<p>5.7 小结
2017-04-11
不要想，而要看
凭空想象，问题可能有几千条原因。而实际的原因只有去看了才能发现。
观察失败。高级工程师看到了真实的问题，并且能够找到原因。而初级工程师们认为他们知道错误发生在哪里，结果他们修复的地方根本没有出错。
查看细节。听到水泵似乎发出声音时不要停下来。到地下室查明是哪个水泵。
植入插装工具。使用源代码调试器、调试日志、状态消息、信号灯和臭鸡蛋的气味。
添加外部插装工具。使用分析器、示波器、量表、金属检测仪、心电图仪和肥皂泡。
不要害怕深入研究。虽然它是软件成品，但它出问题了，你必须打开并修复它。
注意海森堡效应。不要让仪器影响了系统。
猜测只是为了确定搜索的重点。大胆地猜测内存时序发生了错误，但在修复之前应该先查看它。</p>
<p>6.4 修复已知bug
2017-04-12
有时，我们很难相信一个系统中会有多个bug，就像在旅店预订的例子中一样。这使得用“分而治之”原则隔离每个bug变得更加困难。因此，如果同时出现了多个问题，当你确实查明了其中的一个问题时，应该立即修复它，然后再查找其他问题。我总听人们说“那里出问题了，但它不可能影响我们正在查找的问题。”事实上，它确实（而且经常）会产生影响。如果你修复了已知的错误，就可以专心致志地查找其他问题。在旅店预订系统中，技术人员只有在修复了转接盒中的双向电阻阻值过高的问题之后，才能够发现速度最慢的那台终端的接线问题。
有时修复了一个问题，另一个问题也解决了，两个问题实际上是同一个bug。
此外，如果修复某个问题对其他的问题有影响，一定要首先修复它之后再测试其他的问题。如果修复了一个问题后将会引发新的问题，那么你可以尽早发现，并有更多时间处理新的问题。</p>
<p>6.5 首先消除噪声干扰
2017-04-12
人们也很容易成为一个“完美主义者”，为了达到全面的高质量把你发现的所有不好的设计都“修复”一遍。你可能只是因为先前的程序员编写的GOTO语句看起来很差劲就删掉它们，但是，如果它们并没有实际引起问题，最好还是保留它们吧。</p>
<p>6.6 小结
2017-04-12
分而治之
当bug的藏身之地不断被缩小一半时，它将很难再隐藏下去。
通过逐次逼近缩小搜索范围。猜测1～100内的一个数字，只需7次。
确定范围。如果数字是135而你却认为它在1～100内，那么你必须扩大范围。
确定你位于bug的哪一侧。如果你所在的位置有排放物，则排放管就在上游。如果没有排放物，则排放管就在下游。
使用易于查看的测试模式。从干净、清澈的水开始，以便当排放物进入河流中时很容易看到它。
从有问题的一端开始搜索。如果你验证的是正确的部分，那么需要验证的地方太多了。应该从有问题的地方开始，然后向后追查原因。
修复已知bug。bug互相保护，互相隐藏。因此一旦找到，立即修复它们。
首先消除噪声干扰。注意那些导致系统问题的干扰因素。但对一些无足轻重的问题不要过于极端，也不要为了追求完美而去修改所有地方。</p>
<p>第7章 一次只改一个地方
2017-04-12
我们的软件工程师为了修复问题而更改了一个地方，但这个修改并没有解决问题，而他认为这不会产生什么影响。这是一个非常错误的假设。它确实有影响，它使得音频数据发生错误，只是两次错误与一次错误也没有什么太大的区别。当原来的错误被修复后，他犯的错误仍然存在，因此声音的质量仍很差。当他的修改没有解决问题时，应该立即把它改回来。
註: 经常遇到</p>
<p>7.2 用双手抓住黄铜杆
2017-04-23
在很多情况下，你可能想改变系统的不同部分，以便看看它们是否对问题有影响。这往往是一个危险的信号，说明你正在猜测，而不是使用插装工具来观察正在发生什么。你正在改变条件，而不是捕捉错误的自然发生。这可能会把最初的错误隐藏起来，而且引起更多错误。</p>
<p>7.5 自从上一次能够正常工作以来你更改了什么
2017-04-23
有时，正常的系统和错误的系统之间的区别是由于一项更改造成的。做了更改之后，正常的系统开始出现故障。一种非常有效的办法是找出第一个导致系统出错的版本，尽管这可能需要连续测试原来的版本，直到找到没有故障的版本。一旦找到了这个版本，再前进到下一个版本，验证故障是否再次出现。做完这一步之后，至少可以把问题的范围限定到两个版本之间所做的修改。
2017-04-23
问题已经存在了很长时间，但只是某个地方（例如时序或数据库大小）被改变之后，它才显露出来</p>
<p>7.6 小结
2017-04-23
一次只改一个地方
我们在生活中要有一点先见之明。如果你所做的更改没有起到预期的作用，那么就把它改回来。它们可能会产生无法预料的影响。
隔离关键因素。如果你在检查日照时间的影响，就不要改变灌溉方案。
用双手抓住黄铜杆。如果你在不知道具体发生了什么问题的情况下就试图去修理核潜艇，可能会引发一次水下的切尔诺贝利爆炸。
一次只改一个测试。我之所以知道我的VGA采集相位被破坏了，就是因为其他东西都没有发生改变。
与正常情况进行比较。如果所有出错的情况都有一些特征，而这些特征是正常情况所没有的，那么
你就找到了问题所在。
确定自从上一次正常工作以来你改变了什么地方。我的工友改变了唱机转盘上的唱头，因此这是一个很好的调试起点。</p>
<p>8.6 小结
2017-04-23
保持审计跟踪
不要只是在心里记住“保持审计跟踪”这条规则，而要把它写下来。
把你的操作、操作的顺序和结果全部记录下来。你上一次喝咖啡是什么时候？你的头痛是从什么时候开始的？
要知道，任何细节都可能是重要的。视频压缩芯片的崩溃是由于格子衬衫造成的。
把事件关联到一起。“它发出噪声，从21:04:53开始，持续4秒”比仅仅说“它发出噪声”要好得多。
用于设计的审计跟踪在测试中也非常有用。软件配置控制工具可以告诉你哪次修订引入了bug。
把事情记录下来！无论那个时刻多么恐怖，都要把它记到备忘录中，这样你才不会忘记。</p>
<p>9.4 小结
2017-04-23
检查插头
一些显而易见的假设往往是错误的。请恕我赘述，假设错误通常是最容易修复的错误。
置疑你的假设。是否运行了正确的代码？是不是燃气用完了？插头是否已插好？
从头开始。是否正确地对内存进行了初始化？是否按了除草机上的“primer bulb”按钮？开关是否已打开？
对工具进行测试。是否运行了正确的编译器？燃料油表是否被粘住了？量表是不是没电了？</p>
<p>10.5 小结
2017-04-23
获得全新观点
不管怎样，你都需要休息一下，喝杯咖啡。
征求别人的意见。甚至一个不说话的人体模特也能帮助你认识到你先前没有注意到的事情。
获取专业知识。只有VGA视频采集卡的厂商才能够肯定相位功能发生了错误。
听取别人的经验。别人会告诉你车内顶灯的线被挤压出来了。
帮助无处不在。同事、供应商、网络，还有书店，都在等待着为你提供帮助。
放下面子。bug发生了。以除掉bug为自豪，而不要非得以自己除掉bug才为自豪。
报告症状，而不要讲你的理论。不要把别人拖进你的思维定式中。
你提出的问题不必十分肯定。甚至连“穿了格子衬衫”这样的事情也可以提出来。</p>
<p>11.6 小结
2017-04-23
如果你不修复bug，它将依然存在
现在你已经掌握了所有的技术，没有理由再让bug存在了。
查证问题确实已被修复。不要假设是电路的问题，而仍然让汽车带着脏的滤油嘴上路。
查证确实是你的修复措施解决了问题。口中大喊“Wubba!”并不是使计算机打开的窍门。
要知道，bug从来不会自己消失。使用最初导致它失败的方法再次制造失败。如果必须交付产品，那么就在产品中设计一个用于捕捉bug的“陷阱”，以便产品在客户现场发生失败时，把它捉住。
从根本上解决问题。在烧坏另一台变压器之前，先把无用的8音轨磁带卡座扔掉。
对过程进行修复。不要只是擦掉地上的油，而要纠正设计机器的方式。</p>
<p>14.3 小结
2017-04-25
从帮助台得到的观点是不明确的
只能通过远程方式了解问题，眼睛和耳朵接收到的信息并不十分准确，而且关键是时间紧迫。
遵循规则。无论用户多么糊涂，都必须找到应用规则的途径。
对行动和结果加以确认。用户会误解你的意思，同时会犯错误。通过确认他们所说和所做的一切可以及早发现这些问题。
使用自动工具。不要让用户参与系统生成的日志和远程监控与控制工具。
即使是最简单的假设也需要确认。是的，有些人就是不知道有电才能使用字处理器。
使用可用的故障检修指南。要处理的很可能就是已知的、好的设计。不要忽略历史。
帮助完善故障检修指南。如果找到了某个已知系统的一个新问题，将解决问题的所有内容进行归档可以帮助下一位支持人员。</p>]]></description>
</item><item>
    <title>读书摘录-程序员的思维方式</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/</link>
    <pubDate>Sun, 26 Mar 2017 12:26:05 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/</guid>
    <description><![CDATA[<p>2.2 德雷福斯模型的5个阶段</p>
<p>2017-01-24</p>
<p>但是，如果给新手提供与情境无关的规则去参照，他们就会变得能干起来。也就是说，需要这种形式的规则：“当X发生时，执行Y。”换言之，需要一份指令清单。
图2-2　玉米饼食谱，不过你知道需要烹饪多长时间吗
这就是呼叫中心的工作原理。你可以雇用一大批对当前技术没有很多经验的人，然后让他们按照一个决策树按部就班地执行下去。</p>
<p>3.3 L型和R型的特征</p>
<p>2017-02-06</p>
<p>事实上，综合是一项非常强大的学习技术，以至于麻省理工学院媒体实验室的尼葛洛庞蒂在Don&rsquo;t Dissect the Frog, Build It [Neg94]中建议，真正想要了解一只青蛙，传统的解剖不是办法，更好的方式是构造一只青蛙。
也就是说，要求学生构造一个具有青蛙特征的生物。这是一种伟大的方式，可以真正了解到，什么使青蛙成之为青蛙，以及青蛙如何适应其特定环境。这是一个综合学习的绝佳例子。</p>
<p>4.4 收获R型线索</p>
<p>2017-02-08</p>
<p>这种方法为什么会起作用？我认为这是因为晨写让毫无防备的大脑倾倒想法。早上刚起床时，你还没有像你想的那样清醒。潜意识仍然占主角。你还没有提起所有防备，也还未适应有限的现实世界。你可以直接连通R型，至少一小会儿。</p>
<p>2017-02-08</p>
<p>你需要培养一种非目标驱动的思维方式。正如庞加莱所做，把一切都写在纸上（或者编辑器中，如果你必须得这么做的话），然后不去管它。不要试图思考。记住它，如布朗所说，不要关注它。只要简单地记住它。让事实和问题自由地搅和、浸泡（我们将在8.2节讨论这一话题）</p>
<p>4.5 收获模式</p>
<p>2017-02-08</p>
<p>“在开始练习武术之后，我感觉到我的注意力持续时间和控制能力（比如在糟糕的环境下集中注意力）都有了提高。我一直在向软件开发人员和其他知识工作者推荐我的实践经验。它就是气功，它既有武术的一面，也包含太极、冥想和呼吸的方面。</p>
<p>注</p>
<p>跑步应该也行的。</p>
<p>6.2 瞄准SMART目标</p>
<p>2017-03-05</p>
<p>使用SMART方法实现你的目标。
在这里，SMART代表具体的、可度量的、可实现的、相关的和时间可控的（Specific, Measurable, Achievable, Relevant, and Time-boxed）。对于任何目标（减肥、炒老板鱿鱼、征服世界等），你都需要制定一个计划，定出一系列帮助你实现目标的任务（objective）。每一个任务都应该具有SMART特性。</p>
<p>6.3 建立一个务实的投资计划</p>
<p>2017-03-05</p>
<p>就像任何投资一样——无论是金融还是艺术上的——都必须时刻进行管理。
很多年来，戴维·托马斯（Dave Thomas）和我一直把实用投资计划作为咨询实践的一部分，在这里我简单地介绍一下这些内容。实用投资计划基于一种非常简单但是有效的理念：像管理你的金融投资一样小心管理你的知识投资。</p>
<p>6.4 使用你的原生学习模式</p>
<p>2017-03-05</p>
<p>很多教育家把学习者分为三大类：视觉型、听觉型和动觉型。
视觉型学习者需要看到学习资料和老师。图片和图表对视觉型学习者都很有效，他们对肢体语言和面部表情也很敏感。
听觉型学习者必须听到学习材料。讲座、研讨会和播客都很有效。他们对语气、语速和其他细节都很敏感。
动觉型学习者通过活动和触摸来学习。他们需要亲身感受学习材料。特别是对运动、艺术和
工艺等领域，你都需要通过动手来学习。</p>
<p>6.9 利用文档的真正力量</p>
<p>2017-03-05</p>
<p>创建低层次的设计文档，简单地反映代码的细节（几乎很快就会过时）对任何人都没有意义。但是其他形式的文档可能是有价值的，即使没有明确的读者。</p>
<p>6.10 以教代学</p>
<p>2017-03-05</p>
<p>为了省掉你的同事过来，我们建议你在桌子上摆一只黄色橡皮鸭作替身，当你遇到问题时，先和它
聊聊。
另一种有用的办法是尝试向一个孩子或者你所在领域之外的人解释你的东西。诀窍就是用他们能理解的话语进行解释。这是一个向你的Edna大婶解释你的工作的好机会，也是一个练习从听众角度观察问题并创建隐喻的好机会，这些隐喻有助于解释、阐明你的工作。你可能会在这个过程中惊奇地发现一些新的收获和领悟。</p>
<p>第7章 积累经验</p>
<p>2017-03-05</p>
<p>我们应该小心翼翼地从实践中获得智慧并适可而止，否则我们就会像不慎坐在热炉子上的猫一样，它再也不会坐在热炉子上——这还好，但是它也再也不会坐在冷炉子上。
——马克·吐温</p>
<p>7.3 正确对待实践中的失败</p>
<p>2017-03-05</p>
<p>你可以在公司范围之外尝试，比如在家里做开源项目。这起码会减少产生负面结果的风险。但是仅仅这样不足以为你建立一个积极的学习环境。不论是在公司团队还是在黑夜里偷偷进行的独自实验，你都需要做到以下几点。</p>
<p>7.4 了解内在诀窍</p>
<p>2017-03-05</p>
<p>在采取纠正行动之前完全知道“这是什么”对于调试非常重要。太多程序员（包括我自己）往往在没有完全明白真正的错误是什么之前就着急修正它。匆忙地作出判断或者过早地进行修补。你需要首先完全明白系统的原理，然后再判断哪部分错了，最后提供解决方案。也就说，不要动手做，而是要袖手旁观。琼·金姆介绍下述方法来帮助大家充分了解。</p>
<p>8.2 通过分散注意力来集中注意力</p>
<p>2017-03-05</p>
<p>怎么区分你是在浸泡思想还是在拖延、浪费时间呢？
我总是把拖延称为“做纸娃娃”。一个密友（姓名保密）第二天有一门重要的考试，但是前一天晚上，她并不学习，而是坐在沙发上剪纸娃娃。当时这在我看来就是典型的耗费时间：一个无关的非生产性的活动阻碍了你需要做的真正工作。
但也许我错了。也许这不是拖延。这是一个高级触觉练习，也许是她浸泡思想的方法。她通过了测验并以优异成绩毕业。
如果某个任务你真的不想做，那么任何分散注意力的努力都很可能只是耗费时间。如果你仍然有兴趣，但感觉“困难”，那么思想其实是在继
续发酵，这当然没问题。</p>
<p>8.6 保持足够大的情境</p>
<p>2017-03-05</p>
<p>事实上，保持情境中任务相关的东西很有益处。不论你如何衡量生产力，仅仅多使用一台显示器就可以让你的生产力提升20%~30%。
这是为什么？
适合你的不是桌面隐喻，而是Frederick Brooks在几年前描述的拥挤的飞机座位隐喻。在一个大桌面上，你可以展开你的工作，看到你在做什么——同时看到所有的。在拥挤的飞机座位上，你没有足够的空间同时看两份以上的文档（或者文档的一部分）。你必须来回地切换文档。
我敢打赌，让你去Staples或者Office Depot等办公用品店寻找一张17英寸的办公桌，你找不到，因为这个尺寸实在是太小了。然而，大多数显示器都是17到21英寸。这点空间就是我们办公的地方。你不得不在活动窗口和应用程序之间切换，因为你无法在如此小的空间里保持足够的情境。
你知道Alt-Tab组合键（Mac上的Command-Tab）称为什么吗?情境切换。正如我们看到的，情景切换扼杀生产力。即使是类似使用Alt-Tab切换不同窗口的小动作也会花费时间、短期记忆力和精力。</p>
<p>2017-03-05</p>
<p>在最先进的操作系统上你可以使用虚拟桌面切换器，允许你拥有很多不同的屏幕，你可以使用特殊键随意切换。每一个屏幕都是独立的，称为工作空间。秘诀在于你如何在工作空间中分配应用。</p>
<p>9.2 明天上午做什么</p>
<p>2017-03-05</p>
<p>现在就开始吧！你选择开始做什么并不特别重要，重要的是主动尝试本书中提到的知识，这是你明天一大早要做的第一件事。
下面是对第一步的一些建议。
开始承担责任，不要害怕问“为什么”，也不要害怕问“你怎么知道的”或者“我怎么知道的”，同样要大方地回答“我目前还不知道”。
挑两件帮助你维持情境、免受干扰的事情，立即实施。
创建一个实用投资计划，设定SMART目标。
弄清楚你在所属专业领域中所处的位置（从新手到专家）和你期望的位置。保证诚实。你需要更多的诀窍还是更多的情境？更多规则还是更多直觉？
实践。某段代码遇到问题了吗？尝试用五种不同的方式编写。
允许犯更多错误——错误是许可的，要从中学习教训。
携带一个笔记本（最好不带横线）。涂鸦，做思维导图，记笔记。让你的思想自由地流动。
打开心扉接收美感和其他的感官输入。不论是
你的房间、桌面还是代码，关注它们是多么地赏心悦目。
开始在私人wiki上记录你感兴趣的事情。
开始写博客。为你读过的书写评论。阅读更多书，你会有更多可写的东西。使用SQ3R和思维导图。
让散步成为你每天生活的一部分。
启动一个读书小组。
再拿一个显示器，开始使用虚拟桌面。
回顾每章的“实践单元”，尝试去做。</p>
<p>9.3 超越专家</p>
<p>2017-03-05</p>
<p>达芬奇在600年前抱怨说：“人们看却没有看见，听却没有听见，吃却没有味觉，接触却没有触觉，说话却没有思考。”</p>]]></description>
</item><item>
    <title>[读书笔记] stl源码剖析 总结</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
    <pubDate>Mon, 21 Nov 2016 20:32:26 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
    <description><![CDATA[<p>大致上是将STL源码剖析看过了一篇。
前三章看到比较认真，后面几章就看到比较粗略了。
我想STL的精髓正是在内存配置、迭代器、容器中。
至于后面的一些关联式容器，用的红黑树稍复杂，不过在之前的数据结构的基础上和前几章对stl的一些常用方法是熟悉下，其实也就简单了。算法，利用迭代器，同时特化不同的版本。仿函数则是模仿函数效果的对象。整体上都算简单了。
我的计划是在未来的一小段日子里实现一个小型的stl，所谓实现，可能也不过是重新将sgi的代码打一遍罢了。不过对于整个stl的理解，我相信会更好一些。
之后我应该会更新一些写小型stl遇到的问题和解决方案。
项目的地址：
<a href="https://github.com/MekaYangyi/STL/">https://github.com/MekaYangyi/STL/</a></p>
]]></description>
</item><item>
    <title>[读书笔记] stl源码剖析 第四章 序列式容器</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</link>
    <pubDate>Sun, 20 Nov 2016 20:32:26 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</guid>
    <description><![CDATA[<p>容器分类
</p>
<h1 id="vector">vector</h1>
<p>vector还是比较简单，也就是一个动态数组，提供了些操作，带三个指针，start/finish/end
核心就是动态调整内存的方法，也就是满了开大一倍空间，拷贝过去。
push_back等操作都是值语义的，拷贝传进来的内容放入到vector中。
因为是连续的空间，所有元素连续存储在一整块内存上，迭代器直接用的原始指针。</p>
<h1 id="list">list</h1>
<p>list复杂些.
模型和常见的list是一致的，动态创建节点，插入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">_List_node_base</span> <span class="p">{</span>
  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_next</span><span class="p">;</span>
  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_List_node</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_List_node_base</span> <span class="p">{</span>
  <span class="n">_Tp</span> <span class="n">_M_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//迭代器base
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">_List_iterator_base</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">size_t</span>                     <span class="n">size_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ptrdiff_t</span>                  <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">bidirectional_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>

  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_node</span><span class="p">;</span><span class="c1">//节点指针
</span><span class="c1"></span>
  <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">_List_node_base</span><span class="o">*</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_M_node</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">_List_iterator_base</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="nf">_M_incr</span><span class="p">()</span> <span class="p">{</span> <span class="n">_M_node</span> <span class="o">=</span> <span class="n">_M_node</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">_M_decr</span><span class="p">()</span> <span class="p">{</span> <span class="n">_M_node</span> <span class="o">=</span> <span class="n">_M_node</span><span class="o">-&gt;</span><span class="n">_M_prev</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">_List_iterator_base</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_M_node</span> <span class="o">==</span> <span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">_List_iterator_base</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_M_node</span> <span class="o">!=</span> <span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>  

<span class="c1">//迭代器,重载了++ -- == * -&gt;等操作
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ref</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ptr</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_List_iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_List_iterator_base</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span><span class="n">_Tp</span><span class="o">*&gt;</span>             <span class="n">iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Ref</span><span class="p">,</span><span class="n">_Ptr</span><span class="o">&gt;</span>             <span class="n">_Self</span><span class="p">;</span>

  <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Ptr</span> <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Ref</span> <span class="n">reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_node</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">_Node</span><span class="p">;</span>

  <span class="n">_List_iterator</span><span class="p">(</span><span class="n">_Node</span><span class="o">*</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">_List_iterator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="n">_List_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">((</span><span class="n">_Node</span><span class="o">*</span><span class="p">)</span> <span class="n">_M_node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">_M_data</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#ifndef __SGI_STL_NO_ARROW_OPERATOR
</span><span class="cp"></span>  <span class="n">pointer</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">operator</span><span class="o">*</span><span class="p">());</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __SGI_STL_NO_ARROW_OPERATOR */</span><span class="cp">
</span><span class="cp"></span>
  <span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_incr</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">_Self</span> <span class="n">__tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_incr</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">__tmp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_decr</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">_Self</span> <span class="n">__tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_decr</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">__tmp</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><h1 id="deque">deque</h1>
<p>双向开头的连续空间</p>

比较特别的地方是用一个双指针维护了一个多个连续的空间

迭代器保持连续的方式
```cpp
inline size_t __deque_buf_size(size_t __size) {
  return __size < 512 ? size_t(512 / __size) : size_t(1);
}
<p>template &lt;class _Tp, class _Ref, class _Ptr&gt;
struct _Deque_iterator {
typedef _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;
typedef _Deque_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;
static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }</p>
<p>&hellip;..</p>
<p>_Tp* _M_cur;
_Tp* _M_first;
_Tp* _M_last;
_Map_pointer _M_node;</p>
<p>_Deque_iterator(_Tp* __x, _Map_pointer __y)
: _M_cur(__x), _M_first(*__y),
_M_last(*__y + _S_buffer_size()), _M_node(__y) {}
_Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}
_Deque_iterator(const iterator&amp; __x)
: _M_cur(__x._M_cur), _M_first(__x._M_first),
_M_last(__x._M_last), _M_node(__x._M_node) {}</p>
<p>reference operator*() const { return *_M_cur; }
#ifndef __SGI_STL_NO_ARROW_OPERATOR
pointer operator-&gt;() const { return _M_cur; }
#endif /* __SGI_STL_NO_ARROW_OPERATOR */</p>
<p>difference_type operator-(const _Self&amp; __x) const {
return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - 1) +
(_M_cur - _M_first) + (__x._M_last - __x._M_cur);
}</p>
<p>//++
_Self&amp; operator++() {
++_M_cur;
if (_M_cur == _M_last) {
//到尾部了就进入下一个区域
_M_set_node(_M_node + 1);//_M_node + 1就是下一个区域
_M_cur = _M_first;
}
return *this;
}
&hellip;&hellip;
//重置first等指针
void _M_set_node(_Map_pointer __new_node) {
_M_node = __new_node;
_M_first = *__new_node;
_M_last = _M_first + difference_type(_S_buffer_size());
}
};</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">如果map不足，分配空间
```cpp
template &lt;class _Tp, class _Alloc&gt;
class _Deque_base {
....
protected:
  _Tp** _M_map;
  size_t _M_map_size;  //记录的map的大小
  iterator _M_start;
  iterator _M_finish;
  ....
};
</code></pre></td></tr></table>
</div>
</div><p>空间不足分配空间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span> <span class="o">!=</span> <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">construct</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">,</span> <span class="n">__t</span><span class="p">);</span>
      <span class="o">++</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">_M_push_back_aux</span><span class="p">(</span><span class="n">__t</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Alloc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Alloc</span><span class="o">&gt;::</span><span class="n">_M_push_back_aux</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">value_type</span> <span class="n">__t_copy</span> <span class="o">=</span> <span class="n">__t</span><span class="p">;</span>
  <span class="n">_M_reserve_map_at_back</span><span class="p">();</span>
  <span class="o">*</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">_M_allocate_node</span><span class="p">();</span>
  <span class="n">__STL_TRY</span> <span class="p">{</span>
    <span class="n">construct</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">,</span> <span class="n">__t_copy</span><span class="p">);</span>
    <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_set_node</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span> <span class="o">=</span> <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_first</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">_M_deallocate_node</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="stack">stack</h1>
<p>以deuqe为底部结构，封闭头端开口，就是stack。
没有迭代器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//这里设定了了 以deque为基础
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> 
          <span class="k">class</span> <span class="nc">_Sequence</span> <span class="n">__STL_DEPENDENT_DEFAULT_TMPL</span><span class="p">(</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">stack</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Seq</span><span class="o">&gt;&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Seq</span><span class="o">&gt;&amp;</span> <span class="n">__y</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Seq</span><span class="o">&gt;&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Seq</span><span class="o">&gt;&amp;</span> <span class="n">__y</span><span class="p">);</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Sequence</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">stack</span> <span class="p">{</span>
<span class="p">.....</span>


<span class="cp">#ifdef __STL_MEMBER_TEMPLATES
</span><span class="cp"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq1</span><span class="o">&gt;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq1</span><span class="o">&gt;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* __STL_MEMBER_TEMPLATES */</span><span class="cp">
</span><span class="cp"></span>  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">__STD_QUALIFIER</span>
  <span class="k">operator</span><span class="o">==</span> <span class="n">__STL_NULL_TMPL_ARGS</span> <span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">stack</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">__STD_QUALIFIER</span>
  <span class="k">operator</span><span class="o">&lt;</span> <span class="n">__STL_NULL_TMPL_ARGS</span> <span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">stack</span><span class="o">&amp;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __STL_MEMBER_TEMPLATES */</span><span class="cp">
</span><span class="cp"></span>
<span class="p">.....</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">stack</span><span class="p">()</span> <span class="o">:</span> <span class="n">c</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="nf">stack</span><span class="p">(</span><span class="k">const</span> <span class="n">_Sequence</span><span class="o">&amp;</span> <span class="n">__s</span><span class="p">)</span> <span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">__s</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">reference</span> <span class="nf">top</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="nf">top</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">__x</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><h1 id="queue">queue</h1>
<p>同样以deque为基础</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> 
          <span class="k">class</span> <span class="nc">_Sequence</span> <span class="n">__STL_DEPENDENT_DEFAULT_TMPL</span><span class="p">(</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">queue</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Seq</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Seq</span><span class="o">&gt;&amp;</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Seq</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Seq</span><span class="o">&gt;&amp;</span><span class="p">);</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Sequence</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">queue</span> <span class="p">{</span>

<span class="p">.....</span>

<span class="cp">#ifdef __STL_MEMBER_TEMPLATES 
</span><span class="cp"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq1</span><span class="o">&gt;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq1</span><span class="o">&gt;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* __STL_MEMBER_TEMPLATES */</span><span class="cp">
</span><span class="cp"></span>  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">__STD_QUALIFIER</span>
  <span class="k">operator</span><span class="o">==</span> <span class="n">__STL_NULL_TMPL_ARGS</span> <span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">__STD_QUALIFIER</span>
  <span class="k">operator</span><span class="o">&lt;</span>  <span class="n">__STL_NULL_TMPL_ARGS</span> <span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __STL_MEMBER_TEMPLATES */</span><span class="cp">
</span><span class="cp"></span>
<span class="p">.....</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">queue</span><span class="p">()</span> <span class="o">:</span> <span class="n">c</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="nf">queue</span><span class="p">(</span><span class="k">const</span> <span class="n">_Sequence</span><span class="o">&amp;</span> <span class="n">__c</span><span class="p">)</span> <span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">__c</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">reference</span> <span class="nf">front</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="nf">front</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">reference</span> <span class="nf">back</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="nf">back</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">__x</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="heap">heap</h1>
<p>堆也就是个完全二叉树。用个数组或者vector就能实现
stl中的heap是保证每个父节点大于等于子节点，每次插入删除节点需要重新调整树</p>
<h2 id="push_heap">push_heap</h2>
<p>push操作,后调整树，查看父节点是不是符合要求</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">__push_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span>
            <span class="n">_Distance</span> <span class="n">__holeIndex</span><span class="p">,</span> <span class="n">_Distance</span> <span class="n">__topIndex</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">__value</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_Distance</span> <span class="n">__parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">__holeIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span><span class="c1">//父节点
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">__holeIndex</span> <span class="o">&gt;</span> <span class="n">__topIndex</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__parent</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">__value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//调整节点
</span><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__holeIndex</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__parent</span><span class="p">);</span>
    <span class="n">__holeIndex</span> <span class="o">=</span> <span class="n">__parent</span><span class="p">;</span>
    <span class="n">__parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">__holeIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span><span class="c1">//再判断父节点
</span><span class="c1"></span>  <span class="p">}</span>    
  <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__holeIndex</span><span class="p">)</span> <span class="o">=</span> <span class="n">__value</span><span class="p">;</span><span class="c1">//把新值移动到新位置
</span><span class="c1"></span><span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">__push_heap_aux</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span>
                <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span> <span class="n">_Distance</span><span class="o">*</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__push_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">_Distance</span><span class="p">((</span><span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">_Distance</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> 
              <span class="n">_Tp</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">//push_heap算法，这个时候值已经插入heap的最尾端，调用此函数调整heap
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">push_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="n">_Mutable_RandomAccessIterator</span><span class="p">);</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
                 <span class="n">_LessThanComparable</span><span class="p">);</span>
  <span class="n">__push_heap_aux</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span>
                  <span class="n">__DISTANCE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">),</span> <span class="n">__VALUE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="pop_heap">pop_heap</h2>
<p>调整相关节点，使得上部全部填满，最底层空出区域。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kt">void</span> 
<span class="n">__adjust_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Distance</span> <span class="n">__holeIndex</span><span class="p">,</span>
              <span class="n">_Distance</span> <span class="n">__len</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">__value</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_Distance</span> <span class="n">__topIndex</span> <span class="o">=</span> <span class="n">__holeIndex</span><span class="p">;</span>
  <span class="n">_Distance</span> <span class="n">__secondChild</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">__holeIndex</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">&lt;</span> <span class="n">__len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__secondChild</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="n">__secondChild</span><span class="o">--</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__holeIndex</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__secondChild</span><span class="p">);</span>
    <span class="n">__holeIndex</span> <span class="o">=</span> <span class="n">__secondChild</span><span class="p">;</span>
    <span class="n">__secondChild</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">==</span> <span class="n">__len</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__holeIndex</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">__holeIndex</span> <span class="o">=</span> <span class="n">__secondChild</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">__push_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__holeIndex</span><span class="p">,</span> <span class="n">__topIndex</span><span class="p">,</span> <span class="n">__value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">__pop_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span>
           <span class="n">_RandomAccessIterator</span> <span class="n">__result</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">__value</span><span class="p">,</span> <span class="n">_Distance</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//把first放到last-1
</span><span class="c1"></span>  <span class="o">*</span><span class="n">__result</span> <span class="o">=</span> <span class="o">*</span><span class="n">__first</span><span class="p">;</span>
  <span class="c1">//重新整理first到last-1之间重新成为heap
</span><span class="c1"></span>  <span class="n">__adjust_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">_Distance</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_Distance</span><span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span><span class="p">),</span> <span class="n">__value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">__pop_heap_aux</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span>
               <span class="n">_Tp</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//pop出的是最大值，也就是删除掉first，把first放到last-1，然后重新整理first到last-1之间重新成为heap
</span><span class="c1"></span>  <span class="c1">//这样之后只要去取last-1的值，就是弹出的值了。
</span><span class="c1"></span>  <span class="n">__pop_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">__last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> 
             <span class="n">_Tp</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">__DISTANCE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//pop
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">pop_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> 
                     <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="n">_Mutable_RandomAccessIterator</span><span class="p">);</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
                 <span class="n">_LessThanComparable</span><span class="p">);</span>
  <span class="n">__pop_heap_aux</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span> <span class="n">__VALUE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="make_heap">make_heap</h2>
<p>不断调用__adjust_heap调整heap的话，最终会是一个heap</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span><span class="o">&gt;</span>
<span class="kt">void</span> 
<span class="n">__make_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span>
            <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">,</span> <span class="n">_Distance</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">_Distance</span> <span class="n">__len</span> <span class="o">=</span> <span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span><span class="p">;</span>
  <span class="n">_Distance</span> <span class="n">__parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">__len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__adjust_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__parent</span><span class="p">,</span> <span class="n">__len</span><span class="p">,</span> <span class="n">_Tp</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__parent</span><span class="p">)));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__parent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">__parent</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">make_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="n">_Mutable_RandomAccessIterator</span><span class="p">);</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
                 <span class="n">_LessThanComparable</span><span class="p">);</span>
  <span class="n">__make_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span>
              <span class="n">__VALUE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">),</span> <span class="n">__DISTANCE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="sort_heap">sort_heap</h2>
<p>对一个heap一直pop，最大值移到末尾，那么就是增序序列 了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">sort_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="n">_Mutable_RandomAccessIterator</span><span class="p">);</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
                 <span class="n">_LessThanComparable</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">pop_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="o">--</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="priority_queue">priority_queue</h1>
<p>优先弹出权值高的项目，用上面的max_heap就能够实现。
操作不多。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> 
          <span class="k">class</span> <span class="nc">_Sequence</span> <span class="n">__STL_DEPENDENT_DEFAULT_TMPL</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span><span class="p">),</span>
          <span class="k">class</span> <span class="nc">_Compare</span>
          <span class="n">__STL_DEPENDENT_DEFAULT_TMPL</span><span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Sequence</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">priority_queue</span> <span class="p">{</span>
<span class="p">......</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">_Compare</span> <span class="n">comp</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">priority_queue</span><span class="p">()</span> <span class="o">:</span> <span class="n">c</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="nf">priority_queue</span><span class="p">(</span><span class="k">const</span> <span class="n">_Compare</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span>  <span class="n">c</span><span class="p">(),</span> <span class="n">comp</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">priority_queue</span><span class="p">(</span><span class="k">const</span> <span class="n">_Compare</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Sequence</span><span class="o">&amp;</span> <span class="n">__s</span><span class="p">)</span> 
    <span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">__s</span><span class="p">),</span> <span class="n">comp</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> 
    <span class="p">{</span> <span class="n">make_heap</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span> <span class="p">}</span>
<span class="p">.....</span>
  <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="nf">top</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__STL_TRY</span> <span class="p">{</span>
      <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">__x</span><span class="p">);</span> 
      <span class="n">push_heap</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">clear</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">__STL_TRY</span> <span class="p">{</span>
      <span class="n">pop_heap</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
      <span class="n">c</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">clear</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>[读书笔记] stl源码剖析 第三章 迭代器</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
    <pubDate>Thu, 17 Nov 2016 20:32:26 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
    <description><![CDATA[<p>迭代器是一种抽象的设计概念。iterator模式：提供一种方法，使能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表述方式。</p>
<h1 id="迭代器的设计思维-stl关键所在">迭代器的设计思维-stl关键所在</h1>
<p>STL的中心思想在于：将数据容器和算法分开，彼此独立设计。容器和算法的泛型化。
迭代器就是扮演着粘胶角色。</p>
<h1 id="迭代器是一种smart-pointer">迭代器是一种smart pointer</h1>
<p>list迭代器stl的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//listnode的基础类
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">_List_node_base</span> <span class="p">{</span>
  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_next</span><span class="p">;</span>
  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_prev</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//listnode
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_List_node</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_List_node_base</span> <span class="p">{</span>
  <span class="n">_Tp</span> <span class="n">_M_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//迭代器基础类
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">_List_iterator_base</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">size_t</span>                     <span class="n">size_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ptrdiff_t</span>                  <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">bidirectional_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>

  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_node</span><span class="p">;</span><span class="c1">//包含一个node
</span><span class="c1"></span>
  <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">_List_node_base</span><span class="o">*</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_M_node</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">_List_iterator_base</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="nf">_M_incr</span><span class="p">()</span> <span class="p">{</span> <span class="n">_M_node</span> <span class="o">=</span> <span class="n">_M_node</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">_M_decr</span><span class="p">()</span> <span class="p">{</span> <span class="n">_M_node</span> <span class="o">=</span> <span class="n">_M_node</span><span class="o">-&gt;</span><span class="n">_M_prev</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">_List_iterator_base</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_M_node</span> <span class="o">==</span> <span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">_List_iterator_base</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_M_node</span> <span class="o">!=</span> <span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>  
<span class="c1">//迭代器
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ref</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ptr</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_List_iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_List_iterator_base</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span><span class="n">_Tp</span><span class="o">*&gt;</span>             <span class="n">iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Ref</span><span class="p">,</span><span class="n">_Ptr</span><span class="o">&gt;</span>             <span class="n">_Self</span><span class="p">;</span>

  <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Ptr</span> <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Ref</span> <span class="n">reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_node</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">_Node</span><span class="p">;</span>

  <span class="n">_List_iterator</span><span class="p">(</span><span class="n">_Node</span><span class="o">*</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">_List_iterator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="n">_List_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">((</span><span class="n">_Node</span><span class="o">*</span><span class="p">)</span> <span class="n">_M_node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">_M_data</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#ifndef __SGI_STL_NO_ARROW_OPERATOR
</span><span class="cp"></span>  <span class="n">pointer</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">operator</span><span class="o">*</span><span class="p">());</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __SGI_STL_NO_ARROW_OPERATOR */</span><span class="cp">
</span><span class="cp"></span>  <span class="c1">//重载了几个操作实现了迭代器，不是很复杂
</span><span class="c1"></span>  <span class="c1">//++i
</span><span class="c1"></span>  <span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_incr</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//i++
</span><span class="c1"></span>  <span class="n">_Self</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">_Self</span> <span class="n">__tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_incr</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">__tmp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_decr</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">_Self</span> <span class="n">__tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_decr</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">__tmp</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="traits编程技法">Traits编程技法</h1>
<p>之前就见到用过，通过类型获取，其余的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Category</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span> <span class="o">=</span> <span class="n">ptrdiff_t</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">_Pointer</span> <span class="o">=</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Reference</span> <span class="o">=</span> <span class="n">_Tp</span><span class="o">&amp;&gt;</span>
<span class="k">struct</span> <span class="nc">iterator</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">_Category</span>  <span class="n">iterator_category</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span>        <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Distance</span>  <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Pointer</span>   <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Reference</span> <span class="n">reference</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Iterator</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">iterator_traits</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">iterator_category</span> <span class="n">iterator_category</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">value_type</span>        <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">difference_type</span>   <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">pointer</span>           <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">reference</span>         <span class="n">reference</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//对原生指针特化
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">iterator_traits</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">*&gt;</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">random_access_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span>                         <span class="n">value_type</span><span class="p">;</span>
  <span class="c1">//ptrdiff_t是C/C++标准库中定义的一个与机器相关的数据类型。ptrdiff_t类型变量通常用来保存两个指针减法操作的结果。ptrdiff_t定义在stddef.h（cstddef）这个文件内。ptrdiff_t通常被定义为long int类型。
</span><span class="c1"></span>  <span class="k">typedef</span> <span class="n">ptrdiff_t</span>                   <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span><span class="o">*</span>                        <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span><span class="o">&amp;</span>                        <span class="n">reference</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">iterator_traits</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*&gt;</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">random_access_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span>                         <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ptrdiff_t</span>                   <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>                  <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>                  <span class="n">reference</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代器的分类：
input iter：只读iter
output iter:只写iter
forward iter:允许写入型算法在这种迭代器所形成的区间操作，前向迭代器
bidirectional iterator：双向移动iter。
random access iter：前三种支持++,第四种支持++ &ndash;。这种支持所有指针的算术能力。</p>

typedef typename _Iterator::iterator_category iterator_category;的作用就是能够在编译器发现迭代器的类型，选用最合适的函数版本。
```cpp
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};
```
例子
```cpp
template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, input_iterator_tag) {
  while (__n--) ++__i;
}
<p>template &lt;class _BidirectionalIterator, class _Distance&gt;
inline void __advance(_BidirectionalIterator&amp; __i, _Distance __n,
bidirectional_iterator_tag) {
__STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);
if (__n &gt;= 0)
while (__n&ndash;) ++__i;
else
while (__n++) &ndash;__i;
}</p>
<p>template &lt;class _RandomAccessIterator, class _Distance&gt;
inline void __advance(_RandomAccessIterator&amp; __i, _Distance __n,
random_access_iterator_tag) {
__STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);
__i += __n;
}</p>
<p>template &lt;class _InputIterator, class _Distance&gt;
inline void advance(_InputIterator&amp; __i, _Distance __n) {
__STL_REQUIRES(_InputIterator, _InputIterator);
//通过下面的函数，选用合适的版本
//不需要传递参数，能够在编译器选定版本
__advance(__i, __n, iterator_category(__i));
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># __type_traits
提供一种机制，允许针对不同的型别熟悉，完成函数派送。
在内存配置器中就用到了，比如有没有拷贝构造函数等

```cpp
struct __true_type {
};

struct __false_type {
};
//选择使用__false_type为struct的目的是为了类型推倒，而不是使用bool值作为参数的话只是运行时的选择。
template &lt;class _Tp&gt;
struct __type_traits { 
   typedef __true_type     this_dummy_member_must_be_first;
                   /* Do not remove this member. It informs a compiler which
                      automatically specializes __type_traits that this
                      __type_traits template is special. It just makes sure that
                      things work if an implementation is using a template
                      called __type_traits for something unrelated. */

   /* The following restrictions should be observed for the sake of
      compilers which automatically produce type specific specializations 
      of this class:
          - You may reorder the members below if you wish
          - You may remove any of the members below if you wish
          - You must not rename members without making the corresponding
            name change in the compiler
          - Members you add will be treated like regular members unless
            you add the appropriate support in the compiler. */
 

   typedef __false_type    has_trivial_default_constructor;
   typedef __false_type    has_trivial_copy_constructor;
   typedef __false_type    has_trivial_assignment_operator;
   typedef __false_type    has_trivial_destructor;
   typedef __false_type    is_POD_type;
};

</code></pre></td></tr></table>
</div>
</div><p>然后在这个文件里定义了大量的特化，主要是特化C++标准类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="nc">__type_traits</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">has_trivial_default_constructor</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">has_trivial_copy_constructor</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">has_trivial_assignment_operator</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">has_trivial_destructor</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">is_POD_type</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//等。。。
</span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>[读书笔记] stl源码剖析 第一章、第二章 概论、内存配置器</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/</link>
    <pubDate>Wed, 16 Nov 2016 08:32:26 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/</guid>
    <description><![CDATA[<h1 id="概论">概论</h1>
<p>第一章基本都是C++基础的知识，读了《C++ Primer》的话都懂。关于各种C++的特性、STL特性都有。</p>
<h2 id="stl六大组件-功能与运用">STL六大组件 功能与运用</h2>
<p>STL提供六大组件，彼此可以组合套用</p>
<ol>
<li>容器：各种数据结构。Vector,list,deque,set,map</li>
<li>算法：各种常用算法如sort,search,copy,erase</li>
<li>迭代器：扮演容器与算法之间的粘合剂，所谓的泛型指针。五种类型</li>
<li>仿函数：行为类似函数，可以作为算法的某种策略。仿函数是重载了()的class或者class template，一般函数指针可视为狭义的仿函数</li>
<li>配接器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>配置器：负责控件的配置与管理。</li>
</ol>

# 空间配置器
SGI STL时间了一个专属的，拥有次层配置能力的、效率优越的特殊配置器。
SGI STL的缺省分配器都是其自己的分配器。
## SGI特殊的空间配置器 std::alloc
使用::construct() ::destroy()构造和析构
使用alloc::allocate() alloc::deallocate()分配 释放
```cpp
//直接利用这个类能够用指定类型指针，转换为其他引用等
template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef const _Tp*                  pointer;
  typedef const _Tp&                  reference;
};
```
```cpp
//如果有non-trivial 析构函数
template <class _ForwardIterator>
void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)
{
  for ( ; __first != __last; ++__first)
    destroy(&*__first);
}
//如果没有non-trivial 析构函数
template <class _ForwardIterator> 
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) {}
<p>template &lt;class _ForwardIterator, class _Tp&gt;
inline void
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)
{
typedef typename __type_traits&lt;_Tp&gt;::has_trivial_destructor
_Trivial_destructor;
__destroy_aux(__first, __last, _Trivial_destructor());//_Trivial_destructor()将会是_true_type 或者_false_type
//利用模板和特化
}</p>
<p>template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
__destroy(__first, __last, __VALUE_TYPE(__first));//__VALUE_TYPE(__first)获取到了类型的指针，然后调用上面函数
//利用模板和特化
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">## 空间的配置与释放 std::alloc
sgi设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略。
当分配大于128bytes时候调用第一级，小于128时候，为了降低额外负担，使用负责的memory pool整理方式。
### 第一级配置器 __malloc_alloc_template剖析
以malloc free realloc实现。
然后自己实现了一个new handler机制。
```cpp
template &lt;int __inst&gt;
void*
__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(size_t __n)
{
    void (* __my_malloc_handler)();
    void* __result;

    for (;;) {
        __my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
        (*__my_malloc_handler)();
        __result = malloc(__n);
        if (__result) return(__result);
    }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="第二级配置器">第二级配置器</h3>
<p>SIG第二级配置器的做法，如果区块够大，超过128bytes时候，就移交第一级配置器处理。当区块小鱼128bytes时候，则以内存池管理。每次配置一大块内存，并维护对应之自由链表，下次若再有相同大小的内存需求从free-lists中拨出。如果客端释放小额区块，就由配置器回收到fres-lists中。
分配区块时候，自动上调到8的倍数，并维护16个fres-lists,分别管理大小为8/16/24/32/40/48/56/64/72/80/88/96/104/112/120/128的小额区块。</p>
<blockquote>
<p>其实这里和公司用的NG_malloc是一样的策略。ng_malloc之前对于大小的区分是256k的样子，更大。后来又改写了，支持更大的内存块了。</p>
</blockquote>
<p>节点如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="nl">__PRIVATE</span><span class="p">:</span>
  <span class="k">union</span> <span class="nc">_Obj</span> <span class="p">{</span>
        <span class="k">union</span> <span class="nc">_Obj</span><span class="o">*</span> <span class="n">_M_free_list_link</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">_M_client_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>    <span class="cm">/* The client sees this.        */</span>
  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>使用union的话，可以不用每次都去转换。char _M_client_data的存在是，方便去取首地址。实际上下面用到的就是_M_free_list_link，用来作为链表。这样的话，就可以用一个4字节的空间(32位机器指针大小)，实现两个功能。而不是使用struct，因为那样就会浪费空间。</p>
<h4 id="空间配置函数allocate">空间配置函数allocate()</h4>
<p>功能：判断大小，大于128用第一级分配，小于128就查找free list。如果free list中有可用的区块，就直接拿来用，如果没有就将区块大小上调至8的倍数边界，然后调用refill()，准备为free list重新填充空间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">__n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">__ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">//超过设定的最大值就调用第一级配置器，STL设置为128
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">__n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span> <span class="n">_MAX_BYTES</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__ret</span> <span class="o">=</span> <span class="n">malloc_alloc</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="n">__n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
    <span class="c1">//寻找合适的free lists中适当的一个
</span><span class="c1"></span>      <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span> <span class="n">__my_free_list</span>
          <span class="o">=</span> <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__n</span><span class="p">);</span>
      <span class="c1">// Acquire the lock here with a constructor call.
</span><span class="c1"></span>      <span class="c1">// This ensures that it is released in exit or during stack
</span><span class="c1"></span>      <span class="c1">// unwinding.
</span><span class="c1"></span><span class="cp">#     ifndef _NOTHREADS
</span><span class="cp"></span>      <span class="cm">/*REFERENCED*/</span>
      <span class="c1">//多线程锁
</span><span class="c1"></span>      <span class="n">_Lock</span> <span class="n">__lock_instance</span><span class="p">;</span>
<span class="cp">#     endif
</span><span class="cp"></span>      <span class="n">_Obj</span><span class="o">*</span> <span class="n">__RESTRICT</span> <span class="n">__result</span> <span class="o">=</span> <span class="o">*</span><span class="n">__my_free_list</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1">//没找到的话，就重新填充free list
</span><span class="c1"></span>        <span class="n">__ret</span> <span class="o">=</span> <span class="n">_S_refill</span><span class="p">(</span><span class="n">_S_round_up</span><span class="p">(</span><span class="n">__n</span><span class="p">));</span>
      <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//指向后一个成员
</span><span class="c1"></span>        <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">__result</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span><span class="p">;</span>
        <span class="n">__ret</span> <span class="o">=</span> <span class="n">__result</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">__ret</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="空间释放函数-deallocate">空间释放函数 deallocate()</h4>
<p>先判断大小，大于128调用第一级，小于128找出对应的free list，将区块回收。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/* __p may not be 0 */</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">__p</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">__n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span> <span class="n">_MAX_BYTES</span><span class="p">)</span>
      <span class="n">malloc_alloc</span><span class="o">::</span><span class="n">deallocate</span><span class="p">(</span><span class="n">__p</span><span class="p">,</span> <span class="n">__n</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span>  <span class="n">__my_free_list</span>
          <span class="o">=</span> <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__n</span><span class="p">);</span>
      <span class="n">_Obj</span><span class="o">*</span> <span class="n">__q</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)</span><span class="n">__p</span><span class="p">;</span>

      <span class="c1">// acquire lock
</span><span class="c1"></span><span class="cp">#       ifndef _NOTHREADS
</span><span class="cp"></span>      <span class="cm">/*REFERENCED*/</span>
      <span class="n">_Lock</span> <span class="n">__lock_instance</span><span class="p">;</span>
<span class="cp">#       endif </span><span class="cm">/* _NOTHREADS */</span><span class="cp">
</span><span class="cp"></span>      <span class="n">__q</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span> <span class="o">=</span> <span class="o">*</span><span class="n">__my_free_list</span><span class="p">;</span>
      <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">__q</span><span class="p">;</span>
      <span class="c1">// lock is released here
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="重新填充free-lists">重新填充free lists</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">__threads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__inst</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="o">*</span>
<span class="n">__default_alloc_template</span><span class="o">&lt;</span><span class="n">__threads</span><span class="p">,</span> <span class="n">__inst</span><span class="o">&gt;::</span><span class="n">_S_refill</span><span class="p">(</span><span class="n">size_t</span> <span class="n">__n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">__nobjs</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="c1">//尝试分配空间 __nobjs是引用传递，作为返回值
</span><span class="c1"></span>    <span class="kt">char</span><span class="o">*</span> <span class="n">__chunk</span> <span class="o">=</span> <span class="n">_S_chunk_alloc</span><span class="p">(</span><span class="n">__n</span><span class="p">,</span> <span class="n">__nobjs</span><span class="p">);</span>
    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span> <span class="n">__my_free_list</span><span class="p">;</span>
    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__result</span><span class="p">;</span>
    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__current_obj</span><span class="p">;</span>
    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__next_obj</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">__i</span><span class="p">;</span>
    
    <span class="c1">//对只分配出一个的时候的优化
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">__nobjs</span><span class="p">)</span> <span class="k">return</span><span class="p">(</span><span class="n">__chunk</span><span class="p">);</span>
    <span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__n</span><span class="p">);</span>

    <span class="c1">//形成链表
</span><span class="c1"></span>    <span class="cm">/* Build free list in chunk */</span>
      <span class="n">__result</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)</span><span class="n">__chunk</span><span class="p">;</span>
      <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">__next_obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)(</span><span class="n">__chunk</span> <span class="o">+</span> <span class="n">__n</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">__i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="n">__i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__current_obj</span> <span class="o">=</span> <span class="n">__next_obj</span><span class="p">;</span>
        <span class="n">__next_obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">__next_obj</span> <span class="o">+</span> <span class="n">__n</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">__nobjs</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">__i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">__current_obj</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">__current_obj</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span> <span class="o">=</span> <span class="n">__next_obj</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="k">return</span><span class="p">(</span><span class="n">__result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="内存池">内存池</h4>
<p>从内存池中取空间给free list 使用，是chunk_alloc的工作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">__threads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__inst</span><span class="o">&gt;</span>
<span class="kt">char</span><span class="o">*</span>
<span class="n">__default_alloc_template</span><span class="o">&lt;</span><span class="n">__threads</span><span class="p">,</span> <span class="n">__inst</span><span class="o">&gt;::</span><span class="n">_S_chunk_alloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">__size</span><span class="p">,</span> 
                                                            <span class="kt">int</span><span class="o">&amp;</span> <span class="n">__nobjs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">__result</span><span class="p">;</span><span class="c1">//返回值
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">__total_bytes</span> <span class="o">=</span> <span class="n">__size</span> <span class="o">*</span> <span class="n">__nobjs</span><span class="p">;</span><span class="c1">//需要分配的空间大小
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">__bytes_left</span> <span class="o">=</span> <span class="n">_S_end_free</span> <span class="o">-</span> <span class="n">_S_start_free</span><span class="p">;</span><span class="c1">//内存池剩余空间
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__bytes_left</span> <span class="o">&gt;=</span> <span class="n">__total_bytes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__result</span> <span class="o">=</span> <span class="n">_S_start_free</span><span class="p">;</span><span class="c1">//返回
</span><span class="c1"></span>        <span class="n">_S_start_free</span> <span class="o">+=</span> <span class="n">__total_bytes</span><span class="p">;</span><span class="c1">//内存池可用空间起始处后移
</span><span class="c1"></span>        <span class="k">return</span><span class="p">(</span><span class="n">__result</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">__bytes_left</span> <span class="o">&gt;=</span> <span class="n">__size</span><span class="p">)</span> <span class="p">{</span><span class="c1">//能够分配一部分空间
</span><span class="c1"></span>        <span class="n">__nobjs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">__bytes_left</span><span class="o">/</span><span class="n">__size</span><span class="p">);</span><span class="c1">//判断能够分配的块数
</span><span class="c1"></span>        <span class="n">__total_bytes</span> <span class="o">=</span> <span class="n">__size</span> <span class="o">*</span> <span class="n">__nobjs</span><span class="p">;</span>
        <span class="n">__result</span> <span class="o">=</span> <span class="n">_S_start_free</span><span class="p">;</span>
        <span class="n">_S_start_free</span> <span class="o">+=</span> <span class="n">__total_bytes</span><span class="p">;</span><span class="c1">//与上同
</span><span class="c1"></span>        <span class="k">return</span><span class="p">(</span><span class="n">__result</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//不能够分配一块的大小
</span><span class="c1"></span>        <span class="n">size_t</span> <span class="n">__bytes_to_get</span> <span class="o">=</span> 
	  <span class="mi">2</span> <span class="o">*</span> <span class="n">__total_bytes</span> <span class="o">+</span> <span class="n">_S_round_up</span><span class="p">(</span><span class="n">_S_heap_size</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
        <span class="c1">// Try to make use of the left-over piece.
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">__bytes_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">//把剩余空间，分配到合适的free list
</span><span class="c1"></span>            <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span> <span class="n">__my_free_list</span> <span class="o">=</span>
                        <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__bytes_left</span><span class="p">);</span>

            <span class="p">((</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)</span><span class="n">_S_start_free</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span> <span class="o">=</span> <span class="o">*</span><span class="n">__my_free_list</span><span class="p">;</span>
            <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)</span><span class="n">_S_start_free</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">//从堆上重新分配出部分空间
</span><span class="c1"></span>        <span class="n">_S_start_free</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">__bytes_to_get</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">_S_start_free</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">size_t</span> <span class="n">__i</span><span class="p">;</span>
            <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span> <span class="n">__my_free_list</span><span class="p">;</span>
	    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__p</span><span class="p">;</span>
            <span class="c1">// Try to make do with what we have.  That can&#39;t
</span><span class="c1"></span>            <span class="c1">// hurt.  We do not try smaller requests, since that tends
</span><span class="c1"></span>            <span class="c1">// to result in disaster on multi-process machines.
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">__i</span> <span class="o">=</span> <span class="n">__size</span><span class="p">;</span>
                 <span class="n">__i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span> <span class="n">_MAX_BYTES</span><span class="p">;</span>
                 <span class="n">__i</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span> <span class="n">_ALIGN</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__i</span><span class="p">);</span>
                <span class="n">__p</span> <span class="o">=</span> <span class="o">*</span><span class="n">__my_free_list</span><span class="p">;</span>
                <span class="c1">//malloc失败的话，在现有的free list中找未用的、足够大的fee list分配
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">__p</span><span class="p">)</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">__p</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span><span class="p">;</span>
                    <span class="n">_S_start_free</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">__p</span><span class="p">;</span>
                    <span class="n">_S_end_free</span> <span class="o">=</span> <span class="n">_S_start_free</span> <span class="o">+</span> <span class="n">__i</span><span class="p">;</span>
                    <span class="k">return</span><span class="p">(</span><span class="n">_S_chunk_alloc</span><span class="p">(</span><span class="n">__size</span><span class="p">,</span> <span class="n">__nobjs</span><span class="p">));</span>
                    <span class="c1">// Any leftover piece will eventually make it to the
</span><span class="c1"></span>                    <span class="c1">// right free list.
</span><span class="c1"></span>                <span class="p">}</span>
            <span class="p">}</span>
	    <span class="n">_S_end_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// In case of exception.
</span><span class="c1"></span>            <span class="n">_S_start_free</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc_alloc</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="n">__bytes_to_get</span><span class="p">);</span>
            <span class="c1">// This should either throw an
</span><span class="c1"></span>            <span class="c1">// exception or remedy the situation.  Thus we assume it
</span><span class="c1"></span>            <span class="c1">// succeeded.
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">//拿到新空间
</span><span class="c1"></span>        <span class="n">_S_heap_size</span> <span class="o">+=</span> <span class="n">__bytes_to_get</span><span class="p">;</span>
        <span class="n">_S_end_free</span> <span class="o">=</span> <span class="n">_S_start_free</span> <span class="o">+</span> <span class="n">__bytes_to_get</span><span class="p">;</span>
        <span class="k">return</span><span class="p">(</span><span class="n">_S_chunk_alloc</span><span class="p">(</span><span class="n">__size</span><span class="p">,</span> <span class="n">__nobjs</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="内存基本处理工具">内存基本处理工具</h3>
<p>uninitialized_copy、uninitialized_fill、uninitialized_fill_n用来处理一些特殊的复制构造的情况。</p>
<h4 id="uninitialized_fill_n实现">uninitialized_fill_n实现</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_ForwardIter</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Size</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">_ForwardIter</span> 
<span class="n">uninitialized_fill_n</span><span class="p">(</span><span class="n">_ForwardIter</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Size</span> <span class="n">__n</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">__uninitialized_fill_n</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__n</span><span class="p">,</span> <span class="n">__x</span><span class="p">,</span> <span class="n">__VALUE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_ForwardIter</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Size</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">_ForwardIter</span> 
<span class="n">__uninitialized_fill_n</span><span class="p">(</span><span class="n">_ForwardIter</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Size</span> <span class="n">__n</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="n">_Tp1</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">__type_traits</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="o">&gt;::</span><span class="n">is_POD_type</span> <span class="n">_Is_POD</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">__uninitialized_fill_n_aux</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__n</span><span class="p">,</span> <span class="n">__x</span><span class="p">,</span> <span class="n">_Is_POD</span><span class="p">());</span><span class="c1">//判断有没有复制构造函数，调用不同的函数处理
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//没有复制构造函数的版本
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_ForwardIter</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Size</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">_ForwardIter</span>
<span class="n">__uninitialized_fill_n_aux</span><span class="p">(</span><span class="n">_ForwardIter</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Size</span> <span class="n">__n</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="n">__true_type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">fill_n</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__n</span><span class="p">,</span> <span class="n">__x</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//有复制构造函数的版本
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_ForwardIter</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Size</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="n">_ForwardIter</span>
<span class="n">__uninitialized_fill_n_aux</span><span class="p">(</span><span class="n">_ForwardIter</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Size</span> <span class="n">__n</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="n">__false_type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_ForwardIter</span> <span class="n">__cur</span> <span class="o">=</span> <span class="n">__first</span><span class="p">;</span>
  <span class="n">__STL_TRY</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">__n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">__n</span><span class="p">,</span> <span class="o">++</span><span class="n">__cur</span><span class="p">)</span>
      <span class="n">_Construct</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">__cur</span><span class="p">,</span> <span class="n">__x</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">__cur</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">_Destroy</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__cur</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>uninitialized_copy、uninitialized_fill的实现类似</p>]]></description>
</item><item>
    <title>阅读谷歌编程规范</title>
    <link>http://coderyang.com/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</link>
    <pubDate>Sun, 06 Nov 2016 15:47:25 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</guid>
    <description><![CDATA[<h1 id="事情的起因">事情的起因</h1>
<p>好的东西就是这样，你每次看都能够有新的收获。
这次也一样，读了一遍谷歌编程规范，又有些新的理解，也有一些需要重新让自己记住的点。
遂记录下来，成此博文。</p>
<h1 id="头文件">头文件</h1>
<h2 id="define保护">#define保护</h2>
<p>谷歌的格式是
当是： <PROJECT> _ <PATH> _ <FILE> <em>H</em>
为保证唯一性，头文件的命名应基于其所在项目源代码树的全路径。例如，项目 foo 中的头
文件 foo/src/bar/baz.h 按如下方式保护：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#ifndef FOO_BAR_BAZ_H_
</span><span class="cp">#define FOO_BAR_BAZ_H_
</span><span class="cp"></span><span class="p">...</span>
<span class="cp">#endif </span><span class="c1">// FOO_BAR_BAZ_H_
</span></code></pre></td></tr></table>
</div>
</div><p>比较起来我们的格式是使用项目前缀来防止重复，考虑到我们项目的规模一般是不会重复的，因为文件命名上就不一致。</p>
<h2 id="头文件依赖">头文件依赖</h2>
<p>尽量使用前置声明减少头文件的依赖。
因为引入一个新的头文件，头文件改变时，包含这个头文件的其他头文件也会被重新编译。
1.强数据成员声明为Foo* Foo&amp;
2.参数、返回值类型为Foo的函数，只是声明
3.今天数据成员的类型可以被声明为Foo，因为静态数据成员定义在类定义之外
至于使用指针成员替代成员对象，则会降低可读性，执行效率，不要这样做。</p>
<h2 id="内联函数">内联函数</h2>
<p>少于十行的函数定义为内联函数。
小巧的代码更好的利用指令缓存。
短小的内联函数直接放在.h文件中，对于比较复杂的内联应该放在-inl.h文件中</p>
<h2 id="函数参数的顺序">函数参数的顺序</h2>
<p>输入参数在前，输出在后。</p>
<h2 id="包含文件顺序">包含文件顺序</h2>
<p>C库 C++库 其他库 项目内的
头文件应该有带有目录信息,不要使用当前目录和父目录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">举例来说， google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下 ：
#include &#34;foo/public/fooserver.h&#34; // 优先位置
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;hash_map&gt;
#include &lt;vector&gt;
#include &#34;base/basictypes.h&#34;
#include &#34;base/commandlineflags.h&#34;
#include &#34;foo/public/bar.h&#34;
</code></pre></td></tr></table>
</div>
</div><h1 id="作用域">作用域</h1>
<h2 id="命名空间">命名空间</h2>
<p>在.CC文件中，允许甚至提倡使用不具名命名空间，以避免运行时候的命名冲突。
最好不要使用using，不要声明命名空间std下的恩和内容。</p>
<h2 id="嵌套类">嵌套类</h2>
<p>公开嵌套类作为接口的一部分时候，虽然可以直接放在全局作用域中，但是最好还是放在命名空间里。
使用起来的话，</p>
<h2 id="非成员函数静态成员函数和全局函数">非成员函数、静态成员函数和全局函数</h2>
<p>尽量放在命名空间里。</p>
<h2 id="局部变量">局部变量</h2>
<p>将函数变量尽可能置于最小作用域内，在声明变量时候将其初始化。靠近第一次使用，利于阅读。</p>
<h2 id="全局变量">全局变量</h2>
<p>全局变量的构造函数、西沟函数以及初始化操作的调用顺序只是被部分规定，每次生产可能会有变化。
很多可以用单例模式替代。</p>
<h1 id="类">类</h1>
<h2 id="构造函数中只进行哪些没有实际意义的初始化在init中集中初始化有意义的数据">构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。</h2>
<p>构造函数的问题是，没有异常处理。</p>
<h2 id="明确的构造函数">明确的构造函数</h2>
<p>使用explicit，防止自动转换。</p>
<h2 id="拷贝构造函数">拷贝构造函数</h2>
<p>大量类并不要拷贝构造函数，所以应该使用DISALLOW_COPY_AND_ASSIGN来防止拷贝构造函数的自动生成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// 禁止使用拷贝构造函数和赋值操作的宏
// 应在类的 private:中使用
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
TypeName(const TypeName&amp;); \
void operator=(const TypeName&amp;)
class Foo {
public:
Foo(int f);
~Foo();
private:
DISALLOW_COPY_AND_ASSIGN(Foo);
};
</code></pre></td></tr></table>
</div>
</div><h2 id="继承">继承</h2>
<p>使用组合一般都比使用继承合适，继承只使用public继承
虚析构函数只在有继承同时有虚函数的时候使用。</p>
<h2 id="接口">接口</h2>
<p>接口是指满足特定条件的类，这些类以Interface为后缀
定义：纯接口</p>
<blockquote>
<p>只有纯虚函数和静态函数
没有非静态数据成员
没有定义任何构造函数，如果有，也不含参数，并且为protected
如果是子类，也只能继承满足上述条件并以Interface为后缀的类</p>
</blockquote>
<h2 id="操作符重载">操作符重载</h2>
<p>除了少数特定环境外，不要重载操作符。
缺点</p>
<blockquote>
<p>混淆你的直觉，让你误以为费时的操作和内建操作一样轻巧
查找重载操作符的调用处困难
有的操作符可以对指针进行操作
重载的副作用，重载操作符&amp;的类不能被前置声明</p>
</blockquote>
<h2 id="声明次序">声明次序</h2>
<p>在类中使用特定的声明次序：public:在 private:之前，成员函数在数据成员（变量）前。
定义次序如下：public:、protected:、private:，如果那一块没有，直接忽略即可。
每一块中，声明次序一般如下：</p>
<ol>
<li>typedefs 和 enums；</li>
<li>常量；</li>
<li>构造函数；</li>
<li>析构函数；</li>
<li>成员函数，含静态成员函数；</li>
<li>数据成员，含静态数据成员。
宏 DISALLOW_COPY_AND_ASSIGN 置于 private:块之后，作为类的最后部分。参考 拷
贝构造函数。
.cc 文件中函数的定义应尽可能和声明次序一致。
不要将大型函数内联到类的定义中，通常，只有那些没有特别意义的或者性能要求高的，并
且是比较短小的函数才被定义为内联函数。更多细节参考译文第一篇的 内联函数。</li>
</ol>
<h2 id="编写短小函数">编写短小函数</h2>
<p>超过40行，考虑分割。</p>
<h1 id="google特有的风情">Google特有的风情</h1>
<h2 id="智能指针">智能指针</h2>
<p>需要使用智能指针的话scoped_ptr完全可以胜任。特殊情况下使用share_ptr。不要使用auto_ptr。
倾向于设计对象隶属明确的代码。最明确的对象隶属是根本不使用指针，直接将对象作为一个域或者局部变量使用。</p>
<h1 id="其他c特征">其他C++特征</h1>
<h2 id="引用参数">引用参数</h2>
<p>所有按引用传递的参数必须加上const</p>
<h2 id="缺省参数">缺省参数</h2>
<p>禁止使用缺省函数参数，所有参数必须明确指定的话，避免程序员不知道存在的缺省参数。</p>
<h2 id="编程数组和alloca">编程数组和alloca</h2>
<p>禁止使用变长数组。使用安全的分配器。</p>
<h2 id="友元">友元</h2>
<p>将一个单元测试用类声明为待测类的友元，很方便。</p>
<h2 id="不使用c异常">不使用C++异常</h2>
<h2 id="不使用rtti">不使用RTTI</h2>
<p>直接利用虚函数处理不同类型就好了。</p>
<h2 id="类型转换">类型转换</h2>
<p>使用 static_cast
比较好处理，直接查找static_cast，就能找到哪里用了转换。C语言转换语义模糊。</p>
<ol>
<li>static_cast：和 C 风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上
转换；</li>
<li>const_cast：移除 const 属性；</li>
<li>reinterpret_cast：指针类型和整型或其他指针间不安全的相互转换，仅在你对所做一
切了然于心时使用；</li>
<li>dynamic_cast：除测试外不要使用，除单元测试外，如果你需要在运行时确定类型信
息，说明设计有缺陷（参考  RTTI）。</li>
</ol>
<h2 id="流-streams">流 streams</h2>
<p>只在记录日志的时候使用。
其他时候使用printf替代。
估计是stream的构造使用成本高，printf简单直接。
然后steam重载&laquo;会产生很多意想不到的错误，在深入理解C++面向对象的书里面也有提到。</p>
<h2 id="前置自增和自减">前置自增和自减</h2>
<p>效率更高。
对于简单数值来说无所谓，但是对于迭代器这种，前置更好。</p>
<h2 id="const的使用">const的使用</h2>
<p>在能够使用const的时候使用const.</p>
<h2 id="整型">整型</h2>
<p>C++中使用 stdint.h中的确定大小整型
不要使用无符号，使用断言声明变量非负数。也就是在传参的时候，在执行前断言判断。</p>
<h2 id="预处理宏">预处理宏</h2>
<p>宏尽量被内联函数、枚举和常量替代
下面给出的用法模式可以避免一些使用宏的问题，供使用宏时参考：</p>
<ol>
<li>不要在.h 文件中定义宏；</li>
<li>使用前正确#define，使用后正确#undef；</li>
<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>
<li>不使用会导致不稳定的 C++构造（unbalanced C++ constructs，译者注） 的宏，
至少文档说明其行为。
像我们项目里的宏，完全应该被替代，起码使用一个命名空间，防止污染全局空间事情的发生。</li>
</ol>
<h1 id="命名约定">命名约定</h1>
<h2 id="通用命名规则">通用命名规则</h2>
<p>不缩写
易于理解第一</p>
<h1 id="注释">注释</h1>
<h2 id="todo注释">TODO注释</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// TODO(kl@gmail.com): Use a &#34;*&#34; here for concatenation operator.
</span><span class="c1">// TODO(Zeke) change this to use relations.
</span></code></pre></td></tr></table>
</div>
</div><h1 id="格式">格式</h1>
<h2 id="swich">swich</h2>
<p>如果 default 永不会执行，可以简单的使用 assert：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">switch</span> <span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="p">{</span> <span class="c1">// 2 space indent
</span><span class="c1"></span><span class="p">...</span> <span class="c1">// 4 space indent
</span><span class="c1"></span><span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="p">{</span>
<span class="p">...</span>
<span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">default</span><span class="o">:</span> <span class="p">{</span>
<span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item></channel>
</rss>
