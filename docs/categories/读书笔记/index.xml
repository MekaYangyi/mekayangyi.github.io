<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>读书笔记 - Category - 鉴心</title>
        <link>http://coderyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <description>读书笔记 - Category - 鉴心</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 23 Jul 2018 08:31:58 &#43;0000</lastBuildDate><atom:link href="http://coderyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="self" type="application/rss+xml" /><item>
    <title>clean code读书笔记</title>
    <link>http://coderyang.com/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Mon, 23 Jul 2018 08:31:58 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[<p>命名，很多人戏称为编程中最难的事情。从实践经验出发来看，一个好的命名能够让代码阅读者迅速的知道代码的实际用途，而坏的命名不仅仅是让人摸不着头脑，而且可能误导他人。</p>
<p>本文主要是clean code第二章有意义的命名的笔记，该章节系统的讲述了什么才是一个好的名字。</p>
<ol>
<li>
<p>名副其实</p>
<blockquote>
<p>如果命名需要注释，则不是一个好的命名。</p>
<p>命名需要表达出准确的含义，不应该使用magic num或者i、j、k这类无意义的变量名。</p>
</blockquote>
</li>
<li>
<p>避免误导</p>
<blockquote>
<p>0和O、1、I和l。这类视觉上容易混淆的名字不需要使用。</p>
<p>假设存在一个vector，里面存储这actor_rid，但是你命名为actor_list，导致阅读者误认为是用链表实现的。</p>
</blockquote>
</li>
<li>
<p>做有意义的区分</p>
<blockquote>
<p>类似a1、a2、a3不能够带来任何信息的变量命名</p>
<p>类似thexx、xxdata、xxinfo、xxobject这类没有意义的前缀、后缀</p>
<p>不使用匈牙利命名法带上类型信息，现在ide随时可以看到类型</p>
<p>变量的命名需要带有含义，不要带上冗余的无效的信息。</p>
</blockquote>
</li>
<li>
<p>使用读得出来的名称</p>
<blockquote>
<p>如果变量难易阅读的话，对阅读者总是负担，难以记住也难易和他人交流</p>
</blockquote>
</li>
<li>
<p>使用可搜索的名称</p>
<blockquote>
<p>作用域越大变量名越长，便于搜索同时不会重复。</p>
</blockquote>
</li>
<li>
<p>避免使用编码</p>
<blockquote>
<p>匈牙利命名法在现代ide没有必要，同时影响ide的自动补全，修改类型名同时需要修改变量名</p>
<p>类似m_的前缀没有必要</p>
</blockquote>
</li>
<li>
<p>避免翻译</p>
<blockquote>
<p>缩写</p>
</blockquote>
</li>
<li>
<p>类名</p>
<blockquote>
<p>类名应该是名词或者名词短语，不应该是动词</p>
</blockquote>
</li>
<li>
<p>方法名</p>
<blockquote>
<p>方法名应该是动词或者动词短语，类似set_xx、is_xx</p>
</blockquote>
</li>
<li>
<p>别扮可爱</p>
<blockquote>
<p>不要使用难以联想到的词，即使你认为很精妙，直接了当的命名。</p>
</blockquote>
</li>
<li>
<p>每个概念对应一个词</p>
<blockquote>
<p>controller、manager、driver。英语中有很多语义相似的词语，代码中统一使用一个词来描述。</p>
</blockquote>
</li>
<li>
<p>不使用双关</p>
<blockquote>
<p>双关代表者二义性。比如add，有可能是insert的意思，有可能是append的意思。</p>
</blockquote>
</li>
<li>
<p>使用解决方案领域名称</p>
<blockquote>
<p>计算机科学属于、算法名、模式名。使用领域内专有名词利于有共同经验的人理解程序</p>
</blockquote>
</li>
<li>
<p>使用源自所涉问题领域名称</p>
<blockquote>
<p>我们是游戏编程，有很多游戏专有名词。比如exp、level、dps等，更业务的代码使用这些名词易于理解</p>
</blockquote>
</li>
<li>
<p>添加有意义的语境</p>
<blockquote>
<p>将相关的变量设置统一的前缀、后缀，建立语境。</p>
</blockquote>
</li>
<li>
<p>不要添加没用的语境</p>
<blockquote>
<p>比如给同一个项目里的所有类添加上项目名称。</p>
</blockquote>
</li>
</ol>
]]></description>
</item><item>
    <title>[读书笔记] stl源码剖析 总结</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
    <pubDate>Mon, 21 Nov 2016 20:32:26 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
    <description><![CDATA[<p>大致上是将STL源码剖析看过了一篇。
前三章看到比较认真，后面几章就看到比较粗略了。
我想STL的精髓正是在内存配置、迭代器、容器中。
至于后面的一些关联式容器，用的红黑树稍复杂，不过在之前的数据结构的基础上和前几章对stl的一些常用方法是熟悉下，其实也就简单了。算法，利用迭代器，同时特化不同的版本。仿函数则是模仿函数效果的对象。整体上都算简单了。
我的计划是在未来的一小段日子里实现一个小型的stl，所谓实现，可能也不过是重新将sgi的代码打一遍罢了。不过对于整个stl的理解，我相信会更好一些。
之后我应该会更新一些写小型stl遇到的问题和解决方案。
项目的地址：
<a href="https://github.com/MekaYangyi/STL/">https://github.com/MekaYangyi/STL/</a></p>
]]></description>
</item><item>
    <title>[读书笔记] stl源码剖析 第四章 序列式容器</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</link>
    <pubDate>Sun, 20 Nov 2016 20:32:26 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</guid>
    <description><![CDATA[<p>容器分类
</p>
<h1 id="vector">vector</h1>
<p>vector还是比较简单，也就是一个动态数组，提供了些操作，带三个指针，start/finish/end
核心就是动态调整内存的方法，也就是满了开大一倍空间，拷贝过去。
push_back等操作都是值语义的，拷贝传进来的内容放入到vector中。
因为是连续的空间，所有元素连续存储在一整块内存上，迭代器直接用的原始指针。</p>
<h1 id="list">list</h1>
<p>list复杂些.
模型和常见的list是一致的，动态创建节点，插入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">_List_node_base</span> <span class="p">{</span>
  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_next</span><span class="p">;</span>
  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_List_node</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_List_node_base</span> <span class="p">{</span>
  <span class="n">_Tp</span> <span class="n">_M_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//迭代器base
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">_List_iterator_base</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">size_t</span>                     <span class="n">size_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ptrdiff_t</span>                  <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">bidirectional_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>

  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_node</span><span class="p">;</span><span class="c1">//节点指针
</span><span class="c1"></span>
  <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">_List_node_base</span><span class="o">*</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_M_node</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">_List_iterator_base</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="nf">_M_incr</span><span class="p">()</span> <span class="p">{</span> <span class="n">_M_node</span> <span class="o">=</span> <span class="n">_M_node</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">_M_decr</span><span class="p">()</span> <span class="p">{</span> <span class="n">_M_node</span> <span class="o">=</span> <span class="n">_M_node</span><span class="o">-&gt;</span><span class="n">_M_prev</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">_List_iterator_base</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_M_node</span> <span class="o">==</span> <span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">_List_iterator_base</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_M_node</span> <span class="o">!=</span> <span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>  

<span class="c1">//迭代器,重载了++ -- == * -&gt;等操作
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ref</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ptr</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_List_iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_List_iterator_base</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span><span class="n">_Tp</span><span class="o">*&gt;</span>             <span class="n">iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Ref</span><span class="p">,</span><span class="n">_Ptr</span><span class="o">&gt;</span>             <span class="n">_Self</span><span class="p">;</span>

  <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Ptr</span> <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Ref</span> <span class="n">reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_node</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">_Node</span><span class="p">;</span>

  <span class="n">_List_iterator</span><span class="p">(</span><span class="n">_Node</span><span class="o">*</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">_List_iterator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="n">_List_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">((</span><span class="n">_Node</span><span class="o">*</span><span class="p">)</span> <span class="n">_M_node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">_M_data</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#ifndef __SGI_STL_NO_ARROW_OPERATOR
</span><span class="cp"></span>  <span class="n">pointer</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">operator</span><span class="o">*</span><span class="p">());</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __SGI_STL_NO_ARROW_OPERATOR */</span><span class="cp">
</span><span class="cp"></span>
  <span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_incr</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">_Self</span> <span class="n">__tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_incr</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">__tmp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_decr</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">_Self</span> <span class="n">__tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_decr</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">__tmp</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><h1 id="deque">deque</h1>
<p>双向开头的连续空间</p>

比较特别的地方是用一个双指针维护了一个多个连续的空间

迭代器保持连续的方式
```cpp
inline size_t __deque_buf_size(size_t __size) {
  return __size < 512 ? size_t(512 / __size) : size_t(1);
}
<p>template &lt;class _Tp, class _Ref, class _Ptr&gt;
struct _Deque_iterator {
typedef _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;
typedef _Deque_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;
static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }</p>
<p>&hellip;..</p>
<p>_Tp* _M_cur;
_Tp* _M_first;
_Tp* _M_last;
_Map_pointer _M_node;</p>
<p>_Deque_iterator(_Tp* __x, _Map_pointer __y)
: _M_cur(__x), _M_first(*__y),
_M_last(*__y + _S_buffer_size()), _M_node(__y) {}
_Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}
_Deque_iterator(const iterator&amp; __x)
: _M_cur(__x._M_cur), _M_first(__x._M_first),
_M_last(__x._M_last), _M_node(__x._M_node) {}</p>
<p>reference operator*() const { return *_M_cur; }
#ifndef __SGI_STL_NO_ARROW_OPERATOR
pointer operator-&gt;() const { return _M_cur; }
#endif /* __SGI_STL_NO_ARROW_OPERATOR */</p>
<p>difference_type operator-(const _Self&amp; __x) const {
return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - 1) +
(_M_cur - _M_first) + (__x._M_last - __x._M_cur);
}</p>
<p>//++
_Self&amp; operator++() {
++_M_cur;
if (_M_cur == _M_last) {
//到尾部了就进入下一个区域
_M_set_node(_M_node + 1);//_M_node + 1就是下一个区域
_M_cur = _M_first;
}
return *this;
}
&hellip;&hellip;
//重置first等指针
void _M_set_node(_Map_pointer __new_node) {
_M_node = __new_node;
_M_first = *__new_node;
_M_last = _M_first + difference_type(_S_buffer_size());
}
};</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">如果map不足，分配空间
```cpp
template &lt;class _Tp, class _Alloc&gt;
class _Deque_base {
....
protected:
  _Tp** _M_map;
  size_t _M_map_size;  //记录的map的大小
  iterator _M_start;
  iterator _M_finish;
  ....
};
</code></pre></td></tr></table>
</div>
</div><p>空间不足分配空间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span> <span class="o">!=</span> <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">construct</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">,</span> <span class="n">__t</span><span class="p">);</span>
      <span class="o">++</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">_M_push_back_aux</span><span class="p">(</span><span class="n">__t</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Alloc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Alloc</span><span class="o">&gt;::</span><span class="n">_M_push_back_aux</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">value_type</span> <span class="n">__t_copy</span> <span class="o">=</span> <span class="n">__t</span><span class="p">;</span>
  <span class="n">_M_reserve_map_at_back</span><span class="p">();</span>
  <span class="o">*</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">_M_allocate_node</span><span class="p">();</span>
  <span class="n">__STL_TRY</span> <span class="p">{</span>
    <span class="n">construct</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">,</span> <span class="n">__t_copy</span><span class="p">);</span>
    <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_set_node</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span> <span class="o">=</span> <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_first</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">_M_deallocate_node</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="stack">stack</h1>
<p>以deuqe为底部结构，封闭头端开口，就是stack。
没有迭代器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//这里设定了了 以deque为基础
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> 
          <span class="k">class</span> <span class="nc">_Sequence</span> <span class="n">__STL_DEPENDENT_DEFAULT_TMPL</span><span class="p">(</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">stack</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Seq</span><span class="o">&gt;&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Seq</span><span class="o">&gt;&amp;</span> <span class="n">__y</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Seq</span><span class="o">&gt;&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Seq</span><span class="o">&gt;&amp;</span> <span class="n">__y</span><span class="p">);</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Sequence</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">stack</span> <span class="p">{</span>
<span class="p">.....</span>


<span class="cp">#ifdef __STL_MEMBER_TEMPLATES
</span><span class="cp"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq1</span><span class="o">&gt;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq1</span><span class="o">&gt;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* __STL_MEMBER_TEMPLATES */</span><span class="cp">
</span><span class="cp"></span>  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">__STD_QUALIFIER</span>
  <span class="k">operator</span><span class="o">==</span> <span class="n">__STL_NULL_TMPL_ARGS</span> <span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">stack</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">__STD_QUALIFIER</span>
  <span class="k">operator</span><span class="o">&lt;</span> <span class="n">__STL_NULL_TMPL_ARGS</span> <span class="p">(</span><span class="k">const</span> <span class="n">stack</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">stack</span><span class="o">&amp;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __STL_MEMBER_TEMPLATES */</span><span class="cp">
</span><span class="cp"></span>
<span class="p">.....</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">stack</span><span class="p">()</span> <span class="o">:</span> <span class="n">c</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="nf">stack</span><span class="p">(</span><span class="k">const</span> <span class="n">_Sequence</span><span class="o">&amp;</span> <span class="n">__s</span><span class="p">)</span> <span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">__s</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">reference</span> <span class="nf">top</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="nf">top</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">__x</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><h1 id="queue">queue</h1>
<p>同样以deque为基础</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> 
          <span class="k">class</span> <span class="nc">_Sequence</span> <span class="n">__STL_DEPENDENT_DEFAULT_TMPL</span><span class="p">(</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">queue</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Seq</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Seq</span><span class="o">&gt;&amp;</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Seq</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Seq</span><span class="o">&gt;&amp;</span><span class="p">);</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Sequence</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">queue</span> <span class="p">{</span>

<span class="p">.....</span>

<span class="cp">#ifdef __STL_MEMBER_TEMPLATES 
</span><span class="cp"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq1</span><span class="o">&gt;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Seq1</span><span class="o">&gt;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="p">,</span> <span class="n">_Seq1</span><span class="o">&gt;&amp;</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* __STL_MEMBER_TEMPLATES */</span><span class="cp">
</span><span class="cp"></span>  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">__STD_QUALIFIER</span>
  <span class="k">operator</span><span class="o">==</span> <span class="n">__STL_NULL_TMPL_ARGS</span> <span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">__STD_QUALIFIER</span>
  <span class="k">operator</span><span class="o">&lt;</span>  <span class="n">__STL_NULL_TMPL_ARGS</span> <span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __STL_MEMBER_TEMPLATES */</span><span class="cp">
</span><span class="cp"></span>
<span class="p">.....</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">queue</span><span class="p">()</span> <span class="o">:</span> <span class="n">c</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="nf">queue</span><span class="p">(</span><span class="k">const</span> <span class="n">_Sequence</span><span class="o">&amp;</span> <span class="n">__c</span><span class="p">)</span> <span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">__c</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">reference</span> <span class="nf">front</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="nf">front</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">reference</span> <span class="nf">back</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="nf">back</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">__x</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="heap">heap</h1>
<p>堆也就是个完全二叉树。用个数组或者vector就能实现
stl中的heap是保证每个父节点大于等于子节点，每次插入删除节点需要重新调整树</p>
<h2 id="push_heap">push_heap</h2>
<p>push操作,后调整树，查看父节点是不是符合要求</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">__push_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span>
            <span class="n">_Distance</span> <span class="n">__holeIndex</span><span class="p">,</span> <span class="n">_Distance</span> <span class="n">__topIndex</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">__value</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_Distance</span> <span class="n">__parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">__holeIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span><span class="c1">//父节点
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">__holeIndex</span> <span class="o">&gt;</span> <span class="n">__topIndex</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__parent</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">__value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//调整节点
</span><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__holeIndex</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__parent</span><span class="p">);</span>
    <span class="n">__holeIndex</span> <span class="o">=</span> <span class="n">__parent</span><span class="p">;</span>
    <span class="n">__parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">__holeIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span><span class="c1">//再判断父节点
</span><span class="c1"></span>  <span class="p">}</span>    
  <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__holeIndex</span><span class="p">)</span> <span class="o">=</span> <span class="n">__value</span><span class="p">;</span><span class="c1">//把新值移动到新位置
</span><span class="c1"></span><span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">__push_heap_aux</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span>
                <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span> <span class="n">_Distance</span><span class="o">*</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__push_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">_Distance</span><span class="p">((</span><span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">_Distance</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> 
              <span class="n">_Tp</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">//push_heap算法，这个时候值已经插入heap的最尾端，调用此函数调整heap
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">push_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="n">_Mutable_RandomAccessIterator</span><span class="p">);</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
                 <span class="n">_LessThanComparable</span><span class="p">);</span>
  <span class="n">__push_heap_aux</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span>
                  <span class="n">__DISTANCE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">),</span> <span class="n">__VALUE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="pop_heap">pop_heap</h2>
<p>调整相关节点，使得上部全部填满，最底层空出区域。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kt">void</span> 
<span class="n">__adjust_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Distance</span> <span class="n">__holeIndex</span><span class="p">,</span>
              <span class="n">_Distance</span> <span class="n">__len</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">__value</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_Distance</span> <span class="n">__topIndex</span> <span class="o">=</span> <span class="n">__holeIndex</span><span class="p">;</span>
  <span class="n">_Distance</span> <span class="n">__secondChild</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">__holeIndex</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">&lt;</span> <span class="n">__len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__secondChild</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="n">__secondChild</span><span class="o">--</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__holeIndex</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__secondChild</span><span class="p">);</span>
    <span class="n">__holeIndex</span> <span class="o">=</span> <span class="n">__secondChild</span><span class="p">;</span>
    <span class="n">__secondChild</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">==</span> <span class="n">__len</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__holeIndex</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="p">(</span><span class="n">__secondChild</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">__holeIndex</span> <span class="o">=</span> <span class="n">__secondChild</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">__push_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__holeIndex</span><span class="p">,</span> <span class="n">__topIndex</span><span class="p">,</span> <span class="n">__value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">__pop_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span>
           <span class="n">_RandomAccessIterator</span> <span class="n">__result</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">__value</span><span class="p">,</span> <span class="n">_Distance</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//把first放到last-1
</span><span class="c1"></span>  <span class="o">*</span><span class="n">__result</span> <span class="o">=</span> <span class="o">*</span><span class="n">__first</span><span class="p">;</span>
  <span class="c1">//重新整理first到last-1之间重新成为heap
</span><span class="c1"></span>  <span class="n">__adjust_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">_Distance</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_Distance</span><span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span><span class="p">),</span> <span class="n">__value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">__pop_heap_aux</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span>
               <span class="n">_Tp</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//pop出的是最大值，也就是删除掉first，把first放到last-1，然后重新整理first到last-1之间重新成为heap
</span><span class="c1"></span>  <span class="c1">//这样之后只要去取last-1的值，就是弹出的值了。
</span><span class="c1"></span>  <span class="n">__pop_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">__last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> 
             <span class="n">_Tp</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">__DISTANCE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//pop
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">pop_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> 
                     <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="n">_Mutable_RandomAccessIterator</span><span class="p">);</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
                 <span class="n">_LessThanComparable</span><span class="p">);</span>
  <span class="n">__pop_heap_aux</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span> <span class="n">__VALUE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="make_heap">make_heap</h2>
<p>不断调用__adjust_heap调整heap的话，最终会是一个heap</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span><span class="o">&gt;</span>
<span class="kt">void</span> 
<span class="n">__make_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span>
            <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">,</span> <span class="n">_Distance</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">_Distance</span> <span class="n">__len</span> <span class="o">=</span> <span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span><span class="p">;</span>
  <span class="n">_Distance</span> <span class="n">__parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">__len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__adjust_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__parent</span><span class="p">,</span> <span class="n">__len</span><span class="p">,</span> <span class="n">_Tp</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__first</span> <span class="o">+</span> <span class="n">__parent</span><span class="p">)));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__parent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">__parent</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> 
<span class="n">make_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="n">_Mutable_RandomAccessIterator</span><span class="p">);</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
                 <span class="n">_LessThanComparable</span><span class="p">);</span>
  <span class="n">__make_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span>
              <span class="n">__VALUE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">),</span> <span class="n">__DISTANCE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="sort_heap">sort_heap</h2>
<p>对一个heap一直pop，最大值移到末尾，那么就是增序序列 了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_RandomAccessIterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">sort_heap</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="n">_Mutable_RandomAccessIterator</span><span class="p">);</span>
  <span class="n">__STL_REQUIRES</span><span class="p">(</span><span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
                 <span class="n">_LessThanComparable</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="n">__first</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">pop_heap</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="o">--</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="priority_queue">priority_queue</h1>
<p>优先弹出权值高的项目，用上面的max_heap就能够实现。
操作不多。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> 
          <span class="k">class</span> <span class="nc">_Sequence</span> <span class="n">__STL_DEPENDENT_DEFAULT_TMPL</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span><span class="p">),</span>
          <span class="k">class</span> <span class="nc">_Compare</span>
          <span class="n">__STL_DEPENDENT_DEFAULT_TMPL</span><span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Sequence</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">priority_queue</span> <span class="p">{</span>
<span class="p">......</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">_Compare</span> <span class="n">comp</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">priority_queue</span><span class="p">()</span> <span class="o">:</span> <span class="n">c</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="nf">priority_queue</span><span class="p">(</span><span class="k">const</span> <span class="n">_Compare</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span>  <span class="n">c</span><span class="p">(),</span> <span class="n">comp</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">priority_queue</span><span class="p">(</span><span class="k">const</span> <span class="n">_Compare</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Sequence</span><span class="o">&amp;</span> <span class="n">__s</span><span class="p">)</span> 
    <span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">__s</span><span class="p">),</span> <span class="n">comp</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> 
    <span class="p">{</span> <span class="n">make_heap</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span> <span class="p">}</span>
<span class="p">.....</span>
  <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="nf">top</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__STL_TRY</span> <span class="p">{</span>
      <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">__x</span><span class="p">);</span> 
      <span class="n">push_heap</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">clear</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">__STL_TRY</span> <span class="p">{</span>
      <span class="n">pop_heap</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
      <span class="n">c</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">clear</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>[读书笔记] stl源码剖析 第三章 迭代器</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
    <pubDate>Thu, 17 Nov 2016 20:32:26 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
    <description><![CDATA[<p>迭代器是一种抽象的设计概念。iterator模式：提供一种方法，使能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表述方式。</p>
<h1 id="迭代器的设计思维-stl关键所在">迭代器的设计思维-stl关键所在</h1>
<p>STL的中心思想在于：将数据容器和算法分开，彼此独立设计。容器和算法的泛型化。
迭代器就是扮演着粘胶角色。</p>
<h1 id="迭代器是一种smart-pointer">迭代器是一种smart pointer</h1>
<p>list迭代器stl的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//listnode的基础类
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">_List_node_base</span> <span class="p">{</span>
  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_next</span><span class="p">;</span>
  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_prev</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//listnode
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_List_node</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_List_node_base</span> <span class="p">{</span>
  <span class="n">_Tp</span> <span class="n">_M_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//迭代器基础类
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">_List_iterator_base</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">size_t</span>                     <span class="n">size_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ptrdiff_t</span>                  <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">bidirectional_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>

  <span class="n">_List_node_base</span><span class="o">*</span> <span class="n">_M_node</span><span class="p">;</span><span class="c1">//包含一个node
</span><span class="c1"></span>
  <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">_List_node_base</span><span class="o">*</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_M_node</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">_List_iterator_base</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="nf">_M_incr</span><span class="p">()</span> <span class="p">{</span> <span class="n">_M_node</span> <span class="o">=</span> <span class="n">_M_node</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">_M_decr</span><span class="p">()</span> <span class="p">{</span> <span class="n">_M_node</span> <span class="o">=</span> <span class="n">_M_node</span><span class="o">-&gt;</span><span class="n">_M_prev</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">_List_iterator_base</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_M_node</span> <span class="o">==</span> <span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">_List_iterator_base</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_M_node</span> <span class="o">!=</span> <span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>  
<span class="c1">//迭代器
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ref</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ptr</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_List_iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_List_iterator_base</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span><span class="n">_Tp</span><span class="o">*&gt;</span>             <span class="n">iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Ref</span><span class="p">,</span><span class="n">_Ptr</span><span class="o">&gt;</span>             <span class="n">_Self</span><span class="p">;</span>

  <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Ptr</span> <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Ref</span> <span class="n">reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_List_node</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">_Node</span><span class="p">;</span>

  <span class="n">_List_iterator</span><span class="p">(</span><span class="n">_Node</span><span class="o">*</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">__x</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">_List_iterator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="n">_List_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_List_iterator_base</span><span class="p">(</span><span class="n">__x</span><span class="p">.</span><span class="n">_M_node</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">((</span><span class="n">_Node</span><span class="o">*</span><span class="p">)</span> <span class="n">_M_node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">_M_data</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#ifndef __SGI_STL_NO_ARROW_OPERATOR
</span><span class="cp"></span>  <span class="n">pointer</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">operator</span><span class="o">*</span><span class="p">());</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __SGI_STL_NO_ARROW_OPERATOR */</span><span class="cp">
</span><span class="cp"></span>  <span class="c1">//重载了几个操作实现了迭代器，不是很复杂
</span><span class="c1"></span>  <span class="c1">//++i
</span><span class="c1"></span>  <span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_incr</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//i++
</span><span class="c1"></span>  <span class="n">_Self</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">_Self</span> <span class="n">__tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_incr</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">__tmp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_decr</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">_Self</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">_Self</span> <span class="n">__tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_decr</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">__tmp</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="traits编程技法">Traits编程技法</h1>
<p>之前就见到用过，通过类型获取，其余的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Category</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Distance</span> <span class="o">=</span> <span class="n">ptrdiff_t</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">_Pointer</span> <span class="o">=</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Reference</span> <span class="o">=</span> <span class="n">_Tp</span><span class="o">&amp;&gt;</span>
<span class="k">struct</span> <span class="nc">iterator</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">_Category</span>  <span class="n">iterator_category</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span>        <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Distance</span>  <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Pointer</span>   <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Reference</span> <span class="n">reference</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Iterator</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">iterator_traits</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">iterator_category</span> <span class="n">iterator_category</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">value_type</span>        <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">difference_type</span>   <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">pointer</span>           <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">::</span><span class="n">reference</span>         <span class="n">reference</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//对原生指针特化
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">iterator_traits</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">*&gt;</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">random_access_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span>                         <span class="n">value_type</span><span class="p">;</span>
  <span class="c1">//ptrdiff_t是C/C++标准库中定义的一个与机器相关的数据类型。ptrdiff_t类型变量通常用来保存两个指针减法操作的结果。ptrdiff_t定义在stddef.h（cstddef）这个文件内。ptrdiff_t通常被定义为long int类型。
</span><span class="c1"></span>  <span class="k">typedef</span> <span class="n">ptrdiff_t</span>                   <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span><span class="o">*</span>                        <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span><span class="o">&amp;</span>                        <span class="n">reference</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">iterator_traits</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*&gt;</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">random_access_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">_Tp</span>                         <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ptrdiff_t</span>                   <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>                  <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>                  <span class="n">reference</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代器的分类：
input iter：只读iter
output iter:只写iter
forward iter:允许写入型算法在这种迭代器所形成的区间操作，前向迭代器
bidirectional iterator：双向移动iter。
random access iter：前三种支持++,第四种支持++ &ndash;。这种支持所有指针的算术能力。</p>

typedef typename _Iterator::iterator_category iterator_category;的作用就是能够在编译器发现迭代器的类型，选用最合适的函数版本。
```cpp
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};
```
例子
```cpp
template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, input_iterator_tag) {
  while (__n--) ++__i;
}
<p>template &lt;class _BidirectionalIterator, class _Distance&gt;
inline void __advance(_BidirectionalIterator&amp; __i, _Distance __n,
bidirectional_iterator_tag) {
__STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);
if (__n &gt;= 0)
while (__n&ndash;) ++__i;
else
while (__n++) &ndash;__i;
}</p>
<p>template &lt;class _RandomAccessIterator, class _Distance&gt;
inline void __advance(_RandomAccessIterator&amp; __i, _Distance __n,
random_access_iterator_tag) {
__STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);
__i += __n;
}</p>
<p>template &lt;class _InputIterator, class _Distance&gt;
inline void advance(_InputIterator&amp; __i, _Distance __n) {
__STL_REQUIRES(_InputIterator, _InputIterator);
//通过下面的函数，选用合适的版本
//不需要传递参数，能够在编译器选定版本
__advance(__i, __n, iterator_category(__i));
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># __type_traits
提供一种机制，允许针对不同的型别熟悉，完成函数派送。
在内存配置器中就用到了，比如有没有拷贝构造函数等

```cpp
struct __true_type {
};

struct __false_type {
};
//选择使用__false_type为struct的目的是为了类型推倒，而不是使用bool值作为参数的话只是运行时的选择。
template &lt;class _Tp&gt;
struct __type_traits { 
   typedef __true_type     this_dummy_member_must_be_first;
                   /* Do not remove this member. It informs a compiler which
                      automatically specializes __type_traits that this
                      __type_traits template is special. It just makes sure that
                      things work if an implementation is using a template
                      called __type_traits for something unrelated. */

   /* The following restrictions should be observed for the sake of
      compilers which automatically produce type specific specializations 
      of this class:
          - You may reorder the members below if you wish
          - You may remove any of the members below if you wish
          - You must not rename members without making the corresponding
            name change in the compiler
          - Members you add will be treated like regular members unless
            you add the appropriate support in the compiler. */
 

   typedef __false_type    has_trivial_default_constructor;
   typedef __false_type    has_trivial_copy_constructor;
   typedef __false_type    has_trivial_assignment_operator;
   typedef __false_type    has_trivial_destructor;
   typedef __false_type    is_POD_type;
};

</code></pre></td></tr></table>
</div>
</div><p>然后在这个文件里定义了大量的特化，主要是特化C++标准类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="nc">__type_traits</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">has_trivial_default_constructor</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">has_trivial_copy_constructor</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">has_trivial_assignment_operator</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">has_trivial_destructor</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">__true_type</span>    <span class="n">is_POD_type</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//等。。。
</span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>[读书笔记] stl源码剖析 第一章、第二章 概论、内存配置器</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/</link>
    <pubDate>Wed, 16 Nov 2016 08:32:26 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/</guid>
    <description><![CDATA[<h1 id="概论">概论</h1>
<p>第一章基本都是C++基础的知识，读了《C++ Primer》的话都懂。关于各种C++的特性、STL特性都有。</p>
<h2 id="stl六大组件-功能与运用">STL六大组件 功能与运用</h2>
<p>STL提供六大组件，彼此可以组合套用</p>
<ol>
<li>容器：各种数据结构。Vector,list,deque,set,map</li>
<li>算法：各种常用算法如sort,search,copy,erase</li>
<li>迭代器：扮演容器与算法之间的粘合剂，所谓的泛型指针。五种类型</li>
<li>仿函数：行为类似函数，可以作为算法的某种策略。仿函数是重载了()的class或者class template，一般函数指针可视为狭义的仿函数</li>
<li>配接器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>配置器：负责控件的配置与管理。</li>
</ol>

# 空间配置器
SGI STL时间了一个专属的，拥有次层配置能力的、效率优越的特殊配置器。
SGI STL的缺省分配器都是其自己的分配器。
## SGI特殊的空间配置器 std::alloc
使用::construct() ::destroy()构造和析构
使用alloc::allocate() alloc::deallocate()分配 释放
```cpp
//直接利用这个类能够用指定类型指针，转换为其他引用等
template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef const _Tp*                  pointer;
  typedef const _Tp&                  reference;
};
```
```cpp
//如果有non-trivial 析构函数
template <class _ForwardIterator>
void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)
{
  for ( ; __first != __last; ++__first)
    destroy(&*__first);
}
//如果没有non-trivial 析构函数
template <class _ForwardIterator> 
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) {}
<p>template &lt;class _ForwardIterator, class _Tp&gt;
inline void
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)
{
typedef typename __type_traits&lt;_Tp&gt;::has_trivial_destructor
_Trivial_destructor;
__destroy_aux(__first, __last, _Trivial_destructor());//_Trivial_destructor()将会是_true_type 或者_false_type
//利用模板和特化
}</p>
<p>template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
__destroy(__first, __last, __VALUE_TYPE(__first));//__VALUE_TYPE(__first)获取到了类型的指针，然后调用上面函数
//利用模板和特化
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">## 空间的配置与释放 std::alloc
sgi设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略。
当分配大于128bytes时候调用第一级，小于128时候，为了降低额外负担，使用负责的memory pool整理方式。
### 第一级配置器 __malloc_alloc_template剖析
以malloc free realloc实现。
然后自己实现了一个new handler机制。
```cpp
template &lt;int __inst&gt;
void*
__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(size_t __n)
{
    void (* __my_malloc_handler)();
    void* __result;

    for (;;) {
        __my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
        (*__my_malloc_handler)();
        __result = malloc(__n);
        if (__result) return(__result);
    }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="第二级配置器">第二级配置器</h3>
<p>SIG第二级配置器的做法，如果区块够大，超过128bytes时候，就移交第一级配置器处理。当区块小鱼128bytes时候，则以内存池管理。每次配置一大块内存，并维护对应之自由链表，下次若再有相同大小的内存需求从free-lists中拨出。如果客端释放小额区块，就由配置器回收到fres-lists中。
分配区块时候，自动上调到8的倍数，并维护16个fres-lists,分别管理大小为8/16/24/32/40/48/56/64/72/80/88/96/104/112/120/128的小额区块。</p>
<blockquote>
<p>其实这里和公司用的NG_malloc是一样的策略。ng_malloc之前对于大小的区分是256k的样子，更大。后来又改写了，支持更大的内存块了。</p>
</blockquote>
<p>节点如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="nl">__PRIVATE</span><span class="p">:</span>
  <span class="k">union</span> <span class="nc">_Obj</span> <span class="p">{</span>
        <span class="k">union</span> <span class="nc">_Obj</span><span class="o">*</span> <span class="n">_M_free_list_link</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">_M_client_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>    <span class="cm">/* The client sees this.        */</span>
  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>使用union的话，可以不用每次都去转换。char _M_client_data的存在是，方便去取首地址。实际上下面用到的就是_M_free_list_link，用来作为链表。这样的话，就可以用一个4字节的空间(32位机器指针大小)，实现两个功能。而不是使用struct，因为那样就会浪费空间。</p>
<h4 id="空间配置函数allocate">空间配置函数allocate()</h4>
<p>功能：判断大小，大于128用第一级分配，小于128就查找free list。如果free list中有可用的区块，就直接拿来用，如果没有就将区块大小上调至8的倍数边界，然后调用refill()，准备为free list重新填充空间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">__n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">__ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">//超过设定的最大值就调用第一级配置器，STL设置为128
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">__n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span> <span class="n">_MAX_BYTES</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__ret</span> <span class="o">=</span> <span class="n">malloc_alloc</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="n">__n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
    <span class="c1">//寻找合适的free lists中适当的一个
</span><span class="c1"></span>      <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span> <span class="n">__my_free_list</span>
          <span class="o">=</span> <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__n</span><span class="p">);</span>
      <span class="c1">// Acquire the lock here with a constructor call.
</span><span class="c1"></span>      <span class="c1">// This ensures that it is released in exit or during stack
</span><span class="c1"></span>      <span class="c1">// unwinding.
</span><span class="c1"></span><span class="cp">#     ifndef _NOTHREADS
</span><span class="cp"></span>      <span class="cm">/*REFERENCED*/</span>
      <span class="c1">//多线程锁
</span><span class="c1"></span>      <span class="n">_Lock</span> <span class="n">__lock_instance</span><span class="p">;</span>
<span class="cp">#     endif
</span><span class="cp"></span>      <span class="n">_Obj</span><span class="o">*</span> <span class="n">__RESTRICT</span> <span class="n">__result</span> <span class="o">=</span> <span class="o">*</span><span class="n">__my_free_list</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1">//没找到的话，就重新填充free list
</span><span class="c1"></span>        <span class="n">__ret</span> <span class="o">=</span> <span class="n">_S_refill</span><span class="p">(</span><span class="n">_S_round_up</span><span class="p">(</span><span class="n">__n</span><span class="p">));</span>
      <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//指向后一个成员
</span><span class="c1"></span>        <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">__result</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span><span class="p">;</span>
        <span class="n">__ret</span> <span class="o">=</span> <span class="n">__result</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">__ret</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="空间释放函数-deallocate">空间释放函数 deallocate()</h4>
<p>先判断大小，大于128调用第一级，小于128找出对应的free list，将区块回收。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/* __p may not be 0 */</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">__p</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">__n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span> <span class="n">_MAX_BYTES</span><span class="p">)</span>
      <span class="n">malloc_alloc</span><span class="o">::</span><span class="n">deallocate</span><span class="p">(</span><span class="n">__p</span><span class="p">,</span> <span class="n">__n</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span>  <span class="n">__my_free_list</span>
          <span class="o">=</span> <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__n</span><span class="p">);</span>
      <span class="n">_Obj</span><span class="o">*</span> <span class="n">__q</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)</span><span class="n">__p</span><span class="p">;</span>

      <span class="c1">// acquire lock
</span><span class="c1"></span><span class="cp">#       ifndef _NOTHREADS
</span><span class="cp"></span>      <span class="cm">/*REFERENCED*/</span>
      <span class="n">_Lock</span> <span class="n">__lock_instance</span><span class="p">;</span>
<span class="cp">#       endif </span><span class="cm">/* _NOTHREADS */</span><span class="cp">
</span><span class="cp"></span>      <span class="n">__q</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span> <span class="o">=</span> <span class="o">*</span><span class="n">__my_free_list</span><span class="p">;</span>
      <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">__q</span><span class="p">;</span>
      <span class="c1">// lock is released here
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="重新填充free-lists">重新填充free lists</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">__threads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__inst</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="o">*</span>
<span class="n">__default_alloc_template</span><span class="o">&lt;</span><span class="n">__threads</span><span class="p">,</span> <span class="n">__inst</span><span class="o">&gt;::</span><span class="n">_S_refill</span><span class="p">(</span><span class="n">size_t</span> <span class="n">__n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">__nobjs</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="c1">//尝试分配空间 __nobjs是引用传递，作为返回值
</span><span class="c1"></span>    <span class="kt">char</span><span class="o">*</span> <span class="n">__chunk</span> <span class="o">=</span> <span class="n">_S_chunk_alloc</span><span class="p">(</span><span class="n">__n</span><span class="p">,</span> <span class="n">__nobjs</span><span class="p">);</span>
    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span> <span class="n">__my_free_list</span><span class="p">;</span>
    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__result</span><span class="p">;</span>
    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__current_obj</span><span class="p">;</span>
    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__next_obj</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">__i</span><span class="p">;</span>
    
    <span class="c1">//对只分配出一个的时候的优化
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">__nobjs</span><span class="p">)</span> <span class="k">return</span><span class="p">(</span><span class="n">__chunk</span><span class="p">);</span>
    <span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__n</span><span class="p">);</span>

    <span class="c1">//形成链表
</span><span class="c1"></span>    <span class="cm">/* Build free list in chunk */</span>
      <span class="n">__result</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)</span><span class="n">__chunk</span><span class="p">;</span>
      <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">__next_obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)(</span><span class="n">__chunk</span> <span class="o">+</span> <span class="n">__n</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">__i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="n">__i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__current_obj</span> <span class="o">=</span> <span class="n">__next_obj</span><span class="p">;</span>
        <span class="n">__next_obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">__next_obj</span> <span class="o">+</span> <span class="n">__n</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">__nobjs</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">__i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">__current_obj</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">__current_obj</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span> <span class="o">=</span> <span class="n">__next_obj</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="k">return</span><span class="p">(</span><span class="n">__result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="内存池">内存池</h4>
<p>从内存池中取空间给free list 使用，是chunk_alloc的工作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">__threads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__inst</span><span class="o">&gt;</span>
<span class="kt">char</span><span class="o">*</span>
<span class="n">__default_alloc_template</span><span class="o">&lt;</span><span class="n">__threads</span><span class="p">,</span> <span class="n">__inst</span><span class="o">&gt;::</span><span class="n">_S_chunk_alloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">__size</span><span class="p">,</span> 
                                                            <span class="kt">int</span><span class="o">&amp;</span> <span class="n">__nobjs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">__result</span><span class="p">;</span><span class="c1">//返回值
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">__total_bytes</span> <span class="o">=</span> <span class="n">__size</span> <span class="o">*</span> <span class="n">__nobjs</span><span class="p">;</span><span class="c1">//需要分配的空间大小
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">__bytes_left</span> <span class="o">=</span> <span class="n">_S_end_free</span> <span class="o">-</span> <span class="n">_S_start_free</span><span class="p">;</span><span class="c1">//内存池剩余空间
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__bytes_left</span> <span class="o">&gt;=</span> <span class="n">__total_bytes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__result</span> <span class="o">=</span> <span class="n">_S_start_free</span><span class="p">;</span><span class="c1">//返回
</span><span class="c1"></span>        <span class="n">_S_start_free</span> <span class="o">+=</span> <span class="n">__total_bytes</span><span class="p">;</span><span class="c1">//内存池可用空间起始处后移
</span><span class="c1"></span>        <span class="k">return</span><span class="p">(</span><span class="n">__result</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">__bytes_left</span> <span class="o">&gt;=</span> <span class="n">__size</span><span class="p">)</span> <span class="p">{</span><span class="c1">//能够分配一部分空间
</span><span class="c1"></span>        <span class="n">__nobjs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">__bytes_left</span><span class="o">/</span><span class="n">__size</span><span class="p">);</span><span class="c1">//判断能够分配的块数
</span><span class="c1"></span>        <span class="n">__total_bytes</span> <span class="o">=</span> <span class="n">__size</span> <span class="o">*</span> <span class="n">__nobjs</span><span class="p">;</span>
        <span class="n">__result</span> <span class="o">=</span> <span class="n">_S_start_free</span><span class="p">;</span>
        <span class="n">_S_start_free</span> <span class="o">+=</span> <span class="n">__total_bytes</span><span class="p">;</span><span class="c1">//与上同
</span><span class="c1"></span>        <span class="k">return</span><span class="p">(</span><span class="n">__result</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//不能够分配一块的大小
</span><span class="c1"></span>        <span class="n">size_t</span> <span class="n">__bytes_to_get</span> <span class="o">=</span> 
	  <span class="mi">2</span> <span class="o">*</span> <span class="n">__total_bytes</span> <span class="o">+</span> <span class="n">_S_round_up</span><span class="p">(</span><span class="n">_S_heap_size</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
        <span class="c1">// Try to make use of the left-over piece.
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">__bytes_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">//把剩余空间，分配到合适的free list
</span><span class="c1"></span>            <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span> <span class="n">__my_free_list</span> <span class="o">=</span>
                        <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__bytes_left</span><span class="p">);</span>

            <span class="p">((</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)</span><span class="n">_S_start_free</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span> <span class="o">=</span> <span class="o">*</span><span class="n">__my_free_list</span><span class="p">;</span>
            <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">_Obj</span><span class="o">*</span><span class="p">)</span><span class="n">_S_start_free</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">//从堆上重新分配出部分空间
</span><span class="c1"></span>        <span class="n">_S_start_free</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">__bytes_to_get</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">_S_start_free</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">size_t</span> <span class="n">__i</span><span class="p">;</span>
            <span class="n">_Obj</span><span class="o">*</span> <span class="n">__STL_VOLATILE</span><span class="o">*</span> <span class="n">__my_free_list</span><span class="p">;</span>
	    <span class="n">_Obj</span><span class="o">*</span> <span class="n">__p</span><span class="p">;</span>
            <span class="c1">// Try to make do with what we have.  That can&#39;t
</span><span class="c1"></span>            <span class="c1">// hurt.  We do not try smaller requests, since that tends
</span><span class="c1"></span>            <span class="c1">// to result in disaster on multi-process machines.
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">__i</span> <span class="o">=</span> <span class="n">__size</span><span class="p">;</span>
                 <span class="n">__i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span> <span class="n">_MAX_BYTES</span><span class="p">;</span>
                 <span class="n">__i</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span> <span class="n">_ALIGN</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">_S_free_list</span> <span class="o">+</span> <span class="n">_S_freelist_index</span><span class="p">(</span><span class="n">__i</span><span class="p">);</span>
                <span class="n">__p</span> <span class="o">=</span> <span class="o">*</span><span class="n">__my_free_list</span><span class="p">;</span>
                <span class="c1">//malloc失败的话，在现有的free list中找未用的、足够大的fee list分配
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">__p</span><span class="p">)</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">__my_free_list</span> <span class="o">=</span> <span class="n">__p</span> <span class="o">-&gt;</span> <span class="n">_M_free_list_link</span><span class="p">;</span>
                    <span class="n">_S_start_free</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">__p</span><span class="p">;</span>
                    <span class="n">_S_end_free</span> <span class="o">=</span> <span class="n">_S_start_free</span> <span class="o">+</span> <span class="n">__i</span><span class="p">;</span>
                    <span class="k">return</span><span class="p">(</span><span class="n">_S_chunk_alloc</span><span class="p">(</span><span class="n">__size</span><span class="p">,</span> <span class="n">__nobjs</span><span class="p">));</span>
                    <span class="c1">// Any leftover piece will eventually make it to the
</span><span class="c1"></span>                    <span class="c1">// right free list.
</span><span class="c1"></span>                <span class="p">}</span>
            <span class="p">}</span>
	    <span class="n">_S_end_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// In case of exception.
</span><span class="c1"></span>            <span class="n">_S_start_free</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc_alloc</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="n">__bytes_to_get</span><span class="p">);</span>
            <span class="c1">// This should either throw an
</span><span class="c1"></span>            <span class="c1">// exception or remedy the situation.  Thus we assume it
</span><span class="c1"></span>            <span class="c1">// succeeded.
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">//拿到新空间
</span><span class="c1"></span>        <span class="n">_S_heap_size</span> <span class="o">+=</span> <span class="n">__bytes_to_get</span><span class="p">;</span>
        <span class="n">_S_end_free</span> <span class="o">=</span> <span class="n">_S_start_free</span> <span class="o">+</span> <span class="n">__bytes_to_get</span><span class="p">;</span>
        <span class="k">return</span><span class="p">(</span><span class="n">_S_chunk_alloc</span><span class="p">(</span><span class="n">__size</span><span class="p">,</span> <span class="n">__nobjs</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="内存基本处理工具">内存基本处理工具</h3>
<p>uninitialized_copy、uninitialized_fill、uninitialized_fill_n用来处理一些特殊的复制构造的情况。</p>
<h4 id="uninitialized_fill_n实现">uninitialized_fill_n实现</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_ForwardIter</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Size</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">_ForwardIter</span> 
<span class="n">uninitialized_fill_n</span><span class="p">(</span><span class="n">_ForwardIter</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Size</span> <span class="n">__n</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">__uninitialized_fill_n</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__n</span><span class="p">,</span> <span class="n">__x</span><span class="p">,</span> <span class="n">__VALUE_TYPE</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_ForwardIter</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Size</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">_ForwardIter</span> 
<span class="n">__uninitialized_fill_n</span><span class="p">(</span><span class="n">_ForwardIter</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Size</span> <span class="n">__n</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="n">_Tp1</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">__type_traits</span><span class="o">&lt;</span><span class="n">_Tp1</span><span class="o">&gt;::</span><span class="n">is_POD_type</span> <span class="n">_Is_POD</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">__uninitialized_fill_n_aux</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__n</span><span class="p">,</span> <span class="n">__x</span><span class="p">,</span> <span class="n">_Is_POD</span><span class="p">());</span><span class="c1">//判断有没有复制构造函数，调用不同的函数处理
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//没有复制构造函数的版本
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_ForwardIter</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Size</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">_ForwardIter</span>
<span class="n">__uninitialized_fill_n_aux</span><span class="p">(</span><span class="n">_ForwardIter</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Size</span> <span class="n">__n</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="n">__true_type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">fill_n</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__n</span><span class="p">,</span> <span class="n">__x</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//有复制构造函数的版本
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_ForwardIter</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Size</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="n">_ForwardIter</span>
<span class="n">__uninitialized_fill_n_aux</span><span class="p">(</span><span class="n">_ForwardIter</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_Size</span> <span class="n">__n</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="n">__false_type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_ForwardIter</span> <span class="n">__cur</span> <span class="o">=</span> <span class="n">__first</span><span class="p">;</span>
  <span class="n">__STL_TRY</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">__n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">__n</span><span class="p">,</span> <span class="o">++</span><span class="n">__cur</span><span class="p">)</span>
      <span class="n">_Construct</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">__cur</span><span class="p">,</span> <span class="n">__x</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">__cur</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">_Destroy</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__cur</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>uninitialized_copy、uninitialized_fill的实现类似</p>]]></description>
</item><item>
    <title>阅读谷歌编程规范</title>
    <link>http://coderyang.com/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</link>
    <pubDate>Sun, 06 Nov 2016 15:47:25 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</guid>
    <description><![CDATA[<h1 id="事情的起因">事情的起因</h1>
<p>好的东西就是这样，你每次看都能够有新的收获。
这次也一样，读了一遍谷歌编程规范，又有些新的理解，也有一些需要重新让自己记住的点。
遂记录下来，成此博文。</p>
<h1 id="头文件">头文件</h1>
<h2 id="define保护">#define保护</h2>
<p>谷歌的格式是
当是： <PROJECT> _ <PATH> _ <FILE> <em>H</em>
为保证唯一性，头文件的命名应基于其所在项目源代码树的全路径。例如，项目 foo 中的头
文件 foo/src/bar/baz.h 按如下方式保护：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#ifndef FOO_BAR_BAZ_H_
</span><span class="cp">#define FOO_BAR_BAZ_H_
</span><span class="cp"></span><span class="p">...</span>
<span class="cp">#endif </span><span class="c1">// FOO_BAR_BAZ_H_
</span></code></pre></td></tr></table>
</div>
</div><p>比较起来我们的格式是使用项目前缀来防止重复，考虑到我们项目的规模一般是不会重复的，因为文件命名上就不一致。</p>
<h2 id="头文件依赖">头文件依赖</h2>
<p>尽量使用前置声明减少头文件的依赖。
因为引入一个新的头文件，头文件改变时，包含这个头文件的其他头文件也会被重新编译。
1.强数据成员声明为Foo* Foo&amp;
2.参数、返回值类型为Foo的函数，只是声明
3.今天数据成员的类型可以被声明为Foo，因为静态数据成员定义在类定义之外
至于使用指针成员替代成员对象，则会降低可读性，执行效率，不要这样做。</p>
<h2 id="内联函数">内联函数</h2>
<p>少于十行的函数定义为内联函数。
小巧的代码更好的利用指令缓存。
短小的内联函数直接放在.h文件中，对于比较复杂的内联应该放在-inl.h文件中</p>
<h2 id="函数参数的顺序">函数参数的顺序</h2>
<p>输入参数在前，输出在后。</p>
<h2 id="包含文件顺序">包含文件顺序</h2>
<p>C库 C++库 其他库 项目内的
头文件应该有带有目录信息,不要使用当前目录和父目录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">举例来说， google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下 ：
#include &#34;foo/public/fooserver.h&#34; // 优先位置
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;hash_map&gt;
#include &lt;vector&gt;
#include &#34;base/basictypes.h&#34;
#include &#34;base/commandlineflags.h&#34;
#include &#34;foo/public/bar.h&#34;
</code></pre></td></tr></table>
</div>
</div><h1 id="作用域">作用域</h1>
<h2 id="命名空间">命名空间</h2>
<p>在.CC文件中，允许甚至提倡使用不具名命名空间，以避免运行时候的命名冲突。
最好不要使用using，不要声明命名空间std下的恩和内容。</p>
<h2 id="嵌套类">嵌套类</h2>
<p>公开嵌套类作为接口的一部分时候，虽然可以直接放在全局作用域中，但是最好还是放在命名空间里。
使用起来的话，</p>
<h2 id="非成员函数静态成员函数和全局函数">非成员函数、静态成员函数和全局函数</h2>
<p>尽量放在命名空间里。</p>
<h2 id="局部变量">局部变量</h2>
<p>将函数变量尽可能置于最小作用域内，在声明变量时候将其初始化。靠近第一次使用，利于阅读。</p>
<h2 id="全局变量">全局变量</h2>
<p>全局变量的构造函数、西沟函数以及初始化操作的调用顺序只是被部分规定，每次生产可能会有变化。
很多可以用单例模式替代。</p>
<h1 id="类">类</h1>
<h2 id="构造函数中只进行哪些没有实际意义的初始化在init中集中初始化有意义的数据">构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。</h2>
<p>构造函数的问题是，没有异常处理。</p>
<h2 id="明确的构造函数">明确的构造函数</h2>
<p>使用explicit，防止自动转换。</p>
<h2 id="拷贝构造函数">拷贝构造函数</h2>
<p>大量类并不要拷贝构造函数，所以应该使用DISALLOW_COPY_AND_ASSIGN来防止拷贝构造函数的自动生成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// 禁止使用拷贝构造函数和赋值操作的宏
// 应在类的 private:中使用
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
TypeName(const TypeName&amp;); \
void operator=(const TypeName&amp;)
class Foo {
public:
Foo(int f);
~Foo();
private:
DISALLOW_COPY_AND_ASSIGN(Foo);
};
</code></pre></td></tr></table>
</div>
</div><h2 id="继承">继承</h2>
<p>使用组合一般都比使用继承合适，继承只使用public继承
虚析构函数只在有继承同时有虚函数的时候使用。</p>
<h2 id="接口">接口</h2>
<p>接口是指满足特定条件的类，这些类以Interface为后缀
定义：纯接口</p>
<blockquote>
<p>只有纯虚函数和静态函数
没有非静态数据成员
没有定义任何构造函数，如果有，也不含参数，并且为protected
如果是子类，也只能继承满足上述条件并以Interface为后缀的类</p>
</blockquote>
<h2 id="操作符重载">操作符重载</h2>
<p>除了少数特定环境外，不要重载操作符。
缺点</p>
<blockquote>
<p>混淆你的直觉，让你误以为费时的操作和内建操作一样轻巧
查找重载操作符的调用处困难
有的操作符可以对指针进行操作
重载的副作用，重载操作符&amp;的类不能被前置声明</p>
</blockquote>
<h2 id="声明次序">声明次序</h2>
<p>在类中使用特定的声明次序：public:在 private:之前，成员函数在数据成员（变量）前。
定义次序如下：public:、protected:、private:，如果那一块没有，直接忽略即可。
每一块中，声明次序一般如下：</p>
<ol>
<li>typedefs 和 enums；</li>
<li>常量；</li>
<li>构造函数；</li>
<li>析构函数；</li>
<li>成员函数，含静态成员函数；</li>
<li>数据成员，含静态数据成员。
宏 DISALLOW_COPY_AND_ASSIGN 置于 private:块之后，作为类的最后部分。参考 拷
贝构造函数。
.cc 文件中函数的定义应尽可能和声明次序一致。
不要将大型函数内联到类的定义中，通常，只有那些没有特别意义的或者性能要求高的，并
且是比较短小的函数才被定义为内联函数。更多细节参考译文第一篇的 内联函数。</li>
</ol>
<h2 id="编写短小函数">编写短小函数</h2>
<p>超过40行，考虑分割。</p>
<h1 id="google特有的风情">Google特有的风情</h1>
<h2 id="智能指针">智能指针</h2>
<p>需要使用智能指针的话scoped_ptr完全可以胜任。特殊情况下使用share_ptr。不要使用auto_ptr。
倾向于设计对象隶属明确的代码。最明确的对象隶属是根本不使用指针，直接将对象作为一个域或者局部变量使用。</p>
<h1 id="其他c特征">其他C++特征</h1>
<h2 id="引用参数">引用参数</h2>
<p>所有按引用传递的参数必须加上const</p>
<h2 id="缺省参数">缺省参数</h2>
<p>禁止使用缺省函数参数，所有参数必须明确指定的话，避免程序员不知道存在的缺省参数。</p>
<h2 id="编程数组和alloca">编程数组和alloca</h2>
<p>禁止使用变长数组。使用安全的分配器。</p>
<h2 id="友元">友元</h2>
<p>将一个单元测试用类声明为待测类的友元，很方便。</p>
<h2 id="不使用c异常">不使用C++异常</h2>
<h2 id="不使用rtti">不使用RTTI</h2>
<p>直接利用虚函数处理不同类型就好了。</p>
<h2 id="类型转换">类型转换</h2>
<p>使用 static_cast
比较好处理，直接查找static_cast，就能找到哪里用了转换。C语言转换语义模糊。</p>
<ol>
<li>static_cast：和 C 风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上
转换；</li>
<li>const_cast：移除 const 属性；</li>
<li>reinterpret_cast：指针类型和整型或其他指针间不安全的相互转换，仅在你对所做一
切了然于心时使用；</li>
<li>dynamic_cast：除测试外不要使用，除单元测试外，如果你需要在运行时确定类型信
息，说明设计有缺陷（参考  RTTI）。</li>
</ol>
<h2 id="流-streams">流 streams</h2>
<p>只在记录日志的时候使用。
其他时候使用printf替代。
估计是stream的构造使用成本高，printf简单直接。
然后steam重载&laquo;会产生很多意想不到的错误，在深入理解C++面向对象的书里面也有提到。</p>
<h2 id="前置自增和自减">前置自增和自减</h2>
<p>效率更高。
对于简单数值来说无所谓，但是对于迭代器这种，前置更好。</p>
<h2 id="const的使用">const的使用</h2>
<p>在能够使用const的时候使用const.</p>
<h2 id="整型">整型</h2>
<p>C++中使用 stdint.h中的确定大小整型
不要使用无符号，使用断言声明变量非负数。也就是在传参的时候，在执行前断言判断。</p>
<h2 id="预处理宏">预处理宏</h2>
<p>宏尽量被内联函数、枚举和常量替代
下面给出的用法模式可以避免一些使用宏的问题，供使用宏时参考：</p>
<ol>
<li>不要在.h 文件中定义宏；</li>
<li>使用前正确#define，使用后正确#undef；</li>
<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>
<li>不使用会导致不稳定的 C++构造（unbalanced C++ constructs，译者注） 的宏，
至少文档说明其行为。
像我们项目里的宏，完全应该被替代，起码使用一个命名空间，防止污染全局空间事情的发生。</li>
</ol>
<h1 id="命名约定">命名约定</h1>
<h2 id="通用命名规则">通用命名规则</h2>
<p>不缩写
易于理解第一</p>
<h1 id="注释">注释</h1>
<h2 id="todo注释">TODO注释</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// TODO(kl@gmail.com): Use a &#34;*&#34; here for concatenation operator.
</span><span class="c1">// TODO(Zeke) change this to use relations.
</span></code></pre></td></tr></table>
</div>
</div><h1 id="格式">格式</h1>
<h2 id="swich">swich</h2>
<p>如果 default 永不会执行，可以简单的使用 assert：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">switch</span> <span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="p">{</span> <span class="c1">// 2 space indent
</span><span class="c1"></span><span class="p">...</span> <span class="c1">// 4 space indent
</span><span class="c1"></span><span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="p">{</span>
<span class="p">...</span>
<span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">default</span><span class="o">:</span> <span class="p">{</span>
<span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>[读书笔记] sicp 第三章 模块化 对象和状态</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/</link>
    <pubDate>Sat, 10 Sep 2016 08:33:32 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/</guid>
    <description><![CDATA[<p>有效的程序综合还需要一些组织原则，它们能够指导我们系统化地完成系统的整体设计。特别的需要一些能够帮助我们构造起模块化的大型系统策略，也就是说，使这些系统能够“自然地”划分为一些具有内聚力的部分，使这些部分可以分别进行开发和维护。
有一种非常强有力的设计策略，特别适合用于构造那类模拟真实物理系统的程序，那就是基于被模拟程序的结构去设计程序的结构。那么有关的物理系统里的每一个对象，我们构造起一个与之对象的计算对象；对该系统里的每种活动，我们在自己的计算系统里顶一种符号操作。采用这一策略时的希望是，在需要针对系统中的新对象或者新活动扩充对应的计算模型时候，我们能够不必对程序的组织方面做得很成功，那么在需要添加新特城或者排除旧东西里的错误时候，就只需要在系统里的一些小局部中工作。
本章研究两种特点鲜明的策略。第一种策略将注意力集中在对象上，将大型系统看成一大批对象，它们的行为可能随着时间的进展而不断的变化。另一种组织策略将注意力集中在流过的系统的信息流上，非常像电子工程师观察一个信号处理系统。
对于对象途径而言，我们必须关注计算对象可以怎样变化而又同时保持其标识。这将迫使我们抛弃老的计算的代换模型，转向更机械式的，理论上也更不同意把握的计算的环境模型。在处理对象、变化和标识时，各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗。如果允许程序并发指向的可能性，事情会变得更困难许多。流方式特别能用于松解在我们模型中对时间的模拟与计算机求值过程中的各种时间发生的顺序。我们将通过一种称为延时求值的技术做到这一点。</p>
<h1 id="赋值和局部状态">赋值和局部状态</h1>
<p>一个由许多对象组成的系统里，其中的这些对象极少会是完全独立的。每个对象都可能通过交互作用，影响其他对象的状态，所谓交互就是建立起一个对象的状态变量与其他对象的状态变量之间的联系。确实如果一个系统中的状态变量可以分组，形成一些内部紧密结合的子系统，每个子系统与其他子系统之间只存在松散的练习，此时将这个系统看作是由一些独立对象组成的观点就会特别有用。
对于一个系统的这种观点，有可能成为组织这一系统的计算模型的有力框架。要使这样的一个模型成为模块化的，就要求它能够分解为一批计算对象，使它们能够模拟系统里的实际对象。每个计算对象必须有它自己的一些局部状态变量，用于描述实际对象的状态。对于被模拟系统里的对象的状态是随着时间的变化的，与它们对象的计算对象的状态也必须变化。</p>
<h2 id="局部状态变量">局部状态变量</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">set!</span> <span class="nv">&lt;name&gt;</span> <span class="nv">&lt;new-value&gt;</span><span class="p">)</span><span class="c1">;设置值</span>
<span class="p">(</span><span class="nv">begin</span> <span class="nv">&lt;exp1&gt;</span> <span class="nv">&lt;exp2&gt;</span><span class="p">)</span><span class="c1">;顺序求值</span>

<span class="p">(</span><span class="nv">define</span> <span class="nv">balance</span> <span class="mi">100</span><span class="p">)</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&gt;=</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">begin</span> <span class="p">(</span><span class="nv">set!</span> <span class="nv">balance</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
             <span class="nv">balance</span><span class="p">)</span>
      <span class="s">&#34;Insufficient funds&#34;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>上面使用了全局变量
下面使用局部变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="nv">new-withdraw</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">balance</span> <span class="mi">100</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">amount</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&gt;=</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">begin</span> <span class="p">(</span><span class="nv">set!</span> <span class="nv">balance</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
                 <span class="nv">balance</span><span class="p">)</span>
          <span class="s">&#34;Insufficient funds&#34;</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><p>构建一个提款机</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-withdraw</span> <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&gt;=</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">begin</span> <span class="p">(</span><span class="nv">set!</span> <span class="nv">balance</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
               <span class="nv">balance</span><span class="p">)</span>
        <span class="s">&#34;Insufficient funds&#34;</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><p>创建一个账户</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-withdraw</span> <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&gt;=</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">begin</span> <span class="p">(</span><span class="nv">set!</span> <span class="nv">balance</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
               <span class="nv">balance</span><span class="p">)</span>
        <span class="s">&#34;Insufficient funds&#34;</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">deposit</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">set!</span> <span class="nv">balance</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
    <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">dispatch</span> <span class="nv">m</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;withdraw</span><span class="p">)</span> <span class="nv">withdraw</span><span class="p">)</span>
          <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;deposit</span><span class="p">)</span> <span class="nv">deposit</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Unknoew request --MAKE-ACCOUNT&#34;</span>
                       <span class="nv">m</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="引进赋值带来的收益">引进赋值带来的收益</h2>
<p>能够简化一部分需要变量状态的过程。</p>
<h2 id="引进赋值的代价">引进赋值的代价</h2>
<p>相比函数是编程，输入什么结果就是什么。显然引进赋值让程序变得更复杂。
需要存在一个位置存储变量。</p>
<h3 id="命令式程序设计的缺陷">命令式程序设计的缺陷</h3>
<p>与函数式程序设计相对，广泛采用的赋值程序设计被称为命令是程序设计。
求值顺序需要保证。</p>
<h1 id="求值的环境模型">求值的环境模型</h1>
<p>类似于C++的区域。
过程也是对象。
调用过程就会产生新的上下文环境，过程内的是过程内的环境。过程外全局环境等。</p>
<p>过程应用的环境模型两条规则：</p>
<ol>
<li>将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在构造起的这一新环境的上下文中求</li>
<li>相对于一个给定的环境求值一个lambda表达式，将创建其一个过程对象，这个过程对象是一个序对，由该lambda表达式的征文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时候的环境。</li>
</ol>
<h2 id="简单过程的应用">简单过程的应用</h2>
<h2 id="将框架看做局部状态的展台">将框架看做局部状态的展台</h2>
<h2 id="内部定义">内部定义</h2>
<ol>
<li>局部过程的名字不会与包容它们的过程之外的名字互相干扰，这是因为这些局部过程名 都是该过程运行时创建的框架里约束的，而不是在全局环境里约束的。</li>
<li>局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数，这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属。</li>
</ol>
<h1 id="用变动的数据做模拟">用变动的数据做模拟</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">append!</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">set-cdr!</span> <span class="p">(</span><span class="nv">last-pair</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
  <span class="nv">x</span><span class="p">)</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">last-pair</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">null?</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">x</span><span class="p">))</span>
      <span class="nv">x</span>
      <span class="p">(</span><span class="nv">last-pair</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">x</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="共享与相等">共享与相等</h3>
<p>共享会导致多个对象都拥有同一个对象，修改一个会导致另外的也跟着被修改。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">eq?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span><span class="c1">;检查是不是一个对象</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="改变也就是赋值">改变也就是赋值</h3>
<p>主要是构建了一前一后两个指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nc">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">set-x!</span> <span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="nv">set!</span> <span class="nv">x</span> <span class="nv">v</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">set-y!</span> <span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="nv">set!</span> <span class="nv">y</span> <span class="nv">v</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">dispatch</span> <span class="nv">m</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;car</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
          <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;cdr</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
          <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;set-car!</span><span class="p">)</span> <span class="nv">set-x!</span><span class="p">)</span>
          <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;set-cdr!</span><span class="p">)</span> <span class="nv">set-y!</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Undefined operation -- CONS&#34;</span> <span class="nv">m</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="ss">&#39;car</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="ss">&#39;cdr</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">set-car!</span> <span class="nv">z</span> <span class="nv">new-value</span><span class="p">)</span>
  <span class="p">((</span><span class="nv">z</span> <span class="ss">&#39;set-car!</span><span class="p">)</span> <span class="nv">new-value</span><span class="p">)</span>
  <span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">set-cdr!</span> <span class="nv">z</span> <span class="nv">new-value</span><span class="p">)</span>
  <span class="p">((</span><span class="nv">z</span> <span class="ss">&#39;set-cdr!</span><span class="p">)</span> <span class="nv">new-value</span><span class="p">)</span>
  <span class="nv">z</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="队列的表示">队列的表示</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">;构造函数</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-queue</span><span class="p">)</span> <span class="p">(</span><span class="nc">cons</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">()))</span>
<span class="c1">;选择函数</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">front-queue</span> <span class="nv">queue</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">empty-queue?</span> <span class="nv">queue</span><span class="p">)</span>
      <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;FRONT called with an empty queue&#34;</span> <span class="nv">queue</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nv">front-ptr</span> <span class="nv">queue</span><span class="p">))))</span>
<span class="c1">;检测队列是否为空</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">empty-queue?</span> <span class="nv">queue</span><span class="p">)</span> <span class="p">(</span><span class="nv">null?</span> <span class="p">(</span><span class="nv">front-ptr</span> <span class="nv">queue</span><span class="p">)))</span>
<span class="c1">;改变函数</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">insert-queue!</span> <span class="nv">queue</span> <span class="nv">item</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">new-pair</span> <span class="p">(</span><span class="nc">cons</span> <span class="nv">item</span> <span class="o">&#39;</span><span class="p">())))</span>
    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">empty-queue?</span> <span class="nv">queue</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">set-front-ptr!</span> <span class="nv">queue</span> <span class="nv">new-pair</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">set-rear-ptr!</span> <span class="nv">queue</span> <span class="nv">new-pair</span><span class="p">)</span>
           <span class="nv">queue</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">else</span>
           <span class="p">(</span><span class="nv">set-cdr!</span> <span class="p">(</span><span class="nv">rear-ptr</span> <span class="nv">queue</span><span class="p">)</span> <span class="nv">new-pair</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">set-rear-ptr!</span> <span class="nv">queue</span> <span class="nv">new-pair</span><span class="p">)</span>
           <span class="nv">queue</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">delete-queue!</span> <span class="nv">queue</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">empty-queue?</span> <span class="nv">queue</span><span class="p">)</span>
         <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;DELETE! called with an empty queue&#34;</span> <span class="nv">queue</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">else</span>
         <span class="p">(</span><span class="nv">set-front-ptr!</span> <span class="nv">queue</span> <span class="p">(</span><span class="nf">cdr</span> <span class="p">(</span><span class="nv">front-ptr</span> <span class="nv">queue</span><span class="p">)))</span>
         <span class="nv">queue</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">front-ptr</span> <span class="nv">queue</span><span class="p">)</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">queue</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">rear-ptr</span> <span class="nv">queue</span><span class="p">)</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">queue</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">set-front-ptr!</span> <span class="nv">queue</span> <span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nv">set-car!</span> <span class="nv">queue</span> <span class="nv">item</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">set-rear-ptr!</span> <span class="nv">queue</span> <span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nv">set-car!</span> <span class="nv">queue</span> <span class="nv">item</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="表格的表示">表格的表示</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">lookup</span> <span class="nv">key</span> <span class="nv">table</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">record</span> <span class="p">(</span><span class="nf">assoc</span> <span class="nv">key</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">table</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">record</span>
        <span class="p">(</span><span class="nf">cdr</span> <span class="nv">record</span><span class="p">)</span>
        <span class="nv">false</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nf">assoc</span> <span class="nv">key</span> <span class="nv">records</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null?</span> <span class="nv">records</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
        <span class="p">((</span><span class="nv">equal?</span> <span class="nv">key</span> <span class="p">(</span><span class="nf">caar</span> <span class="nv">records</span><span class="p">))</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">records</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="nf">assoc</span> <span class="nv">key</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">records</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">insert!</span> <span class="nv">key</span> <span class="nv">value</span> <span class="nv">table</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">record</span> <span class="p">(</span><span class="nf">assoc</span> <span class="nv">key</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">table</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">record</span>
        <span class="p">(</span><span class="nv">set-cdr!</span> <span class="nv">record</span> <span class="nv">value</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">set-cdr!</span> <span class="nv">table</span>
                  <span class="p">(</span><span class="nc">cons</span> <span class="p">(</span><span class="nc">cons</span> <span class="nv">key</span> <span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">table</span><span class="p">))))))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-table</span><span class="p">)</span>
  <span class="p">(</span><span class="nc">list</span> <span class="ss">&#39;*table*</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="数字电路的模拟器">数字电路的模拟器</h2>
<h1 id="并发时间本质是个问题">并发：时间本质是个问题</h1>
<p>和普通的并发问题是一致的。
串行化共享部分。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="nv">s</span> <span class="nv">make-serializer</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-account</span> <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&gt;=</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">begin</span> <span class="p">(</span><span class="nv">set!</span> <span class="nv">balance</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
               <span class="nv">balance</span><span class="p">)</span>
        <span class="s">&#34;Insufficient funds&#34;</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">deposit</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">set!</span> <span class="nv">balance</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
    <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">protected</span> <span class="p">(</span><span class="nv">make-serializer</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">dispatch</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;withdraw</span><span class="p">)</span> <span class="p">(</span><span class="nv">protected</span> <span class="nv">withdraw</span><span class="p">))</span>
            <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;deposit</span><span class="p">)</span> <span class="p">(</span><span class="nv">protected</span> <span class="nv">deposit</span><span class="p">))</span>
            <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;balance</span><span class="p">)</span> <span class="nv">balance</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Unknown request --MAKE-ACCOUNT&#34;</span>
                         <span class="nv">m</span><span class="p">))))</span>
    <span class="nv">dispatch</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="串行化的实现">串行化的实现</h2>
<p>互斥元同步机制。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-serializer</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">mutex</span> <span class="p">(</span><span class="nv">make-mutex</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">p</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">serialized-p</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">mutex</span> <span class="ss">&#39;acquire</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">val</span> <span class="p">(</span><span class="nf">apply</span> <span class="nv">p</span> <span class="nv">args</span><span class="p">)))</span>
          <span class="p">(</span><span class="nv">mutex</span> <span class="ss">&#39;release</span><span class="p">)</span>
          <span class="nv">val</span><span class="p">))</span>
      <span class="nv">serialized-p</span><span class="p">)))</span>


<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-mutex</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">cell</span> <span class="p">(</span><span class="nc">list</span> <span class="nv">false</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">the-mutex</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;acquire</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">test-and-set!</span> <span class="nv">cell</span><span class="p">)</span>
                 <span class="p">(</span><span class="nv">the-mutex</span> <span class="ss">&#39;acquire</span><span class="p">)))</span>
            <span class="p">((</span><span class="nv">eq?</span> <span class="nv">m</span> <span class="ss">&#39;release</span><span class="p">)</span> <span class="p">(</span><span class="nv">clea!</span> <span class="nv">cell</span><span class="p">))))</span>
    <span class="nv">the-mutex</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">test-and-set!</span> <span class="nv">cell</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">cell</span><span class="p">)</span>
      <span class="nv">true</span>
      <span class="p">(</span><span class="nv">begin</span> <span class="p">(</span><span class="nv">set-car!</span> <span class="nv">cell</span> <span class="nv">true</span><span class="p">)</span>
             <span class="nv">false</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>[读书笔记] sicp 第二章 带有通用型操作的系统</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E6%9C%89%E9%80%9A%E7%94%A8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F/</link>
    <pubDate>Sat, 10 Sep 2016 08:32:54 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E6%9C%89%E9%80%9A%E7%94%A8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F/</guid>
    <description><![CDATA[<h1 id="通用型算术运算">通用型算术运算</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">add</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="ss">&#39;add</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">sub</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="ss">&#39;sub</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">mul</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="ss">&#39;mul</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">div</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="ss">&#39;div</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">install-scheme-number-package</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">tag</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">attach-tag</span> <span class="ss">&#39;scheme-number</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;add</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">tag</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;sub</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">tag</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;mul</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">tag</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;div</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">tag</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;make</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">tag</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="ss">&#39;done</span><span class="p">)</span>
  
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-scheme-number</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">get</span> <span class="ss">&#39;make</span> <span class="ss">&#39;scheme-number</span><span class="p">)</span> <span class="nv">n</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>利用同样的方法可以加入有理数/复数等操作</p>
<h1 id="不同类型数据的组合">不同类型数据的组合</h1>
<p>处理跨类型的操作。
为每一种跨类型操作提供专门的过程处理，是可以，但是太麻烦。每添加一种类型，要增加太多过程。</p>
<h2 id="强制">强制</h2>
<p>类型转换处理能够解决一部分问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">;实数转虚数</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">scheme-number-&gt;complex</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-complex-from-real-imag</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">n</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>将这些强制过程安装到一个特护的表格里，用两个类型的名字作为索引。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">put-coercion</span> <span class="ss">&#39;scheme-number</span> <span class="ss">&#39;complex</span> <span class="nv">scheme-number-&gt;complex</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="nv">op</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">type-tags</span> <span class="p">(</span><span class="nf">map</span> <span class="nv">type-tag</span> <span class="nv">args</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if</span> <span class="nv">proc</span>
          <span class="p">(</span><span class="nf">apply</span> <span class="nv">proc</span> <span class="p">(</span><span class="nf">map</span> <span class="nv">contents</span> <span class="nv">args</span><span class="p">))</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">args</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
              <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">type1</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">type-tags</span><span class="p">))</span>
                    <span class="p">(</span><span class="nv">type2</span> <span class="p">(</span><span class="nf">cadr</span> <span class="nv">type-tags</span><span class="p">))</span>
                    <span class="p">(</span><span class="nv">a1</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">args</span><span class="p">))</span>
                    <span class="p">(</span><span class="nv">a2</span> <span class="p">(</span><span class="nf">cadr</span> <span class="nv">args</span><span class="p">)))</span>
                <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">t1-&gt;t2</span> <span class="p">(</span><span class="nv">get-coercion</span> <span class="nv">type1</span> <span class="nv">type2</span><span class="p">))</span>
                      <span class="p">(</span><span class="nv">t2-&gt;t1</span> <span class="p">(</span><span class="nv">get-coercion</span> <span class="nv">type2</span> <span class="nv">type1</span><span class="p">)))</span>
                  <span class="p">(</span><span class="nb">cond</span> <span class="p">(</span><span class="nv">t1-&gt;t2</span>
                         <span class="p">(</span><span class="nv">apply-generic</span> <span class="nv">op</span> <span class="p">(</span><span class="nv">t1-&gt;t2</span> <span class="nv">a1</span><span class="p">)</span> <span class="nv">a2</span><span class="p">))</span>
                        <span class="p">(</span><span class="nv">t2-&gt;t1</span>
                         <span class="p">(</span><span class="nv">apply-generic</span> <span class="nv">op</span> <span class="nv">a1</span> <span class="p">(</span><span class="nv">t2-&gt;t1</span> <span class="nv">a2</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nv">else</span>
                         <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;No method for these types&#34;</span>
                                <span class="p">(</span><span class="nc">list</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))))))</span>
              <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;No method for these types&#34;</span>
                     <span class="p">(</span><span class="nc">list</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))))))</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="类型的层次结构">类型的层次结构</h1>
<p>就是继承嘛。子类型有父类型的所有操作。
#层次结构的不足
可能产生菱形的层次结构。</p>
<p>在设计大型系统时，处理好一大批相互有关的类型而同时又能保持模块性，这是一个困难的问题，也是当前正在继续研究的领域。
编者注：这句话出现在书的第一版本。它的现在就像20年前写出时候正确。开发出一种有用的，具有一般意义的框架，以描述不同类型对象之间的关系(哲学中本体论)，看来是一件极其困难的工作。在10年前存在的混乱和今天存在的混乱之间的主要差异在于，今天已经有了一批各式各样的并不合适的本体理论，它们已经嵌入数量过多而又先天不足的各种程序设计语言里。举例来说，面向对象语言的大部分复杂性-以及当前各种面向对象语言之间细微的而且诗人迷惑的差异-的核心，就是类型之间通用型操作的处理。我们在第三章有关计算性对象的讨论中完全避免了这些问题。熟悉面向对象程序涉及到读者将会注意到，在第三章里关于局部状态说了许多东西，但是却根本没有提到“类”或者“继承”。事实上，我们的猜想是，如果没有知识表示和自动推理工作的帮助，这些问题是无法仅仅通过计算机语言设计的方式合理处理的。</p>]]></description>
</item><item>
    <title>[读书笔记] sicp 第二章 抽象数据的多重表示</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA/</link>
    <pubDate>Sat, 10 Sep 2016 08:32:38 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA/</guid>
    <description><![CDATA[<p>对于一个数据对象可以能存在多种有用的表示形式，而且我们也希望所涉及的系统能够处理多种表示形式。
例子：复数的极坐标形式和直角坐标的形式
构造通用型过程：可以在不止一种数据表示上操作的过程。采用的技术：让它们在带有类型标志的数据对象上工作。也就是说，让数据对象包含着它们应该如何处理的明确信息。</p>
<h1 id="复数的表示">复数的表示</h1>
<p>为一个数据提供了多种操作，存在多种形式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">sqrt</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">square</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z</span><span class="p">))</span> <span class="p">(</span><span class="nv">square</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">atan</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nc">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-mag-ang</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nc">cons</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">r</span> <span class="p">(</span><span class="nf">cos</span> <span class="nv">a</span><span class="p">))</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">r</span> <span class="p">(</span><span class="nf">sin</span> <span class="nv">a</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">add-complex</span> <span class="nv">z1</span> <span class="nv">z2</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z2</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z2</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">sub-complex</span> <span class="nv">z1</span> <span class="nv">z2</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z2</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z2</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">mul-complex</span> <span class="nv">z1</span> <span class="nv">z2</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-from-mag-ang</span> <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z2</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z2</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">div-complex</span> <span class="nv">z1</span> <span class="nv">z2</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-from-mag-ang</span> <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z2</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z2</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="带标志数据">带标志数据</h1>
<p>认识数据抽象的一种方式是将其看做”最小允诺原则“的一个应用。在实现上面的复数系统的时候，采用两种形式，由选择函数和构造函数形成的抽象屏障，使我们可以把为自己所用的数据对象选择具体表现形式的事情尽量往后推，而且还能够保持系统设计的最大灵活性。
方式，利用类型标志，来确定什么类型，选择什么函数。
增加类型标示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">attach-tag</span> <span class="nv">type-tag</span> <span class="nv">contents</span><span class="p">)</span>
  <span class="p">(</span><span class="nc">cons</span> <span class="nv">type-tag</span> <span class="nv">contents</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">type-tag</span> <span class="nv">datum</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">pair?</span> <span class="nv">datum</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">car</span> <span class="nv">datum</span><span class="p">)</span>
      <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Bad tagged datum -- TYPE-TAG&#34;</span> <span class="nv">datum</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">datum</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">pair?</span> <span class="nv">datum</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">cdr</span> <span class="nv">datum</span><span class="p">)</span>
      <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Bad tagged datum -- CONTENTS&#34;</span> <span class="nv">datum</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">rectangular?</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">eq?</span> <span class="p">(</span><span class="nv">type-tag</span> <span class="nv">z</span><span class="p">)</span> <span class="ss">&#39;rectangular</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">polar?</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">eq?</span> <span class="p">(</span><span class="nv">type-tag</span> <span class="nv">z</span><span class="p">)</span> <span class="ss">&#39;polar</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>修改新的直角坐标表示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">real-part-rectangular</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">imag-part-rectangular</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">magnitude-rectangular</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">sqrt</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">square</span> <span class="p">(</span><span class="nv">real-part-rectangular</span> <span class="nv">z</span><span class="p">))</span> <span class="p">(</span><span class="nv">square</span> <span class="p">(</span><span class="nv">imag-part-rectangular</span> <span class="nv">z</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">angle-rectangular</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">atan</span> <span class="p">(</span><span class="nv">imag-part-rectangular</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nv">real-part-rectangular</span> <span class="nv">z</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-real-imag-rectangular</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">attach-tag</span> <span class="ss">&#39;rectangular</span> <span class="p">(</span><span class="nc">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-mag-ang-rectangular</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">attach-tag</span> <span class="ss">&#39;rectangular</span> <span class="p">(</span><span class="nc">cons</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">r</span> <span class="p">(</span><span class="nf">cos</span> <span class="nv">a</span><span class="p">))</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">r</span> <span class="p">(</span><span class="nf">sin</span> <span class="nv">a</span><span class="p">)))))</span>
</code></pre></td></tr></table>
</div>
</div><p>修改极坐标的表现形式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">real-part-polat</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nv">magnitude-polat</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">cos</span> <span class="p">(</span><span class="nv">angle-polat</span> <span class="nv">z</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">imag-part-polat</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nv">magnitude-polat</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">sin</span> <span class="p">(</span><span class="nv">angle-polat</span> <span class="nv">z</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">magnitude-polat</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">car</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">angle-polat</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">cdr</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-real-imag-polatr</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">attach-tag</span> <span class="ss">&#39;polar</span>
              <span class="p">(</span><span class="nc">cons</span> <span class="p">(</span><span class="nf">sqrt</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">square</span> <span class="nv">y</span><span class="p">)))</span>
                    <span class="p">(</span><span class="nf">atan</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-mag-ang-polat</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">attach-tag</span> <span class="ss">&#39;polar</span> <span class="p">(</span><span class="nc">cons</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><p>在通用选择函数都添加检查类型的标志，调用合适的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">real-patr</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">rectangular?</span> <span class="nv">z</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">real-part-rectangular</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">((</span><span class="nv">polar?</span> <span class="nv">z</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">real-part-polat</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Unknown type -- REAL-PART&#34;</span> <span class="nv">z</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">imag-patr</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">rectangular?</span> <span class="nv">z</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">imag-part-rectangular</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">((</span><span class="nv">polar?</span> <span class="nv">z</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">imag-part-polat</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Unknown type -- IMAG-PART&#34;</span> <span class="nv">z</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">rectangular?</span> <span class="nv">z</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">magnitude-rectangular</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">((</span><span class="nv">polar?</span> <span class="nv">z</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">magnitude-polat</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Unknown type -- MAGNITUDE&#34;</span> <span class="nv">z</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">rectangular?</span> <span class="nv">z</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">angle-rectangular</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">((</span><span class="nv">polar?</span> <span class="nv">z</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">angle-polat</span> <span class="p">(</span><span class="nv">contents</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Unknown type -- ANGLE&#34;</span> <span class="nv">z</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><p>实现算数操作的时候不需要改变。还是原来的形式就可以。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">add-complex</span> <span class="nv">z1</span> <span class="nv">z2</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z2</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z1</span><span class="p">)</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z2</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><p>需要修改下构造函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-from-real-imag-rectangular</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-mag-ang</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-from-mag-ang-polat</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="数据导向的程序设计和可加性">数据导向的程序设计和可加性</h1>
<p>检查一个数据项的类型，并据此去调用某个适当的过程称为基于类型的分派。
在系统设计中，这是一种获得模块性的强有力策略（可能oo是更好的方式，检测类型还是比较麻烦的）。
存在两个弱点：</p>
<ol>
<li>其中的通用型接口过程，必须知道素有的不同表示。需要检测类型，选择适当函数</li>
<li>独立的表现形式分别设计，需要拥有不同的名字。
那么这就导致，这种实现不具有可加性。在每一次增加一种新形式的时候，需要去修改原过程，修改类型判断，增加代码，修改过程名字。</li>
</ol>
<p>现在我们需要的是一种能够将系统设计进一步模块化的方法。一种称为数据导向的程序设计都编程技术提供了这种能力（其实在数据中保存能够处理数据的过程，就能够不用选择函数直接处理了嘛）。
（实际上这里讲的是一种注册机制）
假定存在put get来制造表格</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">install-rectangular-package</span><span class="p">)</span>
  <span class="c1">;internal procedures</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">z</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">z</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nc">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">sqrt</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">square</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z</span><span class="p">))</span> <span class="p">(</span><span class="nv">square</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">atan</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-mag-ang</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nc">cons</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">r</span> <span class="p">(</span><span class="nf">cos</span> <span class="nv">a</span><span class="p">))</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">r</span> <span class="p">(</span><span class="nf">sin</span> <span class="nv">a</span><span class="p">))))</span>
  <span class="c1">;interface the rest of the system</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">tag</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">attach-tag</span> <span class="ss">&#39;rectangular</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;real-part</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;rectangular</span><span class="p">)</span> <span class="nv">real-part</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;imag-part</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;rectangular</span><span class="p">)</span> <span class="nv">imag-part</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;magnitude</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;rectangular</span><span class="p">)</span> <span class="nv">magnitude</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;angle</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;rectangular</span><span class="p">)</span> <span class="nv">angle</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;make-from-real-imag</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;rectangular</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">tag</span> <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;make-from-mag-ang</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;rectangular</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">r</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">tag</span> <span class="p">(</span><span class="nv">make-from-mag-ang</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">))))</span>
  <span class="ss">&#39;done</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">install-polar-package</span><span class="p">)</span>
  <span class="c1">;internal procedures</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">z</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">z</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-mag-ang</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nc">cons</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">cos</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z</span><span class="p">))))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">sin</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z</span><span class="p">))))</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nc">cons</span> <span class="p">(</span><span class="nf">sqrt</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">square</span> <span class="nv">y</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">atan</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="c1">;interface the rest of the system</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">tag</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">attach-tag</span> <span class="ss">&#39;polar</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;real-part</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;polar</span><span class="p">)</span> <span class="nv">real-part</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;imag-part</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;polar</span><span class="p">)</span> <span class="nv">imag-part</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;magnitude</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;polar</span><span class="p">)</span> <span class="nv">magnitude</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;angle</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;polar</span><span class="p">)</span> <span class="nv">angle</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;make-from-real-imag</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;polar</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">tag</span> <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="nv">put</span> <span class="ss">&#39;make-from-mag-ang</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;polar</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">r</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">tag</span> <span class="p">(</span><span class="nv">make-from-mag-ang</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">))))</span>
  <span class="ss">&#39;done</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>下面操作用于访问表格</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="nv">op</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">type-tags</span> <span class="p">(</span><span class="nf">map</span> <span class="nv">type-tag</span> <span class="nv">args</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if</span> <span class="nv">proc</span>
          <span class="p">(</span><span class="nf">apply</span> <span class="nv">proc</span> <span class="p">(</span><span class="nf">map</span> <span class="nv">contents</span> <span class="nv">args</span><span class="p">))</span>
          <span class="p">(</span><span class="kt">error</span>
           <span class="s">&#34;No method for these types -- APPLY-GENERIC&#34;</span>
           <span class="p">(</span><span class="nc">list</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))))))</span>
</code></pre></td></tr></table>
</div>
</div><p>那么通用操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">real-part</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="ss">&#39;real-part</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">imag-part</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="ss">&#39;imag-part</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">magnitude</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="ss">&#39;magnitude</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">angle</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="ss">&#39;angle</span> <span class="nv">z</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">get</span> <span class="ss">&#39;make-from-real-imag</span> <span class="ss">&#39;rectangular</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-mag-ang</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">get</span> <span class="ss">&#39;make-from-mag-ang</span> <span class="ss">&#39;polat</span><span class="p">)</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="消息传递">消息传递</h2>
<p>数据导向的程序设计，最关键的思想是通过显式的操作-类型表格的方式，管理程序中的各种通用性操作。上面使用的程序设计风格是一种基于类型进行分派的组织方式，其中让每个操作管理自己的分派。从效果上看，这种方式就是将操作-类型表哥格分解位一行一行，每个通用型过程表示表格中的一行。
另一种实现策略是将这一表格按列进行分解，不是采用一批“只能”操作区基于数据类型进行分派，而是采用“只能数据对象”，让它们基于操作名完成所需要的分派工作。
需要做的，将每一个数据对象表示为一个过程。（实际上类似于数据封装，每个数据对象保存专有的函数，利用虚函数就行了。思想是一致的。stl）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">dispatch</span> <span class="nv">op</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">eq?</span> <span class="nv">op</span> <span class="ss">&#39;real-part</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
          <span class="p">((</span><span class="nv">eq?</span> <span class="nv">op</span> <span class="ss">&#39;iamg-part</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
          <span class="p">((</span><span class="nv">eq?</span> <span class="nv">op</span> <span class="ss">&#39;magnitude</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">sqrt</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">square</span> <span class="nv">y</span><span class="p">))))</span>
          <span class="p">((</span><span class="nv">eq?</span> <span class="nv">op</span> <span class="ss">&#39;angle</span><span class="p">)</span> <span class="p">(</span><span class="nf">atan</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">else</span>
           <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;Unkonown op -- MAKE-FROM-REAL-IMAG&#34;</span> <span class="nv">op</span><span class="p">))))</span>
<span class="nv">dispatch</span><span class="p">)</span>
<span class="c1">;查找函数</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">apply-generic</span> <span class="nv">op</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">arg</span> <span class="nv">op</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>这种风格的程序设计称为消息传递，将数据对象设想位一个实体，它以消息的方式接受所需要操作的名字。（设计模式里面有一种这种模式）。</p>]]></description>
</item><item>
    <title>[读书笔记] sicp 第二章 符号数据</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/</link>
    <pubDate>Sat, 10 Sep 2016 08:32:26 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/</guid>
    <description><![CDATA[<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nc">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span>
<span class="p">(</span><span class="nv">eq?</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="符号求导">符号求导</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp">
<span class="c1">;e是变量吗</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">variable?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">symbol?</span> <span class="nv">x</span><span class="p">))</span><span class="c1">;symbol?判断变量是不是符号</span>

<span class="c1">;v1和v2是同一个变量吗</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">same-variable?</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">variable?</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nv">variable?</span> <span class="nv">v2</span><span class="p">)</span> <span class="p">(</span><span class="nv">eq?</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)))</span>

<span class="c1">;e是和式吗</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">sum?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">pair?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">eq?</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;+</span><span class="p">)))</span>

<span class="c1">;e的被加数</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">addend</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nf">cadr</span> <span class="nv">s</span><span class="p">))</span>

<span class="c1">;e的加数</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">augend</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nf">caddr</span> <span class="nv">s</span><span class="p">))</span>

<span class="c1">;构造起a1和a2的和式</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="p">(</span><span class="nc">list</span> <span class="ss">&#39;+</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">))</span>

<span class="c1">;e是乘式吗</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">product?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">pair?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">eq?</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;*</span><span class="p">)))</span>

<span class="c1">;e的被乘数</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">multiplier</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">cadr</span> <span class="nv">p</span><span class="p">))</span>

<span class="c1">;e的乘数</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">multiplicand</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">caddr</span> <span class="nv">p</span><span class="p">))</span>

<span class="c1">;构造起来m1与m2的乘式</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-product</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">)</span>
       <span class="p">(</span><span class="nc">list</span> <span class="ss">&#39;*</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">))</span>

<span class="c1">;求导</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">deriv</span> <span class="nf">exp</span> <span class="nv">var</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">number?</span> <span class="nf">exp</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">((</span><span class="nv">variable?</span> <span class="nf">exp</span><span class="p">)</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">same-variable?</span> <span class="nf">exp</span> <span class="nv">var</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">((</span><span class="nv">sum?</span> <span class="nf">exp</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">make-sum</span> <span class="p">(</span><span class="nv">deriv</span> <span class="p">(</span><span class="nv">addend</span> <span class="nf">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">deriv</span> <span class="p">(</span><span class="nv">augend</span> <span class="nf">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
        <span class="p">((</span><span class="nv">product?</span> <span class="nf">exp</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">make-sum</span>
          <span class="p">(</span><span class="nv">make-product</span> <span class="p">(</span><span class="nv">multiplier</span> <span class="nf">exp</span><span class="p">)</span>
                        <span class="p">(</span><span class="nv">deriv</span> <span class="p">(</span><span class="nv">multiplicand</span> <span class="nf">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">make-product</span> <span class="p">(</span><span class="nv">deriv</span> <span class="p">(</span><span class="nv">multiplier</span> <span class="nf">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
                        <span class="p">(</span><span class="nv">multiplicand</span> <span class="nf">exp</span><span class="p">))))</span>
        <span class="p">(</span><span class="nv">else</span>
         <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;unknown expression type -- DERIV&#34;</span> <span class="nf">exp</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">deriv</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">+</span> <span class="nv">x</span> <span class="mi">3</span><span class="p">)</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">deriv</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">deriv</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">x</span> <span class="mi">3</span><span class="p">))</span> <span class="ss">&#39;x</span><span class="p">)</span>

<span class="o">&#39;</span><span class="p">(</span><span class="nf">+</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">1</span> <span class="nv">y</span><span class="p">))</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">1</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">x</span> <span class="mi">3</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="集合的表示">集合的表示</h1>
<h2 id="集合作为未排序的表">集合作为未排序的表</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">;判断是不是表成员</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">element-of-set?</span> <span class="nv">x</span> <span class="nf">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null?</span> <span class="nf">set</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
        <span class="p">((</span><span class="nv">equal?</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">set</span><span class="p">))</span> <span class="nv">true</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="nv">element-of-set?</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nf">set</span><span class="p">)))))</span>
<span class="c1">;向表增加一项</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">adjoin-set</span> <span class="nv">x</span> <span class="nf">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">element-of-set?</span> <span class="nv">x</span> <span class="nf">set</span><span class="p">)</span>
      <span class="nf">set</span>
      <span class="p">(</span><span class="nc">cons</span> <span class="nv">x</span> <span class="nf">set</span><span class="p">)))</span>
<span class="c1">;合并</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">intersection-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">or</span> <span class="p">(</span><span class="nv">null?</span> <span class="nv">set1</span><span class="p">)</span> <span class="p">(</span><span class="nv">null?</span> <span class="nv">set2</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())</span>
        <span class="p">((</span><span class="nv">element-of-set?</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)</span>
         <span class="p">(</span><span class="nc">cons</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">set1</span><span class="p">)</span>
               <span class="p">(</span><span class="nv">intersection-set</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)))</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="nv">intersection-set</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="集合作为排序的表">集合作为排序的表</h2>
<p>排序的存在的好处就是减少复杂度</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">element-of-set?</span> <span class="nv">x</span> <span class="nf">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null?</span> <span class="nf">set</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">=</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">set</span><span class="p">))</span> <span class="nv">true</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">&lt;</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">set</span><span class="p">))</span> <span class="nv">false</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="nv">element-of-set?</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nf">set</span><span class="p">)))))</span>
    
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">intersection-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">null?</span> <span class="nv">set1</span><span class="p">)</span> <span class="p">(</span><span class="nv">null?</span> <span class="nv">set2</span><span class="p">))</span>
       <span class="o">&#39;</span><span class="p">()</span>
       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x1</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nv">x2</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">set2</span><span class="p">)))</span>
         <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nf">=</span> <span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
                <span class="p">(</span><span class="nc">cons</span> <span class="nv">x1</span>
                      <span class="p">(</span><span class="nv">intersection-set</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">set1</span><span class="p">)</span>
                                        <span class="p">(</span><span class="nf">cdr</span> <span class="nv">set2</span><span class="p">))))</span>
               <span class="p">((</span><span class="nf">&lt;</span> <span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">intersection-set</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">))</span>
               <span class="p">((</span><span class="nf">&lt;</span> <span class="nv">x2</span> <span class="nv">x1</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">intersection-set</span> <span class="nf">set</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">set2</span><span class="p">)))))))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="集合作为二叉树">集合作为二叉树</h2>
<p>有序二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">entry</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">tree</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">left-branch</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nf">cadr</span> <span class="nv">tree</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">right-branch</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nf">caddr</span> <span class="nv">tree</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-tree</span> <span class="nv">entry</span> <span class="nv">left</span> <span class="nv">right</span><span class="p">)</span>
  <span class="p">(</span><span class="nc">list</span> <span class="nv">entry</span> <span class="nv">left</span> <span class="nv">right</span><span class="p">))</span>
  
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">element-of-set?</span> <span class="nv">x</span> <span class="nf">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null?</span> <span class="nf">set</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">=</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">entry</span> <span class="nf">set</span><span class="p">))</span> <span class="nv">true</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">&lt;</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">entry</span> <span class="nf">set</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">element-of-set?</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">left-branch</span> <span class="nf">set</span><span class="p">)))</span>
        <span class="p">((</span><span class="nf">&gt;</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">entry</span> <span class="nf">set</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">element-of-set?</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">right-branch</span> <span class="nf">set</span><span class="p">)))))</span>
<span class="c1">;插入要找到正确位置</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">adjoin-set</span> <span class="nv">x</span> <span class="nf">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null?</span> <span class="nf">set</span><span class="p">)</span> <span class="p">(</span><span class="nv">make-tree</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">()))</span>
        <span class="p">((</span><span class="nf">=</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">entry</span> <span class="nf">set</span><span class="p">))</span> <span class="nf">set</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">&lt;</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">entry</span> <span class="nf">set</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">make-tree</span> <span class="p">(</span><span class="nv">entry</span> <span class="nf">set</span><span class="p">)</span>
                    <span class="p">(</span><span class="nv">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">left-branch</span> <span class="nf">set</span><span class="p">))</span>
                    <span class="p">(</span><span class="nv">right-branch</span> <span class="nf">set</span><span class="p">)))</span>
        <span class="p">((</span><span class="nf">&gt;</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">entry</span> <span class="nf">set</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">make-tree</span> <span class="p">(</span><span class="nv">entry</span> <span class="nf">set</span><span class="p">)</span>
                    <span class="p">(</span><span class="nv">left-branch</span> <span class="nf">set</span><span class="p">)</span>
                    <span class="p">(</span><span class="nv">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">right-branch</span> <span class="nf">set</span><span class="p">))))))</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="huffman编码树">huffman编码树</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">;树的表示</span>
<span class="c1">;leaf 符号 权重</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-leaf</span> <span class="nc">symbol</span> <span class="nv">weight</span><span class="p">)</span>
  <span class="p">(</span><span class="nc">list</span> <span class="ss">&#39;leaf</span> <span class="nc">symbol</span> <span class="nv">weight</span><span class="p">))</span>
  
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">leaf?</span> <span class="nv">object</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">eq?</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">object</span><span class="p">)</span> <span class="ss">&#39;leaf</span><span class="p">))</span>
  
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">symbol-leaf</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">cadr</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">weight-leaf</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">caddr</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-code-tree</span> <span class="nv">left</span> <span class="nv">right</span><span class="p">)</span>
  <span class="p">(</span><span class="nc">list</span> <span class="nv">left</span>
        <span class="nv">right</span>
        <span class="p">(</span><span class="nf">append</span> <span class="p">(</span><span class="nv">symbols</span> <span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nv">symbols</span> <span class="nv">right</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">weight</span> <span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nv">weight</span> <span class="nv">right</span><span class="p">))))</span>
        
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">left-branch</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">tree</span><span class="p">))</span>
<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">right-branch</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nf">cadr</span> <span class="nv">tree</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">symbols</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leaf?</span> <span class="nv">tree</span><span class="p">)</span>
      <span class="p">(</span><span class="nc">list</span> <span class="p">(</span><span class="nv">symbol-leaf</span> <span class="nv">tree</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">caddr</span> <span class="nv">tree</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">weight</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leaf?</span> <span class="nv">tree</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">weight-leaf</span> <span class="nv">tree</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">caddr</span> <span class="nv">tree</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="解码过程">解码过程</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">decode</span> <span class="nv">bits</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">decode-1</span> <span class="nv">bits</span> <span class="nv">current-branch</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">null?</span> <span class="nv">bits</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">()</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">next-branch</span>
               <span class="p">(</span><span class="nv">choose-branch</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">bits</span><span class="p">)</span> <span class="nv">current-branch</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leaf?</span> <span class="nv">next-branch</span><span class="p">)</span>
              <span class="p">(</span><span class="nc">cons</span> <span class="p">(</span><span class="nv">symbol-leaf</span> <span class="nv">next-branch</span><span class="p">)</span>
                    <span class="p">(</span><span class="nv">decode-1</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">bits</span><span class="p">)</span> <span class="nv">tree</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">decode-1</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">bits</span><span class="p">)</span> <span class="nv">next-branch</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nv">decode-1</span> <span class="nv">bits</span> <span class="nv">tree</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">choose-branch</span> <span class="kt">bit</span> <span class="nv">branch</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nf">=</span> <span class="kt">bit</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">left-branch</span> <span class="nv">branch</span><span class="p">))</span>
        <span class="p">((</span><span class="nf">=</span> <span class="kt">bit</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">right-branch</span> <span class="nv">branch</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="kt">error</span> <span class="s">&#34;bad bit -- CHOOSE-BRANCH&#34;</span> <span class="kt">bit</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="带权重的集合">带权重的集合</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">adjoin-set</span> <span class="nv">x</span> <span class="nf">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null?</span> <span class="nf">set</span><span class="p">)</span> <span class="p">(</span><span class="nc">list</span> <span class="nv">x</span><span class="p">))</span>
        <span class="p">((</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nv">weight</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">weight</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">set</span><span class="p">)))</span> <span class="p">(</span><span class="nc">cons</span> <span class="nv">x</span> <span class="nf">set</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">else</span> <span class="p">(</span><span class="nc">cons</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">set</span><span class="p">)</span>
                    <span class="p">(</span><span class="nv">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nf">set</span><span class="p">))))))</span>

<span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-leaf-set</span> <span class="nv">pairs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">null?</span> <span class="nv">pairs</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">pair</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">pairs</span><span class="p">)))</span>
        <span class="p">(</span><span class="nv">adjoin-set</span> <span class="p">(</span><span class="nv">make-leaf</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">pair</span><span class="p">)</span>
                               <span class="p">(</span><span class="nf">cadr</span> <span class="nv">pair</span><span class="p">))</span>
                    <span class="p">(</span><span class="nv">make-leaf-set</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">pairs</span><span class="p">))))))</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item></channel>
</rss>
