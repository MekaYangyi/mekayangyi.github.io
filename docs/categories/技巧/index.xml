<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>技巧 - Category - 鉴心</title>
        <link>http://coderyang.com/categories/%E6%8A%80%E5%B7%A7/</link>
        <description>技巧 - Category - 鉴心</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 14 Nov 2020 16:04:59 &#43;0000</lastBuildDate><atom:link href="http://coderyang.com/categories/%E6%8A%80%E5%B7%A7/" rel="self" type="application/rss+xml" /><item>
    <title>高性能libcurl</title>
    <link>http://coderyang.com/libcurl/</link>
    <pubDate>Sat, 14 Nov 2020 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/libcurl/</guid>
    <description><![CDATA[<p>本文主要介绍一下curl接口的使用方法，以及获取高性能的一些实践。</p>
<h2 id="什么是libcurl用处">什么是libcurl？用处？</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more!
</code></pre></td></tr></table>
</div>
</div><p>官网摘的一段，意思大概是免费且容易使用的url传输库，支持下面一堆特性。</p>
<p>项目内用处：基于libcurl实现了一个单线程异步的httpc，用于msdk、防沉迷、信用分等需要接入外部http的服务。</p>
<h2 id="接口介绍">接口介绍</h2>
<p>curl一共有三种接口：</p>
<ul>
<li><a href="https://curl.haxx.se/libcurl/c/libcurl-easy.html" target="_blank" rel="noopener noreffer">Easy Interface</a></li>
<li><a href="https://curl.haxx.se/libcurl/c/libcurl-multi.html" target="_blank" rel="noopener noreffer">Multi Interface</a></li>
<li><a href="https://curl.haxx.se/libcurl/c/libcurl-share.html" target="_blank" rel="noopener noreffer">Share Interface</a></li>
</ul>
<h3 id="easy-interface">Easy Interface</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">The easy interface is a synchronous, efficient, quickly used and... yes, easy interface for file transfers. Numerous applications have been built using this.
</code></pre></td></tr></table>
</div>
</div><p>简单接口是一个同步接口，非常方便使用，接口以curl_easy_开头，下面一个简单的使用例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CURL</span> <span class="o">*</span><span class="n">curl</span> <span class="o">=</span> <span class="n">curl_easy_init</span><span class="p">();</span> <span class="c1">// 创建一个handle
</span><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">curl</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CURLcode</span> <span class="n">res</span><span class="p">;</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">curl</span><span class="p">,</span> <span class="n">CURLOPT_URL</span><span class="p">,</span> <span class="s">&#34;https://example.com&#34;</span><span class="p">);</span> <span class="c1">// 设置参数，参数有很多，header、cookie、接收回调函数、证书等等
</span><span class="c1"></span>  <span class="n">res</span> <span class="o">=</span> <span class="n">curl_easy_perform</span><span class="p">(</span><span class="n">curl</span><span class="p">);</span> <span class="c1">// 执行，注意这里是阻塞的
</span><span class="c1"></span>  <span class="n">curl_easy_cleanup</span><span class="p">(</span><span class="n">curl</span><span class="p">);</span> <span class="c1">// 清理
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="multi-interface">Multi Interface</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">The multi interface is the asynchronous brother in the family and it also offers multiple transfers using a single thread and more. 
</code></pre></td></tr></table>
</div>
</div><p>多重接口是异步接口，libcurl使用一个或者多个线程完成数据传输，通过多重接口可以再单线程下同时操作多个easy handle。</p>
<p>例子：https://gist.github.com/clemensg/4960504</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define MAX_WAIT_MSECS 30*1000 </span><span class="cm">/* Wait max. 30 seconds */</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">urls</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">&#34;http://www.microsoft.com&#34;</span><span class="p">,</span>
  <span class="s">&#34;http://www.yahoo.com&#34;</span><span class="p">,</span>
  <span class="s">&#34;http://www.wikipedia.org&#34;</span><span class="p">,</span>
  <span class="s">&#34;http://slashdot.org&#34;</span>
<span class="p">};</span>
<span class="cp">#define CNT 4
</span><span class="cp"></span>
<span class="k">static</span> <span class="n">size_t</span> <span class="nf">cb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">l</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* take care of the data here, ignored in this example */</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="n">CURLM</span> <span class="o">*</span><span class="n">cm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">CURL</span> <span class="o">*</span><span class="n">eh</span> <span class="o">=</span> <span class="n">curl_easy_init</span><span class="p">();</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_WRITEFUNCTION</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_HEADER</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_URL</span><span class="p">,</span> <span class="n">urls</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_PRIVATE</span><span class="p">,</span> <span class="n">urls</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_VERBOSE</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
  <span class="n">curl_multi_add_handle</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">eh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CURLM</span> <span class="o">*</span><span class="n">cm</span> <span class="o">=</span> <span class="n">curl_multi_init</span><span class="p">();</span> <span class="c1">// 创建一个multi handle
</span><span class="c1"></span>
    <span class="c1">// 创建一堆easy handle加入到multi handle里
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">init</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 执行，等待所有都执行完
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">still_running</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">curl_multi_perform</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">still_running</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
      	<span class="c1">// 等一段时间，MAX_WAIT_MSECS为最长时长
</span><span class="c1"></span>        <span class="c1">// 有事件或者超时了返回
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">curl_multi_wait</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_WAIT_MSECS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numfds</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">CURLM_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;error: curl_multi_wait() returned %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">curl_multi_perform</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">still_running</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">still_running</span><span class="p">);</span>

    <span class="c1">// 读取数据
</span><span class="c1"></span>    <span class="n">CURLMsg</span> <span class="o">*</span><span class="n">msg</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">szUrl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">msgs_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">http_status_code</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">msg</span> <span class="o">=</span> <span class="n">curl_multi_info_read</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msgs_left</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">==</span> <span class="n">CURLMSG_DONE</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">CURL</span> <span class="o">*</span><span class="n">eh</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">easy_handle</span><span class="p">;</span>
            <span class="n">CURLcode</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">result</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">return_code</span><span class="o">!=</span><span class="n">CURLE_OK</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;CURL error code: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">result</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Get HTTP status code
</span><span class="c1"></span>            <span class="n">http_status_code</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="n">szUrl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">curl_easy_getinfo</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLINFO_RESPONSE_CODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">http_status_code</span><span class="p">);</span>
            <span class="n">curl_easy_getinfo</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLINFO_PRIVATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">szUrl</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">http_status_code</span><span class="o">==</span><span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&#34;200 OK for %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">szUrl</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;GET of %s returned http status code %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">szUrl</span><span class="p">,</span> <span class="n">http_status_code</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">curl_multi_remove_handle</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">eh</span><span class="p">);</span>
            <span class="n">curl_easy_cleanup</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;error: after curl_multi_info_read(), CURLMsg=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 关闭
</span><span class="c1"></span>    <span class="n">curl_multi_cleanup</span><span class="p">(</span><span class="n">cm</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="share-interface">Share Interface</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">The share interface was added to enable sharing of data between curl &#34;handles&#34;.
</code></pre></td></tr></table>
</div>
</div><p>用于再多个easy handle共享一些数据，比如dns cache、tls session。</p>
<h3 id="其他">其他</h3>
<p>curl_global_init：进程启动时初始化curl</p>
<p>curl_global_cleanup：进程关闭时清理curl</p>
<p>使用异步DNS，防止同步解析DNS卡住主循环</p>
<h2 id="实践">实践</h2>
<ol>
<li>
<p>最初实现了一个使用Multi Interface的HTTPC。</p>
<ul>
<li>
<p>httpc/unittest/httpc.cpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">TEST_F</span><span class="p">(</span><span class="n">HTTPC_TEST</span><span class="p">,</span> <span class="n">HTTP_GET</span><span class="p">)</span>                                                 
<span class="p">{</span>
    <span class="n">HTTPC_CFG</span> <span class="n">cfg</span><span class="p">;</span>
    <span class="n">REQUEST_DRIVER</span> <span class="nf">driver</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">HTTPC</span> <span class="nf">c</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
         
    <span class="k">auto</span> <span class="n">cb</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">RESPONSE</span> <span class="o">&amp;</span><span class="n">rsp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;result:%d code:%ld </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rsp</span><span class="p">.</span><span class="n">_result</span><span class="p">,</span> <span class="n">rsp</span><span class="p">.</span><span class="n">_http_status_code</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;body:%s&#34;</span><span class="p">,</span> <span class="n">rsp</span><span class="p">.</span><span class="n">_body</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="p">};</span>
     
    <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#34;http://www.baidu.com&#34;</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
    <span class="p">}</span>
     
    <span class="kt">bool</span> <span class="n">idle</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="p">.</span><span class="n">_ctx_map</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">driver</span><span class="p">.</span><span class="n">loop</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>在压测过程中发现性能不足，DNS解析卡住主循环。根据https://moz.com/devblog/high-performance-libcurl-tips，增加了c-ares库，使得libcurl支持异步DNS，最终性能到了3000TPS。</p>
</li>
<li>
<p>尝试使用Share Interface共享DNS，效果在接入异步DNS后不明显。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 初始化共享
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">_dns_lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span>
<span class="n">CURLSH</span><span class="o">*</span> <span class="n">_share_handler</span> <span class="o">=</span> <span class="n">curl_share_init</span><span class="p">();</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_USERDATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_dns_lock</span><span class="p">);</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_LOCKFUNC</span><span class="p">,</span> <span class="n">_lock</span><span class="p">);</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_UNLOCKFUNC</span><span class="p">,</span> <span class="n">_unlock</span><span class="p">);</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_SHARE</span><span class="p">,</span> <span class="n">CURL_LOCK_DATA_DNS</span><span class="p">);</span>
   
<span class="c1">// 设置共享
</span><span class="c1"></span><span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_requst</span><span class="o">-&gt;</span><span class="n">_curl_handle</span><span class="p">,</span> <span class="n">CURLOPT_SHARE</span><span class="p">,</span> <span class="n">_share_handler</span><span class="p">);</span>
<span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_requst</span><span class="o">-&gt;</span><span class="n">_curl_handle</span><span class="p">,</span> <span class="n">CURLOPT_DNS_CACHE_TIMEOUT</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span><span class="p">);</span><span class="c1">//5min
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>请求处理完毕后，不适用curl_easy_cleanup，而是采用连接池的方式通过curl_easy_reset重用连接。</p>
<ul>
<li>
<p><a href="https://curl.se/libcurl/c/libcurl-tutorial.html#Persistence">https://curl.se/libcurl/c/libcurl-tutorial.html#Persistence</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Re-cycling the same easy handle several times when doing multiple requests is the way to go.
     
After each single curl_easy_perform operation, libcurl will keep the connection alive and open. A subsequent request using the same easy handle to the same host might just be able to use the already open connection! This reduces network impact a lot.
     
Even if the connection is dropped, all connections involving SSL to the same host again, will benefit from libcurl&#39;s session ID cache that drastically reduces re-connection time.
     
....
     
libcurl caches DNS name resolving results, to make lookups of a previously looked up name a lot faster.
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><a href="https://curl.se/libcurl/c/curl_easy_reset.html">https://curl.se/libcurl/c/curl_easy_reset.html</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Re-initializes all options previously set on a specified CURL handle to the default values. This puts back the handle to the same state as it was in when it was just created with curl_easy_init.
     
It does not change the following information kept in the handle: live connections, the Session ID cache, the DNS cache, the cookies, the shares or the alt-svc cache.
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ol>
]]></description>
</item><item>
    <title>简易function</title>
    <link>http://coderyang.com/function/</link>
    <pubDate>Sat, 19 Sep 2020 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/function/</guid>
    <description><![CDATA[<p>本文主要讲一下怎么实现一个简易版本的function&lt;&gt;模板，从c++ templates第二版摘出，相应的技巧在timer中一些应用。</p>
<h2 id="出发点">出发点</h2>
<p>一个简单的例子，下面这个模板上述能够接受任意可调用的对象，lambda表达式、函数指针、仿函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">print_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">for_int_up</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">sum</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">});</span>
    
    <span class="n">for_int_up</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">print_int</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>像for_int_up这样的函数其实有两个问题：</p>
<ul>
<li>使用了模板将函数内部实现暴露。</li>
<li>造成代码膨胀，for_int_up函数还比较小，如果是一个很大的函数，代码膨胀会厉害的多。</li>
</ul>
<p>于是为了解决上面两个问题，可能尝试用下面这个方案，这也是我们代码中常见的解决方案。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>考虑到有可能有需要带上参数的需求，我们可能会写成这样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">for_int_up</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用函数指针替代模板，for_int_up只接受函数指针，无法接收lambda表达式、仿函数。</p>
<p>带参数的方案基本上能够满足需求，只是需要将函数与数据分离，代码相对难写，强转可能存在错误。</p>
<p>本质上带参数void*的方案是在抹除类型信息。</p>
<p>基于以上的需求标准库里的std::function&lt;&gt;就应运而生了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>std::function&lt;void(int)&gt;能够接收任意返回值是void，参数为int的函数指针、lambda表达式、仿函数。</p>
<p>上面两个问题一下就得到了解决，内部实现可以隐藏起来，同时模板范围缩小到std::function，即使for_int_up再大也不会出现代码膨胀很厉害的情况。</p>
<h2 id="广义的函数指针">广义的函数指针</h2>
<p>std::function实际上是一个广义上的C++函数指针，需要支持一下操作：</p>
<ul>
<li>在调用者只知道入参与返回值的情况，可以调用执行，不需要理解内部具体实现。</li>
<li>支持复制、移动。</li>
<li>可以被入参与返回值相同的函数指针、lambda表达式、仿函数、std::function初始化</li>
<li>支持null状态</li>
</ul>
<h2 id="实现">实现</h2>
<p>下面我们会实现一个简易版本的std::function，FUNCTION_PTR。FUNCTION_PTR会支持上面提到的所有特性。</p>
<p>functionptr.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 原始模板，因为实际上FUNCTION_PTR模板参数只有一个，所以需要这个原始模板:
</span><span class="c1">// 模板参数是一个函数类型
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FUNCTION_PTR</span><span class="p">;</span>

<span class="c1">// 偏特化，提取出变参Args为所有参数，R为返回值
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">private</span><span class="o">:</span>
    <span class="n">FUNCTOR_BRIDGE</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span> <span class="c1">// 核心类，参数类型信息，提供抽象的invoke。
</span><span class="c1"></span>
   <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 构造:
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span><span class="p">()</span> <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{}</span> <span class="c1">// 默认为空
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span><span class="p">(</span><span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">);</span>  <span class="c1">// see functionptr-cpinv.hpp
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span><span class="p">(</span><span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="p">)</span>
    <span class="p">{</span>
         <span class="c1">// 移动构造，所有权转移
</span><span class="c1"></span>        <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从任意函数对象构造:
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">&gt;</span>
    <span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span> <span class="p">);</span>  <span class="c1">// see functionptr-init.hpp
</span><span class="c1"></span>    
    <span class="c1">// 赋值操作符:
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FUNCTION_PTR</span> <span class="nf">tmp</span><span class="p">(</span> <span class="n">other</span> <span class="p">);</span>
        <span class="n">swap</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">tmp</span> <span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;&amp;</span><span class="n">other</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="n">bridge</span><span class="p">;</span>
        <span class="n">bridge</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从任意函数对象复制:
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">&gt;</span>
    <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FUNCTION_PTR</span> <span class="nf">tmp</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// 先构造一个临时对象
</span><span class="c1"></span>        <span class="n">swap</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">tmp</span> <span class="p">);</span> <span class="c1">// 调用swap
</span><span class="c1"></span>        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 析构:
</span><span class="c1"></span>    <span class="o">~</span><span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">bridge</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="n">fp1</span><span class="p">,</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="n">fp2</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span> <span class="n">fp1</span><span class="p">.</span><span class="n">bridge</span><span class="p">,</span> <span class="n">fp2</span><span class="p">.</span><span class="n">bridge</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// bool隐式转换，便于if判断
</span><span class="c1"></span>    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bridge</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// ()操作符重载:
</span><span class="c1"></span>    <span class="n">R</span> <span class="nf">operator</span><span class="p">(</span> <span class="p">)(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// see functionptr-cpinv.hpp
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到FUNCTION_PTR包含一个FUNCTOR_BRIDGE&lt; R, Args&hellip; &gt;成员，它负责存储具体的功能对象，并将具体类型擦除了。</p>
<p>functorbridge.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// FUNCTOR_BRIDGE只是一个抽象类，定义了几个基本接口
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FUNCTOR_BRIDGE</span> <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FUNCTOR_BRIDGE</span><span class="p">(</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="n">FUNCTOR_BRIDGE</span> <span class="o">*</span><span class="nf">clone</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 复制接口
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="n">R</span> <span class="nf">invoke</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 调用接口
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>bridge/functionptr-cpinv.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 基于FUNCTOR_BRIDGE的抽象接口，我们能够实现FUNCTION_PTR复制与调用
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="n">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;::</span><span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">bridge</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// 复制
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="n">R</span> <span class="n">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;::</span><span class="k">operator</span><span class="p">(</span> <span class="p">)(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">bridge</span><span class="o">-&gt;</span><span class="n">invoke</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span> <span class="c1">// 调用，完美转发
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>bridge/specificfunctorbridge.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 真正存储实际的可调用对象，继承自FUNCTOR_BRIDGE，利用多态实现类型的擦除
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">FUNCTOR</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SPECIFIC_FUNCTOR_BRIDGE</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FUNCTOR_BRIDGE</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">FUNCTOR</span> <span class="n">functor</span><span class="p">;</span>

   <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 构造
</span><span class="c1"></span>    <span class="c1">// 这里用了一个单独的FUNCTOR_FWD而不是FUNCTOR，因为有可能FUNCTOR_FWD类型与FUNCTOR
</span><span class="c1"></span>    <span class="c1">// 不一样，存在隐式转换
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">FUNCTOR_FWD</span> <span class="o">&gt;</span>
    <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span><span class="p">(</span> <span class="n">FUNCTOR_FWD</span> <span class="o">&amp;&amp;</span><span class="n">functor</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">functor</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">FUNCTOR_FWD</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">functor</span> <span class="p">)</span> <span class="p">)</span> 
    <span class="p">{</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span> <span class="o">*</span><span class="nf">clone</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span><span class="p">(</span> <span class="n">functor</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">R</span> <span class="nf">invoke</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">functor</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>functionptr-init.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 任意类型转换为FUNCTION_PTR
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">&gt;</span>
<span class="n">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;::</span><span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span> <span class="p">)</span> <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">FUNCTOR</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 类型退化
</span><span class="c1"></span>    <span class="k">using</span> <span class="n">BRIDGE</span> <span class="o">=</span> <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span><span class="o">&lt;</span> <span class="n">FUNCTOR</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="o">&gt;</span><span class="p">;</span>
    <span class="n">bridge</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BRIDGE</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// 生成brige
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>到此基本上FUNCTION_PTR已经实现完成了。</p>
<h2 id="其他">其他</h2>
<ul>
<li>最终版本欠缺一个小功能判断FUNCTION_PTR内部存储的可调用对象是否相等。</li>
<li>FUNCTION_PTR将所有可调用对象都转换为了一次虚函数的调用，降低了性能。</li>
<li>每创建一个FUNCTION_PTR都需要一次堆内存分配。</li>
<li>gcc4.8中的std::function对于小对象不会进行堆内存的分配。</li>
</ul>
]]></description>
</item><item>
    <title>vs2017与vs2005冲突解决</title>
    <link>http://coderyang.com/vs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</link>
    <pubDate>Sun, 16 Apr 2017 14:24:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/vs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</guid>
    <description><![CDATA[<p>先安装vs2005，后安装vs2017，vs2017无法运行
原因：vs2005注册了Microsoft.VisualStudio.Shell.Interop.8.0.dll，优先于vs2017需要的dll。导致运行错误。</p>
<p>解决方法：</p>
<p>复制
C:\Program_Files_(x86)\Microsoft_Visual Studio\2017\Enterprise\Common7\IDE\PublicAssemblies\Microsoft.VisualStudio.Shell.Interop.8.0.dll
到
C:\Windows\assembly\GAC\Microsoft.VisualStudio.Shell.Interop.8.0\8.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualStudio.Shell.Interop.8.0.dll</p>
]]></description>
</item></channel>
</rss>
