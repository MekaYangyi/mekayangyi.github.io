<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>技巧 - Category - 鉴心</title>
        <link>http://coderyang.com/categories/%E6%8A%80%E5%B7%A7/</link>
        <description>技巧 - Category - 鉴心</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 14 Nov 2020 16:04:59 &#43;0000</lastBuildDate><atom:link href="http://coderyang.com/categories/%E6%8A%80%E5%B7%A7/" rel="self" type="application/rss+xml" /><item>
    <title>高性能libcurl</title>
    <link>http://coderyang.com/libcurl/</link>
    <pubDate>Sat, 14 Nov 2020 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/libcurl/</guid>
    <description><![CDATA[<p>本文主要介绍一下curl接口的使用方法，以及获取高性能的一些实践。</p>
<h2 id="什么是libcurl用处">什么是libcurl？用处？</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more!
</code></pre></td></tr></table>
</div>
</div><p>官网摘的一段，意思大概是免费且容易使用的url传输库，支持下面一堆特性。</p>
<p>项目内用处：基于libcurl实现了一个单线程异步的httpc，用于msdk、防沉迷、信用分等需要接入外部http的服务。</p>
<h2 id="接口介绍">接口介绍</h2>
<p>curl一共有三种接口：</p>
<ul>
<li><a href="https://curl.haxx.se/libcurl/c/libcurl-easy.html" target="_blank" rel="noopener noreffer">Easy Interface</a></li>
<li><a href="https://curl.haxx.se/libcurl/c/libcurl-multi.html" target="_blank" rel="noopener noreffer">Multi Interface</a></li>
<li><a href="https://curl.haxx.se/libcurl/c/libcurl-share.html" target="_blank" rel="noopener noreffer">Share Interface</a></li>
</ul>
<h3 id="easy-interface">Easy Interface</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">The easy interface is a synchronous, efficient, quickly used and... yes, easy interface for file transfers. Numerous applications have been built using this.
</code></pre></td></tr></table>
</div>
</div><p>简单接口是一个同步接口，非常方便使用，接口以curl_easy_开头，下面一个简单的使用例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CURL</span> <span class="o">*</span><span class="n">curl</span> <span class="o">=</span> <span class="n">curl_easy_init</span><span class="p">();</span> <span class="c1">// 创建一个handle
</span><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">curl</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CURLcode</span> <span class="n">res</span><span class="p">;</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">curl</span><span class="p">,</span> <span class="n">CURLOPT_URL</span><span class="p">,</span> <span class="s">&#34;https://example.com&#34;</span><span class="p">);</span> <span class="c1">// 设置参数，参数有很多，header、cookie、接收回调函数、证书等等
</span><span class="c1"></span>  <span class="n">res</span> <span class="o">=</span> <span class="n">curl_easy_perform</span><span class="p">(</span><span class="n">curl</span><span class="p">);</span> <span class="c1">// 执行，注意这里是阻塞的
</span><span class="c1"></span>  <span class="n">curl_easy_cleanup</span><span class="p">(</span><span class="n">curl</span><span class="p">);</span> <span class="c1">// 清理
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="multi-interface">Multi Interface</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">The multi interface is the asynchronous brother in the family and it also offers multiple transfers using a single thread and more. 
</code></pre></td></tr></table>
</div>
</div><p>多重接口是异步接口，libcurl使用一个或者多个线程完成数据传输，通过多重接口可以再单线程下同时操作多个easy handle。</p>
<p>例子：https://gist.github.com/clemensg/4960504</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define MAX_WAIT_MSECS 30*1000 </span><span class="cm">/* Wait max. 30 seconds */</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">urls</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">&#34;http://www.microsoft.com&#34;</span><span class="p">,</span>
  <span class="s">&#34;http://www.yahoo.com&#34;</span><span class="p">,</span>
  <span class="s">&#34;http://www.wikipedia.org&#34;</span><span class="p">,</span>
  <span class="s">&#34;http://slashdot.org&#34;</span>
<span class="p">};</span>
<span class="cp">#define CNT 4
</span><span class="cp"></span>
<span class="k">static</span> <span class="n">size_t</span> <span class="nf">cb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">l</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* take care of the data here, ignored in this example */</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="n">CURLM</span> <span class="o">*</span><span class="n">cm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">CURL</span> <span class="o">*</span><span class="n">eh</span> <span class="o">=</span> <span class="n">curl_easy_init</span><span class="p">();</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_WRITEFUNCTION</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_HEADER</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_URL</span><span class="p">,</span> <span class="n">urls</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_PRIVATE</span><span class="p">,</span> <span class="n">urls</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_VERBOSE</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
  <span class="n">curl_multi_add_handle</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">eh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CURLM</span> <span class="o">*</span><span class="n">cm</span> <span class="o">=</span> <span class="n">curl_multi_init</span><span class="p">();</span> <span class="c1">// 创建一个multi handle
</span><span class="c1"></span>
    <span class="c1">// 创建一堆easy handle加入到multi handle里
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">init</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 执行，等待所有都执行完
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">still_running</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">curl_multi_perform</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">still_running</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
      	<span class="c1">// 等一段时间，MAX_WAIT_MSECS为最长时长
</span><span class="c1"></span>        <span class="c1">// 有事件或者超时了返回
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">curl_multi_wait</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_WAIT_MSECS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numfds</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">CURLM_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;error: curl_multi_wait() returned %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">curl_multi_perform</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">still_running</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">still_running</span><span class="p">);</span>

    <span class="c1">// 读取数据
</span><span class="c1"></span>    <span class="n">CURLMsg</span> <span class="o">*</span><span class="n">msg</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">szUrl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">msgs_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">http_status_code</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">msg</span> <span class="o">=</span> <span class="n">curl_multi_info_read</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msgs_left</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">==</span> <span class="n">CURLMSG_DONE</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">CURL</span> <span class="o">*</span><span class="n">eh</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">easy_handle</span><span class="p">;</span>
            <span class="n">CURLcode</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">result</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">return_code</span><span class="o">!=</span><span class="n">CURLE_OK</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;CURL error code: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">result</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Get HTTP status code
</span><span class="c1"></span>            <span class="n">http_status_code</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="n">szUrl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">curl_easy_getinfo</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLINFO_RESPONSE_CODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">http_status_code</span><span class="p">);</span>
            <span class="n">curl_easy_getinfo</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLINFO_PRIVATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">szUrl</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">http_status_code</span><span class="o">==</span><span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&#34;200 OK for %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">szUrl</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;GET of %s returned http status code %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">szUrl</span><span class="p">,</span> <span class="n">http_status_code</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">curl_multi_remove_handle</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">eh</span><span class="p">);</span>
            <span class="n">curl_easy_cleanup</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;error: after curl_multi_info_read(), CURLMsg=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 关闭
</span><span class="c1"></span>    <span class="n">curl_multi_cleanup</span><span class="p">(</span><span class="n">cm</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="share-interface">Share Interface</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">The share interface was added to enable sharing of data between curl &#34;handles&#34;.
</code></pre></td></tr></table>
</div>
</div><p>用于再多个easy handle共享一些数据，比如dns cache、tls session。</p>
<h3 id="其他">其他</h3>
<p>curl_global_init：进程启动时初始化curl</p>
<p>curl_global_cleanup：进程关闭时清理curl</p>
<p>使用异步DNS，防止同步解析DNS卡住主循环</p>
<h2 id="实践">实践</h2>
<ol>
<li>
<p>最初实现了一个使用Multi Interface的HTTPC。</p>
<ul>
<li>
<p>httpc/unittest/httpc.cpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">TEST_F</span><span class="p">(</span><span class="n">HTTPC_TEST</span><span class="p">,</span> <span class="n">HTTP_GET</span><span class="p">)</span>                                                 
<span class="p">{</span>
    <span class="n">HTTPC_CFG</span> <span class="n">cfg</span><span class="p">;</span>
    <span class="n">REQUEST_DRIVER</span> <span class="nf">driver</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">HTTPC</span> <span class="nf">c</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
         
    <span class="k">auto</span> <span class="n">cb</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">RESPONSE</span> <span class="o">&amp;</span><span class="n">rsp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;result:%d code:%ld </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rsp</span><span class="p">.</span><span class="n">_result</span><span class="p">,</span> <span class="n">rsp</span><span class="p">.</span><span class="n">_http_status_code</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;body:%s&#34;</span><span class="p">,</span> <span class="n">rsp</span><span class="p">.</span><span class="n">_body</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="p">};</span>
     
    <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#34;http://www.baidu.com&#34;</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
    <span class="p">}</span>
     
    <span class="kt">bool</span> <span class="n">idle</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="p">.</span><span class="n">_ctx_map</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">driver</span><span class="p">.</span><span class="n">loop</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>在压测过程中发现性能不足，DNS解析卡住主循环。根据https://moz.com/devblog/high-performance-libcurl-tips，增加了c-ares库，使得libcurl支持异步DNS，最终性能到了3000TPS。</p>
</li>
<li>
<p>尝试使用Share Interface共享DNS，效果在接入异步DNS后不明显。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 初始化共享
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">_dns_lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span>
<span class="n">CURLSH</span><span class="o">*</span> <span class="n">_share_handler</span> <span class="o">=</span> <span class="n">curl_share_init</span><span class="p">();</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_USERDATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_dns_lock</span><span class="p">);</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_LOCKFUNC</span><span class="p">,</span> <span class="n">_lock</span><span class="p">);</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_UNLOCKFUNC</span><span class="p">,</span> <span class="n">_unlock</span><span class="p">);</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_SHARE</span><span class="p">,</span> <span class="n">CURL_LOCK_DATA_DNS</span><span class="p">);</span>
   
<span class="c1">// 设置共享
</span><span class="c1"></span><span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_requst</span><span class="o">-&gt;</span><span class="n">_curl_handle</span><span class="p">,</span> <span class="n">CURLOPT_SHARE</span><span class="p">,</span> <span class="n">_share_handler</span><span class="p">);</span>
<span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_requst</span><span class="o">-&gt;</span><span class="n">_curl_handle</span><span class="p">,</span> <span class="n">CURLOPT_DNS_CACHE_TIMEOUT</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span><span class="p">);</span><span class="c1">//5min
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>请求处理完毕后，不适用curl_easy_cleanup，而是采用连接池的方式通过curl_easy_reset重用连接。</p>
<ul>
<li>
<p><a href="https://curl.se/libcurl/c/libcurl-tutorial.html#Persistence">https://curl.se/libcurl/c/libcurl-tutorial.html#Persistence</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Re-cycling the same easy handle several times when doing multiple requests is the way to go.
     
After each single curl_easy_perform operation, libcurl will keep the connection alive and open. A subsequent request using the same easy handle to the same host might just be able to use the already open connection! This reduces network impact a lot.
     
Even if the connection is dropped, all connections involving SSL to the same host again, will benefit from libcurl&#39;s session ID cache that drastically reduces re-connection time.
     
....
     
libcurl caches DNS name resolving results, to make lookups of a previously looked up name a lot faster.
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><a href="https://curl.se/libcurl/c/curl_easy_reset.html">https://curl.se/libcurl/c/curl_easy_reset.html</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Re-initializes all options previously set on a specified CURL handle to the default values. This puts back the handle to the same state as it was in when it was just created with curl_easy_init.
     
It does not change the following information kept in the handle: live connections, the Session ID cache, the DNS cache, the cookies, the shares or the alt-svc cache.
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ol>
]]></description>
</item><item>
    <title>简易function</title>
    <link>http://coderyang.com/function/</link>
    <pubDate>Sat, 19 Sep 2020 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/function/</guid>
    <description><![CDATA[<p>本文主要讲一下怎么实现一个简易版本的function&lt;&gt;模板，从c++ templates第二版摘出，相应的技巧在timer中一些应用。</p>
<h2 id="出发点">出发点</h2>
<p>一个简单的例子，下面这个模板上述能够接受任意可调用的对象，lambda表达式、函数指针、仿函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">print_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">for_int_up</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">sum</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">});</span>
    
    <span class="n">for_int_up</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">print_int</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>像for_int_up这样的函数其实有两个问题：</p>
<ul>
<li>使用了模板将函数内部实现暴露。</li>
<li>造成代码膨胀，for_int_up函数还比较小，如果是一个很大的函数，代码膨胀会厉害的多。</li>
</ul>
<p>于是为了解决上面两个问题，可能尝试用下面这个方案，这也是我们代码中常见的解决方案。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>考虑到有可能有需要带上参数的需求，我们可能会写成这样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">for_int_up</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用函数指针替代模板，for_int_up只接受函数指针，无法接收lambda表达式、仿函数。</p>
<p>带参数的方案基本上能够满足需求，只是需要将函数与数据分离，代码相对难写，强转可能存在错误。</p>
<p>本质上带参数void*的方案是在抹除类型信息。</p>
<p>基于以上的需求标准库里的std::function&lt;&gt;就应运而生了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>std::function&lt;void(int)&gt;能够接收任意返回值是void，参数为int的函数指针、lambda表达式、仿函数。</p>
<p>上面两个问题一下就得到了解决，内部实现可以隐藏起来，同时模板范围缩小到std::function，即使for_int_up再大也不会出现代码膨胀很厉害的情况。</p>
<h2 id="广义的函数指针">广义的函数指针</h2>
<p>std::function实际上是一个广义上的C++函数指针，需要支持一下操作：</p>
<ul>
<li>在调用者只知道入参与返回值的情况，可以调用执行，不需要理解内部具体实现。</li>
<li>支持复制、移动。</li>
<li>可以被入参与返回值相同的函数指针、lambda表达式、仿函数、std::function初始化</li>
<li>支持null状态</li>
</ul>
<h2 id="实现">实现</h2>
<p>下面我们会实现一个简易版本的std::function，FUNCTION_PTR。FUNCTION_PTR会支持上面提到的所有特性。</p>
<p>functionptr.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 原始模板，因为实际上FUNCTION_PTR模板参数只有一个，所以需要这个原始模板:
</span><span class="c1">// 模板参数是一个函数类型
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FUNCTION_PTR</span><span class="p">;</span>

<span class="c1">// 偏特化，提取出变参Args为所有参数，R为返回值
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">private</span><span class="o">:</span>
    <span class="n">FUNCTOR_BRIDGE</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span> <span class="c1">// 核心类，参数类型信息，提供抽象的invoke。
</span><span class="c1"></span>
   <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 构造:
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span><span class="p">()</span> <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{}</span> <span class="c1">// 默认为空
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span><span class="p">(</span><span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">);</span>  <span class="c1">// see functionptr-cpinv.hpp
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span><span class="p">(</span><span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="p">)</span>
    <span class="p">{</span>
         <span class="c1">// 移动构造，所有权转移
</span><span class="c1"></span>        <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从任意函数对象构造:
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">&gt;</span>
    <span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span> <span class="p">);</span>  <span class="c1">// see functionptr-init.hpp
</span><span class="c1"></span>    
    <span class="c1">// 赋值操作符:
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FUNCTION_PTR</span> <span class="nf">tmp</span><span class="p">(</span> <span class="n">other</span> <span class="p">);</span>
        <span class="n">swap</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">tmp</span> <span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;&amp;</span><span class="n">other</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="n">bridge</span><span class="p">;</span>
        <span class="n">bridge</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从任意函数对象复制:
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">&gt;</span>
    <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FUNCTION_PTR</span> <span class="nf">tmp</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// 先构造一个临时对象
</span><span class="c1"></span>        <span class="n">swap</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">tmp</span> <span class="p">);</span> <span class="c1">// 调用swap
</span><span class="c1"></span>        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 析构:
</span><span class="c1"></span>    <span class="o">~</span><span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">bridge</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="n">fp1</span><span class="p">,</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="n">fp2</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span> <span class="n">fp1</span><span class="p">.</span><span class="n">bridge</span><span class="p">,</span> <span class="n">fp2</span><span class="p">.</span><span class="n">bridge</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// bool隐式转换，便于if判断
</span><span class="c1"></span>    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bridge</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// ()操作符重载:
</span><span class="c1"></span>    <span class="n">R</span> <span class="nf">operator</span><span class="p">(</span> <span class="p">)(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// see functionptr-cpinv.hpp
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到FUNCTION_PTR包含一个FUNCTOR_BRIDGE&lt; R, Args&hellip; &gt;成员，它负责存储具体的功能对象，并将具体类型擦除了。</p>
<p>functorbridge.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// FUNCTOR_BRIDGE只是一个抽象类，定义了几个基本接口
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FUNCTOR_BRIDGE</span> <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FUNCTOR_BRIDGE</span><span class="p">(</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="n">FUNCTOR_BRIDGE</span> <span class="o">*</span><span class="nf">clone</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 复制接口
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="n">R</span> <span class="nf">invoke</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 调用接口
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>bridge/functionptr-cpinv.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 基于FUNCTOR_BRIDGE的抽象接口，我们能够实现FUNCTION_PTR复制与调用
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="n">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;::</span><span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">bridge</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// 复制
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="n">R</span> <span class="n">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;::</span><span class="k">operator</span><span class="p">(</span> <span class="p">)(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">bridge</span><span class="o">-&gt;</span><span class="n">invoke</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span> <span class="c1">// 调用，完美转发
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>bridge/specificfunctorbridge.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 真正存储实际的可调用对象，继承自FUNCTOR_BRIDGE，利用多态实现类型的擦除
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">FUNCTOR</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SPECIFIC_FUNCTOR_BRIDGE</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FUNCTOR_BRIDGE</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">FUNCTOR</span> <span class="n">functor</span><span class="p">;</span>

   <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 构造
</span><span class="c1"></span>    <span class="c1">// 这里用了一个单独的FUNCTOR_FWD而不是FUNCTOR，因为有可能FUNCTOR_FWD类型与FUNCTOR
</span><span class="c1"></span>    <span class="c1">// 不一样，存在隐式转换
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">FUNCTOR_FWD</span> <span class="o">&gt;</span>
    <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span><span class="p">(</span> <span class="n">FUNCTOR_FWD</span> <span class="o">&amp;&amp;</span><span class="n">functor</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">functor</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">FUNCTOR_FWD</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">functor</span> <span class="p">)</span> <span class="p">)</span> 
    <span class="p">{</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span> <span class="o">*</span><span class="nf">clone</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span><span class="p">(</span> <span class="n">functor</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">R</span> <span class="nf">invoke</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">functor</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>functionptr-init.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 任意类型转换为FUNCTION_PTR
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">&gt;</span>
<span class="n">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;::</span><span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span> <span class="p">)</span> <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">FUNCTOR</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 类型退化
</span><span class="c1"></span>    <span class="k">using</span> <span class="n">BRIDGE</span> <span class="o">=</span> <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span><span class="o">&lt;</span> <span class="n">FUNCTOR</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="o">&gt;</span><span class="p">;</span>
    <span class="n">bridge</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BRIDGE</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// 生成brige
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>到此基本上FUNCTION_PTR已经实现完成了。</p>
<h2 id="其他">其他</h2>
<ul>
<li>最终版本欠缺一个小功能判断FUNCTION_PTR内部存储的可调用对象是否相等。</li>
<li>FUNCTION_PTR将所有可调用对象都转换为了一次虚函数的调用，降低了性能。</li>
<li>每创建一个FUNCTION_PTR都需要一次堆内存分配。</li>
<li>gcc4.8中的std::function对于小对象不会进行堆内存的分配。</li>
</ul>
]]></description>
</item><item>
    <title>vs2017与vs2005冲突解决</title>
    <link>http://coderyang.com/vs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</link>
    <pubDate>Sun, 16 Apr 2017 14:24:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/vs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</guid>
    <description><![CDATA[<p>先安装vs2005，后安装vs2017，vs2017无法运行
原因：vs2005注册了Microsoft.VisualStudio.Shell.Interop.8.0.dll，优先于vs2017需要的dll。导致运行错误。</p>
<p>解决方法：</p>
<p>复制
C:\Program_Files_(x86)\Microsoft_Visual Studio\2017\Enterprise\Common7\IDE\PublicAssemblies\Microsoft.VisualStudio.Shell.Interop.8.0.dll
到
C:\Windows\assembly\GAC\Microsoft.VisualStudio.Shell.Interop.8.0\8.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualStudio.Shell.Interop.8.0.dll</p>
]]></description>
</item><item>
    <title>gitlab workflow</title>
    <link>http://coderyang.com/gitlab-workflow/</link>
    <pubDate>Sun, 29 Jan 2017 21:40:40 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/gitlab-workflow/</guid>
    <description><![CDATA[<p>建立一个长期分支，就是master，master分支上的版本都是能够编译运行的版本。
整个工作流程如下。
第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。
第二步：新分支开发完成后，或者需要讨论的时候，先从master合并到分支，解决冲突，然后向master发起一个pull request（简称PR）。
第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。
第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</p>
<h1 id="建立测试项目">建立测试项目</h1>
<p>新建一个项目用于测试工作流。
演示项目地址：http://10.10.10.98/MekaYangyi/workflow
</p>
<h1 id="设置分支保护">设置分支保护</h1>
<p>新建项目默认master用户才能够push和merge。
其余用户只能新建分支，在分支测试完毕后，再发起Merge Requests。发起后，由master进行审核后合并。
</p>
<h1 id="设置开发成员">设置开发成员</h1>
<p>项目创建者在项目页面选择Member。
</p>
<p>设置开发人员分为两种，一种是直接设置用户，一种是设置一Group都为指定权限。
权限分为四类：</p>
<blockquote>
<p>Guest
Reporter
Developer
Master</p>
</blockquote>
<p>一般开发人员指定为Developer。
具体权限在http://10.10.10.98/help/user/permissions.md查看。
设置用户权限

设置整个Group的权限
</p>
<h1 id="建立本地分支">建立本地分支</h1>
<p>在项目文件夹右键，选择TortoiseGit→Create Branch。

填写信息
</p>
<h1 id="切换分支">切换分支</h1>
<p>在项目文件夹右键，选择TortoiseGit→Switch/Checkout。

选择OK。
</p>
<h1 id="commit">Commit</h1>
<p>分出分支后，可以在本地进行Commit，知道一个功能开发完毕后，再上传到服务器。
修改本地的文件，Commit。

填写上传备注，Commit。</p>
<h1 id="将master向test_workflow合并">将Master向Test_WorkFlow合并</h1>
<p>先从服务器pull最新版本，然后将master向Test_WorkFlow合并，防止master在分支分出之后被修改导致的冲突。
从服务器pull最新版本。

将master向Test_WorkFlow合并。

合并解决冲突。
</p>
<h1 id="push">push</h1>
<p>上传成功后选择push。
</p>
<p>确认。

成功。
</p>
<h1 id="发起merge-request">发起Merge Request</h1>
<p>在项目页面找到分支，选择Merge Request

填写相关信息，Submit merge request
</p>
<h1 id="检视代码并讨论">检视代码并讨论</h1>
<p>选择Merge Request。
单击测试分支合并功能这一个Merge Request

弹出页面。

检视代码</p>
<h2 id="commit查看修改记录">Commit，查看修改记录。</h2>
<p>图中红色区域单击可以Diff与查看源文件。

单击任意版本提交记录，增加检视意见，在diff时，任意处可以添加讨论。或者在页面底部对整个修改进行评价。
</p>

<h2 id="changes查看版本区别">Changes，查看版本区别。</h2>

## Discusion，填写建议
填写建议后，选择Comment可以互相讨论。
或者选择Close merge request关闭请求。

## Accept merge request或者Close merge request

## 合并完成
选择Accept Merge Request,同时选择合并时将分支删除。

合并结果。

# 本地pull
在本地项目进行pull,同步服务器版本。

本地同步结果。

# 删除本地分支
由于远程分支与本地分支没有关系，那么当远程正式Merge之后，需要删除本地分支，防止以后分支一直增加，不减少。
在项目文件夹右键，选择TortoiseGit→Switch/Checkout，先把分支切换到本地master。

切换完成后，再次进入该界面选择....

删除分支

<h1 id="issue">Issue</h1>
<p>Issue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。</p>
<h2 id="新建issue">新建Issue</h2>
<p>选择New Issue

填写相关信息。
功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如&quot;1-测试Issue&quot;。
</p>
<p>新建完成,每一个Issue都有一个编号，本Issue的编号为#1。

在分支开发完成后，在commit message里面，可以写上&quot;fixes #14&quot;或者&quot;closes #67&quot;。

Github规定，只要commit message里面有下面这些动词 + 编号，就会关闭对应的issue。</p>
<blockquote>
<p>close
closes
closed
fix
fixes
fixed
resolve
resolves
resolved</p>
</blockquote>
<p>这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是username/repository#issue_number。
Pull Request被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。</p>
<h2 id="查看结果">查看结果</h2>

]]></description>
</item><item>
    <title>第一次使用gitlab</title>
    <link>http://coderyang.com/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/</link>
    <pubDate>Sat, 28 Jan 2017 09:19:43 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/</guid>
    <description><![CDATA[<h1 id="安装git">安装git</h1>
<p>版本差别不大，目前使用的版本git2.11.0.3。
一路下一步,不修改安装位置，直接使用默认设置。</p>
<h1 id="安装tortoisegit">安装TortoiseGit</h1>
<p>一路下一步，不修改安装位置，直接使用默认设置。</p>
<h1 id="登录账户">登录账户</h1>
<h2 id="管理员创建账户">管理员创建账户</h2>
<p>Admin→New User。新建账户、并设置密码。同时设置该用户所属Group。</p>
<blockquote>
<p>name：上传显示的名字，可以经常更改，使用中文名好。</p>
</blockquote>
<blockquote>
<p>username：登陆的用户名，不可修改，用于账户登陆。</p>
</blockquote>
<blockquote>
<p>email：账户email，内网联系email。</p>
</blockquote>
<blockquote>
<p>password：密码，牢记，root用户可修改。</p>
</blockquote>
<h2 id="登录">登录</h2>
<p>登陆内网gitlab，目前网址：10.10.10.98。
</p>
<h2 id="修改密码">修改密码</h2>
<p>登录后会要求修改密码，自己输入即可。
</p>
<h1 id="设置tortoisegit">设置TortoiseGit</h1>
<p>将注册的用户填入TortoiseGit中,设置为全局账号。
</p>
<h1 id="添加ssh">添加ssh</h1>
<p>如果不添加shh，每次修改都会要求输入账号密码，比较麻烦。添加后与设备绑定，修改不再需要填写账号密码。如果不再使用一个设备，请删除ssh。</p>
<h2 id="生成ssh">生成ssh</h2>
<p>任意空白处，选择git bash。

窗口中输入，一路按回车。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ssh-keygen -t rsa -C &#34;你注册的email地址&#34;
</code></pre></td></tr></table>
</div>
</div><p>生成后的公钥会存放在 C:/Users/You_User_Name/.ssh/id_rsa.pub。
用记事本打开，复制。
</p>
<h2 id="将ssh加入gitlab">将ssh加入gitlab</h2>
<p>浏览器转到http://10.10.10.98/profile/keys。
将复制的Key粘贴，Add key。
</p>
<h1 id="新建一个项目">新建一个项目</h1>
<h2 id="新建一个私有项目">新建一个私有项目</h2>
<p>新建一个私有项目进行实验，gitlab是否能够正常上传。
选择new project。
</p>
<h2 id="填写基本信息">填写基本信息</h2>
<blockquote>
<p>Project name：项目名称。
Project description：项目描述。
Visibility Level：项目级别，内网使用只选择public与private。private除了项目成员不可见，public在内网均可见。</p>
</blockquote>
<p>选择Create project创建项目。
</p>
<h1 id="clone项目">Clone项目</h1>
<p>项目创建完成，复制项目地址。
复制浏览器的项目地址：http://10.10.10.98/test/test_project。

选择计算机一个文件夹，右键，选择git clone。

clone之前复制地址项目，确认，输入用户名与密码，clone成功，会新建一个文件夹。
</p>
<h1 id="第一次push">第一次push</h1>
<p>在该文件夹中建立一个README.md文件。
</p>
<h2 id="add">add</h2>
<p>右键add，确认，ok。
</p>
<h2 id="commit">commit</h2>
<p>commit将修改更新到本地。
在项目文件夹空白处右键，选择git commit。

填写上传理由，commit。
</p>
<h2 id="push">push</h2>
<p>选择push，push能够将修改push到服务器。

确认。

成功界面。
</p>
<h1 id="查看结果">查看结果</h1>
<p>成功在网页端看到修改记录(之前误上传为.md.txt文件，修改为.md文件网页端会显示文字)。
</p>]]></description>
</item><item>
    <title>windows下Pyqt &#43; guiqwt环境的搭建</title>
    <link>http://coderyang.com/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</link>
    <pubDate>Wed, 19 Oct 2016 23:47:25 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</guid>
    <description><![CDATA[<h1 id="事情的起因">事情的起因</h1>
<p>这几天为了搭一个PyQt的生产环境遇到了好一些坑。
本身搭建PyQt的目的是为了进行试验，使用PyQt开发曾经开发过的项目的难度。
原项目是使用MFC开发，利用自己开发的折线绘制控件，进行高速的工控数据采集后，显示到界面上。难点主要在，高速采集之后，绘图的效率问题。
最终通过自己开发了一套平移显示绘图控件，在新增数据的时候，每一次只绘制一部分数据，然后通过平移之前的图像与之后的链接在一起，这样达到比较高的绘图效率，才解决了问题。但是MFC界面开发复杂，在MFC界面上花费过多的时间。同时本身绘图控件的开发，可能可以利用现有开源控件进行开发来避免重复造轮子。
于是利用PyQt+guiqwt绘图库来开发的方案构建起来。guiqwt本身是QT下常用的绘图控件，效率足够高，经过一些优化是能够使用的。相对Python经常使用的matplotlib来说不够漂亮，但是进行实时数据的平移绘图，效率高出很多。PyQt是模仿QT写的图形库，可以利用QTCreate进行快速的界面构建，而Python相对C++来说，需要处理的坑更少，出现各类崩溃的异常的情况会更少一些。
本文主要讲的是PyQt+guiqwt在windows上的搭建。
目的是在之后能够通过本文进行快速的开发环境的搭建。</p>
<h1 id="开始搭建">开始搭建</h1>
<h2 id="安装python">安装Python</h2>
<p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener noreffer">Python官网</a><br>
通过Python官网下载相应版本的Python,我这里下载的是：python-3.5.2-amd64。
64位版本，记住版本号，用于之后的库的选择。</p>
<h2 id="安装pyqt">安装PyQt</h2>
<p>PyQt有完整的安装包，过程中会自动安装PyQt+Qt等完整的依赖库。
<a href="https://sourceforge.net/projects/pyqt/?source=directory" target="_blank" rel="noopener noreffer">PyQt下载站点</a><br>
浏览所有文件找到对应的PyQt完整安装包。
我下的是下面网址中的64位版本。
PyQt5-5.6-gpl-Py3.5-Qt5.6.0-x64-2
<a href="https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.6/" target="_blank" rel="noopener noreffer">PyQt完整安装包下载</a><br>
安装一路下一步完成。</p>
<h2 id="安装numpy">安装NumPy</h2>
<p>为了能够使用guiqwt必须安装依赖的库。
首先安装numpy，注意的是需要安装+mk1的numpy库，否则scipy无法正常安装后使用。
<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener noreffer">下载地址</a><br>
搜索Numpy找到相应的位置。
我选择下载的是，与Python版本对应：numpy-1.11.2+mkl-cp35-cp35m-win_amd64.whl
使用pip3.5安装</p>
<h2 id="安装scipy">安装scipy</h2>
<p>同上，在上面的网站找到scipy。
版本我选择的是：scipy-0.18.1-cp35-cp35m-win_amd64
使用pip3.5在numpy之后安装</p>
<h2 id="安装guiqwt">安装guiqwt</h2>
<p>安装guiqwt
上面网站搜索guiqwt
选择guiqwt-3.0.3-cp35-cp35m-win_amd64。
在sicpy之后使用pip3.5安装</p>
<h2 id="安装eric6">安装eric6</h2>
<p><a href="https://sourceforge.net/projects/eric-ide/" target="_blank" rel="noopener noreffer">下载地址</a><br>
我选择的是：eric6-6.1.10和eric6-i18n-zh_CN-6.1.10
解压，放到python的安装目录下：python35/eric6
运行python35/eric6、install.py进行安装。
运行Python35\Scripts\eric6.bat 就打开了eric6</p>
<p>至此开发环境搭建完成。</p>]]></description>
</item></channel>
</rss>
