<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>鉴心</title>
        <link>http://coderyang.com/</link>
        <description>About LoveIt Theme</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 18 Jan 2021 16:04:59 &#43;0000</lastBuildDate>
            <atom:link href="http://coderyang.com/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>一致性与共识算法</title>
    <link>http://coderyang.com/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/</link>
    <pubDate>Mon, 18 Jan 2021 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/</guid>
    <description><![CDATA[<p>本文从《数据密集型引用系统设计》、Paxos lecture (Raft user study)（https://www.youtube.com/watch?v=JEpsBg0AO6o） 各截取了部分。</p>
<h2 id="挑战">挑战</h2>
<h3 id="故障">故障</h3>

<p>数据：</p>
<ul>
<li>磁盘:  4% 年损坏率</li>
<li>服务器宕机时间:  0.1% 或更长</li>
<li>IDC间丢包率:  5% ~ 30%</li>
</ul>
<p>下面是几种分布式系统下典型的问题：</p>
<ol>
<li>当通过网络发送数据包时，数据包可能会丢失或者延迟。同样，回复也可能会丢失或延迟。所以如果没有收到回复，并不能确定消息是否发送成功。</li>
<li>节点的时钟可能会与其他节点存在明显的不同步，时钟还可能会突然向前跳跃或者倒退，依靠精准的时钟存在一些风险，没有特别简单的方法来精确测量时钟的偏差范围。</li>
<li>进程可能在执行过程中的任意时候遭遇长度未知的暂停（一个重要的原因是垃圾回收），结果它被其他节点宣告失效，尽管后来又恢复执行，却对中间的暂停毫无所知。</li>
</ol>
<p>部分失效可能是分布式系统的关键特征。只要软件试图跨节点做任何失效，就有可能出现失败，或者随机变慢，或者根本无应答（最终超时）。对于分布式环境，我们目标是建立容忍部分失效的软件系统，这样即使某些部件发生失效，系统整体还可以继续运行。</p>
<h3 id="线性化与cap理论">线性化与CAP理论</h3>
<p>线性化：表现得好像只有一个数据副本，且其上的所有操作都是原子的。</p>
<p>为什么要线性化？</p>
<p>非线性化系统的问题：</p>

<p>上面违背线性化只产生了一个比较小的问题，仅仅是展示页面不一致。但是如果核心业务违背线性化，可能导致严重问题。常见的就是集群选主，可能会出现两个主，导致脑裂。</p>
<p>常见复制算法，对线性化的支持：</p>
<ul>
<li>主从复制（部分支持）
<ul>
<li>只有主写入读取的话，其他都是备份的情况下，是线性化的。但是不能做高高可用。</li>
<li>异步复制、主脑裂、从读等情况，不可线性化。</li>
</ul>
</li>
<li>多主复制（不可线性化）
<ul>
<li>多副本冲突</li>
</ul>
</li>
<li>无主复制（可能不可线性化）
<ul>
<li>能够实现高可靠、高可用性、数据完整有保证</li>
<li>会出现脏读、更新丢失等情况</li>
<li>具体看ddia吧，不展开了，用的比较少</li>
</ul>
</li>
<li>共识算法（可线性化）
<ul>
<li>具体之后讨论。</li>
</ul>
</li>
</ul>
<p>线性化的代价以及CAP理论：</p>


<h3 id="flp">FLP</h3>
<p>FLP 不可能定理是分布式系统领域最重要的定理之一，它给出了一个非常重要的结论：<strong>在网络可靠并且存在节点失效的异步模型系统中，不存在一个可以解决一致性问题的确定性算法</strong>。</p>
<blockquote>
<p>In this paper, we show the surprising result that no completely asynchronous consensus protocol can tolerate even a single unannounced process death. We do not consider Byzantine failures, and we assume that the message system is reliable it delivers all messages correctly and exactly once.</p>
</blockquote>
<p>这个定理其实也就是告诉我们不要浪费时间去为异步分布式系统设计在任意场景上都能够实现共识的算法，异步系统完全没有办法保证能在有限时间内达成一致。</p>
<p>注意这里的异步系统，参照DDIA第八章理论系统模型与现实的解释：在异步系统中，一个算法不会对时机做任何的假设，甚至里面根本没有时钟。</p>
<p>如果算法可以使用超时或者其他方式来检测崩溃的节点（即使怀疑可能是误报），那么可以实现稳定的共识方案。另外即使算法使用了随机数来检测节点故障也可以绕过FLP结论。</p>
<h3 id="拜占庭将军问题">拜占庭将军问题</h3>
<p>拜占庭将军问题是Lamport 在 <a href="https://web.archive.org/web/20170205142845/http://lamport.azurewebsites.net/pubs/byz.pdf" target="_blank" rel="noopener noreffer">The Byzantine Generals Problem</a> 论文中提出的分布式领域的容错问题，它是分布式领域中最复杂、最严格的容错模型。</p>
<p>在该模型下，系统不会对集群中的节点做任何的限制，它们可以向其他节点发送随机数据、错误数据，也可以选择不响应其他节点的请求，这些无法预测的行为使得容错这一问题变得更加复杂。</p>
<p>这个问题在特定场景是合理的。例如：</p>
<ul>
<li>在航天领域，计算机内存或CPU寄存器的数据可能会被辐射而发生故障，导致以不可预知的方式响应其他节点。这种情况西如果将系统下线，代价将异常昂贵，飞行控制系统必须做到容忍拜占庭故障。</li>
<li>在有多个参与者的系统中，某些参与者可能会作弊或者欺骗他人。这时节点不能完全相信另一个节点所发送的消息，它可能是恶意的。例如，像比特币和其他区块链一样的点对点网络就是让互不新人的当时方就某项交易达成一致，且不依赖于集中的机制。</li>
</ul>
<p>不过在我们一般日常的系统里，不太考虑拜占庭将军问题。不过，系统中的bug可以认为是拜占庭式故障，但是如果只有一种实现，被部署在所有位置。那么出问题了，显然会全军覆没。如果要解决这个问题，只有写好几种不同的实现，然后希望只有部分节点中有bug。这显然是不合算的。</p>
<h2 id="共识算法">共识算法</h2>
<p>我们这里的共识算法主要目的是为了在达到线性化的效果的情况下，能做到足够的容错。允许多个节点中，部分在出现上述故障部分描述的情况下，依旧能够对外提供服务。</p>
<p>同时假定系统中不存在拜占庭式错误，即使真的存在，研究表明只要发生拜占庭故障的节点数小于三分之一，也可以达成共识。</p>
<h3 id="paxos">paxos</h3>
<ul>
<li>一个可靠的存储系统：基于多数派读写</li>
<li><strong>每个paxos实例用来存储一个值</strong></li>
<li>用两轮RPC来确定一个值</li>
<li>一个值&rsquo;确定&rsquo;后不能被修改</li>
<li>&lsquo;确定&rsquo;指被多数派接收写入</li>
<li>强一致性</li>
</ul>
<h4 id="条件">条件</h4>
<p>存储必须可靠：没有数据丢失和错误</p>
<p>容忍：</p>
<ul>
<li>消息丢失（节点不可达）</li>
<li>消息乱序</li>
</ul>
<h4 id="算法流程">算法流程</h4>

<p>首先，每个Acceptor需要持久化三个变量（minProposal、acceptedProposal、acceptValue）。最开始minProposal = acceptedProposal = 0，acceptValue = null。算法有两个阶段：P1（Prepare阶段）、P2（Accept阶段）</p>
<p>P1（Prepare阶段）</p>
<ul>
<li>
<p>P1a：</p>
<ul>
<li>选择一个新的提议序号n，这个序号要全局唯一且递增，一般来说是利用时间+服务器ip</li>
<li>提议者（proposer）向所有接收者（acceptor）发起RPC（Prepare(n)），消息中包含提议序号n。</li>
</ul>
</li>
<li>
<p>P1b：接收者（acceptor）接收到Prepare(n)，会做如下决策：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">if n &gt; minProposal 
  回复yes
  同时minProposal = n (持久化)
  返回(acceptedProposal, acceptValue)
else 
  回复no
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>P1c：提议者（proposer）会等待大多数（超过半数）接收者（acceptor）的响应。</p>
<ul>
<li>接收到响应，并且为yes，选取acceptedProposal最大的acceptValue为新的acceptValue。</li>
<li>返回的acceptValue为null时，acceptedProposal肯定为0，这时候根据算法会选取自己的值为acceptValue。</li>
<li>半数以上的回复是yes，进入下一阶段P2。否则，n自增，重复P1a。</li>
</ul>
</li>
</ul>
<p>P2（Accept阶段）</p>
<ul>
<li>
<p>P2a：提议者（proposer）发起RPC（Accept(n, value)），value为p1选出的acceptValue。</p>
</li>
<li>
<p>P2b：接收者（acceptor）接收到Accept(n, value)，会做如下决策：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">if n &gt;= minProposal
  回复yes
  同时minProposal = acceptedProposal = n（持久化）
  acceptValue = value
  return minProposal
else 
  回复no
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>P2c：提议者（proposer）收到半数以上的yes，并且minProposal = n，则算法结束。否则n自增，重复P1a</p>
</li>
</ul>
<h4 id="示例">示例</h4>
<p>接下来用一些例子来说明提议竞争的状态，以及关键点在于第二次提议的准备阶段。</p>
<p>总共有三种可能。</p>
<h5 id="一已经选定了之前的值">一、已经选定了之前的值</h5>

<p>简单解释下图形的意思：</p>
<ul>
<li>
<p>有两个请求，X向S1请求，Y向S5请求。</p>
</li>
<li>
<p>P3.1表示Prepare阶段，提议序号3.3，高位顺序数3，低位服务器号5。</p>
</li>
<li>
<p>A4.5X表示Accept阶段，提议需要4.5，高位顺序数4，地位服务器号5，接受值X。</p>
</li>
<li>
<p>在第二个提议请求来之前，第一个提议请求已经选定了值，也就是说值 X 已经被集群的大多数服务器所接受。</p>
</li>
<li>
<p>第二个提议请求也需要大多数服务器得到响应，所以一定可以保证会至少有一个准备（Prepare）请求会到达与前一个请求相同的服务器，这里是 S3 。</p>
</li>
<li>
<p>服务器 S5 会发现已经接受的值 X ，当它响应准备请求（Prepare）时，它会放弃 Y 值，并为在所有接受（Accept）请求时使用 X 值。</p>
<ul>
<li>算法选取回复yes中acceptedProposal最大的，那么S3的是3.1，value被替换为X。</li>
</ul>
</li>
<li>
<p>服务器 S5 会成功，选定值为 S1 提议的 X 。</p>
</li>
</ul>
<p>后面两种情况的前提是前值没有被选定的情况下，第二次请求进入了准备阶段（Prepare Phase）</p>
<h5 id="二前值没有被选定但对新提议可见">二、前值没有被选定，但对新提议可见</h5>

<p>有可能前一次的提议正在处于接受值的过程中，第二次提议恰好见到了其中的接受值。</p>
<p>这个场景和第一个场景类似，最终结果是A4.5X。注意这里其实S5并不需要知道S1、S2的情况，不管S1\S2是否接受X，最终选出来的都是X。</p>
<h5 id="三前值没有被选定对新提议也不可见">三、前值没有被选定，对新提议也不可见</h5>

<p>提议A3.1X被拒绝了，因为4.5 &gt; 3.1，X的提议失败了，等待下次重试，Y的提议被接受。</p>
<p>至此，足以说明 Paxos 协议在竞争状态下是安全的，无论如何竞争，最终都会选定某一值并达成一致。但是，这并不能说明基础 Paxos 协议是可用的（Live），可能会发生一组提议相互阻碍的情况，最终不会有任何选定值。下面会对此进行说明。</p>
<h5 id="可用性">可用性</h5>

<p>假设服务器 S1 成功接收到请求，并处于准备阶段（P 3.1）。在接受值 X 之前（A 3.1 X），另外一个服务器 S5 正处于它的准备阶段（P 3.5），这会阻止前序值的接受（A 3.1 X）。然后 S1 会重新选择提议序号并再次开始提议过程（P 4.1），假设它正进入了第二轮的准备阶段，在接受值之前，服务器 S5 正试图完成接受值的选定 Y （A 3.5 Y），不过此时因为（P 4.1）的序号高于（A 3.5 Y），所以它阻止了（A 3.5 Y）的接受，这样 S5 的提议就失败了，然后 S5 又重新开始下一轮的提议，如此往复，这个过程会无限循环下去。</p>
<p>为了不发生活锁，Paxos 需要以某种补充机制来保证它可以正确运行。</p>
<ul>
<li>给重新开始一个随机的延时，让其他提议者有机会完成。</li>
<li>在多 Paxos 协议（Multi-Paxos）下，将多写转变为单写，选出一个Leader。</li>
</ul>
<h4 id="其他">其他</h4>
<p>超时等错误：等价于拒绝</p>
<p>两个阶段的多数派不需要完全相同</p>
<p>读一致：</p>
<ul>
<li>leader</li>
<li>Paxos Quorum Reads</li>
<li>&hellip;</li>
</ul>
<h2 id="常见的应用">常见的应用</h2>
<p>到此为止仅仅是一个值的决议，用处比较小。实践一般是使用paxos协议确定一堆有序的值，实现一个键值存储。具体怎么做的我还在研究。</p>
<ul>
<li>
<p>节点任务分配</p>
<ul>
<li>主从分配</li>
<li>分区ID分配：主从可以看作分区id分配的特化版</li>
<li>分布式锁</li>
</ul>
</li>
<li>
<p>服务发现</p>
<ul>
<li>
<p>用zookeeper\etcd做服务发现的比较多。</p>
</li>
<li>
<p>不过有些人认为服务发现不需要共识。常见的DNS、Eureka、我们的naming都没有用共识实现。</p>
</li>
</ul>
</li>
<li>
<p>成员服务</p>
<ul>
<li>心跳检测</li>
</ul>
</li>
</ul>
]]></description>
</item><item>
    <title>高性能libcurl</title>
    <link>http://coderyang.com/libcurl/</link>
    <pubDate>Sat, 14 Nov 2020 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/libcurl/</guid>
    <description><![CDATA[<p>本文主要介绍一下curl接口的使用方法，以及获取高性能的一些实践。</p>
<h2 id="什么是libcurl用处">什么是libcurl？用处？</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more!
</code></pre></td></tr></table>
</div>
</div><p>官网摘的一段，意思大概是免费且容易使用的url传输库，支持下面一堆特性。</p>
<p>项目内用处：基于libcurl实现了一个单线程异步的httpc，用于msdk、防沉迷、信用分等需要接入外部http的服务。</p>
<h2 id="接口介绍">接口介绍</h2>
<p>curl一共有三种接口：</p>
<ul>
<li><a href="https://curl.haxx.se/libcurl/c/libcurl-easy.html" target="_blank" rel="noopener noreffer">Easy Interface</a></li>
<li><a href="https://curl.haxx.se/libcurl/c/libcurl-multi.html" target="_blank" rel="noopener noreffer">Multi Interface</a></li>
<li><a href="https://curl.haxx.se/libcurl/c/libcurl-share.html" target="_blank" rel="noopener noreffer">Share Interface</a></li>
</ul>
<h3 id="easy-interface">Easy Interface</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">The easy interface is a synchronous, efficient, quickly used and... yes, easy interface for file transfers. Numerous applications have been built using this.
</code></pre></td></tr></table>
</div>
</div><p>简单接口是一个同步接口，非常方便使用，接口以curl_easy_开头，下面一个简单的使用例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CURL</span> <span class="o">*</span><span class="n">curl</span> <span class="o">=</span> <span class="n">curl_easy_init</span><span class="p">();</span> <span class="c1">// 创建一个handle
</span><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">curl</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CURLcode</span> <span class="n">res</span><span class="p">;</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">curl</span><span class="p">,</span> <span class="n">CURLOPT_URL</span><span class="p">,</span> <span class="s">&#34;https://example.com&#34;</span><span class="p">);</span> <span class="c1">// 设置参数，参数有很多，header、cookie、接收回调函数、证书等等
</span><span class="c1"></span>  <span class="n">res</span> <span class="o">=</span> <span class="n">curl_easy_perform</span><span class="p">(</span><span class="n">curl</span><span class="p">);</span> <span class="c1">// 执行，注意这里是阻塞的
</span><span class="c1"></span>  <span class="n">curl_easy_cleanup</span><span class="p">(</span><span class="n">curl</span><span class="p">);</span> <span class="c1">// 清理
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="multi-interface">Multi Interface</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">The multi interface is the asynchronous brother in the family and it also offers multiple transfers using a single thread and more. 
</code></pre></td></tr></table>
</div>
</div><p>多重接口是异步接口，libcurl使用一个或者多个线程完成数据传输，通过多重接口可以再单线程下同时操作多个easy handle。</p>
<p>例子：https://gist.github.com/clemensg/4960504</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define MAX_WAIT_MSECS 30*1000 </span><span class="cm">/* Wait max. 30 seconds */</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">urls</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">&#34;http://www.microsoft.com&#34;</span><span class="p">,</span>
  <span class="s">&#34;http://www.yahoo.com&#34;</span><span class="p">,</span>
  <span class="s">&#34;http://www.wikipedia.org&#34;</span><span class="p">,</span>
  <span class="s">&#34;http://slashdot.org&#34;</span>
<span class="p">};</span>
<span class="cp">#define CNT 4
</span><span class="cp"></span>
<span class="k">static</span> <span class="n">size_t</span> <span class="nf">cb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">l</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* take care of the data here, ignored in this example */</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="n">CURLM</span> <span class="o">*</span><span class="n">cm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">CURL</span> <span class="o">*</span><span class="n">eh</span> <span class="o">=</span> <span class="n">curl_easy_init</span><span class="p">();</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_WRITEFUNCTION</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_HEADER</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_URL</span><span class="p">,</span> <span class="n">urls</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_PRIVATE</span><span class="p">,</span> <span class="n">urls</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLOPT_VERBOSE</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
  <span class="n">curl_multi_add_handle</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">eh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CURLM</span> <span class="o">*</span><span class="n">cm</span> <span class="o">=</span> <span class="n">curl_multi_init</span><span class="p">();</span> <span class="c1">// 创建一个multi handle
</span><span class="c1"></span>
    <span class="c1">// 创建一堆easy handle加入到multi handle里
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">init</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 执行，等待所有都执行完
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">still_running</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">curl_multi_perform</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">still_running</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
      	<span class="c1">// 等一段时间，MAX_WAIT_MSECS为最长时长
</span><span class="c1"></span>        <span class="c1">// 有事件或者超时了返回
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">curl_multi_wait</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_WAIT_MSECS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numfds</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">CURLM_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;error: curl_multi_wait() returned %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">curl_multi_perform</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">still_running</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">still_running</span><span class="p">);</span>

    <span class="c1">// 读取数据
</span><span class="c1"></span>    <span class="n">CURLMsg</span> <span class="o">*</span><span class="n">msg</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">szUrl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">msgs_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">http_status_code</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">msg</span> <span class="o">=</span> <span class="n">curl_multi_info_read</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msgs_left</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">==</span> <span class="n">CURLMSG_DONE</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">CURL</span> <span class="o">*</span><span class="n">eh</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">easy_handle</span><span class="p">;</span>
            <span class="n">CURLcode</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">result</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">return_code</span><span class="o">!=</span><span class="n">CURLE_OK</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;CURL error code: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">result</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Get HTTP status code
</span><span class="c1"></span>            <span class="n">http_status_code</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="n">szUrl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">curl_easy_getinfo</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLINFO_RESPONSE_CODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">http_status_code</span><span class="p">);</span>
            <span class="n">curl_easy_getinfo</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">CURLINFO_PRIVATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">szUrl</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">http_status_code</span><span class="o">==</span><span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&#34;200 OK for %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">szUrl</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;GET of %s returned http status code %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">szUrl</span><span class="p">,</span> <span class="n">http_status_code</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">curl_multi_remove_handle</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">eh</span><span class="p">);</span>
            <span class="n">curl_easy_cleanup</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;error: after curl_multi_info_read(), CURLMsg=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 关闭
</span><span class="c1"></span>    <span class="n">curl_multi_cleanup</span><span class="p">(</span><span class="n">cm</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="share-interface">Share Interface</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">The share interface was added to enable sharing of data between curl &#34;handles&#34;.
</code></pre></td></tr></table>
</div>
</div><p>用于再多个easy handle共享一些数据，比如dns cache、tls session。</p>
<h3 id="其他">其他</h3>
<p>curl_global_init：进程启动时初始化curl</p>
<p>curl_global_cleanup：进程关闭时清理curl</p>
<p>使用异步DNS，防止同步解析DNS卡住主循环</p>
<h2 id="实践">实践</h2>
<ol>
<li>
<p>最初实现了一个使用Multi Interface的HTTPC。</p>
<ul>
<li>
<p>httpc/unittest/httpc.cpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">TEST_F</span><span class="p">(</span><span class="n">HTTPC_TEST</span><span class="p">,</span> <span class="n">HTTP_GET</span><span class="p">)</span>                                                 
<span class="p">{</span>
    <span class="n">HTTPC_CFG</span> <span class="n">cfg</span><span class="p">;</span>
    <span class="n">REQUEST_DRIVER</span> <span class="nf">driver</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">HTTPC</span> <span class="nf">c</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
         
    <span class="k">auto</span> <span class="n">cb</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">RESPONSE</span> <span class="o">&amp;</span><span class="n">rsp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;result:%d code:%ld </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rsp</span><span class="p">.</span><span class="n">_result</span><span class="p">,</span> <span class="n">rsp</span><span class="p">.</span><span class="n">_http_status_code</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;body:%s&#34;</span><span class="p">,</span> <span class="n">rsp</span><span class="p">.</span><span class="n">_body</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="p">};</span>
     
    <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#34;http://www.baidu.com&#34;</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
    <span class="p">}</span>
     
    <span class="kt">bool</span> <span class="n">idle</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="p">.</span><span class="n">_ctx_map</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">driver</span><span class="p">.</span><span class="n">loop</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>在压测过程中发现性能不足，DNS解析卡住主循环。根据https://moz.com/devblog/high-performance-libcurl-tips，增加了c-ares库，使得libcurl支持异步DNS，最终性能到了3000TPS。</p>
</li>
<li>
<p>尝试使用Share Interface共享DNS，效果在接入异步DNS后不明显。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 初始化共享
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">_dns_lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span>
<span class="n">CURLSH</span><span class="o">*</span> <span class="n">_share_handler</span> <span class="o">=</span> <span class="n">curl_share_init</span><span class="p">();</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_USERDATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_dns_lock</span><span class="p">);</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_LOCKFUNC</span><span class="p">,</span> <span class="n">_lock</span><span class="p">);</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_UNLOCKFUNC</span><span class="p">,</span> <span class="n">_unlock</span><span class="p">);</span>
<span class="n">curl_share_setopt</span><span class="p">(</span><span class="n">_share_handler</span><span class="p">,</span> <span class="n">CURLSHOPT_SHARE</span><span class="p">,</span> <span class="n">CURL_LOCK_DATA_DNS</span><span class="p">);</span>
   
<span class="c1">// 设置共享
</span><span class="c1"></span><span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_requst</span><span class="o">-&gt;</span><span class="n">_curl_handle</span><span class="p">,</span> <span class="n">CURLOPT_SHARE</span><span class="p">,</span> <span class="n">_share_handler</span><span class="p">);</span>
<span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_requst</span><span class="o">-&gt;</span><span class="n">_curl_handle</span><span class="p">,</span> <span class="n">CURLOPT_DNS_CACHE_TIMEOUT</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span><span class="p">);</span><span class="c1">//5min
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>请求处理完毕后，不适用curl_easy_cleanup，而是采用连接池的方式通过curl_easy_reset重用连接。</p>
<ul>
<li>
<p><a href="https://curl.se/libcurl/c/libcurl-tutorial.html#Persistence">https://curl.se/libcurl/c/libcurl-tutorial.html#Persistence</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Re-cycling the same easy handle several times when doing multiple requests is the way to go.
     
After each single curl_easy_perform operation, libcurl will keep the connection alive and open. A subsequent request using the same easy handle to the same host might just be able to use the already open connection! This reduces network impact a lot.
     
Even if the connection is dropped, all connections involving SSL to the same host again, will benefit from libcurl&#39;s session ID cache that drastically reduces re-connection time.
     
....
     
libcurl caches DNS name resolving results, to make lookups of a previously looked up name a lot faster.
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><a href="https://curl.se/libcurl/c/curl_easy_reset.html">https://curl.se/libcurl/c/curl_easy_reset.html</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Re-initializes all options previously set on a specified CURL handle to the default values. This puts back the handle to the same state as it was in when it was just created with curl_easy_init.
     
It does not change the following information kept in the handle: live connections, the Session ID cache, the DNS cache, the cookies, the shares or the alt-svc cache.
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ol>
]]></description>
</item><item>
    <title>简易function</title>
    <link>http://coderyang.com/function/</link>
    <pubDate>Sat, 19 Sep 2020 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/function/</guid>
    <description><![CDATA[<p>本文主要讲一下怎么实现一个简易版本的function&lt;&gt;模板，从c++ templates第二版摘出，相应的技巧在timer中一些应用。</p>
<h2 id="出发点">出发点</h2>
<p>一个简单的例子，下面这个模板上述能够接受任意可调用的对象，lambda表达式、函数指针、仿函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">print_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">for_int_up</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">sum</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">});</span>
    
    <span class="n">for_int_up</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">print_int</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>像for_int_up这样的函数其实有两个问题：</p>
<ul>
<li>使用了模板将函数内部实现暴露。</li>
<li>造成代码膨胀，for_int_up函数还比较小，如果是一个很大的函数，代码膨胀会厉害的多。</li>
</ul>
<p>于是为了解决上面两个问题，可能尝试用下面这个方案，这也是我们代码中常见的解决方案。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>考虑到有可能有需要带上参数的需求，我们可能会写成这样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">for_int_up</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用函数指针替代模板，for_int_up只接受函数指针，无法接收lambda表达式、仿函数。</p>
<p>带参数的方案基本上能够满足需求，只是需要将函数与数据分离，代码相对难写，强转可能存在错误。</p>
<p>本质上带参数void*的方案是在抹除类型信息。</p>
<p>基于以上的需求标准库里的std::function&lt;&gt;就应运而生了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_int_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>std::function&lt;void(int)&gt;能够接收任意返回值是void，参数为int的函数指针、lambda表达式、仿函数。</p>
<p>上面两个问题一下就得到了解决，内部实现可以隐藏起来，同时模板范围缩小到std::function，即使for_int_up再大也不会出现代码膨胀很厉害的情况。</p>
<h2 id="广义的函数指针">广义的函数指针</h2>
<p>std::function实际上是一个广义上的C++函数指针，需要支持一下操作：</p>
<ul>
<li>在调用者只知道入参与返回值的情况，可以调用执行，不需要理解内部具体实现。</li>
<li>支持复制、移动。</li>
<li>可以被入参与返回值相同的函数指针、lambda表达式、仿函数、std::function初始化</li>
<li>支持null状态</li>
</ul>
<h2 id="实现">实现</h2>
<p>下面我们会实现一个简易版本的std::function，FUNCTION_PTR。FUNCTION_PTR会支持上面提到的所有特性。</p>
<p>functionptr.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 原始模板，因为实际上FUNCTION_PTR模板参数只有一个，所以需要这个原始模板:
</span><span class="c1">// 模板参数是一个函数类型
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FUNCTION_PTR</span><span class="p">;</span>

<span class="c1">// 偏特化，提取出变参Args为所有参数，R为返回值
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">private</span><span class="o">:</span>
    <span class="n">FUNCTOR_BRIDGE</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span> <span class="c1">// 核心类，参数类型信息，提供抽象的invoke。
</span><span class="c1"></span>
   <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 构造:
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span><span class="p">()</span> <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{}</span> <span class="c1">// 默认为空
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span><span class="p">(</span><span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">);</span>  <span class="c1">// see functionptr-cpinv.hpp
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span><span class="p">(</span><span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="p">)</span>
    <span class="p">{</span>
         <span class="c1">// 移动构造，所有权转移
</span><span class="c1"></span>        <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从任意函数对象构造:
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">&gt;</span>
    <span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span> <span class="p">);</span>  <span class="c1">// see functionptr-init.hpp
</span><span class="c1"></span>    
    <span class="c1">// 赋值操作符:
</span><span class="c1"></span>    <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FUNCTION_PTR</span> <span class="nf">tmp</span><span class="p">(</span> <span class="n">other</span> <span class="p">);</span>
        <span class="n">swap</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">tmp</span> <span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;&amp;</span><span class="n">other</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="n">bridge</span><span class="p">;</span>
        <span class="n">bridge</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从任意函数对象复制:
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">&gt;</span>
    <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FUNCTION_PTR</span> <span class="nf">tmp</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// 先构造一个临时对象
</span><span class="c1"></span>        <span class="n">swap</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">tmp</span> <span class="p">);</span> <span class="c1">// 调用swap
</span><span class="c1"></span>        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 析构:
</span><span class="c1"></span>    <span class="o">~</span><span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">bridge</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="n">fp1</span><span class="p">,</span> <span class="n">FUNCTION_PTR</span> <span class="o">&amp;</span><span class="n">fp2</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span> <span class="n">fp1</span><span class="p">.</span><span class="n">bridge</span><span class="p">,</span> <span class="n">fp2</span><span class="p">.</span><span class="n">bridge</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// bool隐式转换，便于if判断
</span><span class="c1"></span>    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bridge</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// ()操作符重载:
</span><span class="c1"></span>    <span class="n">R</span> <span class="nf">operator</span><span class="p">(</span> <span class="p">)(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// see functionptr-cpinv.hpp
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到FUNCTION_PTR包含一个FUNCTOR_BRIDGE&lt; R, Args&hellip; &gt;成员，它负责存储具体的功能对象，并将具体类型擦除了。</p>
<p>functorbridge.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// FUNCTOR_BRIDGE只是一个抽象类，定义了几个基本接口
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FUNCTOR_BRIDGE</span> <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FUNCTOR_BRIDGE</span><span class="p">(</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="n">FUNCTOR_BRIDGE</span> <span class="o">*</span><span class="nf">clone</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 复制接口
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="n">R</span> <span class="nf">invoke</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 调用接口
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>bridge/functionptr-cpinv.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 基于FUNCTOR_BRIDGE的抽象接口，我们能够实现FUNCTION_PTR复制与调用
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="n">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;::</span><span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">FUNCTION_PTR</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">bridge</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">bridge</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// 复制
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="n">R</span> <span class="n">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;::</span><span class="k">operator</span><span class="p">(</span> <span class="p">)(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">bridge</span><span class="o">-&gt;</span><span class="n">invoke</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span> <span class="c1">// 调用，完美转发
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>bridge/specificfunctorbridge.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 真正存储实际的可调用对象，继承自FUNCTOR_BRIDGE，利用多态实现类型的擦除
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">FUNCTOR</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SPECIFIC_FUNCTOR_BRIDGE</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FUNCTOR_BRIDGE</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">FUNCTOR</span> <span class="n">functor</span><span class="p">;</span>

   <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 构造
</span><span class="c1"></span>    <span class="c1">// 这里用了一个单独的FUNCTOR_FWD而不是FUNCTOR，因为有可能FUNCTOR_FWD类型与FUNCTOR
</span><span class="c1"></span>    <span class="c1">// 不一样，存在隐式转换
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">FUNCTOR_FWD</span> <span class="o">&gt;</span>
    <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span><span class="p">(</span> <span class="n">FUNCTOR_FWD</span> <span class="o">&amp;&amp;</span><span class="n">functor</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">functor</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">FUNCTOR_FWD</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">functor</span> <span class="p">)</span> <span class="p">)</span> 
    <span class="p">{</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span> <span class="o">*</span><span class="nf">clone</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span><span class="p">(</span> <span class="n">functor</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">R</span> <span class="nf">invoke</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">functor</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>functionptr-init.hpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 任意类型转换为FUNCTION_PTR
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">&gt;</span>
<span class="n">FUNCTION_PTR</span><span class="o">&lt;</span> <span class="n">R</span><span class="p">(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="o">&gt;::</span><span class="n">FUNCTION_PTR</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span> <span class="p">)</span> <span class="o">:</span> <span class="n">bridge</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">FUNCTOR</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 类型退化
</span><span class="c1"></span>    <span class="k">using</span> <span class="n">BRIDGE</span> <span class="o">=</span> <span class="n">SPECIFIC_FUNCTOR_BRIDGE</span><span class="o">&lt;</span> <span class="n">FUNCTOR</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="o">&gt;</span><span class="p">;</span>
    <span class="n">bridge</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BRIDGE</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// 生成brige
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>到此基本上FUNCTION_PTR已经实现完成了。</p>
<h2 id="其他">其他</h2>
<ul>
<li>最终版本欠缺一个小功能判断FUNCTION_PTR内部存储的可调用对象是否相等。</li>
<li>FUNCTION_PTR将所有可调用对象都转换为了一次虚函数的调用，降低了性能。</li>
<li>每创建一个FUNCTION_PTR都需要一次堆内存分配。</li>
<li>gcc4.8中的std::function对于小对象不会进行堆内存的分配。</li>
</ul>
]]></description>
</item><item>
    <title>读书摘录-存在主义心理治疗</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97/</link>
    <pubDate>Sat, 29 Dec 2018 08:31:58 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97/</guid>
    <description><![CDATA[<p>本书涉及四个终极关怀:死亡、自由、孤独和无意义。个体与这些生命真相的正面交锋，构成了存在主义动力性冲突的内容。</p>
<p>死亡。最显而易见的、最容易理解的终极关怀就是死亡。我们现在存在，但是总有一天，这种存在会终止。死亡将如期而至，没有逃脱之路。这是一个恐怖的真相，能引发我们巨大的恐惧。用斯宾诺莎的话来说，“每一事物都在尽力维持自身的存在”；而存在的一个核心冲突就是，对死亡必然性的意识与继续生存下去的愿望之间的张力。</p>
<p>自由。另一个相对来说不太容易理解的终极关怀是自由。一般来说我们都认为自由是一个毋庸置疑的积极概念。有史以来，人类不是一直在渴望并为自由而奋斗吗？然而从终极层面来看，自由是与忧惧偶联在一起的。在存在的意义上，“自由”意味着外部结构的空白。与日常经验相反的是，人类并不是进入（和离开）一个拥有内在设计、高度结构化的宇宙。实际上，个体对他自己的世界、生活设计、选择以及行为负有全部责任——也就是说，个体是自己世界的创造者。“自由”在这种含义上，带有一种可怕的暗示:它意味着在我们所站立的地方并不坚实一什么都没有，是空的，无底深渊。所以，存在主义一个关键的动力性冲突就是，们无根基的处境与我们对根基与结构的渴望之间的冲突。</p>
<p>存在性孤独。第三个终极关怀是孤独不是伴随着寂寞的人际性孤独，也不是个人内心的孤独（与自身的其他部分隔离），而是一种根本性孤独既与生命隔绝，也与世界隔绝—隔绝在所有其他孤独之下。无论我们之间变得有多么亲密无间，仍然存在一个最终无法逾越的鸿沟；我们每个人都是独自一人进入这种存在，同时也注定要独自离开。一方面是我们对自身绝对孤独的意识，另一方面是对接触、保护的渴望，以及成为一个更大整体的一部分的愿望在性冲突就是这两个方面之间的张力。</p>
<p>无意义。第四个终极关怀或存在的既定事实是无意义。如果我们注定得死，如果我们构建我们自己的世界，如果每一个人最终都是独自一人身处于一个无关紧要的世界之中，那么生命有什么意义我们为什么要活着？我们应该怎样活着？如果并不存在为我们预先设计的蓝图，那么我们每个人就必须构建自己的生命意义。然而，个人自己创造出来的意义能否坚强到令其能容忍生活？人类这种寻找意义的生物，却被投入到本身毫无意义的宇宙之中，于是，存在的动力性冲突便从进退维谷的境地中滋生出来。</p>
]]></description>
</item><item>
    <title>我的2018</title>
    <link>http://coderyang.com/%E6%88%91%E7%9A%842018/</link>
    <pubDate>Sun, 23 Dec 2018 08:31:58 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E6%88%91%E7%9A%842018/</guid>
    <description><![CDATA[<p>距离上次博客又过去了几个月。自从换了工作之后时间总是比较紧张，一直是996的节奏。每周只有一天的休息日，往往这天会安排着调整下节奏、与朋友聚会，属于自己独处的时间减少了。</p>
<p>当然这不是不写博客的理由了，核心原因还是懒，毕竟真想做什么，怎么都能挤出时间。</p>
<h1 id="一年的总结">一年的总结</h1>
<p>2018对我来说过得很慢的一年，一年里做了挺多的事情。我自己对过去的一年还算满意。</p>
<p>没有女朋友：意识到自己的年龄也挺大了，但是还没有女朋友。</p>
<p>学会了做饭：按照王刚的教程学习做了几个菜。</p>
<p>书籍50余本：10本为技术书籍，17本小说，8本互联网、游戏行业逸闻，10本社科类书籍，还有一些漫画、小品文章。</p>
<p>影视剧50余部：涉及国漫、日漫、欧美电影、日本电影、国产电影。</p>
<p>游戏10个：大作认真玩的只有两部，塞尔达、荒野大镖客2。还有一些开拓游戏叙事的小品游戏，比如弗洛伦丝、伊迪丝芬奇的记忆。</p>
<p>三地：上海、江西、杭州。我挺喜欢杭州的，希望以后有机会去那发展吧。</p>
<p>代码：代码文本行数应该在6w左右。数量还算满意。</p>
<h1 id="明年的展望">明年的展望</h1>
<h2 id="工作">工作</h2>
<p>通过三年的阅读与实践，我能说把计算机系很多本科基础知识都补充了。数据结构、设计模式、计算机组成、网络、数据库、编程语言等等吧，都有了一定程度的理解。</p>
<p>现在大概处于一个瓶颈阶段，想要更进一步，还是有很多东西需要去改进。</p>
<p>然后是希望未来的一年开发的游戏能够成功上市，完成一段心愿。</p>
<h3 id="打字">打字</h3>
<p>问题：</p>
<p>我打字是通过小学时候不断的聊QQ学习的，现在暴露出来几个缺陷。</p>
<ol>
<li>英文单词经常打错，比如linux输入一些命令，10个以内的字母，经常打一半就出错。</li>
<li>中文打字速度不算快，且容易错。</li>
<li>对键盘符号的位置不熟悉，还不能做到完全盲打的程度。</li>
</ol>
<p>解决方案：</p>
<ol>
<li>专门的打字练习</li>
<li>改用双屏</li>
</ol>
<h3 id="代码的复制粘贴">代码的复制粘贴</h3>
<p>问题：</p>
<p>不是指大段代码的复制粘贴，而是指对一些单个变量、函数的粘贴。</p>
<p>原因：</p>
<ol>
<li>emacs的补全不是很好用</li>
<li>整个项目里的变量一直使用复制粘贴，没有那么熟悉，</li>
<li>会打错字</li>
</ol>
<p>解决方案：</p>
<p>强制的不复制粘贴，改为手打。</p>
<h3 id="英文">英文</h3>
<p>问题：</p>
<p>英文很差，导致我现在对于英文的文档比较露怯。</p>
<p>解决方案：</p>
<p>一般来说技术书使用的英文都不是太难，考虑到我提升英语的目的是为了更好的阅读英文技术资料。所以完全可以通过直接开始阅读英文技术资料提高，同时也能够达到提高技术的目的。</p>
<ol>
<li>持续的英文技术资料的阅读。</li>
<li>普通英文咨询的阅读。</li>
</ol>
<h3 id="源码阅读">源码阅读</h3>
<p>今年一年阅读了比较多的书籍，但是除了项目没有怎么阅读优秀开源项目的源码，视野比较窄，急需扩展。同时能够吸收项目之外的优秀设计。</p>
<h3 id="编程练习">编程练习</h3>
<p>项目之外的造轮子少，整体还是懒，经常阅读了书籍没有去实践。编程这个东西，只有练习才能够真正的理解设计。</p>
<h1 id="生活">生活</h1>
<p>生活总是一成不变的，希望在未来的一年里能够多发展几项技能。</p>
<h3 id="锻炼">锻炼</h3>
<p>身体越来越差，体重越来越大。每周能抽出3天时间进行专项的锻炼，初期以跑步为主。</p>
<h3 id="摄影">摄影</h3>
<p>随着年龄的增长，越来越想留住时间。很遗憾的是之前没有做好记录，每年都没有全家福。</p>
]]></description>
</item><item>
    <title>clean code读书笔记</title>
    <link>http://coderyang.com/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Mon, 23 Jul 2018 08:31:58 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[<p>命名，很多人戏称为编程中最难的事情。从实践经验出发来看，一个好的命名能够让代码阅读者迅速的知道代码的实际用途，而坏的命名不仅仅是让人摸不着头脑，而且可能误导他人。</p>
<p>本文主要是clean code第二章有意义的命名的笔记，该章节系统的讲述了什么才是一个好的名字。</p>
<ol>
<li>
<p>名副其实</p>
<blockquote>
<p>如果命名需要注释，则不是一个好的命名。</p>
<p>命名需要表达出准确的含义，不应该使用magic num或者i、j、k这类无意义的变量名。</p>
</blockquote>
</li>
<li>
<p>避免误导</p>
<blockquote>
<p>0和O、1、I和l。这类视觉上容易混淆的名字不需要使用。</p>
<p>假设存在一个vector，里面存储这actor_rid，但是你命名为actor_list，导致阅读者误认为是用链表实现的。</p>
</blockquote>
</li>
<li>
<p>做有意义的区分</p>
<blockquote>
<p>类似a1、a2、a3不能够带来任何信息的变量命名</p>
<p>类似thexx、xxdata、xxinfo、xxobject这类没有意义的前缀、后缀</p>
<p>不使用匈牙利命名法带上类型信息，现在ide随时可以看到类型</p>
<p>变量的命名需要带有含义，不要带上冗余的无效的信息。</p>
</blockquote>
</li>
<li>
<p>使用读得出来的名称</p>
<blockquote>
<p>如果变量难易阅读的话，对阅读者总是负担，难以记住也难易和他人交流</p>
</blockquote>
</li>
<li>
<p>使用可搜索的名称</p>
<blockquote>
<p>作用域越大变量名越长，便于搜索同时不会重复。</p>
</blockquote>
</li>
<li>
<p>避免使用编码</p>
<blockquote>
<p>匈牙利命名法在现代ide没有必要，同时影响ide的自动补全，修改类型名同时需要修改变量名</p>
<p>类似m_的前缀没有必要</p>
</blockquote>
</li>
<li>
<p>避免翻译</p>
<blockquote>
<p>缩写</p>
</blockquote>
</li>
<li>
<p>类名</p>
<blockquote>
<p>类名应该是名词或者名词短语，不应该是动词</p>
</blockquote>
</li>
<li>
<p>方法名</p>
<blockquote>
<p>方法名应该是动词或者动词短语，类似set_xx、is_xx</p>
</blockquote>
</li>
<li>
<p>别扮可爱</p>
<blockquote>
<p>不要使用难以联想到的词，即使你认为很精妙，直接了当的命名。</p>
</blockquote>
</li>
<li>
<p>每个概念对应一个词</p>
<blockquote>
<p>controller、manager、driver。英语中有很多语义相似的词语，代码中统一使用一个词来描述。</p>
</blockquote>
</li>
<li>
<p>不使用双关</p>
<blockquote>
<p>双关代表者二义性。比如add，有可能是insert的意思，有可能是append的意思。</p>
</blockquote>
</li>
<li>
<p>使用解决方案领域名称</p>
<blockquote>
<p>计算机科学属于、算法名、模式名。使用领域内专有名词利于有共同经验的人理解程序</p>
</blockquote>
</li>
<li>
<p>使用源自所涉问题领域名称</p>
<blockquote>
<p>我们是游戏编程，有很多游戏专有名词。比如exp、level、dps等，更业务的代码使用这些名词易于理解</p>
</blockquote>
</li>
<li>
<p>添加有意义的语境</p>
<blockquote>
<p>将相关的变量设置统一的前缀、后缀，建立语境。</p>
</blockquote>
</li>
<li>
<p>不要添加没用的语境</p>
<blockquote>
<p>比如给同一个项目里的所有类添加上项目名称。</p>
</blockquote>
</li>
</ol>
]]></description>
</item><item>
    <title>这几个月的一点随感</title>
    <link>http://coderyang.com/%E8%BF%99%E5%87%A0%E4%B8%AA%E6%9C%88%E7%9A%84%E4%B8%80%E7%82%B9%E9%9A%8F%E6%84%9F/</link>
    <pubDate>Sun, 15 Oct 2017 19:22:57 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%BF%99%E5%87%A0%E4%B8%AA%E6%9C%88%E7%9A%84%E4%B8%80%E7%82%B9%E9%9A%8F%E6%84%9F/</guid>
    <description><![CDATA[<p>又有几个月没写博客了，自上次Redis系列之后，三个月过去。中间结束一个项目、面试了很多次、换了个工作、搬了次家、在家度过了一次国庆长假。</p>
<h1 id="结束一个项目">结束一个项目</h1>
<p>结束的一个项目，算是基本独立完成的比较大的一个项目。项目团队四个人，两程序、两自动化。</p>
<p>出差到施工现场三个月，在那里完成了从客户端界面到服务端大部分编码测试工作，独立解决各种现场需求。很顺利的完成了工作，结题一个多月。项目在之前做的一个十多万行的项目基础上开发，新增了几万行代码，需要对程序进行设计架构的要求少，大部分还是在原来代码基础上修改，增加删除功能。做完这个项目之后，感觉编码上能遇到的问题越来越少，到了一个算是瓶颈的位置。</p>
<p>原公司是一个做轧钢工业控制系统的公司，十几个人，一半是程序员，一半是自动化工程师。毕业时候进去的。它给了我成为程序员的机会，工作氛围也很好，让我在基础薄弱的时候自由学习，并应用到项目之上。</p>
<p>从技术上看，软件需要对工业设备进行控制，对稳定性安全性要求高，程序崩溃或者控制逻辑上产生问题，可能导致很大的生产事故。用户量小，一般只需要一个服务器，搭配几个客户端界面。</p>
<p>公司依靠自动化起家，软件部门薄弱。老板对于软件的认识不足，认为编码简单，只要找些应届生学学就能上。又由于行业比较小，难以从社会上补充有经验的人员。不过话说回来，从公司需求来说，确实不需要大牛。维持住业务，两年三年工作经验程序经验即可胜任，基础好的应届生也能完成大部分工作。工作的主要难度在业务的理解上，这也是我能成为程序的原因。</p>
<p>刚进去的时候，之前的干了八年的主程序因故出走，剩下的都是只有一年经验的程序。还好老板在之后请来了老同学（20年经验），管理队伍。但是由于工作性质，需要长期出差，大部分代码在施工现场完成，一般一两人负责一个项目，没有完善的流程，更多是靠个人的自我约束，自我驱动去完成项目。从代码质量来看，肯定不会好。</p>
<p>如果要对我过去两年工作进行一个总结的话，那就是野蛮生长，整个过程中很少有人能够给予我指导，都是依靠个人去搜索资料、学习知识。对于程序更多的停留在编码阶段，对与程序设计、软件工程的管理认识浅薄。</p>
<h1 id="面了很多次试">面了很多次试</h1>
<p>项目结束之后，休了个一周的长假。顺便也投了很多简历，面了很多次试。</p>
<p>面试的本意是看看自己在市场上到底值多少，了解市场的需求。八月份，不是招聘旺季，拉勾上C++的岗位只有三百多一点，适合我这个经验的100多个。由于之前的工作业务关系，干什么都是转行，同时不管是客户端还是服务端都干过，很多工作对我来说即适合又不适合。尝试着投递了一些岗位。后来感觉面试邀约不多，陆陆续续投递简历半个多月，最后发现快把适合我这个经验的岗位投递完了。一百来份简历，最终收到不到20个面试邀请。</p>
<p>从市场上看，C++需求的主要是两种windows客户端和linux服务端开发。需求最旺的依次是游戏、金融、工业控制领域。面试考察的大部分还是计算机原理、c++基础、数据结构、tcp网络基础，这可能由于我没行业背景有关。个人感觉我对于C++基础、数据结构没有太多问题，计算机原理稍薄弱，tcp网络了解很少，行业知识有限，对Linux开发没有经验。对于市场上很多岗位不能很好的匹配，于是给我面试机会的相对也比较少。</p>
<h1 id="换了个工作">换了个工作</h1>
<p>本意是出去见见世面的我，最终换了一份工作。面试的多了，愈加感觉到自己的不足。虽然在过去两年里还算努力的进行学习（总是有惰性，要是真的非常努力，肯定混的比现在好）。但是由于自身视野的问题和业务性质，我觉得要想更快速的更进一步，是时候去一个新的地方闯荡了。</p>
<p>于是，最终选择加入游戏公司成为linux服务端程序员。面试的时候，新公司主程序对我的评价是很对的：一个处在进阶阶段的程序。在这么一个阶段，需要更多的环境上的促进。这样我才能接触到更多的问题，发现一个更大的世界，逼着我去处理各种问题，不断的前进。很多时候，对于程序员来说，如果没有接触到问题的环境，你很难去想象到怎么处理问题，这也是很多公司要求行业经验的原因。不仅仅是业务上的熟悉，同时也是你只有在那个环境，比如用户量达到一定量级，才可能接触到问题，才可能知道怎么去处理问题。</p>
<p>另一个原因是我个人的心愿与理想。我是一个喜欢游戏的人，一直希望能够进入游戏公司，去看看怎么做游戏的。毕业的时候，一直在尝试找一个游戏策划的工作，但最终只收到一个小公司的游戏测试岗位offer，没有去。最后成员工业控制程序员，有一部分原因是c++在游戏领域用的很多，以后有机会跳槽。</p>
<p>现在能有机会进入一家在我看来还算不错的游戏公司，也算是了却一个心愿。虽然网上对于国内游戏开发有很多负面评论，但是不管怎么样，我也要去看看。不管未来这个工作会不会真的喜欢，我也要去尝试。</p>
<h1 id="搬了次家">搬了次家</h1>
<p>又搬了次家，这次是由于新工作离原来住的地方有点远，接近两小时的路程，必须得搬家了。毕业两年，包括离校的那次，搬了七次家，算下来三四个月就要搬一次家。过去两年里，出差过三个地方，广东湛江、河南安阳、辽宁营口，一出差就是几个月半年的，天南海北的。</p>
<p>飘临。</p>
<p>我算是一个适应能力很强的一个人了，在一个新地方能够比较快的熟悉起来。但是这么多次搬家，又经常长期出差到不熟悉的地方，那种人在异乡的感觉就愈加强烈了。以前觉得出差没什么，反正单身狗一个，一人吃饱全家不饿的，但是真的出差久了，就发现你跑到一个陌生的地方，人要重新熟悉，城市要重新熟悉，又不能带很多东西。这意味着你之前的积累都没了，你只能带着其实就是你这个人。外物积累都没了，周围的熟悉事物没了，你其实对于一个新的环境来说是一个异物，你是个格格不入的东西。但是我又不是旅游，我必须去熟悉，因为要做项目，要与人打交道，要在这生活一段时间。可熟悉了，立马又要进入一个新的陌生环境。搬家一样，搬到一个新的地方，室友不认识，周围环境不熟悉，又要重新认识熟悉。</p>
<p>很多精力，就在这样的过程中被磨灭了。</p>
<h1 id="在家度过了一个国庆">在家度过了一个国庆</h1>
<p>上一次回家是过年的时候了，中间的一些假期不是在加班就是在出差。项目结束的假期又在面试。这样一算又是大半年没回去了。</p>
<p>时间。</p>
<p>很多时候你没有意识到，其实离开家已经很久了。现在24岁，人生的前12年在小镇上度过，初高中到了新余市，过了6年。大学到了上海4年，加上毕业2年，已经6年了。人生的四分之一是在外面度过的，可以预料到的是之后很长一段时间依旧会在上海。在家的时间越来越少。</p>
<p>我是喜欢回家的，在家的话很多事情不需要考虑，饭来张口衣来伸手，每天看看电脑，看看电视，啥事不管。对我来说，最大的幸福就是和自己爱的人待在一个地方，可以不说话，只要在一起，互相能够感觉到对方。回家对我来说就是这样一件事情，大家都很熟悉了，不管是父母、亲戚、朋友，只要在一起，互相有默契。这种长时间磨合之后产生的默契的感觉是最让我留恋的。</p>
]]></description>
</item><item>
    <title>Redis源码阅读-总结</title>
    <link>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%80%BB%E7%BB%93/</link>
    <pubDate>Tue, 18 Jul 2017 15:59:57 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[<p>之前的一系列Redis源码阅读的博客都是基于《Redis设计与实现》的，内容上不免和书有雷同。</p>
<p>本来计划是三月份开始看，但是中间由于接到一个开发速度要求很高的项目，加班很多耽误了些进度，只在这一段时间里看了部分小书（部分书摘录成了博客），耽搁了。</p>
<p>然后快到七月的时候，项目在经过编码、测试，最终投用起来之后，又有了更多的时间来学习。便开始了源码的继续阅读。</p>
<p>阅读redis源码的目的:</p>
<ul>
<li>为了之后项目如果使用redis的话能够游刃有余。</li>
<li>学习其优秀的编码。</li>
</ul>
<p>参加工作两年。</p>
<p>第一年是从机械专业学生转变为程序员，更多的是在打基础，看了挺多计算机的基础书籍。那段时间相对是痛苦的，遇到一个问题往往不明白，不断去探究又探究出一个新的不明白的问题。</p>
<p>第二年在积累了几万行之后，开始感觉基础编码方面比较游刃有余了，遇到的问题大多数能提取重点，找到解决方案。但是想着继续提升，于是开始了部分项目的源码阅读。除了公司项目源码的阅读，网上开源项目的源码阅读也提上了日程，在经过了sgi stl的仿写之后，开始了redis的阅读。</p>
<p>redis是我第一个比较完整的看完的现在流行的开源项目源码。不算中间停下来的时间，大概看了三个星期。这三个星期里不能说对redis理解很深透，但是起码整个项目的结构，怎么实现主要的功能，内部模块的互相调用算是理解了。</p>
<p>收获有很多，修炼还需要继续。</p>
]]></description>
</item><item>
    <title>redis源码阅读-一个命令的旅程</title>
    <link>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/</link>
    <pubDate>Tue, 18 Jul 2017 15:28:23 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/</guid>
    <description><![CDATA[<p>redis服务器会与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行的命令，并通过资源管理来维持整个服务器自身的运转。</p>
<p>本文目的是为了理清楚服务器对于命令请求的整个处理过程，说明这个过程中服务器与客户端如何互相交互，服务器内部如何调用内部组件达到对命令的执行。</p>
<h2 id="命令的处理流程">命令的处理流程</h2>
<p>之前在事务代码部分的阅读，已经对于服务器接收客户端的连接并创建命令请求处理器等待命令请求的过程。</p>
<p>现在以一个简单的set命令为例子，看服务器在接收请求之后如何处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">KEY</span> <span class="n">VALUE</span>
<span class="n">ok</span>
</code></pre></td></tr></table>
</div>
</div><p>从客户端发送set key value命令到接收回复ok，都做了如下操作：</p>
<ul>
<li>客户端发送命令。</li>
<li>服务器命令请求处理器接收，引发命令的执行，并产生命令回复处理器。</li>
<li>命令回复处理器发送ok给客户端。</li>
<li>客户端接收ok，并打印。</li>
</ul>
<h2 id="发送命令">发送命令</h2>
<p>客户端将键入的命令转换为协议格式并套接字发送到服务器</p>
<h2 id="读取命令">读取命令</h2>
<p>服务器发现客户端连接套接字变为可读时，通过命令请求处理器readQueryFromClient()函数来进行处理。</p>
<h3 id="读取命令到缓冲区并处理">读取命令到缓冲区并处理</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 读取客户端的查询缓冲区内容
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">readQueryFromClient</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">redisClient</span><span class="o">*</span><span class="p">)</span> <span class="n">privdata</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nread</span><span class="p">,</span> <span class="n">readlen</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">qblen</span><span class="p">;</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

    <span class="n">server</span><span class="p">.</span><span class="n">current_client</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// 设置服务器的当前客户端
</span><span class="c1"></span>    <span class="n">readlen</span> <span class="o">=</span> <span class="n">REDIS_IOBUF_LEN</span><span class="p">;</span> <span class="c1">// 读取的默认长度
</span><span class="c1"></span>    <span class="cm">/* If this is a multi bulk request, and we are processing a bulk reply
</span><span class="cm">     * that is large enough, try to maximize the probability that the query
</span><span class="cm">     * buffer contains exactly the SDS string representing the object, even
</span><span class="cm">     * at the risk of requiring more read(2) calls. This way the function
</span><span class="cm">     * processMultiBulkBuffer() can avoid copying buffers to create the
</span><span class="cm">     * Redis Object representing the argument. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">==</span> <span class="n">REDIS_REQ_MULTIBULK</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">&gt;=</span> <span class="n">REDIS_MBULK_BIG_ARG</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">remaining</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&lt;</span> <span class="n">readlen</span><span class="p">)</span> <span class="n">readlen</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 获取缓存区遗留数据长度
</span><span class="c1"></span>    <span class="n">qblen</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf_peak</span> <span class="o">&lt;</span> <span class="n">qblen</span><span class="p">)</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf_peak</span> <span class="o">=</span> <span class="n">qblen</span><span class="p">;</span> <span class="c1">// 查询缓冲区长度峰值更新
</span><span class="c1"></span>    <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="n">sdsMakeRoomFor</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span> <span class="n">readlen</span><span class="p">);</span> <span class="c1">// 重新分配查询缓冲区空间
</span><span class="c1"></span>    <span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="o">+</span><span class="n">qblen</span><span class="p">,</span> <span class="n">readlen</span><span class="p">);</span> <span class="c1">// 读取fd中数据，在遗留数据之后
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 读取错误处理
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_VERBOSE</span><span class="p">,</span> <span class="s">&#34;Reading from client: %s&#34;</span><span class="p">,</span><span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="n">freeClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 遇到EOF,关闭客户端
</span><span class="c1"></span>        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_VERBOSE</span><span class="p">,</span> <span class="s">&#34;Client closed connection&#34;</span><span class="p">);</span>
        <span class="n">freeClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 读取成功
</span><span class="c1"></span>        <span class="n">sdsIncrLen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="n">nread</span><span class="p">);</span> <span class="c1">// 正确更新 free 和 len 属性的。
</span><span class="c1"></span>        <span class="n">c</span><span class="o">-&gt;</span><span class="n">lastinteraction</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span> <span class="c1">// 记录最后一次互动时间
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_MASTER</span><span class="p">)</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">reploff</span> <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span> <span class="c1">// 客户端为master,更新复制偏移量
</span><span class="c1"></span>        <span class="n">server</span><span class="p">.</span><span class="n">stat_net_input_bytes</span> <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 在 nread == -1 且 errno == EAGAIN 时运行
</span><span class="c1"></span>        <span class="n">server</span><span class="p">.</span><span class="n">current_client</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 缓冲区长度超过服务器最大缓冲区长度
</span><span class="c1"></span>    <span class="c1">// 清空缓冲区并释放客户端
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">client_max_querybuf_len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sds</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">catClientInfoString</span><span class="p">(</span><span class="n">sdsempty</span><span class="p">(),</span><span class="n">c</span><span class="p">),</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>

        <span class="n">bytes</span> <span class="o">=</span> <span class="n">sdscatrepr</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="mi">64</span><span class="p">);</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&#34;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&#34;</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
        <span class="n">freeClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 从缓冲区中读取内容，创建参数，并执行命令
</span><span class="c1"></span>    <span class="c1">// 直到缓冲区所有的内容被处理完为止
</span><span class="c1"></span>    <span class="n">processInputBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">current_client</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="从缓冲区中读取命令并处理">从缓冲区中读取命令并处理</h3>
<p>redis的readQueryFromClient()函数在将命令读取到缓冲区之后，调用processInputBuffer()对缓冲区内的命令进行处理，直到所有命令处理完毕。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 处理客户端输入的内容
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">processInputBuffer</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Keep processing while there is something in the input buffer */</span>
    <span class="k">while</span><span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 客户端处于暂停状态，直接返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_SLAVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">clientsArePaused</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

        <span class="c1">// 客户端被阻塞直接返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_BLOCKED</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="c1">// 客户端被设置为关闭，返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_CLOSE_AFTER_REPLY</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="c1">// 判断请求类型
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">=</span> <span class="n">REDIS_REQ_MULTIBULK</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">=</span> <span class="n">REDIS_REQ_INLINE</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 将缓冲区中的内容转换为命令，以及命令参数
</span><span class="c1"></span>        <span class="c1">// processMultibulkBuffer()处理一般客户端发送的信息
</span><span class="c1"></span>      	<span class="c1">// processInlineBuffer()处理TELNET发送的信息
</span><span class="c1"></span>        <span class="c1">// 命令转换失败跳出循环，也就是可能在没有处理完缓冲区所有数据的情况下跳出。
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">==</span> <span class="n">REDIS_REQ_INLINE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">processInlineBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">==</span> <span class="n">REDIS_REQ_MULTIBULK</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">processMultibulkBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">redisPanic</span><span class="p">(</span><span class="s">&#34;Unknown request type&#34;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 命令参数为0，不需要执行
</span><span class="c1"></span>            <span class="n">resetClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 执行命令，在成功执行之后重置客户端
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">processCommand</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_OK</span><span class="p">)</span>
                <span class="n">resetClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 命令的转换介绍下processMultibulkBuffer()，此为处理客户端发送来命令，相对协议更复杂。
</span><span class="c1">// processInlineBuffer()相对协议简单就不介绍了。
</span><span class="c1"></span><span class="cm">/*
</span><span class="cm"> * 将 c-&gt;querybuf 中的协议内容转换成 c-&gt;argv 中的参数对象
</span><span class="cm"> * 
</span><span class="cm"> * 比如 *3\r\n$3\r\nSET\r\n$3\r\nMSG\r\n$5\r\nHELLO\r\n
</span><span class="cm"> * 将被转换为：
</span><span class="cm"> * argv[0] = SET
</span><span class="cm"> * argv[1] = MSG
</span><span class="cm"> * argv[2] = HELLO
</span><span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">processMultibulkBuffer</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">newline</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ok</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>

    <span class="c1">// 读取命令参数个数
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1">// 校验命令参数中&#34;\r\n&#34;的存在
</span><span class="c1"></span>        <span class="n">newline</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="sc">&#39;\r&#39;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newline</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">REDIS_INLINE_MAX_SIZE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&#34;Protocol error: too big mbulk count string&#34;</span><span class="p">);</span>
                <span class="n">setProtocolError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 异步关闭客户端
</span><span class="c1"></span>            <span class="p">}</span>
            <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">newline</span><span class="o">-</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">((</span><span class="kt">signed</span><span class="p">)</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>

        <span class="c1">// 第一个字符必须时*
</span><span class="c1"></span>        <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">);</span>

        <span class="c1">// 转换出参数的个数
</span><span class="c1"></span>        <span class="n">ok</span> <span class="o">=</span> <span class="n">string2ll</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">newline</span><span class="o">-</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="o">&amp;</span><span class="n">ll</span><span class="p">);</span>

        <span class="c1">// 检测参数个数是否超限
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span> <span class="o">||</span> <span class="n">ll</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&#34;Protocol error: invalid multibulk length&#34;</span><span class="p">);</span>
            <span class="n">setProtocolError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">pos</span><span class="p">);</span> <span class="c1">// 异步关闭客户端
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">newline</span><span class="o">-</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 参数小于等于0，删除c-&gt;querybuf中从pos到-1的内容
</span><span class="c1"></span>            <span class="c1">// 返回读取成功
</span><span class="c1"></span>            <span class="n">sdsrange</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 设置参数个数
</span><span class="c1"></span>        <span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>

        <span class="c1">// 分配参数空间
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">)</span> <span class="n">zfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">);</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">robj</span><span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 读取参数长度
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 校验命令参数中&#34;\r\n&#34;的存在
</span><span class="c1"></span>            <span class="n">newline</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="o">+</span><span class="n">pos</span><span class="p">,</span><span class="sc">&#39;\r&#39;</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">newline</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">REDIS_INLINE_MAX_SIZE</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span>
                        <span class="s">&#34;Protocol error: too big bulk count string&#34;</span><span class="p">);</span>
                    <span class="n">setProtocolError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
                    <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">newline</span><span class="o">-</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">((</span><span class="kt">signed</span><span class="p">)</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="c1">// 确认格式
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span>
                    <span class="s">&#34;Protocol error: expected &#39;$&#39;, got &#39;%c&#39;&#34;</span><span class="p">,</span>
                    <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">[</span><span class="n">pos</span><span class="p">]);</span>
                <span class="n">setProtocolError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">pos</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 读取长度
</span><span class="c1"></span>            <span class="n">ok</span> <span class="o">=</span> <span class="n">string2ll</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="o">+</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">newline</span><span class="o">-</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="o">+</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="o">&amp;</span><span class="n">ll</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span> <span class="o">||</span> <span class="n">ll</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ll</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&#34;Protocol error: invalid bulk length&#34;</span><span class="p">);</span>
                <span class="n">setProtocolError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">pos</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">newline</span><span class="o">-</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="o">+</span><span class="n">pos</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
            
            <span class="c1">// 参数太长的特殊处理
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="n">REDIS_MBULK_BIG_ARG</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">size_t</span> <span class="n">qblen</span><span class="p">;</span>

                <span class="cm">/* If we are going to read a large object from network
</span><span class="cm">                 * try to make it likely that it will start at c-&gt;querybuf
</span><span class="cm">                 * boundary so that we can optimize object creation
</span><span class="cm">                 * avoiding a large copy of data. */</span>
                <span class="n">sdsrange</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">qblen</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
                <span class="cm">/* Hint the sds library about the amount of bytes this string is
</span><span class="cm">                 * going to contain. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">qblen</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="n">ll</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="n">sdsMakeRoomFor</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="n">ll</span><span class="o">+</span><span class="mi">2</span><span class="o">-</span><span class="n">qblen</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 读取参数
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span><span class="o">-</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// 确认协议内容
</span><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">//复制参数
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">&gt;=</span> <span class="n">REDIS_MBULK_BIG_ARG</span> <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="kt">signed</span><span class="p">)</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">createObject</span><span class="p">(</span><span class="n">REDIS_STRING</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
                <span class="n">sdsIncrLen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="cm">/* remove CRLF */</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
                <span class="cm">/* Assume that if we saw a fat argument we&#39;ll see another one
</span><span class="cm">                 * likely... */</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="n">sdsMakeRoomFor</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
                    <span class="n">createStringObject</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="o">+</span><span class="n">pos</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="p">);</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span><span class="o">--</span><span class="p">;</span> <span class="c1">// 继续读取
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 清除已经读取的内容
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="n">sdsrange</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">// 读取完毕返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>

    <span class="c1">// 可能内容不符合协议返回失败
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="命令的执行">命令的执行</h2>
<p>processInputBuffer()在解析成功命令之后，调用processCommand()对命令进行执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">processInputBuffer</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  		<span class="c1">// ....
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 命令参数为0，不需要执行
</span><span class="c1"></span>            <span class="n">resetClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 执行命令，在成功执行之后重置客户端
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">processCommand</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_OK</span><span class="p">)</span>
                <span class="n">resetClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
  		<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="命令的查找">命令的查找</h3>
<p>在processCommand()执行的第一步就是查询命令表，找到对于的命令实现信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"> <span class="c1">// 命令的执行
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">processCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// quit命令特殊处理，异步关闭服务器
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&#34;quit&#34;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CLOSE_AFTER_REPLY</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 查找命令
</span><span class="c1"></span>    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lastcmd</span> <span class="o">=</span> <span class="n">lookupCommand</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 没有查找倒
</span><span class="c1"></span>        <span class="n">flagTransaction</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&#34;unknown command &#39;%s&#39;&#34;</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">arity</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">arity</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">)</span> <span class="o">||</span>
               <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">arity</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 命令实现与输入的参数数量不匹配
</span><span class="c1"></span>        <span class="n">flagTransaction</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&#34;wrong number of arguments for &#39;%s&#39; command&#34;</span><span class="p">,</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>redis维护了一个命令表，该命令表为一个字典，键为命令名字，值是一个redisCommand结构，该结构记录了一个Redis的命令实现。</p>
<p>服务器启动时，调用初始化服务器配置函数initServerConfig()，该函数会进行命令表的初始化，保存在两个字典中commands、orig_commands。原始的命令表初始参数保存在redis.c文件中的redisCommandTable定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
 	<span class="c1">// ...
</span><span class="c1"></span>    <span class="c1">// 命令表（受到 rename 配置选项的作用）
</span><span class="c1"></span>    <span class="n">dict</span> <span class="o">*</span><span class="n">commands</span><span class="p">;</span>
    <span class="c1">// 命令表（无 rename 配置选项的作用）
</span><span class="c1"></span>    <span class="n">dict</span> <span class="o">*</span><span class="n">orig_commands</span><span class="p">;</span>
  	<span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  	<span class="c1">// ...
</span><span class="c1"></span>    <span class="n">initServerConfig</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">initServerConfig</span><span class="p">()</span> <span class="p">{</span>
  	<span class="c1">// ...
</span><span class="c1"></span>  	
    <span class="c1">// 初始化命令表
</span><span class="c1"></span>  	<span class="c1">// 创建命令字典
</span><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">commands</span> <span class="o">=</span> <span class="n">dictCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commandTableDictType</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">orig_commands</span> <span class="o">=</span> <span class="n">dictCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commandTableDictType</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">populateCommandTable</span><span class="p">();</span> <span class="c1">// 初始化命令表
</span><span class="c1"></span>  
  	<span class="c1">// 初始化常用命令快捷
</span><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">delCommand</span> <span class="o">=</span> <span class="n">lookupCommandByCString</span><span class="p">(</span><span class="s">&#34;del&#34;</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">multiCommand</span> <span class="o">=</span> <span class="n">lookupCommandByCString</span><span class="p">(</span><span class="s">&#34;multi&#34;</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">lpushCommand</span> <span class="o">=</span> <span class="n">lookupCommandByCString</span><span class="p">(</span><span class="s">&#34;lpush&#34;</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">lpopCommand</span> <span class="o">=</span> <span class="n">lookupCommandByCString</span><span class="p">(</span><span class="s">&#34;lpop&#34;</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">rpopCommand</span> <span class="o">=</span> <span class="n">lookupCommandByCString</span><span class="p">(</span><span class="s">&#34;rpop&#34;</span><span class="p">);</span>
  	<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">populateCommandTable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="c1">// 命令数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">numcommands</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">redisCommandTable</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">redisCommand</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numcommands</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">redisCommandTable</span><span class="o">+</span><span class="n">j</span><span class="p">;</span> <span class="c1">// 命令
</span><span class="c1"></span>        <span class="kt">char</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sflags</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">retval1</span><span class="p">,</span> <span class="n">retval2</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">f</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">switch</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="sc">&#39;w&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_WRITE</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;r&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_READONLY</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;m&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_DENYOOM</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;a&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_ADMIN</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;p&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_PUBSUB</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_NOSCRIPT</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;R&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_RANDOM</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;S&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_SORT_FOR_SCRIPT</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;l&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_LOADING</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;t&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_STALE</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;M&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_SKIP_MONITOR</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;k&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_ASKING</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;F&#39;</span><span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_CMD_FAST</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span> <span class="n">redisPanic</span><span class="p">(</span><span class="s">&#34;Unsupported command flag&#34;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">f</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 添加
</span><span class="c1"></span>        <span class="n">retval1</span> <span class="o">=</span> <span class="n">dictAdd</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">commands</span><span class="p">,</span> <span class="n">sdsnew</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="n">c</span><span class="p">);</span>
        <span class="cm">/* Populate an additional dictionary that will be unaffected
</span><span class="cm">         * by rename-command statements in redis.conf. */</span>
        <span class="n">retval2</span> <span class="o">=</span> <span class="n">dictAdd</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">orig_commands</span><span class="p">,</span> <span class="n">sdsnew</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="n">c</span><span class="p">);</span>
        <span class="n">redisAssert</span><span class="p">(</span><span class="n">retval1</span> <span class="o">==</span> <span class="n">DICT_OK</span> <span class="o">&amp;&amp;</span> <span class="n">retval2</span> <span class="o">==</span> <span class="n">DICT_OK</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>redisCommandTable定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// Redis 命令
</span><span class="c1"></span><span class="k">struct</span> <span class="n">redisCommand</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span> <span class="c1">// 命令名
</span><span class="c1"></span>    <span class="n">redisCommandProc</span> <span class="o">*</span><span class="n">proc</span><span class="p">;</span> <span class="c1">// 实现函数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">arity</span><span class="p">;</span> <span class="c1">// 参数个数
</span><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">sflags</span><span class="p">;</span> <span class="c1">// 字符串表示FLAG
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>   <span class="c1">// 实际FLAG
</span><span class="c1"></span>    <span class="cm">/* Use a function to determine keys arguments in a command line.
</span><span class="cm">     * Used for Redis Cluster redirect. */</span>
    <span class="n">redisGetKeysProc</span> <span class="o">*</span><span class="n">getkeys_proc</span><span class="p">;</span>
    <span class="c1">// 指定哪个参数为key
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">firstkey</span><span class="p">;</span> <span class="cm">/* The first argument that&#39;s a key (0 = no keys) */</span>
    <span class="kt">int</span> <span class="n">lastkey</span><span class="p">;</span>  <span class="cm">/* The last argument that&#39;s a key */</span>
    <span class="kt">int</span> <span class="n">keystep</span><span class="p">;</span>  <span class="cm">/* The step between first and last key */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">microseconds</span><span class="p">,</span> <span class="n">calls</span><span class="p">;</span> <span class="c1">// 统计信息
</span><span class="c1"></span><span class="p">};</span>

<span class="k">struct</span> <span class="n">redisCommand</span> <span class="n">redisCommandTable</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&#34;get&#34;</span><span class="p">,</span><span class="n">getCommand</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">&#34;r&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;set&#34;</span><span class="p">,</span><span class="n">setCommand</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="s">&#34;wm&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span>
  	<span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>这样通过一个命令表，能够快捷的找到命令实现及相关参数。</p>
<h3 id="命令的执行-1">命令的执行</h3>
<p>找到命令之后即可执行命令。继续看processCommand()函数。在经过一系列特殊情况处理之后，开始执行命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 命令的执行
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">processCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  	<span class="c1">// ...查找命令
</span><span class="c1"></span>  
    <span class="c1">// 一系列特殊情况处理
</span><span class="c1"></span>
    <span class="cm">/* Exec the command */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_MULTI</span> <span class="o">&amp;&amp;</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">!=</span> <span class="n">execCommand</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">!=</span> <span class="n">discardCommand</span> <span class="o">&amp;&amp;</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">!=</span> <span class="n">multiCommand</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">!=</span> <span class="n">watchCommand</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 事务状态下的特殊处理
</span><span class="c1"></span>        <span class="n">queueMultiCommand</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">queued</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

        <span class="c1">// 执行命令
</span><span class="c1"></span>        <span class="n">call</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">REDIS_CALL_FULL</span><span class="p">);</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">woff</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span><span class="p">;</span>

        <span class="c1">// 处理那些解除阻塞的键
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">ready_keys</span><span class="p">))</span>
            <span class="n">handleClientsBlockedOnLists</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 执行命令
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">call</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">client_old_flags</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

    <span class="c1">// 命令发送倒MONITOR
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">monitors</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">loading</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_CMD_SKIP_MONITOR</span><span class="o">|</span><span class="n">REDIS_CMD_ADMIN</span><span class="p">)))</span>
    <span class="p">{</span>
        <span class="n">replicationFeedMonitors</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">monitors</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 执行命令
</span><span class="c1"></span>    <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">REDIS_FORCE_AOF</span><span class="o">|</span><span class="n">REDIS_FORCE_REPL</span><span class="p">);</span>
    <span class="n">redisOpArrayInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">.</span><span class="n">also_propagate</span><span class="p">);</span>
    <span class="n">dirty</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">dirty</span><span class="p">;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">ustime</span><span class="p">();</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// 命令实现函数
</span><span class="c1"></span>    <span class="n">duration</span> <span class="o">=</span> <span class="n">ustime</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">;</span> <span class="c1">// 执行时间
</span><span class="c1"></span>    <span class="n">dirty</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">dirty</span><span class="o">-</span><span class="n">dirty</span><span class="p">;</span> <span class="c1">// 命令执行dirty的数量
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// ... 一系列附加操作
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最终调用到setCommand(redisClient *c)函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* SET key value [NX] [XX] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;] */</span>
<span class="kt">void</span> <span class="nf">setCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">expire</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">UNIT_SECONDS</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">REDIS_SET_NO_FLAGS</span><span class="p">;</span>

    <span class="c1">// 设置选项参数
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
        <span class="n">robj</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;n&#39;</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;N&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;X&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_SET_NX</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;X&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                   <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;X&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_SET_XX</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;e&#39;</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                   <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;X&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">UNIT_SECONDS</span><span class="p">;</span>
            <span class="n">expire</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;p&#39;</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;P&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                   <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;X&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">UNIT_MILLISECONDS</span><span class="p">;</span>
            <span class="n">expire</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">syntaxerr</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 尝试编码转换
</span><span class="c1"></span>    <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tryObjectEncoding</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="c1">// set命令通用的实现
</span><span class="c1"></span>    <span class="n">setGenericCommand</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">flags</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">expire</span><span class="p">,</span><span class="n">unit</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">setGenericCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">expire</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unit</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">ok_reply</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">abort_reply</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">milliseconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* initialized to avoid any harmness warning */</span>

    <span class="c1">// 取出过期时间 expire为过期时间参数
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">expire</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getLongLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">expire</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">milliseconds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">milliseconds</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&#34;invalid expire time in %s&#34;</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unit</span> <span class="o">==</span> <span class="n">UNIT_SECONDS</span><span class="p">)</span> <span class="n">milliseconds</span> <span class="o">*=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 如果REDIS_SET_NX REDIS_SET_XX 判断是否符合规范
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_SET_NX</span> <span class="o">&amp;&amp;</span> <span class="n">lookupKeyWrite</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_SET_XX</span> <span class="o">&amp;&amp;</span> <span class="n">lookupKeyWrite</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">abort_reply</span> <span class="o">?</span> <span class="nl">abort_reply</span> <span class="p">:</span> <span class="n">shared</span><span class="p">.</span><span class="n">nullbulk</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 设置键
</span><span class="c1"></span>    <span class="n">setKey</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">dirty</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 脏计数增加
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">expire</span><span class="p">)</span> <span class="n">setExpire</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">mstime</span><span class="p">()</span><span class="o">+</span><span class="n">milliseconds</span><span class="p">);</span> <span class="c1">// 设置过期时间
</span><span class="c1"></span>    <span class="n">notifyKeyspaceEvent</span><span class="p">(</span><span class="n">REDIS_NOTIFY_STRING</span><span class="p">,</span><span class="s">&#34;set&#34;</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span> <span class="c1">// 发送事件通知
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">expire</span><span class="p">)</span> <span class="n">notifyKeyspaceEvent</span><span class="p">(</span><span class="n">REDIS_NOTIFY_GENERIC</span><span class="p">,</span>
        <span class="s">&#34;expire&#34;</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span><span class="c1">// 发送事件通知
</span><span class="c1"></span>    <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ok_reply</span> <span class="o">?</span> <span class="nl">ok_reply</span> <span class="p">:</span> <span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span> <span class="c1">// 回复
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="回复客户端">回复客户端</h2>
<p>在执行命令出错或者成功后使用addReply()生成回复信息，该函数将通过prepareClientToWrite()产生回复客户端的文件事件，同时将回复内容复制到回复缓存区。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">addReply</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">prepareClientToWrite</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// 生成回复客户端的文件事件
</span><span class="c1"></span>
    <span class="c1">// 根据不同情况，生成回复内容,写入不同的缓冲区
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">sdsEncodedObject</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_addReplyToBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">))</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span>
            <span class="n">_addReplyObjectToList</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">REDIS_ENCODING_INT</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Optimization: if there is room in the static buffer for 32 bytes
</span><span class="cm">         * (more than the max chars a 64 bit integer can take as string) we
</span><span class="cm">         * avoid decoding the object and go for the lower level approach. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

            <span class="n">len</span> <span class="o">=</span> <span class="n">ll2string</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),(</span><span class="kt">long</span><span class="p">)</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_addReplyToBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_OK</span><span class="p">)</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="cm">/* else... continue with the normal code path, but should never
</span><span class="cm">             * happen actually since we verified there is room. */</span>
        <span class="p">}</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">getDecodedObject</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_addReplyToBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">))</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span>
            <span class="n">_addReplyObjectToList</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
        <span class="n">decrRefCount</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">redisPanic</span><span class="p">(</span><span class="s">&#34;Wrong obj-&gt;encoding in addReply()&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">prepareClientToWrite</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// lua 脚本伪客户端
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_LUA_CLIENT</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>

    <span class="c1">// 客户端为REDIS_MASTER REDIS_MASTER_FORCE_REPLY
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_MASTER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_MASTER_FORCE_REPLY</span><span class="p">))</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span> <span class="cm">/* Fake client for AOF loading. */</span>

    <span class="c1">// 一般的客户端生成写事件
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">listLength</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_NONE</span> <span class="o">||</span>
         <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_ONLINE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_put_online_on_ack</span><span class="p">)))</span>
    <span class="p">{</span>
        <span class="cm">/* Try to install the write handler. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">AE_WRITABLE</span><span class="p">,</span>
                <span class="n">sendReplyToClient</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Authorize the caller to queue in the output buffer of this client. */</span>
    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最终文件事件调用sendReplyToClient()回复客户端。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">sendReplyToClient</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">privdata</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">totwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">objlen</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">objmem</span><span class="p">;</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

    <span class="c1">// 从缓存区获取数据，写入，直到写完
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">listLength</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 先写入回复缓冲区数据
</span><span class="c1"></span>            <span class="n">nwritten</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">+</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span><span class="o">-</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 出错跳出
</span><span class="c1"></span>
            <span class="c1">// 成功计数
</span><span class="c1"></span>            <span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>
            <span class="n">totwritten</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>

            <span class="c1">// 如果内容写完则清空两个计数器
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

            <span class="c1">// 回复缓冲区为空的话，在回复链表查找
</span><span class="c1"></span>            <span class="n">o</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">listFirst</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">));</span>
            <span class="n">objlen</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
            <span class="n">objmem</span> <span class="o">=</span> <span class="n">getStringObjectSdsUsedMemory</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>

            <span class="c1">// 跳过空对象
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">objlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">listDelNode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">,</span><span class="n">listFirst</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">));</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">reply_bytes</span> <span class="o">-=</span> <span class="n">objmem</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 写入
</span><span class="c1"></span>            <span class="n">nwritten</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span><span class="o">+</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span><span class="p">,</span><span class="n">objlen</span><span class="o">-</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 出错跳出
</span><span class="c1"></span>
            <span class="c1">// 计数
</span><span class="c1"></span>            <span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>
            <span class="n">totwritten</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>

            <span class="c1">// 如果汉冲去内容写入完毕，删除已经写入的节点
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span> <span class="o">==</span> <span class="n">objlen</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">listDelNode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">,</span><span class="n">listFirst</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">));</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">reply_bytes</span> <span class="o">-=</span> <span class="n">objmem</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 写入量超过限制 在最大内存没设或者最大内存没使用完的情况下跳出
</span><span class="c1"></span>        <span class="n">server</span><span class="p">.</span><span class="n">stat_net_output_bytes</span> <span class="o">+=</span> <span class="n">totwritten</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">totwritten</span> <span class="o">&gt;</span> <span class="n">REDIS_MAX_WRITE_PER_EVENT</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
             <span class="n">zmalloc_used_memory</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 写入出错
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_VERBOSE</span><span class="p">,</span>
                <span class="s">&#34;Error writing to client: %s&#34;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="n">freeClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">totwritten</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* For clients representing masters we don&#39;t count sending data
</span><span class="cm">         * as an interaction, since we always send REPLCONF ACK commands
</span><span class="cm">         * that take some time to just fill the socket output buffer.
</span><span class="cm">         * We just rely on data / pings received for timeout detection. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_MASTER</span><span class="p">))</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lastinteraction</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">listLength</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// 写完了删除write handler
</span><span class="c1"></span>        <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_WRITABLE</span><span class="p">);</span>

        <span class="c1">// 必要的话关闭客户端
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_CLOSE_AFTER_REPLY</span><span class="p">)</span> <span class="n">freeClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="结束">结束</h2>
<p>至此一个命令的旅程就结束了。</p>]]></description>
</item><item>
    <title>redis源码阅读-事件</title>
    <link>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/</link>
    <pubDate>Sun, 16 Jul 2017 22:24:01 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/</guid>
    <description><![CDATA[<h1 id="redis源码阅读-事件">redis源码阅读-事件</h1>
<p>redis服务器是一个事件驱动程序。当触发一个事件时,redis会创建一个事件,放入到待处理的队列，依次进行处理。</p>
<p>redis事件分为文件时间和时间事件。</p>
<p>文件事件：文件事件是对套接字操作的抽象，当服务器与客户端进行通讯，会产生出各种文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通讯操作。</p>
<p>时间事件：redis一些操作是需要定时进行执行的，而时间事件就是对这类操作的抽象。</p>
<h2 id="事件的实现">事件的实现</h2>
<p>以下是事件结构体定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* File event structure */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeFileEvent</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span> <span class="c1">// one of AE_(READABLE|WRITABLE) 类型
</span><span class="c1"></span>    <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">rfileProc</span><span class="p">;</span> <span class="c1">// 读事件处理器
</span><span class="c1"></span>    <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">wfileProc</span><span class="p">;</span> <span class="c1">// 写事件处理器
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">;</span> <span class="c1">// 多路复用库的私有数据
</span><span class="c1"></span><span class="p">}</span> <span class="n">aeFileEvent</span><span class="p">;</span>

<span class="cm">/* Time event structure */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeTimeEvent</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>  <span class="c1">// 唯一标志
</span><span class="c1"></span>    <span class="kt">long</span> <span class="n">when_sec</span><span class="p">;</span> <span class="c1">// 事件到达事件s
</span><span class="c1"></span>    <span class="kt">long</span> <span class="n">when_ms</span><span class="p">;</span>  <span class="c1">// 事件到达事件ms
</span><span class="c1"></span>    <span class="n">aeTimeProc</span> <span class="o">*</span><span class="n">timeProc</span><span class="p">;</span> <span class="c1">// 事件处理函数
</span><span class="c1"></span>    <span class="n">aeEventFinalizerProc</span> <span class="o">*</span><span class="n">finalizerProc</span><span class="p">;</span> <span class="c1">// 事件释放函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">;</span> <span class="c1">// 多路复用库的私有数据
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="c1">//　指向下一个时间事件结构，形成链表
</span><span class="c1"></span><span class="p">}</span> <span class="n">aeTimeEvent</span><span class="p">;</span>

<span class="cm">/* A fired event */</span>
<span class="c1">// 触发的事件结构体
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeFiredEvent</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span> <span class="c1">// 文件事件描述符
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>　<span class="c1">// one of AE_(READABLE|WRITABLE) 类型
</span><span class="c1"></span><span class="p">}</span> <span class="n">aeFiredEvent</span><span class="p">;</span>

<span class="c1">// 事件循环结构体
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxfd</span><span class="p">;</span>   <span class="c1">// 当前注册的最大描述符
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">setsize</span><span class="p">;</span> <span class="c1">// 需要监听的描述符个数
</span><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">timeEventNextId</span><span class="p">;</span> <span class="c1">// 下一个时间事件ID
</span><span class="c1"></span>    <span class="n">time_t</span> <span class="n">lastTime</span><span class="p">;</span>     <span class="c1">// 上一次时间循环时间
</span><span class="c1"></span>    <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span> <span class="c1">// 注册要使用的文件时间
</span><span class="c1"></span>    <span class="n">aeFiredEvent</span> <span class="o">*</span><span class="n">fired</span><span class="p">;</span> <span class="c1">// 已准备好，待处理事件
</span><span class="c1"></span>    <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">timeEventHead</span><span class="p">;</span> <span class="c1">// 时间事件
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">stop</span><span class="p">;</span> <span class="c1">// 事件处理器开关
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">apidata</span><span class="p">;</span> <span class="c1">// 处理多路服用库的私有数据
</span><span class="c1"></span>    <span class="n">aeBeforeSleepProc</span> <span class="o">*</span><span class="n">beforesleep</span><span class="p">;</span> <span class="c1">// 处理事件前要执行的函数
</span><span class="c1"></span><span class="p">}</span> <span class="n">aeEventLoop</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="事件处理流程">事件处理流程</h2>
<p>redis使用i/o多路复用程序同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。文件处理流程如图。时间事件则定时执行。</p>

图片(来自《Redis设计与实现》
## 事件的API
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Prototypes */</span>
<span class="n">aeEventLoop</span> <span class="o">*</span><span class="nf">aeCreateEventLoop</span><span class="p">(</span><span class="kt">int</span> <span class="n">setsize</span><span class="p">);</span> <span class="c1">// 初始化时间处理器状态
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">aeDeleteEventLoop</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">);</span> <span class="c1">// 删除事件处理器
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">aeStop</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">);</span> <span class="c1">// 停止事件处理器
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">aeCreateFileEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span>
        <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">);</span> <span class="c1">// 根据mask参数，监听fd文件的状态，fd可用，执行proc函数
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">aeDeleteFileEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span><span class="c1">// 将fd从mask指定的监听队列中删除
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">aeGetFileEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">);</span> <span class="c1">// 获取给定fd正在监听的事件类型
</span><span class="c1"></span><span class="kt">long</span> <span class="kt">long</span> <span class="nf">aeCreateTimeEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">milliseconds</span><span class="p">,</span>
        <span class="n">aeTimeProc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">,</span>
        <span class="n">aeEventFinalizerProc</span> <span class="o">*</span><span class="n">finalizerProc</span><span class="p">);</span> <span class="c1">// 创建时间事件
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">aeDeleteTimeEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span><span class="p">);</span> <span class="c1">// 删除给定ID的时间事件
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">aeProcessEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span> <span class="c1">// 处理所有已经到达时间的事件，以及所有就绪的文件事件
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">aeWait</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">milliseconds</span><span class="p">);</span> <span class="c1">// 指定时间等待fd变为可读、可写
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">aeMain</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">);</span><span class="c1">// 事件处理主循环
</span><span class="c1"></span><span class="kt">char</span> <span class="o">*</span><span class="nf">aeGetApiName</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// 返回所使用的多路服用库的名字
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">aeSetBeforeSleepProc</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">aeBeforeSleepProc</span> <span class="o">*</span><span class="n">beforesleep</span><span class="p">);</span> <span class="c1">// 设置事件前所需要执行的函数
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">aeGetSetSize</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">);</span> <span class="c1">// 返回当前事件槽大小
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">aeResizeSetSize</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">setsize</span><span class="p">);</span> <span class="c1">// 调整事件槽大小
</span></code></pre></td></tr></table>
</div>
</div><h2 id="文件事件的创建">文件事件的创建</h2>
<p>文件事件有三个方面需要创建：</p>
<ul>
<li>连接应答处理器，用来处理对连接服务器监听套接字的客户端进行应答。</li>
<li>命令请求处理器，用来处理从套接字读取客户端发送的命令请求内容。</li>
<li>命令回复处理器，用来处理执行命令后得到的命令回复通过套接字返回给客户端。</li>
</ul>
<h3 id="连接应答处理器">连接应答处理器</h3>
<p>acceptTcpHandler是连接应答处理器，当监听套接字产生AE_READABLE事件时，就会引发连接应答处理器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">initServer</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="c1">// 为 TCP 连接关联连接应答（accept）处理器
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">ipfd_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">ipfd</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">AE_READABLE</span><span class="p">,</span>
            <span class="n">acceptTcpHandler</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">redisPanic</span><span class="p">(</span>
                    <span class="s">&#34;Unrecoverable error creating server.ipfd file event.&#34;</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 为本地套接字关联应答处理器
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">sofd</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">sofd</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="p">,</span>
        <span class="n">acceptUnixHandler</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span> <span class="n">redisPanic</span><span class="p">(</span><span class="s">&#34;Unrecoverable error creating server.sofd file event.&#34;</span><span class="p">);</span>
  	<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="命令请求处理器">命令请求处理器</h3>
<p>在连接应答处理器调用的函数acceptTcpHandler中，会在连接成功之后，创建命令请求处理器readQueryFromClient()，在客户端发送的命令请求时，调用命令请求处理器进行处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 创建一个 TCP 连接处理器
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">acceptTcpHandler</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cport</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="n">max</span> <span class="o">=</span> <span class="n">MAX_ACCEPTS_PER_CALL</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">cip</span><span class="p">[</span><span class="n">REDIS_IP_STR_LEN</span><span class="p">];</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">privdata</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="n">max</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// accept 客户端连接
</span><span class="c1"></span>        <span class="n">cfd</span> <span class="o">=</span> <span class="n">anetTcpAccept</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">cip</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cip</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cport</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cfd</span> <span class="o">==</span> <span class="n">ANET_ERR</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EWOULDBLOCK</span><span class="p">)</span>
                <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
                    <span class="s">&#34;Accepting client connection: %s&#34;</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_VERBOSE</span><span class="p">,</span><span class="s">&#34;Accepted %s:%d&#34;</span><span class="p">,</span> <span class="n">cip</span><span class="p">,</span> <span class="n">cport</span><span class="p">);</span>

      	<span class="c1">// 连接完成，创建一个客户端状态
</span><span class="c1"></span>        <span class="n">acceptCommonHandler</span><span class="p">(</span><span class="n">cfd</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define MAX_ACCEPTS_PER_CALL 1000
</span><span class="cp"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">acceptCommonHandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 创建客户端
</span><span class="c1"></span>    <span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">createClient</span><span class="p">(</span><span class="n">fd</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
            <span class="s">&#34;Error registering fd event for the new client: %s (fd=%d)&#34;</span><span class="p">,</span>
            <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">),</span><span class="n">fd</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span> <span class="cm">/* May be already closed, just ignore errors */</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 达到上限
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">maxclients</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="s">&#34;-ERR max number of clients reached</span><span class="se">\r\n</span><span class="s">&#34;</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">err</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span>
        <span class="c1">// 更新拒绝连接数
</span><span class="c1"></span>        <span class="n">server</span><span class="p">.</span><span class="n">stat_rejected_conn</span><span class="o">++</span><span class="p">;</span>
        <span class="n">freeClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  
    <span class="n">server</span><span class="p">.</span><span class="n">stat_numconnections</span><span class="o">++</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">redisClient</span> <span class="o">*</span><span class="nf">createClient</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">redisClient</span><span class="p">));</span>

    <span class="c1">// -1时使用的是无网络连接的伪客户端
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">anetNonBlock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">fd</span><span class="p">);</span> <span class="c1">// 非阻塞
</span><span class="c1"></span>        <span class="n">anetEnableTcpNoDelay</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">fd</span><span class="p">);</span> <span class="c1">// 关闭nagle算法，那个合并小报文的算法
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">tcpkeepalive</span><span class="p">)</span>
            <span class="n">anetKeepAlive</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">tcpkeepalive</span><span class="p">);</span>

        <span class="c1">// 创建命令请求处理器
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="p">,</span>
            <span class="n">readQueryFromClient</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
            <span class="n">zfree</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
	<span class="c1">// 客户端的初始化
</span><span class="c1"></span>  	<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="命令回复处理器">命令回复处理器</h3>
<p>当服务器有命令回复需要传送给客户端时，服务器将客户端套接字的AE_WRITABLE事件与命令回复处理器关联，当客户端准备好接收时，就会执行AE_WRITABLE事件，触发命令回复处理器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">prepareClientToWrite</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_LUA_CLIENT</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_MASTER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_MASTER_FORCE_REPLY</span><span class="p">))</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span> <span class="cm">/* Fake client */</span>

    <span class="c1">// 为客户端套接字安装写处理器到事件循环
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">listLength</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_NONE</span> <span class="o">||</span>
         <span class="n">c</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_ONLINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">AE_WRITABLE</span><span class="p">,</span>
        <span class="n">sendReplyToClient</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="时间事件的创建">时间事件的创建</h2>
<p>redis在初始化时创建时间时间，用来周期执行serverCron()。</p>
<p>serverCron()主要功能：</p>
<ul>
<li>更新服务器的各类统计信息</li>
<li>清理过期的键值对</li>
<li>关闭和清理连接失效的客户端</li>
<li>尝试AOF\RDB持久化</li>
<li>主服务器则定期同步</li>
<li>集群模式，对集群定期同步和连接测试</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">initServer</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// ...
</span><span class="c1"></span>    <span class="c1">// 为 serverCron() 创建时间事件
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">aeCreateTimeEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">serverCron</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisPanic</span><span class="p">(</span><span class="s">&#34;Can&#39;t create the serverCron time event.&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  	<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="事件循环">事件循环</h2>
<p>事件循环主函数为aeMain()，该函数在redis的main()函数中被调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  	<span class="c1">// ...
</span><span class="c1"></span>    <span class="c1">// 运行事件处理器，一直到服务器关闭为止
</span><span class="c1"></span>    <span class="n">aeSetBeforeSleepProc</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">beforeSleep</span><span class="p">);</span> <span class="c1">// 设置事件前调用函数
</span><span class="c1"></span>    <span class="n">aeMain</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">);</span>
  
    <span class="c1">// 服务器关闭，停止事件循环
</span><span class="c1"></span>    <span class="n">aeDeleteEventLoop</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="err">｝</span>
</code></pre></td></tr></table>
</div>
</div><p>事件循环的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 事件处理器的主循环
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">aeMain</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果有需要在事件处理前执行的函数，那么运行它
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>

        <span class="c1">// 开始处理事件
</span><span class="c1"></span>        <span class="n">aeProcessEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">AE_ALL_EVENTS</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 事件处理函数
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">aeProcessEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numevents</span><span class="p">;</span>

    <span class="c1">// 没有需要处理的事件则返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_FILE_EVENTS</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
        <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">)))</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">shortest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">,</span> <span class="o">*</span><span class="n">tvp</span><span class="p">;</span>

        <span class="c1">// 获取最近的时间事件
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">))</span>
            <span class="n">shortest</span> <span class="o">=</span> <span class="n">aeSearchNearestTimer</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shortest</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">long</span> <span class="n">now_sec</span><span class="p">,</span> <span class="n">now_ms</span><span class="p">;</span>

            <span class="cm">/* Calculate the time missing for the nearest
</span><span class="cm">             * timer to fire. */</span>
            <span class="n">aeGetTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now_sec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now_ms</span><span class="p">);</span>
            <span class="n">tvp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">;</span>
            <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">shortest</span><span class="o">-&gt;</span><span class="n">when_sec</span> <span class="o">-</span> <span class="n">now_sec</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">shortest</span><span class="o">-&gt;</span><span class="n">when_ms</span> <span class="o">&lt;</span> <span class="n">now_ms</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">((</span><span class="n">shortest</span><span class="o">-&gt;</span><span class="n">when_ms</span><span class="o">+</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-</span> <span class="n">now_ms</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">;</span>
                <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">--</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">(</span><span class="n">shortest</span><span class="o">-&gt;</span><span class="n">when_ms</span> <span class="o">-</span> <span class="n">now_ms</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 获取要执行事件事件，要等待的时间
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 没有时间事件
</span><span class="c1"></span>            <span class="c1">// 根据AE_DONT_WAIT参数来设置文件事件的阻塞、阻塞时间
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">tvp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* Otherwise we can block */</span>
                <span class="n">tvp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* wait forever */</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 调用io复用函数获取准备好的事件，底层使用select或epoll或其他实现
</span><span class="c1"></span>      	<span class="c1">// tvp阻塞时间
</span><span class="c1"></span>        <span class="n">numevents</span> <span class="o">=</span> <span class="n">aeApiPoll</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">tvp</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 获取所有能够执行的文件事件，并执行
</span><span class="c1"></span>            <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">rfired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	        <span class="cm">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed
</span><span class="cm">             * event removed an element that fired and we still didn&#39;t
</span><span class="cm">             * processed, so we check if the event is still valid. */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 读事件
</span><span class="c1"></span>                <span class="n">rfired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="p">{</span>

                <span class="c1">// 写事件
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfired</span> <span class="o">||</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">!=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">)</span>
                    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">processed</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* Check time events */</span>
    <span class="c1">// 执行时间事件，在阻塞等待一段时间之后，时间事件已经能够执行
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span>
        <span class="n">processed</span> <span class="o">+=</span> <span class="n">processTimeEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span> <span class="cm">/* return the number of processed file/time events */</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="小结">小结</h2>
<p>事件其实不算复杂，整个redis没有太多的事件。但是要理解IO多路服用和redis事件的调用逻辑。理清楚之后就比较好办了。</p>]]></description>
</item></channel>
</rss>
