<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>鉴心</title>
        <link>http://coderyang.com/</link>
        <description>About LoveIt Theme</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 24 Feb 2021 09:26:09 &#43;0800</lastBuildDate>
            <atom:link href="http://coderyang.com/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>设计模式的个人总结</title>
    <link>http://coderyang.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</link>
    <pubDate>Wed, 24 Feb 2021 09:26:09 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[创建型模式  工厂方法  简单来说就是提供一个create方法 代码两个变化方向，一个是子类的扩展，一个是框架层的不变。 另外还有一种用法和单例有点像，提供一个create接口，但是返回的可能是公用的对象。   抽象工厂  单个类里有很好个create方法，用于创建不同的产品。 一般把创建操作独立成一个类A，然后组合进另一个类B。类B利用类A的接口完成具体的业务。   生成器  和抽象工厂有点像的，只是这里更强调步骤。生成器是把步骤隐藏，抽象工厂的步骤是不变的。 两个变化的方向，一个是创建不同的产品、一个是构建步骤不同，导致有两个继承树。   原型  就是一个clone接口，能够从已有的类copy一个新的出来。 比较适合的场景 怪物、AI的创建，怪物种类太多了，那么直接按照怪物的行为划分更下层的子类，通过组合的形式构造出来成千上万种怪物。 深入设计模式这种还要搞一个prototype继承树有点二，在游戏里组合用的更多些。   单例  全局访问点、通过封装保证只会创建出一个、延迟初始化 用的太多了，不过要写出一个线程安全的单例其实不容易。 隐式的构造时机，可能导致隐藏bug，不适合服务器场景，服务器要求行为固定 全局只能有一个对象，好处是调用可以少穿一个参数，坏处就是这个全局只有一个对象的限制很蛋痛，没法扩展成多个。    结构型模式  适配器  简单说就是套个壳，伪装成另外一种东西。非常朴素的一种设计模式，很常用。 装饰模式和适配器不太一样，装饰主要是想偷偷做一点其他事情。   桥接  功能和名字匹配，两种不同类型对象的中间连接的部分。 对象可以独立扩展，桥接部分也能独立扩展，这里面有三个变化的方向。   组合  同一类对象组合成一个大对象，偶尔用。 组合的模式可以有多种：并列、树等等。 使用范围有限，大部分类这样组合起来语义上就不通了。   装饰  简单来说就是穿一层衣服，增强功能。   外观  相当于一个大的模块，提供一个api类，把对外暴露的接口都放在这个类里。 使用者就不用关心模块内部的实现，最简单做法就是搞一个api.hpp暴露一些全局函数。 一个模块可以提供好几个外观。   享元  省内存，最常见的就是文字处理程序依靠该模式处理字符串。 游戏行业有很多特效、物件都可以用这个方法处理。   代理  非常常用的模式，比如数据库代理、RPC stub。 代理模式提供相同的接口，但是真实对象在另外的地方。    行为模式  责任链  常见于消息处理，一个消息过来，被一个链条下的handle消费。 有两种做法，一种是调用下一个节点由框架来做，一种是由节点来做。 节点来做比较适合插入时间统计的代码，这个节点相当于下一个节点的装饰器。然后也可以根据业务看是否取消继续调用，适合做拦截器。 形式可以不是链状，树也行，随意啥形状都行。   命令  游戏行业用的比较多的就是对同一个玩家输入的操作执行不同的响应。 本质上是框架复用。   迭代器：没啥好说的，框架复用，迭代模式任意扩展，stl用的太多了。 中介者  依赖导致，解除类之间互相调用产生的网状结构。 网状结构没了，都依赖中介者，这样只要改中介者，代码更容易改。   备忘录  用的很少的一个模式，就是把状态从对象中剥离，可以任意恢复状态。   观察者：  天天用的玩意，解耦，依赖倒置。 通知没有顺序，调用关系隐蔽，重入风险。   状态：和命令模式类似，是为了对同一个行为产生不同的反应，但是状态模式操作是一组的。 策略  代码分成两部分，上下文和策略，策略能独立扩展，上下文不变。 和命令模式有点像，不过目的不一样，命令不强调这个上下文。   模板方法：框架复用，和模板差不多，替换几个预设的步骤。 访问者：  双分发，不是很好用的一个模式，子类扩展还要改visitor。 框架复用，visitor就是一个遍历，然后每种类型对象调用不通的接口，接口的    ]]></description>
</item><item>
    <title>一致性与共识算法</title>
    <link>http://coderyang.com/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/</link>
    <pubDate>Mon, 18 Jan 2021 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/</guid>
    <description><![CDATA[本文从《数据密集型引用系统设计》、Paxos lecture (Raft user study)（https://www.youtube.com/watch?v=JEpsBg0AO6o） 各截取了部分。
挑战 故障 数据：
 磁盘: 4% 年损坏率 服务器宕机时间: 0.1% 或更长 IDC间丢包率: 5% ~ 30%  下面是几种分布式系统下典型的问题：
 当通过网络发送数据包时，数据包可能会丢失或者延迟。同样，回复也可能会丢失或延迟。所以如果没有收到回复，并不能确定消息是否发送成功。 节点的时钟可能会与其他节点存在明显的不同步，时钟还可能会突然向前跳跃或者倒退，依靠精准的时钟存在一些风险，没有特别简单的方法来精确测量时钟的偏差范围。 进程可能在执行过程中的任意时候遭遇长度未知的暂停（一个重要的原因是垃圾回收），结果它被其他节点宣告失效，尽管后来又恢复执行，却对中间的暂停毫无所知。  部分失效可能是分布式系统的关键特征。只要软件试图跨节点做任何失效，就有可能出现失败，或者随机变慢，或者根本无应答（最终超时）。对于分布式环境，我们目标是建立容忍部分失效的软件系统，这样即使某些部件发生失效，系统整体还可以继续运行。
线性化与CAP理论 线性化：表现得好像只有一个数据副本，且其上的所有操作都是原子的。
为什么要线性化？
非线性化系统的问题：
上面违背线性化只产生了一个比较小的问题，仅仅是展示页面不一致。但是如果核心业务违背线性化，可能导致严重问题。常见的就是集群选主，可能会出现两个主，导致脑裂。
常见复制算法，对线性化的支持：
 主从复制（部分支持）  只有主写入读取的话，其他都是备份的情况下，是线性化的。但是不能做高高可用。 异步复制、主脑裂、从读等情况，不可线性化。   多主复制（不可线性化）  多副本冲突   无主复制（可能不可线性化）  能够实现高可靠、高可用性、数据完整有保证 会出现脏读、更新丢失等情况 具体看ddia吧，不展开了，用的比较少   共识算法（可线性化）  具体之后讨论。    线性化的代价以及CAP理论：
FLP FLP 不可能定理是分布式系统领域最重要的定理之一，它给出了一个非常重要的结论：在网络可靠并且存在节点失效的异步模型系统中，不存在一个可以解决一致性问题的确定性算法。
 In this paper, we show the surprising result that no completely asynchronous consensus protocol can tolerate even a single unannounced process death.]]></description>
</item><item>
    <title>高性能libcurl</title>
    <link>http://coderyang.com/libcurl/</link>
    <pubDate>Sat, 14 Nov 2020 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/libcurl/</guid>
    <description><![CDATA[本文主要介绍一下curl接口的使用方法，以及获取高性能的一些实践。
什么是libcurl？用处？ 1  libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more!   官网摘的一段，意思大概是免费且容易使用的url传输库，支持下面一堆特性。]]></description>
</item><item>
    <title>简易function</title>
    <link>http://coderyang.com/function/</link>
    <pubDate>Sat, 19 Sep 2020 16:04:59 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/function/</guid>
    <description><![CDATA[本文主要讲一下怎么实现一个简易版本的function&lt;&gt;模板，从c++ templates第二版摘出。
出发点 一个简单的例子，下面这个模板上述能够接受任意可调用的对象，lambda表达式、函数指针、仿函数。
1 2 3 4 5 6 7  template&lt;typename F&gt; void for_int_up(int n, F f) { for (int i = 0; i &lt;= n; ++i) { f(i); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void print_int(int i) { std::count &lt;&lt; i &lt;&lt; &#39; &#39;; } int main() { int sum = 0; for_int_up(5, [&amp;sum](int i) { sum += i; }); for_int_up(5, print_int); return 0; }   像for_int_up这样的函数其实有两个问题：]]></description>
</item><item>
    <title>读书摘录-存在主义心理治疗</title>
    <link>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97/</link>
    <pubDate>Sat, 29 Dec 2018 08:31:58 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97/</guid>
    <description><![CDATA[本书涉及四个终极关怀:死亡、自由、孤独和无意义。个体与这些生命真相的正面交锋，构成了存在主义动力性冲突的内容。
死亡。最显而易见的、最容易理解的终极关怀就是死亡。我们现在存在，但是总有一天，这种存在会终止。死亡将如期而至，没有逃脱之路。这是一个恐怖的真相，能引发我们巨大的恐惧。用斯宾诺莎的话来说，“每一事物都在尽力维持自身的存在”；而存在的一个核心冲突就是，对死亡必然性的意识与继续生存下去的愿望之间的张力。
自由。另一个相对来说不太容易理解的终极关怀是自由。一般来说我们都认为自由是一个毋庸置疑的积极概念。有史以来，人类不是一直在渴望并为自由而奋斗吗？然而从终极层面来看，自由是与忧惧偶联在一起的。在存在的意义上，“自由”意味着外部结构的空白。与日常经验相反的是，人类并不是进入（和离开）一个拥有内在设计、高度结构化的宇宙。实际上，个体对他自己的世界、生活设计、选择以及行为负有全部责任——也就是说，个体是自己世界的创造者。“自由”在这种含义上，带有一种可怕的暗示:它意味着在我们所站立的地方并不坚实一什么都没有，是空的，无底深渊。所以，存在主义一个关键的动力性冲突就是，们无根基的处境与我们对根基与结构的渴望之间的冲突。
存在性孤独。第三个终极关怀是孤独不是伴随着寂寞的人际性孤独，也不是个人内心的孤独（与自身的其他部分隔离），而是一种根本性孤独既与生命隔绝，也与世界隔绝—隔绝在所有其他孤独之下。无论我们之间变得有多么亲密无间，仍然存在一个最终无法逾越的鸿沟；我们每个人都是独自一人进入这种存在，同时也注定要独自离开。一方面是我们对自身绝对孤独的意识，另一方面是对接触、保护的渴望，以及成为一个更大整体的一部分的愿望在性冲突就是这两个方面之间的张力。
无意义。第四个终极关怀或存在的既定事实是无意义。如果我们注定得死，如果我们构建我们自己的世界，如果每一个人最终都是独自一人身处于一个无关紧要的世界之中，那么生命有什么意义我们为什么要活着？我们应该怎样活着？如果并不存在为我们预先设计的蓝图，那么我们每个人就必须构建自己的生命意义。然而，个人自己创造出来的意义能否坚强到令其能容忍生活？人类这种寻找意义的生物，却被投入到本身毫无意义的宇宙之中，于是，存在的动力性冲突便从进退维谷的境地中滋生出来。]]></description>
</item><item>
    <title>我的2018</title>
    <link>http://coderyang.com/%E6%88%91%E7%9A%842018/</link>
    <pubDate>Sun, 23 Dec 2018 08:31:58 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E6%88%91%E7%9A%842018/</guid>
    <description><![CDATA[距离上次博客又过去了几个月。自从换了工作之后时间总是比较紧张，一直是996的节奏。每周只有一天的休息日，往往这天会安排着调整下节奏、与朋友聚会，属于自己独处的时间减少了。
当然这不是不写博客的理由了，核心原因还是懒，毕竟真想做什么，怎么都能挤出时间。
一年的总结 2018对我来说过得很慢的一年，一年里做了挺多的事情。我自己对过去的一年还算满意。
没有女朋友：意识到自己的年龄也挺大了，但是还没有女朋友。
学会了做饭：按照王刚的教程学习做了几个菜。
书籍50余本：10本为技术书籍，17本小说，8本互联网、游戏行业逸闻，10本社科类书籍，还有一些漫画、小品文章。
影视剧50余部：涉及国漫、日漫、欧美电影、日本电影、国产电影。
游戏10个：大作认真玩的只有两部，塞尔达、荒野大镖客2。还有一些开拓游戏叙事的小品游戏，比如弗洛伦丝、伊迪丝芬奇的记忆。
三地：上海、江西、杭州。我挺喜欢杭州的，希望以后有机会去那发展吧。
代码：代码文本行数应该在6w左右。数量还算满意。
明年的展望 工作 通过三年的阅读与实践，我能说把计算机系很多本科基础知识都补充了。数据结构、设计模式、计算机组成、网络、数据库、编程语言等等吧，都有了一定程度的理解。
现在大概处于一个瓶颈阶段，想要更进一步，还是有很多东西需要去改进。
然后是希望未来的一年开发的游戏能够成功上市，完成一段心愿。
打字 问题：
我打字是通过小学时候不断的聊QQ学习的，现在暴露出来几个缺陷。
 英文单词经常打错，比如linux输入一些命令，10个以内的字母，经常打一半就出错。 中文打字速度不算快，且容易错。 对键盘符号的位置不熟悉，还不能做到完全盲打的程度。  解决方案：
 专门的打字练习 改用双屏  代码的复制粘贴 问题：
不是指大段代码的复制粘贴，而是指对一些单个变量、函数的粘贴。
原因：
 emacs的补全不是很好用 整个项目里的变量一直使用复制粘贴，没有那么熟悉， 会打错字  解决方案：
强制的不复制粘贴，改为手打。
英文 问题：
英文很差，导致我现在对于英文的文档比较露怯。
解决方案：
一般来说技术书使用的英文都不是太难，考虑到我提升英语的目的是为了更好的阅读英文技术资料。所以完全可以通过直接开始阅读英文技术资料提高，同时也能够达到提高技术的目的。
 持续的英文技术资料的阅读。 普通英文咨询的阅读。  源码阅读 今年一年阅读了比较多的书籍，但是除了项目没有怎么阅读优秀开源项目的源码，视野比较窄，急需扩展。同时能够吸收项目之外的优秀设计。
编程练习 项目之外的造轮子少，整体还是懒，经常阅读了书籍没有去实践。编程这个东西，只有练习才能够真正的理解设计。
生活 生活总是一成不变的，希望在未来的一年里能够多发展几项技能。
锻炼 身体越来越差，体重越来越大。每周能抽出3天时间进行专项的锻炼，初期以跑步为主。
摄影 随着年龄的增长，越来越想留住时间。很遗憾的是之前没有做好记录，每年都没有全家福。]]></description>
</item><item>
    <title>clean code读书笔记</title>
    <link>http://coderyang.com/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Mon, 23 Jul 2018 08:31:58 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[命名，很多人戏称为编程中最难的事情。从实践经验出发来看，一个好的命名能够让代码阅读者迅速的知道代码的实际用途，而坏的命名不仅仅是让人摸不着头脑，而且可能误导他人。
本文主要是clean code第二章有意义的命名的笔记，该章节系统的讲述了什么才是一个好的名字。
  名副其实
 如果命名需要注释，则不是一个好的命名。
命名需要表达出准确的含义，不应该使用magic num或者i、j、k这类无意义的变量名。
   避免误导
 0和O、1、I和l。这类视觉上容易混淆的名字不需要使用。
假设存在一个vector，里面存储这actor_rid，但是你命名为actor_list，导致阅读者误认为是用链表实现的。
   做有意义的区分
 类似a1、a2、a3不能够带来任何信息的变量命名
类似thexx、xxdata、xxinfo、xxobject这类没有意义的前缀、后缀
不使用匈牙利命名法带上类型信息，现在ide随时可以看到类型
变量的命名需要带有含义，不要带上冗余的无效的信息。
   使用读得出来的名称
 如果变量难易阅读的话，对阅读者总是负担，难以记住也难易和他人交流
   使用可搜索的名称
 作用域越大变量名越长，便于搜索同时不会重复。
   避免使用编码
 匈牙利命名法在现代ide没有必要，同时影响ide的自动补全，修改类型名同时需要修改变量名
类似m_的前缀没有必要
   避免翻译
 缩写
   类名
 类名应该是名词或者名词短语，不应该是动词
   方法名
 方法名应该是动词或者动词短语，类似set_xx、is_xx
   别扮可爱
 不要使用难以联想到的词，即使你认为很精妙，直接了当的命名。
   每个概念对应一个词]]></description>
</item><item>
    <title>这几个月的一点随感</title>
    <link>http://coderyang.com/%E8%BF%99%E5%87%A0%E4%B8%AA%E6%9C%88%E7%9A%84%E4%B8%80%E7%82%B9%E9%9A%8F%E6%84%9F/</link>
    <pubDate>Sun, 15 Oct 2017 19:22:57 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/%E8%BF%99%E5%87%A0%E4%B8%AA%E6%9C%88%E7%9A%84%E4%B8%80%E7%82%B9%E9%9A%8F%E6%84%9F/</guid>
    <description><![CDATA[又有几个月没写博客了，自上次Redis系列之后，三个月过去。中间结束一个项目、面试了很多次、换了个工作、搬了次家、在家度过了一次国庆长假。
结束一个项目 结束的一个项目，算是基本独立完成的比较大的一个项目。项目团队四个人，两程序、两自动化。
出差到施工现场三个月，在那里完成了从客户端界面到服务端大部分编码测试工作，独立解决各种现场需求。很顺利的完成了工作，结题一个多月。项目在之前做的一个十多万行的项目基础上开发，新增了几万行代码，需要对程序进行设计架构的要求少，大部分还是在原来代码基础上修改，增加删除功能。做完这个项目之后，感觉编码上能遇到的问题越来越少，到了一个算是瓶颈的位置。
原公司是一个做轧钢工业控制系统的公司，十几个人，一半是程序员，一半是自动化工程师。毕业时候进去的。它给了我成为程序员的机会，工作氛围也很好，让我在基础薄弱的时候自由学习，并应用到项目之上。
从技术上看，软件需要对工业设备进行控制，对稳定性安全性要求高，程序崩溃或者控制逻辑上产生问题，可能导致很大的生产事故。用户量小，一般只需要一个服务器，搭配几个客户端界面。
公司依靠自动化起家，软件部门薄弱。老板对于软件的认识不足，认为编码简单，只要找些应届生学学就能上。又由于行业比较小，难以从社会上补充有经验的人员。不过话说回来，从公司需求来说，确实不需要大牛。维持住业务，两年三年工作经验程序经验即可胜任，基础好的应届生也能完成大部分工作。工作的主要难度在业务的理解上，这也是我能成为程序的原因。
刚进去的时候，之前的干了八年的主程序因故出走，剩下的都是只有一年经验的程序。还好老板在之后请来了老同学（20年经验），管理队伍。但是由于工作性质，需要长期出差，大部分代码在施工现场完成，一般一两人负责一个项目，没有完善的流程，更多是靠个人的自我约束，自我驱动去完成项目。从代码质量来看，肯定不会好。
如果要对我过去两年工作进行一个总结的话，那就是野蛮生长，整个过程中很少有人能够给予我指导，都是依靠个人去搜索资料、学习知识。对于程序更多的停留在编码阶段，对与程序设计、软件工程的管理认识浅薄。
面了很多次试 项目结束之后，休了个一周的长假。顺便也投了很多简历，面了很多次试。
面试的本意是看看自己在市场上到底值多少，了解市场的需求。八月份，不是招聘旺季，拉勾上C++的岗位只有三百多一点，适合我这个经验的100多个。由于之前的工作业务关系，干什么都是转行，同时不管是客户端还是服务端都干过，很多工作对我来说即适合又不适合。尝试着投递了一些岗位。后来感觉面试邀约不多，陆陆续续投递简历半个多月，最后发现快把适合我这个经验的岗位投递完了。一百来份简历，最终收到不到20个面试邀请。
从市场上看，C++需求的主要是两种windows客户端和linux服务端开发。需求最旺的依次是游戏、金融、工业控制领域。面试考察的大部分还是计算机原理、c++基础、数据结构、tcp网络基础，这可能由于我没行业背景有关。个人感觉我对于C++基础、数据结构没有太多问题，计算机原理稍薄弱，tcp网络了解很少，行业知识有限，对Linux开发没有经验。对于市场上很多岗位不能很好的匹配，于是给我面试机会的相对也比较少。
换了个工作 本意是出去见见世面的我，最终换了一份工作。面试的多了，愈加感觉到自己的不足。虽然在过去两年里还算努力的进行学习（总是有惰性，要是真的非常努力，肯定混的比现在好）。但是由于自身视野的问题和业务性质，我觉得要想更快速的更进一步，是时候去一个新的地方闯荡了。
于是，最终选择加入游戏公司成为linux服务端程序员。面试的时候，新公司主程序对我的评价是很对的：一个处在进阶阶段的程序。在这么一个阶段，需要更多的环境上的促进。这样我才能接触到更多的问题，发现一个更大的世界，逼着我去处理各种问题，不断的前进。很多时候，对于程序员来说，如果没有接触到问题的环境，你很难去想象到怎么处理问题，这也是很多公司要求行业经验的原因。不仅仅是业务上的熟悉，同时也是你只有在那个环境，比如用户量达到一定量级，才可能接触到问题，才可能知道怎么去处理问题。
另一个原因是我个人的心愿与理想。我是一个喜欢游戏的人，一直希望能够进入游戏公司，去看看怎么做游戏的。毕业的时候，一直在尝试找一个游戏策划的工作，但最终只收到一个小公司的游戏测试岗位offer，没有去。最后成员工业控制程序员，有一部分原因是c++在游戏领域用的很多，以后有机会跳槽。
现在能有机会进入一家在我看来还算不错的游戏公司，也算是了却一个心愿。虽然网上对于国内游戏开发有很多负面评论，但是不管怎么样，我也要去看看。不管未来这个工作会不会真的喜欢，我也要去尝试。
搬了次家 又搬了次家，这次是由于新工作离原来住的地方有点远，接近两小时的路程，必须得搬家了。毕业两年，包括离校的那次，搬了七次家，算下来三四个月就要搬一次家。过去两年里，出差过三个地方，广东湛江、河南安阳、辽宁营口，一出差就是几个月半年的，天南海北的。
飘临。
我算是一个适应能力很强的一个人了，在一个新地方能够比较快的熟悉起来。但是这么多次搬家，又经常长期出差到不熟悉的地方，那种人在异乡的感觉就愈加强烈了。以前觉得出差没什么，反正单身狗一个，一人吃饱全家不饿的，但是真的出差久了，就发现你跑到一个陌生的地方，人要重新熟悉，城市要重新熟悉，又不能带很多东西。这意味着你之前的积累都没了，你只能带着其实就是你这个人。外物积累都没了，周围的熟悉事物没了，你其实对于一个新的环境来说是一个异物，你是个格格不入的东西。但是我又不是旅游，我必须去熟悉，因为要做项目，要与人打交道，要在这生活一段时间。可熟悉了，立马又要进入一个新的陌生环境。搬家一样，搬到一个新的地方，室友不认识，周围环境不熟悉，又要重新认识熟悉。
很多精力，就在这样的过程中被磨灭了。
在家度过了一个国庆 上一次回家是过年的时候了，中间的一些假期不是在加班就是在出差。项目结束的假期又在面试。这样一算又是大半年没回去了。
时间。
很多时候你没有意识到，其实离开家已经很久了。现在24岁，人生的前12年在小镇上度过，初高中到了新余市，过了6年。大学到了上海4年，加上毕业2年，已经6年了。人生的四分之一是在外面度过的，可以预料到的是之后很长一段时间依旧会在上海。在家的时间越来越少。
我是喜欢回家的，在家的话很多事情不需要考虑，饭来张口衣来伸手，每天看看电脑，看看电视，啥事不管。对我来说，最大的幸福就是和自己爱的人待在一个地方，可以不说话，只要在一起，互相能够感觉到对方。回家对我来说就是这样一件事情，大家都很熟悉了，不管是父母、亲戚、朋友，只要在一起，互相有默契。这种长时间磨合之后产生的默契的感觉是最让我留恋的。]]></description>
</item><item>
    <title>Redis源码阅读-总结</title>
    <link>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%80%BB%E7%BB%93/</link>
    <pubDate>Tue, 18 Jul 2017 15:59:57 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[之前的一系列Redis源码阅读的博客都是基于《Redis设计与实现》的，内容上不免和书有雷同。
本来计划是三月份开始看，但是中间由于接到一个开发速度要求很高的项目，加班很多耽误了些进度，只在这一段时间里看了部分小书（部分书摘录成了博客），耽搁了。
然后快到七月的时候，项目在经过编码、测试，最终投用起来之后，又有了更多的时间来学习。便开始了源码的继续阅读。
阅读redis源码的目的:
 为了之后项目如果使用redis的话能够游刃有余。 学习其优秀的编码。  参加工作两年。
第一年是从机械专业学生转变为程序员，更多的是在打基础，看了挺多计算机的基础书籍。那段时间相对是痛苦的，遇到一个问题往往不明白，不断去探究又探究出一个新的不明白的问题。
第二年在积累了几万行之后，开始感觉基础编码方面比较游刃有余了，遇到的问题大多数能提取重点，找到解决方案。但是想着继续提升，于是开始了部分项目的源码阅读。除了公司项目源码的阅读，网上开源项目的源码阅读也提上了日程，在经过了sgi stl的仿写之后，开始了redis的阅读。
redis是我第一个比较完整的看完的现在流行的开源项目源码。不算中间停下来的时间，大概看了三个星期。这三个星期里不能说对redis理解很深透，但是起码整个项目的结构，怎么实现主要的功能，内部模块的互相调用算是理解了。
收获有很多，修炼还需要继续。]]></description>
</item><item>
    <title>redis源码阅读-一个命令的旅程</title>
    <link>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/</link>
    <pubDate>Tue, 18 Jul 2017 15:28:23 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://coderyang.com/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/</guid>
    <description><![CDATA[<p>redis服务器会与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行的命令，并通过资源管理来维持整个服务器自身的运转。</p>
<p>本文目的是为了理清楚服务器对于命令请求的整个处理过程，说明这个过程中服务器与客户端如何互相交互，服务器内部如何调用内部组件达到对命令的执行。</p>
<h2 id="命令的处理流程">命令的处理流程</h2>
<p>之前在事务代码部分的阅读，已经对于服务器接收客户端的连接并创建命令请求处理器等待命令请求的过程。</p>
<p>现在以一个简单的set命令为例子，看服务器在接收请求之后如何处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">KEY</span> <span class="n">VALUE</span>
<span class="n">ok</span>
</code></pre></td></tr></table>
</div>
</div><p>从客户端发送set key value命令到接收回复ok，都做了如下操作：</p>
<ul>
<li>客户端发送命令。</li>
<li>服务器命令请求处理器接收，引发命令的执行，并产生命令回复处理器。</li>
<li>命令回复处理器发送ok给客户端。</li>
<li>客户端接收ok，并打印。</li>
</ul>]]></description>
</item></channel>
</rss>
