[{"categories":["分享"],"content":"本文从《数据密集型引用系统设计》、Paxos lecture (Raft user study)（https://www.youtube.com/watch?v=JEpsBg0AO6o） 各截取了部分。 ","date":"2021-01-18","objectID":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/:0:0","tags":["分布式"],"title":"一致性与共识算法","uri":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/"},{"categories":["分享"],"content":"挑战 ","date":"2021-01-18","objectID":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/:1:0","tags":["分布式"],"title":"一致性与共识算法","uri":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/"},{"categories":["分享"],"content":"故障 数据： 磁盘: 4% 年损坏率 服务器宕机时间: 0.1% 或更长 IDC间丢包率: 5% ~ 30% 下面是几种分布式系统下典型的问题： 当通过网络发送数据包时，数据包可能会丢失或者延迟。同样，回复也可能会丢失或延迟。所以如果没有收到回复，并不能确定消息是否发送成功。 节点的时钟可能会与其他节点存在明显的不同步，时钟还可能会突然向前跳跃或者倒退，依靠精准的时钟存在一些风险，没有特别简单的方法来精确测量时钟的偏差范围。 进程可能在执行过程中的任意时候遭遇长度未知的暂停（一个重要的原因是垃圾回收），结果它被其他节点宣告失效，尽管后来又恢复执行，却对中间的暂停毫无所知。 部分失效可能是分布式系统的关键特征。只要软件试图跨节点做任何失效，就有可能出现失败，或者随机变慢，或者根本无应答（最终超时）。对于分布式环境，我们目标是建立容忍部分失效的软件系统，这样即使某些部件发生失效，系统整体还可以继续运行。 ","date":"2021-01-18","objectID":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/:1:1","tags":["分布式"],"title":"一致性与共识算法","uri":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/"},{"categories":["分享"],"content":"线性化与CAP理论 线性化：表现得好像只有一个数据副本，且其上的所有操作都是原子的。 为什么要线性化？ 非线性化系统的问题： 上面违背线性化只产生了一个比较小的问题，仅仅是展示页面不一致。但是如果核心业务违背线性化，可能导致严重问题。常见的就是集群选主，可能会出现两个主，导致脑裂。 常见复制算法，对线性化的支持： 主从复制（部分支持） 只有主写入读取的话，其他都是备份的情况下，是线性化的。但是不能做高高可用。 异步复制、主脑裂、从读等情况，不可线性化。 多主复制（不可线性化） 多副本冲突 无主复制（可能不可线性化） 能够实现高可靠、高可用性、数据完整有保证 会出现脏读、更新丢失等情况 具体看ddia吧，不展开了，用的比较少 共识算法（可线性化） 具体之后讨论。 线性化的代价以及CAP理论： ","date":"2021-01-18","objectID":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/:1:2","tags":["分布式"],"title":"一致性与共识算法","uri":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/"},{"categories":["分享"],"content":"FLP FLP 不可能定理是分布式系统领域最重要的定理之一，它给出了一个非常重要的结论：在网络可靠并且存在节点失效的异步模型系统中，不存在一个可以解决一致性问题的确定性算法。 In this paper, we show the surprising result that no completely asynchronous consensus protocol can tolerate even a single unannounced process death. We do not consider Byzantine failures, and we assume that the message system is reliable it delivers all messages correctly and exactly once. 这个定理其实也就是告诉我们不要浪费时间去为异步分布式系统设计在任意场景上都能够实现共识的算法，异步系统完全没有办法保证能在有限时间内达成一致。 注意这里的异步系统，参照DDIA第八章理论系统模型与现实的解释：在异步系统中，一个算法不会对时机做任何的假设，甚至里面根本没有时钟。 如果算法可以使用超时或者其他方式来检测崩溃的节点（即使怀疑可能是误报），那么可以实现稳定的共识方案。另外即使算法使用了随机数来检测节点故障也可以绕过FLP结论。 ","date":"2021-01-18","objectID":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/:1:3","tags":["分布式"],"title":"一致性与共识算法","uri":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/"},{"categories":["分享"],"content":"拜占庭将军问题 拜占庭将军问题是Lamport 在 The Byzantine Generals Problem 论文中提出的分布式领域的容错问题，它是分布式领域中最复杂、最严格的容错模型。 在该模型下，系统不会对集群中的节点做任何的限制，它们可以向其他节点发送随机数据、错误数据，也可以选择不响应其他节点的请求，这些无法预测的行为使得容错这一问题变得更加复杂。 这个问题在特定场景是合理的。例如： 在航天领域，计算机内存或CPU寄存器的数据可能会被辐射而发生故障，导致以不可预知的方式响应其他节点。这种情况西如果将系统下线，代价将异常昂贵，飞行控制系统必须做到容忍拜占庭故障。 在有多个参与者的系统中，某些参与者可能会作弊或者欺骗他人。这时节点不能完全相信另一个节点所发送的消息，它可能是恶意的。例如，像比特币和其他区块链一样的点对点网络就是让互不新人的当时方就某项交易达成一致，且不依赖于集中的机制。 不过在我们一般日常的系统里，不太考虑拜占庭将军问题。不过，系统中的bug可以认为是拜占庭式故障，但是如果只有一种实现，被部署在所有位置。那么出问题了，显然会全军覆没。如果要解决这个问题，只有写好几种不同的实现，然后希望只有部分节点中有bug。这显然是不合算的。 ","date":"2021-01-18","objectID":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/:1:4","tags":["分布式"],"title":"一致性与共识算法","uri":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/"},{"categories":["分享"],"content":"共识算法 我们这里的共识算法主要目的是为了在达到线性化的效果的情况下，能做到足够的容错。允许多个节点中，部分在出现上述故障部分描述的情况下，依旧能够对外提供服务。 同时假定系统中不存在拜占庭式错误，即使真的存在，研究表明只要发生拜占庭故障的节点数小于三分之一，也可以达成共识。 ","date":"2021-01-18","objectID":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/:2:0","tags":["分布式"],"title":"一致性与共识算法","uri":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/"},{"categories":["分享"],"content":"paxos 一个可靠的存储系统：基于多数派读写 每个paxos实例用来存储一个值 用两轮RPC来确定一个值 一个值’确定’后不能被修改 ‘确定’指被多数派接收写入 强一致性 条件 存储必须可靠：没有数据丢失和错误 容忍： 消息丢失（节点不可达） 消息乱序 算法流程 首先，每个Acceptor需要持久化三个变量（minProposal、acceptedProposal、acceptValue）。最开始minProposal = acceptedProposal = 0，acceptValue = null。算法有两个阶段：P1（Prepare阶段）、P2（Accept阶段） P1（Prepare阶段） P1a： 选择一个新的提议序号n，这个序号要全局唯一且递增，一般来说是利用时间+服务器ip 提议者（proposer）向所有接收者（acceptor）发起RPC（Prepare(n)），消息中包含提议序号n。 P1b：接收者（acceptor）接收到Prepare(n)，会做如下决策： if n \u003e minProposal 回复yes 同时minProposal = n (持久化) 返回(acceptedProposal, acceptValue) else 回复no P1c：提议者（proposer）会等待大多数（超过半数）接收者（acceptor）的响应。 接收到响应，并且为yes，选取acceptedProposal最大的acceptValue为新的acceptValue。 返回的acceptValue为null时，acceptedProposal肯定为0，这时候根据算法会选取自己的值为acceptValue。 半数以上的回复是yes，进入下一阶段P2。否则，n自增，重复P1a。 P2（Accept阶段） P2a：提议者（proposer）发起RPC（Accept(n, value)），value为p1选出的acceptValue。 P2b：接收者（acceptor）接收到Accept(n, value)，会做如下决策： if n \u003e= minProposal 回复yes 同时minProposal = acceptedProposal = n（持久化） acceptValue = value return minProposal else 回复no P2c：提议者（proposer）收到半数以上的yes，并且minProposal = n，则算法结束。否则n自增，重复P1a 示例 接下来用一些例子来说明提议竞争的状态，以及关键点在于第二次提议的准备阶段。 总共有三种可能。 一、已经选定了之前的值 简单解释下图形的意思： 有两个请求，X向S1请求，Y向S5请求。 P3.1表示Prepare阶段，提议序号3.3，高位顺序数3，低位服务器号5。 A4.5X表示Accept阶段，提议需要4.5，高位顺序数4，地位服务器号5，接受值X。 在第二个提议请求来之前，第一个提议请求已经选定了值，也就是说值 X 已经被集群的大多数服务器所接受。 第二个提议请求也需要大多数服务器得到响应，所以一定可以保证会至少有一个准备（Prepare）请求会到达与前一个请求相同的服务器，这里是 S3 。 服务器 S5 会发现已经接受的值 X ，当它响应准备请求（Prepare）时，它会放弃 Y 值，并为在所有接受（Accept）请求时使用 X 值。 算法选取回复yes中acceptedProposal最大的，那么S3的是3.1，value被替换为X。 服务器 S5 会成功，选定值为 S1 提议的 X 。 后面两种情况的前提是前值没有被选定的情况下，第二次请求进入了准备阶段（Prepare Phase） 二、前值没有被选定，但对新提议可见 有可能前一次的提议正在处于接受值的过程中，第二次提议恰好见到了其中的接受值。 这个场景和第一个场景类似，最终结果是A4.5X。注意这里其实S5并不需要知道S1、S2的情况，不管S1\\S2是否接受X，最终选出来的都是X。 三、前值没有被选定，对新提议也不可见 提议A3.1X被拒绝了，因为4.5 \u003e 3.1，X的提议失败了，等待下次重试，Y的提议被接受。 至此，足以说明 Paxos 协议在竞争状态下是安全的，无论如何竞争，最终都会选定某一值并达成一致。但是，这并不能说明基础 Paxos 协议是可用的（Live），可能会发生一组提议相互阻碍的情况，最终不会有任何选定值。下面会对此进行说明。 可用性 假设服务器 S1 成功接收到请求，并处于准备阶段（P 3.1）。在接受值 X 之前（A 3.1 X），另外一个服务器 S5 正处于它的准备阶段（P 3.5），这会阻止前序值的接受（A 3.1 X）。然后 S1 会重新选择提议序号并再次开始提议过程（P 4.1），假设它正进入了第二轮的准备阶段，在接受值之前，服务器 S5 正试图完成接受值的选定 Y （A 3.5 Y），不过此时因为（P 4.1）的序号高于（A 3.5 Y），所以它阻止了（A 3.5 Y）的接受，这样 S5 的提议就失败了，然后 S5 又重新开始下一轮的提议，如此往复，这个过程会无限循环下去。 为了不发生活锁，Paxos 需要以某种补充机制来保证它可以正确运行。 给重新开始一个随机的延时，让其他提议者有机会完成。 在多 Paxos 协议（Multi-Paxos）下，将多写转变为单写，选出一个Leader。 其他 超时等错误：等价于拒绝 两个阶段的多数派不需要完全相同 读一致： leader Paxos Quorum Reads … ","date":"2021-01-18","objectID":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/:2:1","tags":["分布式"],"title":"一致性与共识算法","uri":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/"},{"categories":["分享"],"content":"常见的应用 到此为止仅仅是一个值的决议，用处比较小。实践一般是使用paxos协议确定一堆有序的值，实现一个键值存储。具体怎么做的我还在研究。 节点任务分配 主从分配 分区ID分配：主从可以看作分区id分配的特化版 分布式锁 服务发现 用zookeeper\\etcd做服务发现的比较多。 不过有些人认为服务发现不需要共识。常见的DNS、Eureka、我们的naming都没有用共识实现。 成员服务 心跳检测 ","date":"2021-01-18","objectID":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/:3:0","tags":["分布式"],"title":"一致性与共识算法","uri":"/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/"},{"categories":["技巧"],"content":"本文主要介绍一下curl接口的使用方法，以及获取高性能的一些实践。 ","date":"2020-11-14","objectID":"/libcurl/:0:0","tags":["curl"],"title":"高性能libcurl","uri":"/libcurl/"},{"categories":["技巧"],"content":"什么是libcurl？用处？ libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more! 官网摘的一段，意思大概是免费且容易使用的url传输库，支持下面一堆特性。 项目内用处：基于libcurl实现了一个单线程异步的httpc，用于msdk、防沉迷、信用分等需要接入外部http的服务。 ","date":"2020-11-14","objectID":"/libcurl/:1:0","tags":["curl"],"title":"高性能libcurl","uri":"/libcurl/"},{"categories":["技巧"],"content":"接口介绍 curl一共有三种接口： Easy Interface Multi Interface Share Interface ","date":"2020-11-14","objectID":"/libcurl/:2:0","tags":["curl"],"title":"高性能libcurl","uri":"/libcurl/"},{"categories":["技巧"],"content":"Easy Interface The easy interface is a synchronous, efficient, quickly used and... yes, easy interface for file transfers. Numerous applications have been built using this. 简单接口是一个同步接口，非常方便使用，接口以curl_easy_开头，下面一个简单的使用例子。 CURL *curl = curl_easy_init(); // 创建一个handle if(curl) { CURLcode res; curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com\"); // 设置参数，参数有很多，header、cookie、接收回调函数、证书等等 res = curl_easy_perform(curl); // 执行，注意这里是阻塞的 curl_easy_cleanup(curl); // 清理 } ","date":"2020-11-14","objectID":"/libcurl/:2:1","tags":["curl"],"title":"高性能libcurl","uri":"/libcurl/"},{"categories":["技巧"],"content":"Multi Interface The multi interface is the asynchronous brother in the family and it also offers multiple transfers using a single thread and more. 多重接口是异步接口，libcurl使用一个或者多个线程完成数据传输，通过多重接口可以再单线程下同时操作多个easy handle。 例子：https://gist.github.com/clemensg/4960504 #define MAX_WAIT_MSECS 30*1000 /* Wait max. 30 seconds */ static const char *urls[] = { \"http://www.microsoft.com\", \"http://www.yahoo.com\", \"http://www.wikipedia.org\", \"http://slashdot.org\" }; #define CNT 4 static size_t cb(char *d, size_t n, size_t l, void *p) { /* take care of the data here, ignored in this example */ (void)d; (void)p; return n*l; } static void init(CURLM *cm, int i) { CURL *eh = curl_easy_init(); curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, cb); curl_easy_setopt(eh, CURLOPT_HEADER, 0L); curl_easy_setopt(eh, CURLOPT_URL, urls[i]); curl_easy_setopt(eh, CURLOPT_PRIVATE, urls[i]); curl_easy_setopt(eh, CURLOPT_VERBOSE, 0L); curl_multi_add_handle(cm, eh); } int main(void) { CURLM *cm = curl_multi_init(); // 创建一个multi handle // 创建一堆easy handle加入到multi handle里 for (int i = 0; i \u003c CNT; ++i) { init(cm, i); } // 执行，等待所有都执行完 int still_running=0; curl_multi_perform(cm, \u0026still_running); do { // 等一段时间，MAX_WAIT_MSECS为最长时长 // 有事件或者超时了返回 int res = curl_multi_wait(cm, NULL, 0, MAX_WAIT_MSECS, \u0026numfds); if(res != CURLM_OK) { fprintf(stderr, \"error: curl_multi_wait() returned %d\\n\", res); return EXIT_FAILURE; } curl_multi_perform(cm, \u0026still_running); } while(still_running); // 读取数据 CURLMsg *msg=NULL; const char *szUrl; int msgs_left = 0; int http_status_code; while ((msg = curl_multi_info_read(cm, \u0026msgs_left))) { if (msg-\u003emsg == CURLMSG_DONE) { CURL *eh = msg-\u003eeasy_handle; CURLcode return_code = msg-\u003edata.result; if(return_code!=CURLE_OK) { fprintf(stderr, \"CURL error code: %d\\n\", msg-\u003edata.result); continue; } // Get HTTP status code http_status_code=0; szUrl = NULL; curl_easy_getinfo(eh, CURLINFO_RESPONSE_CODE, \u0026http_status_code); curl_easy_getinfo(eh, CURLINFO_PRIVATE, \u0026szUrl); if(http_status_code==200) { printf(\"200 OK for %s\\n\", szUrl); } else { fprintf(stderr, \"GET of %s returned http status code %d\\n\", szUrl, http_status_code); } curl_multi_remove_handle(cm, eh); curl_easy_cleanup(eh); } else { fprintf(stderr, \"error: after curl_multi_info_read(), CURLMsg=%d\\n\", msg-\u003emsg); } } // 关闭 curl_multi_cleanup(cm); return EXIT_SUCCESS; } ","date":"2020-11-14","objectID":"/libcurl/:2:2","tags":["curl"],"title":"高性能libcurl","uri":"/libcurl/"},{"categories":["技巧"],"content":"Share Interface The share interface was added to enable sharing of data between curl \"handles\". 用于再多个easy handle共享一些数据，比如dns cache、tls session。 ","date":"2020-11-14","objectID":"/libcurl/:2:3","tags":["curl"],"title":"高性能libcurl","uri":"/libcurl/"},{"categories":["技巧"],"content":"其他 curl_global_init：进程启动时初始化curl curl_global_cleanup：进程关闭时清理curl 使用异步DNS，防止同步解析DNS卡住主循环 ","date":"2020-11-14","objectID":"/libcurl/:2:4","tags":["curl"],"title":"高性能libcurl","uri":"/libcurl/"},{"categories":["技巧"],"content":"实践 最初实现了一个使用Multi Interface的HTTPC。 httpc/unittest/httpc.cpp TEST_F(HTTPC_TEST, HTTP_GET) { HTTPC_CFG cfg; REQUEST_DRIVER driver(10); HTTPC c(cfg, driver); auto cb = [\u0026](RESPONSE \u0026rsp) { printf(\"result:%d code:%ld \\n\", rsp._result, rsp._http_status_code); printf(\"body:%s\", rsp._body.c_str()); }; for (u32 i = 0; i \u003c 10; ++i) { c.get(\"http://www.baidu.com\", cb); } bool idle; while (!driver._ctx_map.empty()) { driver.loop(idle, 0); }; } 在压测过程中发现性能不足，DNS解析卡住主循环。根据https://moz.com/devblog/high-performance-libcurl-tips，增加了c-ares库，使得libcurl支持异步DNS，最终性能到了3000TPS。 尝试使用Share Interface共享DNS，效果在接入异步DNS后不明显。 // 初始化共享 pthread_mutex_t _dns_lock = PTHREAD_MUTEX_INITIALIZER CURLSH* _share_handler = curl_share_init(); curl_share_setopt(_share_handler, CURLSHOPT_USERDATA, \u0026_dns_lock); curl_share_setopt(_share_handler, CURLSHOPT_LOCKFUNC, _lock); curl_share_setopt(_share_handler, CURLSHOPT_UNLOCKFUNC, _unlock); curl_share_setopt(_share_handler, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS); // 设置共享 curl_easy_setopt(ctx-\u003e_requst-\u003e_curl_handle, CURLOPT_SHARE, _share_handler); curl_easy_setopt(ctx-\u003e_requst-\u003e_curl_handle, CURLOPT_DNS_CACHE_TIMEOUT, 5 * 60);//5min 请求处理完毕后，不适用curl_easy_cleanup，而是采用连接池的方式通过curl_easy_reset重用连接。 https://curl.se/libcurl/c/libcurl-tutorial.html#Persistence Re-cycling the same easy handle several times when doing multiple requests is the way to go. After each single curl_easy_perform operation, libcurl will keep the connection alive and open. A subsequent request using the same easy handle to the same host might just be able to use the already open connection! This reduces network impact a lot. Even if the connection is dropped, all connections involving SSL to the same host again, will benefit from libcurl's session ID cache that drastically reduces re-connection time. .... libcurl caches DNS name resolving results, to make lookups of a previously looked up name a lot faster. https://curl.se/libcurl/c/curl_easy_reset.html Re-initializes all options previously set on a specified CURL handle to the default values. This puts back the handle to the same state as it was in when it was just created with curl_easy_init. It does not change the following information kept in the handle: live connections, the Session ID cache, the DNS cache, the cookies, the shares or the alt-svc cache. ","date":"2020-11-14","objectID":"/libcurl/:3:0","tags":["curl"],"title":"高性能libcurl","uri":"/libcurl/"},{"categories":["技巧"],"content":"本文主要讲一下怎么实现一个简易版本的function\u003c\u003e模板，从c++ templates第二版摘出，相应的技巧在timer中一些应用。 ","date":"2020-09-19","objectID":"/function/:0:0","tags":["c++"],"title":"简易function","uri":"/function/"},{"categories":["技巧"],"content":"出发点 一个简单的例子，下面这个模板上述能够接受任意可调用的对象，lambda表达式、函数指针、仿函数。 template\u003ctypename F\u003e void for_int_up(int n, F f) { for (int i = 0; i \u003c= n; ++i) { f(i); } } void print_int(int i) { std::count \u003c\u003c i \u003c\u003c ' '; } int main() { int sum = 0; for_int_up(5, [\u0026sum](int i) { sum += i; }); for_int_up(5, print_int); return 0; } 像for_int_up这样的函数其实有两个问题： 使用了模板将函数内部实现暴露。 造成代码膨胀，for_int_up函数还比较小，如果是一个很大的函数，代码膨胀会厉害的多。 于是为了解决上面两个问题，可能尝试用下面这个方案，这也是我们代码中常见的解决方案。 void for_int_up(int n, void (*f)(int)) { for (int i = 0; i \u003c= n; ++i) { f(i); } } 考虑到有可能有需要带上参数的需求，我们可能会写成这样。 void for_int_up(int n, void (*f)(int, void *data), void *data) { for (int i = 0; i \u003c= n; ++i) { f(i, data); } } void sum(int i, void *data) { int *sum = (int*)data; *sum += i; } int main() { int j = 0; for_int_up(5, sum, \u0026j); return 0; } 使用函数指针替代模板，for_int_up只接受函数指针，无法接收lambda表达式、仿函数。 带参数的方案基本上能够满足需求，只是需要将函数与数据分离，代码相对难写，强转可能存在错误。 本质上带参数void*的方案是在抹除类型信息。 基于以上的需求标准库里的std::function\u003c\u003e就应运而生了。 void for_int_up(int n, std::function\u003cvoid(int)\u003e f) { for (int i = 0; i \u003c= n; ++i) { f(i); } } std::function\u003cvoid(int)\u003e能够接收任意返回值是void，参数为int的函数指针、lambda表达式、仿函数。 上面两个问题一下就得到了解决，内部实现可以隐藏起来，同时模板范围缩小到std::function，即使for_int_up再大也不会出现代码膨胀很厉害的情况。 ","date":"2020-09-19","objectID":"/function/:1:0","tags":["c++"],"title":"简易function","uri":"/function/"},{"categories":["技巧"],"content":"广义的函数指针 std::function实际上是一个广义上的C++函数指针，需要支持一下操作： 在调用者只知道入参与返回值的情况，可以调用执行，不需要理解内部具体实现。 支持复制、移动。 可以被入参与返回值相同的函数指针、lambda表达式、仿函数、std::function初始化 支持null状态 ","date":"2020-09-19","objectID":"/function/:2:0","tags":["c++"],"title":"简易function","uri":"/function/"},{"categories":["技巧"],"content":"实现 下面我们会实现一个简易版本的std::function，FUNCTION_PTR。FUNCTION_PTR会支持上面提到的所有特性。 functionptr.hpp // 原始模板，因为实际上FUNCTION_PTR模板参数只有一个，所以需要这个原始模板: // 模板参数是一个函数类型 template \u003c typename T \u003e class FUNCTION_PTR; // 偏特化，提取出变参Args为所有参数，R为返回值 template \u003c typename R, typename... Args \u003e class FUNCTION_PTR\u003c R( Args... ) \u003e { private: FUNCTOR_BRIDGE\u003c R, Args... \u003e *bridge; // 核心类，参数类型信息，提供抽象的invoke。 public: // 构造: FUNCTION_PTR() : bridge( nullptr ) {} // 默认为空 FUNCTION_PTR(FUNCTION_PTR const \u0026other ); // see functionptr-cpinv.hpp FUNCTION_PTR(FUNCTION_PTR \u0026other ) : FUNCTION_PTR( static_cast\u003c FUNCTION_PTR const \u0026 \u003e( other ) ) {} FUNCTION_PTR( FUNCTION_PTR \u0026\u0026other ) : bridge( other.bridge ) { // 移动构造，所有权转移 other.bridge = nullptr; } // 从任意函数对象构造: template \u003c typename F \u003e FUNCTION_PTR( F \u0026\u0026f ); // see functionptr-init.hpp // 赋值操作符: FUNCTION_PTR \u0026operator=( FUNCTION_PTR const \u0026other ) { FUNCTION_PTR tmp( other ); swap( *this, tmp ); return *this; } FUNCTION_PTR \u0026operator=( FUNCTION_PTR \u0026\u0026other ) { delete bridge; bridge = other.bridge; other.bridge = nullptr; return *this; } // 从任意函数对象复制: template \u003c typename F \u003e FUNCTION_PTR \u0026operator=( F \u0026\u0026f ) { FUNCTION_PTR tmp( std::forward\u003c F \u003e( f ) ); // 先构造一个临时对象 swap( *this, tmp ); // 调用swap return *this; } // 析构: ~FUNCTION_PTR( ) { delete bridge; } friend void swap( FUNCTION_PTR \u0026fp1, FUNCTION_PTR \u0026fp2 ) { std::swap( fp1.bridge, fp2.bridge ); } // bool隐式转换，便于if判断 explicit operator bool( ) const { return bridge == nullptr; } // ()操作符重载: R operator( )( Args... args ) const; // see functionptr-cpinv.hpp }; 可以看到FUNCTION_PTR包含一个FUNCTOR_BRIDGE\u003c R, Args… \u003e成员，它负责存储具体的功能对象，并将具体类型擦除了。 functorbridge.hpp // FUNCTOR_BRIDGE只是一个抽象类，定义了几个基本接口 template \u003c typename R, typename... Args \u003e class FUNCTOR_BRIDGE { public: virtual ~FUNCTOR_BRIDGE( ) {} virtual FUNCTOR_BRIDGE *clone( ) const = 0; // 复制接口 virtual R invoke( Args... args ) const = 0; // 调用接口 }; bridge/functionptr-cpinv.hpp // 基于FUNCTOR_BRIDGE的抽象接口，我们能够实现FUNCTION_PTR复制与调用 template \u003c typename R, typename... Args \u003e FUNCTION_PTR\u003c R( Args... ) \u003e::FUNCTION_PTR( FUNCTION_PTR const \u0026other ) : bridge( nullptr ) { if ( other.bridge ) { bridge = other.bridge-\u003eclone( ); // 复制 } } template \u003c typename R, typename... Args \u003e R FUNCTION_PTR\u003c R( Args... ) \u003e::operator( )( Args... args ) const { return bridge-\u003einvoke( std::forward\u003c Args \u003e( args )... ); // 调用，完美转发 } bridge/specificfunctorbridge.hpp // 真正存储实际的可调用对象，继承自FUNCTOR_BRIDGE，利用多态实现类型的擦除 template \u003c typename FUNCTOR, typename R, typename... Args \u003e class SPECIFIC_FUNCTOR_BRIDGE : public FUNCTOR_BRIDGE\u003c R, Args... \u003e { FUNCTOR functor; public: // 构造 // 这里用了一个单独的FUNCTOR_FWD而不是FUNCTOR，因为有可能FUNCTOR_FWD类型与FUNCTOR // 不一样，存在隐式转换 template \u003c typename FUNCTOR_FWD \u003e SPECIFIC_FUNCTOR_BRIDGE( FUNCTOR_FWD \u0026\u0026functor ) : functor( std::forward\u003c FUNCTOR_FWD \u003e( functor ) ) { } virtual SPECIFIC_FUNCTOR_BRIDGE *clone( ) const override { return new SPECIFIC_FUNCTOR_BRIDGE( functor ); } virtual R invoke( Args... args ) const override { return functor( std::forward\u003c Args \u003e( args )... ); } }; functionptr-init.hpp // 任意类型转换为FUNCTION_PTR template \u003c typename R, typename... Args \u003e template \u003c typename F \u003e FUNCTION_PTR\u003c R( Args... ) \u003e::FUNCTION_PTR( F \u0026\u0026f ) : bridge( nullptr ) { using FUNCTOR = std::decay_t\u003c F \u003e; // 类型退化 using BRIDGE = SPECIFIC_FUNCTOR_BRIDGE\u003c FUNCTOR, R, Args... \u003e; bridge = new BRIDGE( std::forward\u003c F \u003e( f ) ); // 生成brige } 到此基本上FUNCTION_PTR已经实现完成了。 ","date":"2020-09-19","objectID":"/function/:3:0","tags":["c++"],"title":"简易function","uri":"/function/"},{"categories":["技巧"],"content":"其他 最终版本欠缺一个小功能判断FUNCTION_PTR内部存储的可调用对象是否相等。 FUNCTION_PTR将所有可调用对象都转换为了一次虚函数的调用，降低了性能。 每创建一个FUNCTION_PTR都需要一次堆内存分配。 gcc4.8中的std::function对于小对象不会进行堆内存的分配。 ","date":"2020-09-19","objectID":"/function/:4:0","tags":["c++"],"title":"简易function","uri":"/function/"},{"categories":["读书笔记"],"content":"本书涉及四个终极关怀:死亡、自由、孤独和无意义。个体与这些生命真相的正面交锋，构成了存在主义动力性冲突的内容。 死亡。最显而易见的、最容易理解的终极关怀就是死亡。我们现在存在，但是总有一天，这种存在会终止。死亡将如期而至，没有逃脱之路。这是一个恐怖的真相，能引发我们巨大的恐惧。用斯宾诺莎的话来说，“每一事物都在尽力维持自身的存在”；而存在的一个核心冲突就是，对死亡必然性的意识与继续生存下去的愿望之间的张力。 自由。另一个相对来说不太容易理解的终极关怀是自由。一般来说我们都认为自由是一个毋庸置疑的积极概念。有史以来，人类不是一直在渴望并为自由而奋斗吗？然而从终极层面来看，自由是与忧惧偶联在一起的。在存在的意义上，“自由”意味着外部结构的空白。与日常经验相反的是，人类并不是进入（和离开）一个拥有内在设计、高度结构化的宇宙。实际上，个体对他自己的世界、生活设计、选择以及行为负有全部责任——也就是说，个体是自己世界的创造者。“自由”在这种含义上，带有一种可怕的暗示:它意味着在我们所站立的地方并不坚实一什么都没有，是空的，无底深渊。所以，存在主义一个关键的动力性冲突就是，们无根基的处境与我们对根基与结构的渴望之间的冲突。 存在性孤独。第三个终极关怀是孤独不是伴随着寂寞的人际性孤独，也不是个人内心的孤独（与自身的其他部分隔离），而是一种根本性孤独既与生命隔绝，也与世界隔绝—隔绝在所有其他孤独之下。无论我们之间变得有多么亲密无间，仍然存在一个最终无法逾越的鸿沟；我们每个人都是独自一人进入这种存在，同时也注定要独自离开。一方面是我们对自身绝对孤独的意识，另一方面是对接触、保护的渴望，以及成为一个更大整体的一部分的愿望在性冲突就是这两个方面之间的张力。 无意义。第四个终极关怀或存在的既定事实是无意义。如果我们注定得死，如果我们构建我们自己的世界，如果每一个人最终都是独自一人身处于一个无关紧要的世界之中，那么生命有什么意义我们为什么要活着？我们应该怎样活着？如果并不存在为我们预先设计的蓝图，那么我们每个人就必须构建自己的生命意义。然而，个人自己创造出来的意义能否坚强到令其能容忍生活？人类这种寻找意义的生物，却被投入到本身毫无意义的宇宙之中，于是，存在的动力性冲突便从进退维谷的境地中滋生出来。 ","date":"2018-12-29","objectID":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97/:0:0","tags":["心理学"],"title":"读书摘录-存在主义心理治疗","uri":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97/"},{"categories":["杂谈"],"content":"距离上次博客又过去了几个月。自从换了工作之后时间总是比较紧张，一直是996的节奏。每周只有一天的休息日，往往这天会安排着调整下节奏、与朋友聚会，属于自己独处的时间减少了。 当然这不是不写博客的理由了，核心原因还是懒，毕竟真想做什么，怎么都能挤出时间。 一年的总结 2018对我来说过得很慢的一年，一年里做了挺多的事情。我自己对过去的一年还算满意。 没有女朋友：意识到自己的年龄也挺大了，但是还没有女朋友。 学会了做饭：按照王刚的教程学习做了几个菜。 书籍50余本：10本为技术书籍，17本小说，8本互联网、游戏行业逸闻，10本社科类书籍，还有一些漫画、小品文章。 影视剧50余部：涉及国漫、日漫、欧美电影、日本电影、国产电影。 游戏10个：大作认真玩的只有两部，塞尔达、荒野大镖客2。还有一些开拓游戏叙事的小品游戏，比如弗洛伦丝、伊迪丝芬奇的记忆。 三地：上海、江西、杭州。我挺喜欢杭州的，希望以后有机会去那发展吧。 代码：代码文本行数应该在6w左右。数量还算满意。 明年的展望 ","date":"2018-12-23","objectID":"/%E6%88%91%E7%9A%842018/:0:0","tags":["随感"],"title":"我的2018","uri":"/%E6%88%91%E7%9A%842018/"},{"categories":["杂谈"],"content":"工作 通过三年的阅读与实践，我能说把计算机系很多本科基础知识都补充了。数据结构、设计模式、计算机组成、网络、数据库、编程语言等等吧，都有了一定程度的理解。 现在大概处于一个瓶颈阶段，想要更进一步，还是有很多东西需要去改进。 然后是希望未来的一年开发的游戏能够成功上市，完成一段心愿。 ","date":"2018-12-23","objectID":"/%E6%88%91%E7%9A%842018/:1:0","tags":["随感"],"title":"我的2018","uri":"/%E6%88%91%E7%9A%842018/"},{"categories":["杂谈"],"content":"打字 问题： 我打字是通过小学时候不断的聊QQ学习的，现在暴露出来几个缺陷。 英文单词经常打错，比如linux输入一些命令，10个以内的字母，经常打一半就出错。 中文打字速度不算快，且容易错。 对键盘符号的位置不熟悉，还不能做到完全盲打的程度。 解决方案： 专门的打字练习 改用双屏 ","date":"2018-12-23","objectID":"/%E6%88%91%E7%9A%842018/:1:1","tags":["随感"],"title":"我的2018","uri":"/%E6%88%91%E7%9A%842018/"},{"categories":["杂谈"],"content":"代码的复制粘贴 问题： 不是指大段代码的复制粘贴，而是指对一些单个变量、函数的粘贴。 原因： emacs的补全不是很好用 整个项目里的变量一直使用复制粘贴，没有那么熟悉， 会打错字 解决方案： 强制的不复制粘贴，改为手打。 ","date":"2018-12-23","objectID":"/%E6%88%91%E7%9A%842018/:1:2","tags":["随感"],"title":"我的2018","uri":"/%E6%88%91%E7%9A%842018/"},{"categories":["杂谈"],"content":"英文 问题： 英文很差，导致我现在对于英文的文档比较露怯。 解决方案： 一般来说技术书使用的英文都不是太难，考虑到我提升英语的目的是为了更好的阅读英文技术资料。所以完全可以通过直接开始阅读英文技术资料提高，同时也能够达到提高技术的目的。 持续的英文技术资料的阅读。 普通英文咨询的阅读。 ","date":"2018-12-23","objectID":"/%E6%88%91%E7%9A%842018/:1:3","tags":["随感"],"title":"我的2018","uri":"/%E6%88%91%E7%9A%842018/"},{"categories":["杂谈"],"content":"源码阅读 今年一年阅读了比较多的书籍，但是除了项目没有怎么阅读优秀开源项目的源码，视野比较窄，急需扩展。同时能够吸收项目之外的优秀设计。 ","date":"2018-12-23","objectID":"/%E6%88%91%E7%9A%842018/:1:4","tags":["随感"],"title":"我的2018","uri":"/%E6%88%91%E7%9A%842018/"},{"categories":["杂谈"],"content":"编程练习 项目之外的造轮子少，整体还是懒，经常阅读了书籍没有去实践。编程这个东西，只有练习才能够真正的理解设计。 生活 生活总是一成不变的，希望在未来的一年里能够多发展几项技能。 ","date":"2018-12-23","objectID":"/%E6%88%91%E7%9A%842018/:1:5","tags":["随感"],"title":"我的2018","uri":"/%E6%88%91%E7%9A%842018/"},{"categories":["杂谈"],"content":"锻炼 身体越来越差，体重越来越大。每周能抽出3天时间进行专项的锻炼，初期以跑步为主。 ","date":"2018-12-23","objectID":"/%E6%88%91%E7%9A%842018/:1:6","tags":["随感"],"title":"我的2018","uri":"/%E6%88%91%E7%9A%842018/"},{"categories":["杂谈"],"content":"摄影 随着年龄的增长，越来越想留住时间。很遗憾的是之前没有做好记录，每年都没有全家福。 ","date":"2018-12-23","objectID":"/%E6%88%91%E7%9A%842018/:1:7","tags":["随感"],"title":"我的2018","uri":"/%E6%88%91%E7%9A%842018/"},{"categories":["读书笔记"],"content":"命名，很多人戏称为编程中最难的事情。从实践经验出发来看，一个好的命名能够让代码阅读者迅速的知道代码的实际用途，而坏的命名不仅仅是让人摸不着头脑，而且可能误导他人。 本文主要是clean code第二章有意义的命名的笔记，该章节系统的讲述了什么才是一个好的名字。 名副其实 如果命名需要注释，则不是一个好的命名。 命名需要表达出准确的含义，不应该使用magic num或者i、j、k这类无意义的变量名。 避免误导 0和O、1、I和l。这类视觉上容易混淆的名字不需要使用。 假设存在一个vector，里面存储这actor_rid，但是你命名为actor_list，导致阅读者误认为是用链表实现的。 做有意义的区分 类似a1、a2、a3不能够带来任何信息的变量命名 类似thexx、xxdata、xxinfo、xxobject这类没有意义的前缀、后缀 不使用匈牙利命名法带上类型信息，现在ide随时可以看到类型 变量的命名需要带有含义，不要带上冗余的无效的信息。 使用读得出来的名称 如果变量难易阅读的话，对阅读者总是负担，难以记住也难易和他人交流 使用可搜索的名称 作用域越大变量名越长，便于搜索同时不会重复。 避免使用编码 匈牙利命名法在现代ide没有必要，同时影响ide的自动补全，修改类型名同时需要修改变量名 类似m_的前缀没有必要 避免翻译 缩写 类名 类名应该是名词或者名词短语，不应该是动词 方法名 方法名应该是动词或者动词短语，类似set_xx、is_xx 别扮可爱 不要使用难以联想到的词，即使你认为很精妙，直接了当的命名。 每个概念对应一个词 controller、manager、driver。英语中有很多语义相似的词语，代码中统一使用一个词来描述。 不使用双关 双关代表者二义性。比如add，有可能是insert的意思，有可能是append的意思。 使用解决方案领域名称 计算机科学属于、算法名、模式名。使用领域内专有名词利于有共同经验的人理解程序 使用源自所涉问题领域名称 我们是游戏编程，有很多游戏专有名词。比如exp、level、dps等，更业务的代码使用这些名词易于理解 添加有意义的语境 将相关的变量设置统一的前缀、后缀，建立语境。 不要添加没用的语境 比如给同一个项目里的所有类添加上项目名称。 ","date":"2018-07-23","objectID":"/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":["编程","读书笔记"],"title":"clean code读书笔记","uri":"/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["杂谈"],"content":"又有几个月没写博客了，自上次Redis系列之后，三个月过去。中间结束一个项目、面试了很多次、换了个工作、搬了次家、在家度过了一次国庆长假。 结束一个项目 结束的一个项目，算是基本独立完成的比较大的一个项目。项目团队四个人，两程序、两自动化。 出差到施工现场三个月，在那里完成了从客户端界面到服务端大部分编码测试工作，独立解决各种现场需求。很顺利的完成了工作，结题一个多月。项目在之前做的一个十多万行的项目基础上开发，新增了几万行代码，需要对程序进行设计架构的要求少，大部分还是在原来代码基础上修改，增加删除功能。做完这个项目之后，感觉编码上能遇到的问题越来越少，到了一个算是瓶颈的位置。 原公司是一个做轧钢工业控制系统的公司，十几个人，一半是程序员，一半是自动化工程师。毕业时候进去的。它给了我成为程序员的机会，工作氛围也很好，让我在基础薄弱的时候自由学习，并应用到项目之上。 从技术上看，软件需要对工业设备进行控制，对稳定性安全性要求高，程序崩溃或者控制逻辑上产生问题，可能导致很大的生产事故。用户量小，一般只需要一个服务器，搭配几个客户端界面。 公司依靠自动化起家，软件部门薄弱。老板对于软件的认识不足，认为编码简单，只要找些应届生学学就能上。又由于行业比较小，难以从社会上补充有经验的人员。不过话说回来，从公司需求来说，确实不需要大牛。维持住业务，两年三年工作经验程序经验即可胜任，基础好的应届生也能完成大部分工作。工作的主要难度在业务的理解上，这也是我能成为程序的原因。 刚进去的时候，之前的干了八年的主程序因故出走，剩下的都是只有一年经验的程序。还好老板在之后请来了老同学（20年经验），管理队伍。但是由于工作性质，需要长期出差，大部分代码在施工现场完成，一般一两人负责一个项目，没有完善的流程，更多是靠个人的自我约束，自我驱动去完成项目。从代码质量来看，肯定不会好。 如果要对我过去两年工作进行一个总结的话，那就是野蛮生长，整个过程中很少有人能够给予我指导，都是依靠个人去搜索资料、学习知识。对于程序更多的停留在编码阶段，对与程序设计、软件工程的管理认识浅薄。 面了很多次试 项目结束之后，休了个一周的长假。顺便也投了很多简历，面了很多次试。 面试的本意是看看自己在市场上到底值多少，了解市场的需求。八月份，不是招聘旺季，拉勾上C++的岗位只有三百多一点，适合我这个经验的100多个。由于之前的工作业务关系，干什么都是转行，同时不管是客户端还是服务端都干过，很多工作对我来说即适合又不适合。尝试着投递了一些岗位。后来感觉面试邀约不多，陆陆续续投递简历半个多月，最后发现快把适合我这个经验的岗位投递完了。一百来份简历，最终收到不到20个面试邀请。 从市场上看，C++需求的主要是两种windows客户端和linux服务端开发。需求最旺的依次是游戏、金融、工业控制领域。面试考察的大部分还是计算机原理、c++基础、数据结构、tcp网络基础，这可能由于我没行业背景有关。个人感觉我对于C++基础、数据结构没有太多问题，计算机原理稍薄弱，tcp网络了解很少，行业知识有限，对Linux开发没有经验。对于市场上很多岗位不能很好的匹配，于是给我面试机会的相对也比较少。 换了个工作 本意是出去见见世面的我，最终换了一份工作。面试的多了，愈加感觉到自己的不足。虽然在过去两年里还算努力的进行学习（总是有惰性，要是真的非常努力，肯定混的比现在好）。但是由于自身视野的问题和业务性质，我觉得要想更快速的更进一步，是时候去一个新的地方闯荡了。 于是，最终选择加入游戏公司成为linux服务端程序员。面试的时候，新公司主程序对我的评价是很对的：一个处在进阶阶段的程序。在这么一个阶段，需要更多的环境上的促进。这样我才能接触到更多的问题，发现一个更大的世界，逼着我去处理各种问题，不断的前进。很多时候，对于程序员来说，如果没有接触到问题的环境，你很难去想象到怎么处理问题，这也是很多公司要求行业经验的原因。不仅仅是业务上的熟悉，同时也是你只有在那个环境，比如用户量达到一定量级，才可能接触到问题，才可能知道怎么去处理问题。 另一个原因是我个人的心愿与理想。我是一个喜欢游戏的人，一直希望能够进入游戏公司，去看看怎么做游戏的。毕业的时候，一直在尝试找一个游戏策划的工作，但最终只收到一个小公司的游戏测试岗位offer，没有去。最后成员工业控制程序员，有一部分原因是c++在游戏领域用的很多，以后有机会跳槽。 现在能有机会进入一家在我看来还算不错的游戏公司，也算是了却一个心愿。虽然网上对于国内游戏开发有很多负面评论，但是不管怎么样，我也要去看看。不管未来这个工作会不会真的喜欢，我也要去尝试。 搬了次家 又搬了次家，这次是由于新工作离原来住的地方有点远，接近两小时的路程，必须得搬家了。毕业两年，包括离校的那次，搬了七次家，算下来三四个月就要搬一次家。过去两年里，出差过三个地方，广东湛江、河南安阳、辽宁营口，一出差就是几个月半年的，天南海北的。 飘临。 我算是一个适应能力很强的一个人了，在一个新地方能够比较快的熟悉起来。但是这么多次搬家，又经常长期出差到不熟悉的地方，那种人在异乡的感觉就愈加强烈了。以前觉得出差没什么，反正单身狗一个，一人吃饱全家不饿的，但是真的出差久了，就发现你跑到一个陌生的地方，人要重新熟悉，城市要重新熟悉，又不能带很多东西。这意味着你之前的积累都没了，你只能带着其实就是你这个人。外物积累都没了，周围的熟悉事物没了，你其实对于一个新的环境来说是一个异物，你是个格格不入的东西。但是我又不是旅游，我必须去熟悉，因为要做项目，要与人打交道，要在这生活一段时间。可熟悉了，立马又要进入一个新的陌生环境。搬家一样，搬到一个新的地方，室友不认识，周围环境不熟悉，又要重新认识熟悉。 很多精力，就在这样的过程中被磨灭了。 在家度过了一个国庆 上一次回家是过年的时候了，中间的一些假期不是在加班就是在出差。项目结束的假期又在面试。这样一算又是大半年没回去了。 时间。 很多时候你没有意识到，其实离开家已经很久了。现在24岁，人生的前12年在小镇上度过，初高中到了新余市，过了6年。大学到了上海4年，加上毕业2年，已经6年了。人生的四分之一是在外面度过的，可以预料到的是之后很长一段时间依旧会在上海。在家的时间越来越少。 我是喜欢回家的，在家的话很多事情不需要考虑，饭来张口衣来伸手，每天看看电脑，看看电视，啥事不管。对我来说，最大的幸福就是和自己爱的人待在一个地方，可以不说话，只要在一起，互相能够感觉到对方。回家对我来说就是这样一件事情，大家都很熟悉了，不管是父母、亲戚、朋友，只要在一起，互相有默契。这种长时间磨合之后产生的默契的感觉是最让我留恋的。 ","date":"2017-10-15","objectID":"/%E8%BF%99%E5%87%A0%E4%B8%AA%E6%9C%88%E7%9A%84%E4%B8%80%E7%82%B9%E9%9A%8F%E6%84%9F/:0:0","tags":["随感"],"title":"这几个月的一点随感","uri":"/%E8%BF%99%E5%87%A0%E4%B8%AA%E6%9C%88%E7%9A%84%E4%B8%80%E7%82%B9%E9%9A%8F%E6%84%9F/"},{"categories":["源码阅读"],"content":"之前的一系列Redis源码阅读的博客都是基于《Redis设计与实现》的，内容上不免和书有雷同。 本来计划是三月份开始看，但是中间由于接到一个开发速度要求很高的项目，加班很多耽误了些进度，只在这一段时间里看了部分小书（部分书摘录成了博客），耽搁了。 然后快到七月的时候，项目在经过编码、测试，最终投用起来之后，又有了更多的时间来学习。便开始了源码的继续阅读。 阅读redis源码的目的: 为了之后项目如果使用redis的话能够游刃有余。 学习其优秀的编码。 参加工作两年。 第一年是从机械专业学生转变为程序员，更多的是在打基础，看了挺多计算机的基础书籍。那段时间相对是痛苦的，遇到一个问题往往不明白，不断去探究又探究出一个新的不明白的问题。 第二年在积累了几万行之后，开始感觉基础编码方面比较游刃有余了，遇到的问题大多数能提取重点，找到解决方案。但是想着继续提升，于是开始了部分项目的源码阅读。除了公司项目源码的阅读，网上开源项目的源码阅读也提上了日程，在经过了sgi stl的仿写之后，开始了redis的阅读。 redis是我第一个比较完整的看完的现在流行的开源项目源码。不算中间停下来的时间，大概看了三个星期。这三个星期里不能说对redis理解很深透，但是起码整个项目的结构，怎么实现主要的功能，内部模块的互相调用算是理解了。 收获有很多，修炼还需要继续。 ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%80%BB%E7%BB%93/:0:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-总结","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%80%BB%E7%BB%93/"},{"categories":["源码阅读"],"content":"redis服务器会与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行的命令，并通过资源管理来维持整个服务器自身的运转。 本文目的是为了理清楚服务器对于命令请求的整个处理过程，说明这个过程中服务器与客户端如何互相交互，服务器内部如何调用内部组件达到对命令的执行。 ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"命令的处理流程 之前在事务代码部分的阅读，已经对于服务器接收客户端的连接并创建命令请求处理器等待命令请求的过程。 现在以一个简单的set命令为例子，看服务器在接收请求之后如何处理。 redis\u003e SET KEY VALUE ok 从客户端发送set key value命令到接收回复ok，都做了如下操作： 客户端发送命令。 服务器命令请求处理器接收，引发命令的执行，并产生命令回复处理器。 命令回复处理器发送ok给客户端。 客户端接收ok，并打印。 ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"发送命令 客户端将键入的命令转换为协议格式并套接字发送到服务器 ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"读取命令 服务器发现客户端连接套接字变为可读时，通过命令请求处理器readQueryFromClient()函数来进行处理。 ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"读取命令到缓冲区并处理 // 读取客户端的查询缓冲区内容 void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) { redisClient *c = (redisClient*) privdata; int nread, readlen; size_t qblen; REDIS_NOTUSED(el); REDIS_NOTUSED(mask); server.current_client = c; // 设置服务器的当前客户端 readlen = REDIS_IOBUF_LEN; // 读取的默认长度 /* If this is a multi bulk request, and we are processing a bulk reply * that is large enough, try to maximize the probability that the query * buffer contains exactly the SDS string representing the object, even * at the risk of requiring more read(2) calls. This way the function * processMultiBulkBuffer() can avoid copying buffers to create the * Redis Object representing the argument. */ if (c-\u003ereqtype == REDIS_REQ_MULTIBULK \u0026\u0026 c-\u003emultibulklen \u0026\u0026 c-\u003ebulklen != -1 \u0026\u0026 c-\u003ebulklen \u003e= REDIS_MBULK_BIG_ARG) { int remaining = (unsigned)(c-\u003ebulklen+2)-sdslen(c-\u003equerybuf); if (remaining \u003c readlen) readlen = remaining; } // 获取缓存区遗留数据长度 qblen = sdslen(c-\u003equerybuf); if (c-\u003equerybuf_peak \u003c qblen) c-\u003equerybuf_peak = qblen; // 查询缓冲区长度峰值更新 c-\u003equerybuf = sdsMakeRoomFor(c-\u003equerybuf, readlen); // 重新分配查询缓冲区空间 nread = read(fd, c-\u003equerybuf+qblen, readlen); // 读取fd中数据，在遗留数据之后 if (nread == -1) { // 读取错误处理 if (errno == EAGAIN) { nread = 0; } else { redisLog(REDIS_VERBOSE, \"Reading from client: %s\",strerror(errno)); freeClient(c); return; } } else if (nread == 0) { // 遇到EOF,关闭客户端 redisLog(REDIS_VERBOSE, \"Client closed connection\"); freeClient(c); return; } if (nread) { // 读取成功 sdsIncrLen(c-\u003equerybuf,nread); // 正确更新 free 和 len 属性的。 c-\u003elastinteraction = server.unixtime; // 记录最后一次互动时间 if (c-\u003eflags \u0026 REDIS_MASTER) c-\u003ereploff += nread; // 客户端为master,更新复制偏移量 server.stat_net_input_bytes += nread; } else { // 在 nread == -1 且 errno == EAGAIN 时运行 server.current_client = NULL; return; } // 缓冲区长度超过服务器最大缓冲区长度 // 清空缓冲区并释放客户端 if (sdslen(c-\u003equerybuf) \u003e server.client_max_querybuf_len) { sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty(); bytes = sdscatrepr(bytes,c-\u003equerybuf,64); redisLog(REDIS_WARNING,\"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)\", ci, bytes); sdsfree(ci); sdsfree(bytes); freeClient(c); return; } // 从缓冲区中读取内容，创建参数，并执行命令 // 直到缓冲区所有的内容被处理完为止 processInputBuffer(c); server.current_client = NULL; } ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:3:1","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"从缓冲区中读取命令并处理 redis的readQueryFromClient()函数在将命令读取到缓冲区之后，调用processInputBuffer()对缓冲区内的命令进行处理，直到所有命令处理完毕。 // 处理客户端输入的内容 void processInputBuffer(redisClient *c) { /* Keep processing while there is something in the input buffer */ while(sdslen(c-\u003equerybuf)) { // 客户端处于暂停状态，直接返回 if (!(c-\u003eflags \u0026 REDIS_SLAVE) \u0026\u0026 clientsArePaused()) return; // 客户端被阻塞直接返回 if (c-\u003eflags \u0026 REDIS_BLOCKED) return; // 客户端被设置为关闭，返回 if (c-\u003eflags \u0026 REDIS_CLOSE_AFTER_REPLY) return; // 判断请求类型 if (!c-\u003ereqtype) { if (c-\u003equerybuf[0] == '*') { c-\u003ereqtype = REDIS_REQ_MULTIBULK; } else { c-\u003ereqtype = REDIS_REQ_INLINE; } } // 将缓冲区中的内容转换为命令，以及命令参数 // processMultibulkBuffer()处理一般客户端发送的信息 // processInlineBuffer()处理TELNET发送的信息 // 命令转换失败跳出循环，也就是可能在没有处理完缓冲区所有数据的情况下跳出。 if (c-\u003ereqtype == REDIS_REQ_INLINE) { if (processInlineBuffer(c) != REDIS_OK) break; } else if (c-\u003ereqtype == REDIS_REQ_MULTIBULK) { if (processMultibulkBuffer(c) != REDIS_OK) break; } else { redisPanic(\"Unknown request type\"); } if (c-\u003eargc == 0) { // 命令参数为0，不需要执行 resetClient(c); } else { // 执行命令，在成功执行之后重置客户端 if (processCommand(c) == REDIS_OK) resetClient(c); } } } // 命令的转换介绍下processMultibulkBuffer()，此为处理客户端发送来命令，相对协议更复杂。 // processInlineBuffer()相对协议简单就不介绍了。 /* * 将 c-\u003equerybuf 中的协议内容转换成 c-\u003eargv 中的参数对象 * * 比如 *3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nMSG\\r\\n$5\\r\\nHELLO\\r\\n * 将被转换为： * argv[0] = SET * argv[1] = MSG * argv[2] = HELLO */ int processMultibulkBuffer(redisClient *c) { char *newline = NULL; int pos = 0, ok; long long ll; // 读取命令参数个数 if (c-\u003emultibulklen == 0) { redisAssertWithInfo(c,NULL,c-\u003eargc == 0); // 校验命令参数中\"\\r\\n\"的存在 newline = strchr(c-\u003equerybuf,'\\r'); if (newline == NULL) { if (sdslen(c-\u003equerybuf) \u003e REDIS_INLINE_MAX_SIZE) { addReplyError(c,\"Protocol error: too big mbulk count string\"); setProtocolError(c,0); // 异步关闭客户端 } return REDIS_ERR; } if (newline-(c-\u003equerybuf) \u003e ((signed)sdslen(c-\u003equerybuf)-2)) return REDIS_ERR; // 第一个字符必须时* redisAssertWithInfo(c,NULL,c-\u003equerybuf[0] == '*'); // 转换出参数的个数 ok = string2ll(c-\u003equerybuf+1,newline-(c-\u003equerybuf+1),\u0026ll); // 检测参数个数是否超限 if (!ok || ll \u003e 1024*1024) { addReplyError(c,\"Protocol error: invalid multibulk length\"); setProtocolError(c,pos); // 异步关闭客户端 return REDIS_ERR; } pos = (newline-c-\u003equerybuf)+2; if (ll \u003c= 0) { // 参数小于等于0，删除c-\u003equerybuf中从pos到-1的内容 // 返回读取成功 sdsrange(c-\u003equerybuf,pos,-1); return REDIS_OK; } // 设置参数个数 c-\u003emultibulklen = ll; // 分配参数空间 if (c-\u003eargv) zfree(c-\u003eargv); c-\u003eargv = zmalloc(sizeof(robj*)*c-\u003emultibulklen); } redisAssertWithInfo(c,NULL,c-\u003emultibulklen \u003e 0); while(c-\u003emultibulklen) { // 读取参数长度 if (c-\u003ebulklen == -1) { // 校验命令参数中\"\\r\\n\"的存在 newline = strchr(c-\u003equerybuf+pos,'\\r'); if (newline == NULL) { if (sdslen(c-\u003equerybuf) \u003e REDIS_INLINE_MAX_SIZE) { addReplyError(c, \"Protocol error: too big bulk count string\"); setProtocolError(c,0); return REDIS_ERR; } break; } if (newline-(c-\u003equerybuf) \u003e ((signed)sdslen(c-\u003equerybuf)-2)) break; // 确认格式 if (c-\u003equerybuf[pos] != '$') { addReplyErrorFormat(c, \"Protocol error: expected '$', got '%c'\", c-\u003equerybuf[pos]); setProtocolError(c,pos); return REDIS_ERR; } // 读取长度 ok = string2ll(c-\u003equerybuf+pos+1,newline-(c-\u003equerybuf+pos+1),\u0026ll); if (!ok || ll \u003c 0 || ll \u003e 512*1024*1024) { addReplyError(c,\"Protocol error: invalid bulk length\"); setProtocolError(c,pos); return REDIS_ERR; } pos += newline-(c-\u003equerybuf+pos)+2; // 参数太长的特殊处理 if (ll \u003e= REDIS_MBULK_BIG_ARG) { size_t qblen; /* If we are going to read a large object from network * try to make it likely that it will start at c-\u003equerybuf * boundary so that we can optimize object creation * avoiding a large copy of data. */ sdsrange(c-\u003equerybuf,pos,-1); pos = 0; qblen = sdslen(c-\u003equerybuf); /* Hint the sds library about the amount of bytes this string is * going to contain. */ if (qblen \u003c (size_t)ll+2) c-\u003equerybuf = sdsMakeRoomFor(c-\u003equerybuf,ll+2-qblen); } c-\u003ebulklen = ll; } // 读取参数 if (sdslen(c-\u003equerybuf)-pos \u003c (unsigned)(c-\u003ebulklen+2)) { // 确认协议内容 break; } else { //复制参数 if (pos == 0 \u0026\u0026 c-\u003ebulklen \u003e= REDIS_MBULK_BIG_ARG \u0026\u0026 (signed) sdslen(c-\u003equerybuf) == c-\u003ebulklen+2) { c-\u003eargv[c-\u003eargc+","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:3:2","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"命令的执行 processInputBuffer()在解析成功命令之后，调用processCommand()对命令进行执行。 void processInputBuffer(redisClient *c) { // .... if (c-\u003eargc == 0) { // 命令参数为0，不需要执行 resetClient(c); } else { // 执行命令，在成功执行之后重置客户端 if (processCommand(c) == REDIS_OK) resetClient(c); } // ... } ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:4:0","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"命令的查找 在processCommand()执行的第一步就是查询命令表，找到对于的命令实现信息。 // 命令的执行 int processCommand(redisClient *c) { // quit命令特殊处理，异步关闭服务器 if (!strcasecmp(c-\u003eargv[0]-\u003eptr,\"quit\")) { addReply(c,shared.ok); c-\u003eflags |= REDIS_CLOSE_AFTER_REPLY; return REDIS_ERR; } // 查找命令 c-\u003ecmd = c-\u003elastcmd = lookupCommand(c-\u003eargv[0]-\u003eptr); if (!c-\u003ecmd) { // 没有查找倒 flagTransaction(c); addReplyErrorFormat(c,\"unknown command '%s'\", (char*)c-\u003eargv[0]-\u003eptr); return REDIS_OK; } else if ((c-\u003ecmd-\u003earity \u003e 0 \u0026\u0026 c-\u003ecmd-\u003earity != c-\u003eargc) || (c-\u003eargc \u003c -c-\u003ecmd-\u003earity)) { // 命令实现与输入的参数数量不匹配 flagTransaction(c); addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\", c-\u003ecmd-\u003ename); return REDIS_OK; } // ... } redis维护了一个命令表，该命令表为一个字典，键为命令名字，值是一个redisCommand结构，该结构记录了一个Redis的命令实现。 服务器启动时，调用初始化服务器配置函数initServerConfig()，该函数会进行命令表的初始化，保存在两个字典中commands、orig_commands。原始的命令表初始参数保存在redis.c文件中的redisCommandTable定义。 struct redisServer { // ... // 命令表（受到 rename 配置选项的作用） dict *commands; // 命令表（无 rename 配置选项的作用） dict *orig_commands; // ... }; int main(int argc, char **argv) { // ... initServerConfig(); } void initServerConfig() { // ... // 初始化命令表 // 创建命令字典 server.commands = dictCreate(\u0026commandTableDictType,NULL); server.orig_commands = dictCreate(\u0026commandTableDictType,NULL); populateCommandTable(); // 初始化命令表 // 初始化常用命令快捷 server.delCommand = lookupCommandByCString(\"del\"); server.multiCommand = lookupCommandByCString(\"multi\"); server.lpushCommand = lookupCommandByCString(\"lpush\"); server.lpopCommand = lookupCommandByCString(\"lpop\"); server.rpopCommand = lookupCommandByCString(\"rpop\"); // ... } void populateCommandTable(void) { int j; // 命令数量 int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand); for (j = 0; j \u003c numcommands; j++) { struct redisCommand *c = redisCommandTable+j; // 命令 char *f = c-\u003esflags; int retval1, retval2; while(*f != '\\0') { switch(*f) { case 'w': c-\u003eflags |= REDIS_CMD_WRITE; break; case 'r': c-\u003eflags |= REDIS_CMD_READONLY; break; case 'm': c-\u003eflags |= REDIS_CMD_DENYOOM; break; case 'a': c-\u003eflags |= REDIS_CMD_ADMIN; break; case 'p': c-\u003eflags |= REDIS_CMD_PUBSUB; break; case 's': c-\u003eflags |= REDIS_CMD_NOSCRIPT; break; case 'R': c-\u003eflags |= REDIS_CMD_RANDOM; break; case 'S': c-\u003eflags |= REDIS_CMD_SORT_FOR_SCRIPT; break; case 'l': c-\u003eflags |= REDIS_CMD_LOADING; break; case 't': c-\u003eflags |= REDIS_CMD_STALE; break; case 'M': c-\u003eflags |= REDIS_CMD_SKIP_MONITOR; break; case 'k': c-\u003eflags |= REDIS_CMD_ASKING; break; case 'F': c-\u003eflags |= REDIS_CMD_FAST; break; default: redisPanic(\"Unsupported command flag\"); break; } f++; } // 添加 retval1 = dictAdd(server.commands, sdsnew(c-\u003ename), c); /* Populate an additional dictionary that will be unaffected * by rename-command statements in redis.conf. */ retval2 = dictAdd(server.orig_commands, sdsnew(c-\u003ename), c); redisAssert(retval1 == DICT_OK \u0026\u0026 retval2 == DICT_OK); } } redisCommandTable定义 // Redis 命令 struct redisCommand { char *name; // 命令名 redisCommandProc *proc; // 实现函数 int arity; // 参数个数 char *sflags; // 字符串表示FLAG int flags; // 实际FLAG /* Use a function to determine keys arguments in a command line. * Used for Redis Cluster redirect. */ redisGetKeysProc *getkeys_proc; // 指定哪个参数为key int firstkey; /* The first argument that's a key (0 = no keys) */ int lastkey; /* The last argument that's a key */ int keystep; /* The step between first and last key */ long long microseconds, calls; // 统计信息 }; struct redisCommand redisCommandTable[] = { {\"get\",getCommand,2,\"r\",0,NULL,1,1,1,0,0}, {\"set\",setCommand,-3,\"wm\",0,NULL,1,1,1,0,0}, // ... }; 这样通过一个命令表，能够快捷的找到命令实现及相关参数。 ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:4:1","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"命令的执行 找到命令之后即可执行命令。继续看processCommand()函数。在经过一系列特殊情况处理之后，开始执行命令。 // 命令的执行 int processCommand(redisClient *c) { // ...查找命令 // 一系列特殊情况处理 /* Exec the command */ if (c-\u003eflags \u0026 REDIS_MULTI \u0026\u0026 c-\u003ecmd-\u003eproc != execCommand \u0026\u0026 c-\u003ecmd-\u003eproc != discardCommand \u0026\u0026 c-\u003ecmd-\u003eproc != multiCommand \u0026\u0026 c-\u003ecmd-\u003eproc != watchCommand) { // 事务状态下的特殊处理 queueMultiCommand(c); addReply(c,shared.queued); } else { // 执行命令 call(c,REDIS_CALL_FULL); c-\u003ewoff = server.master_repl_offset; // 处理那些解除阻塞的键 if (listLength(server.ready_keys)) handleClientsBlockedOnLists(); } return REDIS_OK; } // 执行命令 void call(redisClient *c, int flags) { long long dirty, start, duration; int client_old_flags = c-\u003eflags; // 命令发送倒MONITOR if (listLength(server.monitors) \u0026\u0026 !server.loading \u0026\u0026 !(c-\u003ecmd-\u003eflags \u0026 (REDIS_CMD_SKIP_MONITOR|REDIS_CMD_ADMIN))) { replicationFeedMonitors(c,server.monitors,c-\u003edb-\u003eid,c-\u003eargv,c-\u003eargc); } // 执行命令 c-\u003eflags \u0026= ~(REDIS_FORCE_AOF|REDIS_FORCE_REPL); redisOpArrayInit(\u0026server.also_propagate); dirty = server.dirty; start = ustime(); c-\u003ecmd-\u003eproc(c); // 命令实现函数 duration = ustime()-start; // 执行时间 dirty = server.dirty-dirty; // 命令执行dirty的数量 if (dirty \u003c 0) dirty = 0; // ... 一系列附加操作 } 最终调用到setCommand(redisClient *c)函数。 /* SET key value [NX] [XX] [EX \u003cseconds\u003e] [PX \u003cmilliseconds\u003e] */ void setCommand(redisClient *c) { int j; robj *expire = NULL; int unit = UNIT_SECONDS; int flags = REDIS_SET_NO_FLAGS; // 设置选项参数 for (j = 3; j \u003c c-\u003eargc; j++) { char *a = c-\u003eargv[j]-\u003eptr; robj *next = (j == c-\u003eargc-1) ? NULL : c-\u003eargv[j+1]; if ((a[0] == 'n' || a[0] == 'N') \u0026\u0026 (a[1] == 'x' || a[1] == 'X') \u0026\u0026 a[2] == '\\0') { flags |= REDIS_SET_NX; } else if ((a[0] == 'x' || a[0] == 'X') \u0026\u0026 (a[1] == 'x' || a[1] == 'X') \u0026\u0026 a[2] == '\\0') { flags |= REDIS_SET_XX; } else if ((a[0] == 'e' || a[0] == 'E') \u0026\u0026 (a[1] == 'x' || a[1] == 'X') \u0026\u0026 a[2] == '\\0' \u0026\u0026 next) { unit = UNIT_SECONDS; expire = next; j++; } else if ((a[0] == 'p' || a[0] == 'P') \u0026\u0026 (a[1] == 'x' || a[1] == 'X') \u0026\u0026 a[2] == '\\0' \u0026\u0026 next) { unit = UNIT_MILLISECONDS; expire = next; j++; } else { addReply(c,shared.syntaxerr); return; } } // 尝试编码转换 c-\u003eargv[2] = tryObjectEncoding(c-\u003eargv[2]); // set命令通用的实现 setGenericCommand(c,flags,c-\u003eargv[1],c-\u003eargv[2],expire,unit,NULL,NULL); } void setGenericCommand(redisClient *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) { long long milliseconds = 0; /* initialized to avoid any harmness warning */ // 取出过期时间 expire为过期时间参数 if (expire) { if (getLongLongFromObjectOrReply(c, expire, \u0026milliseconds, NULL) != REDIS_OK) return; if (milliseconds \u003c= 0) { addReplyErrorFormat(c,\"invalid expire time in %s\",c-\u003ecmd-\u003ename); return; } if (unit == UNIT_SECONDS) milliseconds *= 1000; } // 如果REDIS_SET_NX REDIS_SET_XX 判断是否符合规范 if ((flags \u0026 REDIS_SET_NX \u0026\u0026 lookupKeyWrite(c-\u003edb,key) != NULL) || (flags \u0026 REDIS_SET_XX \u0026\u0026 lookupKeyWrite(c-\u003edb,key) == NULL)) { addReply(c, abort_reply ? abort_reply : shared.nullbulk); return; } // 设置键 setKey(c-\u003edb,key,val); server.dirty++; // 脏计数增加 if (expire) setExpire(c-\u003edb,key,mstime()+milliseconds); // 设置过期时间 notifyKeyspaceEvent(REDIS_NOTIFY_STRING,\"set\",key,c-\u003edb-\u003eid); // 发送事件通知 if (expire) notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC, \"expire\",key,c-\u003edb-\u003eid);// 发送事件通知 addReply(c, ok_reply ? ok_reply : shared.ok); // 回复 } ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:4:2","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"回复客户端 在执行命令出错或者成功后使用addReply()生成回复信息，该函数将通过prepareClientToWrite()产生回复客户端的文件事件，同时将回复内容复制到回复缓存区。 void addReply(redisClient *c, robj *obj) { if (prepareClientToWrite(c) != REDIS_OK) return; // 生成回复客户端的文件事件 // 根据不同情况，生成回复内容,写入不同的缓冲区 if (sdsEncodedObject(obj)) { if (_addReplyToBuffer(c,obj-\u003eptr,sdslen(obj-\u003eptr)) != REDIS_OK) _addReplyObjectToList(c,obj); } else if (obj-\u003eencoding == REDIS_ENCODING_INT) { /* Optimization: if there is room in the static buffer for 32 bytes * (more than the max chars a 64 bit integer can take as string) we * avoid decoding the object and go for the lower level approach. */ if (listLength(c-\u003ereply) == 0 \u0026\u0026 (sizeof(c-\u003ebuf) - c-\u003ebufpos) \u003e= 32) { char buf[32]; int len; len = ll2string(buf,sizeof(buf),(long)obj-\u003eptr); if (_addReplyToBuffer(c,buf,len) == REDIS_OK) return; /* else... continue with the normal code path, but should never * happen actually since we verified there is room. */ } obj = getDecodedObject(obj); if (_addReplyToBuffer(c,obj-\u003eptr,sdslen(obj-\u003eptr)) != REDIS_OK) _addReplyObjectToList(c,obj); decrRefCount(obj); } else { redisPanic(\"Wrong obj-\u003eencoding in addReply()\"); } } int prepareClientToWrite(redisClient *c) { // lua 脚本伪客户端 if (c-\u003eflags \u0026 REDIS_LUA_CLIENT) return REDIS_OK; // 客户端为REDIS_MASTER REDIS_MASTER_FORCE_REPLY if ((c-\u003eflags \u0026 REDIS_MASTER) \u0026\u0026 !(c-\u003eflags \u0026 REDIS_MASTER_FORCE_REPLY)) return REDIS_ERR; if (c-\u003efd \u003c= 0) return REDIS_ERR; /* Fake client for AOF loading. */ // 一般的客户端生成写事件 if (c-\u003ebufpos == 0 \u0026\u0026 listLength(c-\u003ereply) == 0 \u0026\u0026 (c-\u003ereplstate == REDIS_REPL_NONE || (c-\u003ereplstate == REDIS_REPL_ONLINE \u0026\u0026 !c-\u003erepl_put_online_on_ack))) { /* Try to install the write handler. */ if (aeCreateFileEvent(server.el, c-\u003efd, AE_WRITABLE, sendReplyToClient, c) == AE_ERR) { freeClientAsync(c); return REDIS_ERR; } } /* Authorize the caller to queue in the output buffer of this client. */ return REDIS_OK; } 最终文件事件调用sendReplyToClient()回复客户端。 void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) { redisClient *c = privdata; int nwritten = 0, totwritten = 0, objlen; size_t objmem; robj *o; REDIS_NOTUSED(el); REDIS_NOTUSED(mask); // 从缓存区获取数据，写入，直到写完 while(c-\u003ebufpos \u003e 0 || listLength(c-\u003ereply)) { if (c-\u003ebufpos \u003e 0) { // 先写入回复缓冲区数据 nwritten = write(fd,c-\u003ebuf+c-\u003esentlen,c-\u003ebufpos-c-\u003esentlen); if (nwritten \u003c= 0) break; // 出错跳出 // 成功计数 c-\u003esentlen += nwritten; totwritten += nwritten; // 如果内容写完则清空两个计数器 if (c-\u003esentlen == c-\u003ebufpos) { c-\u003ebufpos = 0; c-\u003esentlen = 0; } } else { // 回复缓冲区为空的话，在回复链表查找 o = listNodeValue(listFirst(c-\u003ereply)); objlen = sdslen(o-\u003eptr); objmem = getStringObjectSdsUsedMemory(o); // 跳过空对象 if (objlen == 0) { listDelNode(c-\u003ereply,listFirst(c-\u003ereply)); c-\u003ereply_bytes -= objmem; continue; } // 写入 nwritten = write(fd, ((char*)o-\u003eptr)+c-\u003esentlen,objlen-c-\u003esentlen); if (nwritten \u003c= 0) break; // 出错跳出 // 计数 c-\u003esentlen += nwritten; totwritten += nwritten; // 如果汉冲去内容写入完毕，删除已经写入的节点 if (c-\u003esentlen == objlen) { listDelNode(c-\u003ereply,listFirst(c-\u003ereply)); c-\u003esentlen = 0; c-\u003ereply_bytes -= objmem; } } // 写入量超过限制 在最大内存没设或者最大内存没使用完的情况下跳出 server.stat_net_output_bytes += totwritten; if (totwritten \u003e REDIS_MAX_WRITE_PER_EVENT \u0026\u0026 (server.maxmemory == 0 || zmalloc_used_memory() \u003c server.maxmemory)) break; } // 写入出错 if (nwritten == -1) { if (errno == EAGAIN) { nwritten = 0; } else { redisLog(REDIS_VERBOSE, \"Error writing to client: %s\", strerror(errno)); freeClient(c); return; } } if (totwritten \u003e 0) { /* For clients representing masters we don't count sending data * as an interaction, since we always send REPLCONF ACK commands * that take some time to just fill the socket output buffer. * We just rely on data / pings received for timeout detection. */ if (!(c-\u003eflags \u0026 REDIS_MASTER)) c-\u003elastinteraction = server.unixtime; } if (c-\u003ebufpos == 0 \u0026\u0026 listLength(c-\u003ereply) == 0) { c-\u003esentlen = 0; // 写完了删除write handler aeDeleteFileEvent(server.el,c-\u003efd,AE_WRITABLE); // 必要的话关闭客户端 if (c-\u003eflags \u0026 REDIS_CLOSE_AFTER_REPLY) freeClient(c); } } ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:5:0","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"结束 至此一个命令的旅程就结束了。 ","date":"2017-07-18","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/:6:0","tags":["redis","源码阅读"],"title":"redis源码阅读-一个命令的旅程","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/"},{"categories":["源码阅读"],"content":"redis源码阅读-事件 redis服务器是一个事件驱动程序。当触发一个事件时,redis会创建一个事件,放入到待处理的队列，依次进行处理。 redis事件分为文件时间和时间事件。 文件事件：文件事件是对套接字操作的抽象，当服务器与客户端进行通讯，会产生出各种文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通讯操作。 时间事件：redis一些操作是需要定时进行执行的，而时间事件就是对这类操作的抽象。 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"事件的实现 以下是事件结构体定义。 /* File event structure */ typedef struct aeFileEvent { int mask; // one of AE_(READABLE|WRITABLE) 类型 aeFileProc *rfileProc; // 读事件处理器 aeFileProc *wfileProc; // 写事件处理器 void *clientData; // 多路复用库的私有数据 } aeFileEvent; /* Time event structure */ typedef struct aeTimeEvent { long long id; // 唯一标志 long when_sec; // 事件到达事件s long when_ms; // 事件到达事件ms aeTimeProc *timeProc; // 事件处理函数 aeEventFinalizerProc *finalizerProc; // 事件释放函数 void *clientData; // 多路复用库的私有数据 struct aeTimeEvent *next; //　指向下一个时间事件结构，形成链表 } aeTimeEvent; /* A fired event */ // 触发的事件结构体 typedef struct aeFiredEvent { int fd; // 文件事件描述符 int mask;　// one of AE_(READABLE|WRITABLE) 类型 } aeFiredEvent; // 事件循环结构体 typedef struct aeEventLoop { int maxfd; // 当前注册的最大描述符 int setsize; // 需要监听的描述符个数 long long timeEventNextId; // 下一个时间事件ID time_t lastTime; // 上一次时间循环时间 aeFileEvent *events; // 注册要使用的文件时间 aeFiredEvent *fired; // 已准备好，待处理事件 aeTimeEvent *timeEventHead; // 时间事件 int stop; // 事件处理器开关 void *apidata; // 处理多路服用库的私有数据 aeBeforeSleepProc *beforesleep; // 处理事件前要执行的函数 } aeEventLoop; ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"事件处理流程 redis使用i/o多路复用程序同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。文件处理流程如图。时间事件则定时执行。 图片(来自《Redis设计与实现》 ## 事件的API /* Prototypes */ aeEventLoop *aeCreateEventLoop(int setsize); // 初始化时间处理器状态 void aeDeleteEventLoop(aeEventLoop *eventLoop); // 删除事件处理器 void aeStop(aeEventLoop *eventLoop); // 停止事件处理器 int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData); // 根据mask参数，监听fd文件的状态，fd可用，执行proc函数 void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask);// 将fd从mask指定的监听队列中删除 int aeGetFileEvents(aeEventLoop *eventLoop, int fd); // 获取给定fd正在监听的事件类型 long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc); // 创建时间事件 int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id); // 删除给定ID的时间事件 int aeProcessEvents(aeEventLoop *eventLoop, int flags); // 处理所有已经到达时间的事件，以及所有就绪的文件事件 int aeWait(int fd, int mask, long long milliseconds); // 指定时间等待fd变为可读、可写 void aeMain(aeEventLoop *eventLoop);// 事件处理主循环 char *aeGetApiName(void); // 返回所使用的多路服用库的名字 void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep); // 设置事件前所需要执行的函数 int aeGetSetSize(aeEventLoop *eventLoop); // 返回当前事件槽大小 int aeResizeSetSize(aeEventLoop *eventLoop, int setsize); // 调整事件槽大小 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"文件事件的创建 文件事件有三个方面需要创建： 连接应答处理器，用来处理对连接服务器监听套接字的客户端进行应答。 命令请求处理器，用来处理从套接字读取客户端发送的命令请求内容。 命令回复处理器，用来处理执行命令后得到的命令回复通过套接字返回给客户端。 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"连接应答处理器 acceptTcpHandler是连接应答处理器，当监听套接字产生AE_READABLE事件时，就会引发连接应答处理器。 void initServer() { // ... // 为 TCP 连接关联连接应答（accept）处理器 for (j = 0; j \u003c server.ipfd_count; j++) { if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL) == AE_ERR) { redisPanic( \"Unrecoverable error creating server.ipfd file event.\"); } } // 为本地套接字关联应答处理器 if (server.sofd \u003e 0 \u0026\u0026 aeCreateFileEvent(server.el,server.sofd,AE_READABLE, acceptUnixHandler,NULL) == AE_ERR) redisPanic(\"Unrecoverable error creating server.sofd file event.\"); // ... } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:3:1","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"命令请求处理器 在连接应答处理器调用的函数acceptTcpHandler中，会在连接成功之后，创建命令请求处理器readQueryFromClient()，在客户端发送的命令请求时，调用命令请求处理器进行处理。 // 创建一个 TCP 连接处理器 void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) { int cport, cfd, max = MAX_ACCEPTS_PER_CALL; char cip[REDIS_IP_STR_LEN]; REDIS_NOTUSED(el); REDIS_NOTUSED(mask); REDIS_NOTUSED(privdata); while(max--) { // accept 客户端连接 cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), \u0026cport); if (cfd == ANET_ERR) { if (errno != EWOULDBLOCK) redisLog(REDIS_WARNING, \"Accepting client connection: %s\", server.neterr); return; } redisLog(REDIS_VERBOSE,\"Accepted %s:%d\", cip, cport); // 连接完成，创建一个客户端状态 acceptCommonHandler(cfd,0); } } #define MAX_ACCEPTS_PER_CALL 1000 static void acceptCommonHandler(int fd, int flags) { // 创建客户端 redisClient *c; if ((c = createClient(fd)) == NULL) { redisLog(REDIS_WARNING, \"Error registering fd event for the new client: %s (fd=%d)\", strerror(errno),fd); close(fd); /* May be already closed, just ignore errors */ return; } // 达到上限 if (listLength(server.clients) \u003e server.maxclients) { char *err = \"-ERR max number of clients reached\\r\\n\"; if (write(c-\u003efd,err,strlen(err)) == -1) { } // 更新拒绝连接数 server.stat_rejected_conn++; freeClient(c); return; } server.stat_numconnections++; c-\u003eflags |= flags; } redisClient *createClient(int fd) { redisClient *c = zmalloc(sizeof(redisClient)); // -1时使用的是无网络连接的伪客户端 if (fd != -1) { anetNonBlock(NULL,fd); // 非阻塞 anetEnableTcpNoDelay(NULL,fd); // 关闭nagle算法，那个合并小报文的算法 if (server.tcpkeepalive) anetKeepAlive(NULL,fd,server.tcpkeepalive); // 创建命令请求处理器 if (aeCreateFileEvent(server.el,fd,AE_READABLE, readQueryFromClient, c) == AE_ERR) { close(fd); zfree(c); return NULL; } } // 客户端的初始化 // ... } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:3:2","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"命令回复处理器 当服务器有命令回复需要传送给客户端时，服务器将客户端套接字的AE_WRITABLE事件与命令回复处理器关联，当客户端准备好接收时，就会执行AE_WRITABLE事件，触发命令回复处理器。 int prepareClientToWrite(redisClient *c) { if (c-\u003eflags \u0026 REDIS_LUA_CLIENT) return REDIS_OK; if ((c-\u003eflags \u0026 REDIS_MASTER) \u0026\u0026 !(c-\u003eflags \u0026 REDIS_MASTER_FORCE_REPLY)) return REDIS_ERR; if (c-\u003efd \u003c= 0) return REDIS_ERR; /* Fake client */ // 为客户端套接字安装写处理器到事件循环 if (c-\u003ebufpos == 0 \u0026\u0026 listLength(c-\u003ereply) == 0 \u0026\u0026 (c-\u003ereplstate == REDIS_REPL_NONE || c-\u003ereplstate == REDIS_REPL_ONLINE) \u0026\u0026 aeCreateFileEvent(server.el, c-\u003efd, AE_WRITABLE, sendReplyToClient, c) == AE_ERR) return REDIS_ERR; return REDIS_OK; } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:3:3","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"时间事件的创建 redis在初始化时创建时间时间，用来周期执行serverCron()。 serverCron()主要功能： 更新服务器的各类统计信息 清理过期的键值对 关闭和清理连接失效的客户端 尝试AOF\\RDB持久化 主服务器则定期同步 集群模式，对集群定期同步和连接测试 void initServer() { // ... // 为 serverCron() 创建时间事件 if(aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) { redisPanic(\"Can't create the serverCron time event.\"); exit(1); } // ... } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:4:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"事件循环 事件循环主函数为aeMain()，该函数在redis的main()函数中被调用 int main(int argc, char **argv) { // ... // 运行事件处理器，一直到服务器关闭为止 aeSetBeforeSleepProc(server.el,beforeSleep); // 设置事件前调用函数 aeMain(server.el); // 服务器关闭，停止事件循环 aeDeleteEventLoop(server.el); return 0; ｝ 事件循环的实现 // 事件处理器的主循环 void aeMain(aeEventLoop *eventLoop) { eventLoop-\u003estop = 0; while (!eventLoop-\u003estop) { // 如果有需要在事件处理前执行的函数，那么运行它 if (eventLoop-\u003ebeforesleep != NULL) eventLoop-\u003ebeforesleep(eventLoop); // 开始处理事件 aeProcessEvents(eventLoop, AE_ALL_EVENTS); } } // 事件处理函数 int aeProcessEvents(aeEventLoop *eventLoop, int flags) { int processed = 0, numevents; // 没有需要处理的事件则返回 if (!(flags \u0026 AE_TIME_EVENTS) \u0026\u0026 !(flags \u0026 AE_FILE_EVENTS)) return 0; if (eventLoop-\u003emaxfd != -1 || ((flags \u0026 AE_TIME_EVENTS) \u0026\u0026 !(flags \u0026 AE_DONT_WAIT))) { int j; aeTimeEvent *shortest = NULL; struct timeval tv, *tvp; // 获取最近的时间事件 if (flags \u0026 AE_TIME_EVENTS \u0026\u0026 !(flags \u0026 AE_DONT_WAIT)) shortest = aeSearchNearestTimer(eventLoop); if (shortest) { long now_sec, now_ms; /* Calculate the time missing for the nearest * timer to fire. */ aeGetTime(\u0026now_sec, \u0026now_ms); tvp = \u0026tv; tvp-\u003etv_sec = shortest-\u003ewhen_sec - now_sec; if (shortest-\u003ewhen_ms \u003c now_ms) { tvp-\u003etv_usec = ((shortest-\u003ewhen_ms+1000) - now_ms)*1000; tvp-\u003etv_sec --; } else { tvp-\u003etv_usec = (shortest-\u003ewhen_ms - now_ms)*1000; } // 获取要执行事件事件，要等待的时间 if (tvp-\u003etv_sec \u003c 0) tvp-\u003etv_sec = 0; if (tvp-\u003etv_usec \u003c 0) tvp-\u003etv_usec = 0; } else { // 没有时间事件 // 根据AE_DONT_WAIT参数来设置文件事件的阻塞、阻塞时间 if (flags \u0026 AE_DONT_WAIT) { tv.tv_sec = tv.tv_usec = 0; tvp = \u0026tv; } else { /* Otherwise we can block */ tvp = NULL; /* wait forever */ } } // 调用io复用函数获取准备好的事件，底层使用select或epoll或其他实现 // tvp阻塞时间 numevents = aeApiPoll(eventLoop, tvp); for (j = 0; j \u003c numevents; j++) { // 获取所有能够执行的文件事件，并执行 aeFileEvent *fe = \u0026eventLoop-\u003eevents[eventLoop-\u003efired[j].fd]; int mask = eventLoop-\u003efired[j].mask; int fd = eventLoop-\u003efired[j].fd; int rfired = 0; /* note the fe-\u003emask \u0026 mask \u0026 ... code: maybe an already processed * event removed an element that fired and we still didn't * processed, so we check if the event is still valid. */ if (fe-\u003emask \u0026 mask \u0026 AE_READABLE) { // 读事件 rfired = 1; fe-\u003erfileProc(eventLoop,fd,fe-\u003eclientData,mask); } if (fe-\u003emask \u0026 mask \u0026 AE_WRITABLE) { // 写事件 if (!rfired || fe-\u003ewfileProc != fe-\u003erfileProc) fe-\u003ewfileProc(eventLoop,fd,fe-\u003eclientData,mask); } processed++; } } /* Check time events */ // 执行时间事件，在阻塞等待一段时间之后，时间事件已经能够执行 if (flags \u0026 AE_TIME_EVENTS) processed += processTimeEvents(eventLoop); return processed; /* return the number of processed file/time events */ } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:5:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"小结 事件其实不算复杂，整个redis没有太多的事件。但是要理解IO多路服用和redis事件的调用逻辑。理清楚之后就比较好办了。 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/:6:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事件","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/"},{"categories":["源码阅读"],"content":"redis的事务提供了一种将单个命令请求打包，然后一次性、按照顺序执行多个命令的机制，这种方式服务器会一次性把命令执行完，中间不会执行其他客户端的命令。不过redis的命令不支持错误命令执行后的回滚机制，也就是命令设计者要对命令的正确性负责，即使多个命令中存在部分错误的命令，剩余命令也会继续执行下去。 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事务","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/"},{"categories":["源码阅读"],"content":"主要命令 命令 功能 MULTI 开始一个新的事务 DISCARD 放弃执行事务 EXEC 执行事务中的所有命令 WATCH 监视key，如果在exec之前被修改，则不执行事务 UNWATCH 取消对所有键的监视 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事务","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/"},{"categories":["源码阅读"],"content":"事务的实现 一个事务分为三个阶段： 事务开始 命令入队 事务执行 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-事务","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/"},{"categories":["源码阅读"],"content":"事务开始 使用multi开启事务，redis主要使用redisClient中flag成员记录状态。 void multiCommand(redisClient *c) { // 已经开启事务 if (c-\u003eflags \u0026 REDIS_MULTI) { addReplyError(c,\"MULTI calls can not be nested\"); return; } // 标记事务开启 c-\u003eflags |= REDIS_MULTI; addReply(c,shared.ok); } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/:2:1","tags":["redis","源码阅读"],"title":"redis源码阅读-事务","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/"},{"categories":["源码阅读"],"content":"事务入队 当客户端进入事务状态时，客户端不会立即执行命令EXEC、DISCARD、WATCH、MULTI之外的命令，这些命令先进入事务队列，在之后事务执行时候执行。 // 客户端结构体 struct redisClient { // .... multiState mstate; // 事务状态 // .... } // 事务状态 typedef struct multiState { multiCmd *commands; // 事务队列 int count; // 命令计数 int minreplicas; // 用于同步复制 time_t minreplicas_timeout; // 超时时间 } multiState; // 事务命令 typedef struct multiCmd { robj **argv; // 参数 int argc; // 参数数量 struct redisCommand *cmd; // 命令指针 } multiCmd; redis在执行客户端命令时，会判断事务是否开启，如果开启且不是上面提到的几个命令，那么就会将命令压入队列,在redis的命令处理函数processCommand()中。 int processCommand(redisClient *c) { // ... /* Exec the command */ if (c-\u003eflags \u0026 REDIS_MULTI \u0026\u0026 c-\u003ecmd-\u003eproc != execCommand \u0026\u0026 c-\u003ecmd-\u003eproc != discardCommand \u0026\u0026 c-\u003ecmd-\u003eproc != multiCommand \u0026\u0026 c-\u003ecmd-\u003eproc != watchCommand) { // 处在事务状态 // 不是execCommand、discardCommand、multiCommand、watchCommand // 执行入队操作 queueMultiCommand(c); addReply(c,shared.queued); } else { // 命令直接执行 call(c,REDIS_CALL_FULL); c-\u003ewoff = server.master_repl_offset; if (listLength(server.ready_keys)) handleClientsBlockedOnLists(); } // ... } 入队的实现:入队功能依靠queueMultiCommand()实现 void queueMultiCommand(redisClient *c) { multiCmd *mc; int j; // 重新分配足够的空间 c-\u003emstate.commands = zrealloc(c-\u003emstate.commands, sizeof(multiCmd)*(c-\u003emstate.count+1)); mc = c-\u003emstate.commands+c-\u003emstate.count; // 压入点 // 初始化事务结构体 mc-\u003ecmd = c-\u003ecmd; mc-\u003eargc = c-\u003eargc; mc-\u003eargv = zmalloc(sizeof(robj*)*c-\u003eargc); memcpy(mc-\u003eargv,c-\u003eargv,sizeof(robj*)*c-\u003eargc); for (j = 0; j \u003c c-\u003eargc; j++) incrRefCount(mc-\u003eargv[j]); c-\u003emstate.count++; // 计数+1 } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/:2:2","tags":["redis","源码阅读"],"title":"redis源码阅读-事务","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/"},{"categories":["源码阅读"],"content":"事务的执行 当处于事务状态的客户端向服务器发送EXEC命令时，这个命令被立即执行，具体见processCommand()函数。 最终命令调用execCommand()执行exec命令。 void execCommand(redisClient *c) { int j; robj **orig_argv; int orig_argc; struct redisCommand *orig_cmd; int must_propagate = 0; /* Need to propagate MULTI/EXEC to AOF / slaves? */ // 判断是否执行事务中 if (!(c-\u003eflags \u0026 REDIS_MULTI)) { addReplyError(c,\"EXEC without MULTI\"); return; } // 判断监视键是否被修改 // 命令在入队时发送错误 // 均不执行命令 // 取消事务 if (c-\u003eflags \u0026 (REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC)) { addReply(c, c-\u003eflags \u0026 REDIS_DIRTY_EXEC ? shared.execaborterr : shared.nullmultibulk); discardTransaction(c); // 取消事务 goto handle_monitor; } // 取消对键的监视 unwatchAllKeys(c); /* Unwatch ASAP otherwise we'll waste CPU cycles */ // 备份 orig_argv = c-\u003eargv; orig_argc = c-\u003eargc; orig_cmd = c-\u003ecmd; addReplyMultiBulkLen(c,c-\u003emstate.count); // 遍历事务中的命令，执行 for (j = 0; j \u003c c-\u003emstate.count; j++) { // 备份 c-\u003eargc = c-\u003emstate.commands[j].argc; c-\u003eargv = c-\u003emstate.commands[j].argv; c-\u003ecmd = c-\u003emstate.commands[j].cmd; // 在事务中，发现了写命令，传播multi if (!must_propagate \u0026\u0026 !(c-\u003ecmd-\u003eflags \u0026 REDIS_CMD_READONLY)) { execCommandPropagateMulti(c); must_propagate = 1; } // 执行命令 call(c,REDIS_CALL_FULL); // 恢复 c-\u003emstate.commands[j].argc = c-\u003eargc; c-\u003emstate.commands[j].argv = c-\u003eargv; c-\u003emstate.commands[j].cmd = c-\u003ecmd; } // 恢复 c-\u003eargv = orig_argv; c-\u003eargc = orig_argc; c-\u003ecmd = orig_cmd; discardTransaction(c); // 关闭事务状态 /* Make sure the EXEC command will be propagated as well if MULTI * was already propagated. */ if (must_propagate) server.dirty++; handle_monitor: /* Send EXEC to clients waiting data from MONITOR. We do it here * since the natural order of commands execution is actually: * MUTLI, EXEC, ... commands inside transaction ... * Instead EXEC is flagged as REDIS_CMD_SKIP_MONITOR in the command * table, and we do it here with correct ordering. */ if (listLength(server.monitors) \u0026\u0026 !server.loading) replicationFeedMonitors(c,server.monitors,c-\u003edb-\u003eid,c-\u003eargv,c-\u003eargc); } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/:2:3","tags":["redis","源码阅读"],"title":"redis源码阅读-事务","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/"},{"categories":["源码阅读"],"content":"事务取消 DISCARD函数取消客户端的事务状态 // discardCommand命令处理函数 void discardCommand(redisClient *c) { // 没有在事务状态 if (!(c-\u003eflags \u0026 REDIS_MULTI)) { addReplyError(c,\"DISCARD without MULTI\"); return; } // 取消事务状态 discardTransaction(c); addReply(c,shared.ok); } // 取消事务状态 void discardTransaction(redisClient *c) { freeClientMultiState(c); // 释放事务 initClientMultiState(c); // 初始化事务 // 取消事务状态 c-\u003eflags \u0026= ~(REDIS_MULTI|REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC); unwatchAllKeys(c); // 取消键的监视 } void freeClientMultiState(redisClient *c) { int j; for (j = 0; j \u003c c-\u003emstate.count; j++) { int i; multiCmd *mc = c-\u003emstate.commands+j; for (i = 0; i \u003c mc-\u003eargc; i++) decrRefCount(mc-\u003eargv[i]); zfree(mc-\u003eargv); } zfree(c-\u003emstate.commands); } void initClientMultiState(redisClient *c) { c-\u003emstate.commands = NULL; c-\u003emstate.count = 0; } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/:2:4","tags":["redis","源码阅读"],"title":"redis源码阅读-事务","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/"},{"categories":["源码阅读"],"content":"WATCH命令的实现 WATCH命令用来监视键是否被修改。 typedef struct redisDb { // ... dict *watched_keys; // 监视键的字典，字典的键为数据库的键，值为链表，保存所有监视的客户端 // ... } redisDb; typedef struct redisClient { // ... list *watched_keys; // 保存该客户端所有被监视的键,保存watchedKey结构 // ... } typedef struct watchedKey { robj *key; // 保存键 redisDb *db; // 保存键所在的数据库 } watchedKey; WATCH的触发 所有的对数据库进行修改的命令，比如set、del等，在执行之后都会调用signalModifiedKey(redisDb *db, robj *key)，而该函数调用touchWatchedKey(redisDb *db, robj *key)。touchWatchedKey(redisDb *db, robj *key)查找监视字典，对被修改的键进行标记。 void signalModifiedKey(redisDb *db, robj *key) { touchWatchedKey(db,key); } void touchWatchedKey(redisDb *db, robj *key) { list *clients; listIter li; listNode *ln; // 字典为空 if (dictSize(db-\u003ewatched_keys) == 0) return; // 获取进行监视的客户端 clients = dictFetchValue(db-\u003ewatched_keys, key); if (!clients) return; // 遍历所有客户端，进行标记 listRewind(clients,\u0026li); while((ln = listNext(\u0026li))) { redisClient *c = listNodeValue(ln); c-\u003eflags |= REDIS_DIRTY_CAS; } } 监视的开启 监视的开启就是在字典里添加键 void watchCommand(redisClient *c) { int j; if (c-\u003eflags \u0026 REDIS_MULTI) { addReplyError(c,\"WATCH inside MULTI is not allowed\"); return; } for (j = 1; j \u003c c-\u003eargc; j++) watchForKey(c,c-\u003eargv[j]); addReply(c,shared.ok); } // 客户端C监视键Key void watchForKey(redisClient *c, robj *key) { list *clients = NULL; listIter li; listNode *ln; watchedKey *wk; // 判断是否已经被监视了 // 发现则直接返回 listRewind(c-\u003ewatched_keys,\u0026li); while((ln = listNext(\u0026li))) { wk = listNodeValue(ln); if (wk-\u003edb == c-\u003edb \u0026\u0026 equalStringObjects(key,wk-\u003ekey)) return; /* Key already watched */ } // 检查key是否存在数据库的watched_keys字典力 clients = dictFetchValue(c-\u003edb-\u003ewatched_keys,key); if (!clients) { // 不存在就增加一个链表 clients = listCreate(); dictAdd(c-\u003edb-\u003ewatched_keys,key,clients); incrRefCount(key); } // 在链表末尾增加key // 前面已经保证没有被监视过，所以这里不需要再判断，直接插入到末尾 listAddNodeTail(clients,c); /* Add the new key to the list of keys watched by this client */ wk = zmalloc(sizeof(*wk)); wk-\u003ekey = key; wk-\u003edb = c-\u003edb; incrRefCount(key); listAddNodeTail(c-\u003ewatched_keys,wk); } 监视的关闭 监视的关闭即将字典中键删除。 void unwatchCommand(redisClient *c) { // 取消客户端对所有键的监视 unwatchAllKeys(c); // 重置状态 c-\u003eflags \u0026= (~REDIS_DIRTY_CAS); addReply(c,shared.ok); } // 清除所有监视 void unwatchAllKeys(redisClient *c) { listIter li; listNode *ln; // 没有键被监视，直接返回 if (listLength(c-\u003ewatched_keys) == 0) return; // 遍历被监视的键 listRewind(c-\u003ewatched_keys,\u0026li); while((ln = listNext(\u0026li))) { list *clients; watchedKey *wk; wk = listNodeValue(ln); // 键 clients = dictFetchValue(wk-\u003edb-\u003ewatched_keys, wk-\u003ekey); // 数据库中查找 redisAssertWithInfo(c,NULL,clients != NULL); listDelNode(clients,listSearchKey(clients,c)); // 删除数据库中监视节点 // 如果链表为空，删除键 if (listLength(clients) == 0) dictDelete(wk-\u003edb-\u003ewatched_keys, wk-\u003ekey); // 删除客户端监视的节点key listDelNode(c-\u003ewatched_keys,ln); decrRefCount(wk-\u003ekey); zfree(wk); } } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/:2:5","tags":["redis","源码阅读"],"title":"redis源码阅读-事务","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/"},{"categories":["源码阅读"],"content":"之前看了RDB持久化，功能是把数据库的数据全部使用一种特定格式进行存储。恢复时一个一个数据库键恢复。 AOF持久化与RDB持久化不同，AOF通过保存Redis服务器执行的写命令来记录数据库的状态。 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/:0:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-AOF持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"AOF持久化的实现 AOF持久化功能分为命令追加、文件写入、文件同步三个步骤。 命令追加：将命令数据写入aof_buf缓冲区 文件写入：将aof_buff缓冲区数据写入系统IO缓冲区 文件同步：将系统IO缓冲区的数据同步到磁盘文件 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/:1:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-AOF持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"命令追加 AOF持久化打开时，服务器在执行一个写命令之后，会以协议的格式将执行的命令追加倒服务器状态aof_buf缓冲区尾部。 struct redisServer { // ... sds aof_buf; // aof缓冲区 // .... } 命令追加的实现 // 将命令追加到AOF缓冲区中 void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) { sds buf = sdsempty(); robj *tmpargv[3]; // 如果没切换到正确的数据库，则追加切换数据库命令 if (dictid != server.aof_selected_db) { char seldb[64]; snprintf(seldb,sizeof(seldb),\"%d\",dictid); buf = sdscatprintf(buf,\"*2\\r\\n$6\\r\\nSELECT\\r\\n$%lu\\r\\n%s\\r\\n\", (unsigned long)strlen(seldb),seldb); server.aof_selected_db = dictid; } // 根据命令类型追加命令 if (cmd-\u003eproc == expireCommand || cmd-\u003eproc == pexpireCommand || cmd-\u003eproc == expireatCommand) { // 追加过期键命令 buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]); } else if (cmd-\u003eproc == setexCommand || cmd-\u003eproc == psetexCommand) { // 追加setexCommand或者psetexCommand tmpargv[0] = createStringObject(\"SET\",3); tmpargv[1] = argv[1]; tmpargv[2] = argv[3]; buf = catAppendOnlyGenericCommand(buf,3,tmpargv); decrRefCount(tmpargv[0]); buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]); } else { // 追加其他一般修改数据库命令 buf = catAppendOnlyGenericCommand(buf,argc,argv); } // 将格式化的命令字符串追加到aof_buf缓冲区中 if (server.aof_state == REDIS_AOF_ON) server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf)); if (server.aof_child_pid != -1) // 如果在执行AOF重写，那么追加的新的AOF文件中 aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf)); sdsfree(buf); } // 根据参数，格式化命令 sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) { char buf[32]; int len, j; robj *o; buf[0] = '*'; len = 1+ll2string(buf+1,sizeof(buf)-1,argc); buf[len++] = '\\r'; buf[len++] = '\\n'; dst = sdscatlen(dst,buf,len); // 遍历每一个参数，支架到AOF缓冲区中 for (j = 0; j \u003c argc; j++) { o = getDecodedObject(argv[j]); buf[0] = '$'; len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o-\u003eptr)); buf[len++] = '\\r'; buf[len++] = '\\n'; dst = sdscatlen(dst,buf,len); dst = sdscatlen(dst,o-\u003eptr,sdslen(o-\u003eptr)); dst = sdscatlen(dst,\"\\r\\n\",2); decrRefCount(o); } return dst; } ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/:1:1","tags":["redis","源码阅读"],"title":"Redis源码阅读-AOF持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"文件写入与同步 Redis服务器就是一个事件循环，这个循环中的文件时间负责接收客户端的命令请求，同时存在serverCron函数定时运行函数。 服务器每次结束事件循环之前，会调用flushAppendOnlyFile函数，执行文件写入操作。 调用write函数时，系统会将数据保存到一个内存缓冲区，等到填满时才进行写入，或者在指定时间之后才真正写入。虽然提高了效率，但是带来了数据安全问题。 redis提供了appendgsync选项来设置aof持久化怎么同步，三种方案： always，一直同步，安全性好，但是最慢。 everysec，当aof文件内容全部写入时，每隔一秒在子线程中对aof文件进行一次同步。 no，由操作系统决定什么时候同步。 void flushAppendOnlyFile(int force) { ssize_t nwritten; int sync_in_progress = 0; mstime_t latency; // 缓冲区没有内容直接返回 if (sdslen(server.aof_buf) == 0) return; if (server.aof_fsync == AOF_FSYNC_EVERYSEC) sync_in_progress = bioPendingJobsOfType(REDIS_BIO_AOF_FSYNC) != 0; if (server.aof_fsync == AOF_FSYNC_EVERYSEC \u0026\u0026 !force) { /* With this append fsync policy we do background fsyncing. * If the fsync is still in progress we can try to delay * the write for a couple of seconds. */ if (sync_in_progress) { if (server.aof_flush_postponed_start == 0) { /* No previous write postponing, remember that we are * postponing the flush and return. */ server.aof_flush_postponed_start = server.unixtime; return; } else if (server.unixtime - server.aof_flush_postponed_start \u003c 2) { /* We were already waiting for fsync to finish, but for less * than two seconds this is still ok. Postpone again. */ return; } /* Otherwise fall trough, and go write since we can't wait * over two seconds. */ server.aof_delayed_fsync++; redisLog(REDIS_NOTICE,\"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.\"); } } // 调用write命令将缓冲区数据写入磁盘文件中， latencyStartMonitor(latency); nwritten = write(server.aof_fd,server.aof_buf,sdslen(server.aof_buf)); latencyEndMonitor(latency); /* We want to capture different events for delayed writes: * when the delay happens with a pending fsync, or with a saving child * active, and when the above two conditions are missing. * We also use an additional event name to save all samples which is * useful for graphing / monitoring purposes. */ // ...部分同步功能 // 重置aof写入的延迟时间 server.aof_flush_postponed_start = 0; // 写入操作出现错误 if (nwritten != (signed)sdslen(server.aof_buf)) { static time_t last_write_error_log = 0; int can_log = 0; /* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */ if ((server.unixtime - last_write_error_log) \u003e AOF_WRITE_LOG_ERROR_RATE) { can_log = 1; last_write_error_log = server.unixtime; } /* Log the AOF write error and record the error code. */ // 写错误日志 if (nwritten == -1) { if (can_log) { redisLog(REDIS_WARNING,\"Error writing to the AOF file: %s\", strerror(errno)); server.aof_last_write_errno = errno; } } else { if (can_log) { redisLog(REDIS_WARNING,\"Short write while writing to \" \"the AOF file: (nwritten=%lld, \" \"expected=%lld)\", (long long)nwritten, (long long)sdslen(server.aof_buf)); } // 尝试移除新追加的不完整内容 if (ftruncate(server.aof_fd, server.aof_current_size) == -1) { if (can_log) { redisLog(REDIS_WARNING, \"Could not remove short write \" \"from the append-only file. Redis may refuse \" \"to load the AOF the next time it starts. \" \"ftruncate: %s\", strerror(errno)); } } else { /* If the ftruncate() succeeded we can set nwritten to * -1 since there is no longer partial data into the AOF. */ nwritten = -1; } server.aof_last_write_errno = ENOSPC; } // 处理写入时错误 if (server.aof_fsync == AOF_FSYNC_ALWAYS) { /* We can't recover when the fsync policy is ALWAYS since the * reply for the client is already in the output buffers, and we * have the contract with the user that on acknowledged write data * is synced on disk. */ redisLog(REDIS_WARNING,\"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting...\"); exit(1); } else { /* Recover from failed write leaving data into the buffer. However * set an error to stop accepting writes as long as the error * condition is not cleared. */ server.aof_last_write_status = REDIS_ERR; /* Trim the sds buffer if there was a partial write, and there * was no way to undo it with ftruncate(2). */ if (nwritten \u003e 0) { server.aof_current_size += nwritten; sdsrange(","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/:1:2","tags":["redis","源码阅读"],"title":"Redis源码阅读-AOF持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"AOF文件的载入与数据还原 数据存储在AOF文件中后，服务器只要读取并重新执行一遍AOF文件里保存的写命令，就可以还原服务器关闭之前的数据库状态。 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/:2:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-AOF持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"AOF重写 重写的目的主要是因为很多命令在执行多次后，可以进行合并，恢复时起始并不需要执行这么多命令。其实只要找到数据库的所有数据，生成相对应的命令即可，至于其他的命令完全不需要。 // aof重写的实现 int rewriteAppendOnlyFile(char *filename) { dictIterator *di = NULL; dictEntry *de; rio aof; FILE *fp; char tmpfile[256]; int j; long long now = mstime(); char byte; size_t processed = 0; // 创建一个零食文件 snprintf(tmpfile,256,\"temp-rewriteaof-%d.aof\", (int) getpid()); fp = fopen(tmpfile,\"w\"); if (!fp) { redisLog(REDIS_WARNING, \"Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s\", strerror(errno)); return REDIS_ERR; } server.aof_child_diff = sdsempty(); // redis内部文件结构体初始化 rioInitWithFile(\u0026aof,fp); if (server.aof_rewrite_incremental_fsync) rioSetAutoSync(\u0026aof,REDIS_AOF_AUTOSYNC_BYTES); // 遍历数据库 for (j = 0; j \u003c server.dbnum; j++) { char selectcmd[] = \"*2\\r\\n$6\\r\\nSELECT\\r\\n\"; redisDb *db = server.db+j; dict *d = db-\u003edict; if (dictSize(d) == 0) continue; di = dictGetSafeIterator(d); if (!di) { fclose(fp); return REDIS_ERR; } // 生成数据库选择语句 if (rioWrite(\u0026aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr; if (rioWriteBulkLongLong(\u0026aof,j) == 0) goto werr; // 获取每一个键，生成命令 while((de = dictNext(di)) != NULL) { sds keystr; robj key, *o; long long expiretime; keystr = dictGetKey(de); o = dictGetVal(de); initStaticStringObject(key,keystr); expiretime = getExpire(db,\u0026key); // 跳过过期键 if (expiretime != -1 \u0026\u0026 expiretime \u003c now) continue; // 根据类型保存 if (o-\u003etype == REDIS_STRING) { /* Emit a SET command */ char cmd[]=\"*3\\r\\n$3\\r\\nSET\\r\\n\"; if (rioWrite(\u0026aof,cmd,sizeof(cmd)-1) == 0) goto werr; /* Key and value */ if (rioWriteBulkObject(\u0026aof,\u0026key) == 0) goto werr; if (rioWriteBulkObject(\u0026aof,o) == 0) goto werr; } else if (o-\u003etype == REDIS_LIST) { if (rewriteListObject(\u0026aof,\u0026key,o) == 0) goto werr; } else if (o-\u003etype == REDIS_SET) { if (rewriteSetObject(\u0026aof,\u0026key,o) == 0) goto werr; } else if (o-\u003etype == REDIS_ZSET) { if (rewriteSortedSetObject(\u0026aof,\u0026key,o) == 0) goto werr; } else if (o-\u003etype == REDIS_HASH) { if (rewriteHashObject(\u0026aof,\u0026key,o) == 0) goto werr; } else { redisPanic(\"Unknown object type\"); } // 保存过期时间 if (expiretime != -1) { char cmd[]=\"*3\\r\\n$9\\r\\nPEXPIREAT\\r\\n\"; if (rioWrite(\u0026aof,cmd,sizeof(cmd)-1) == 0) goto werr; if (rioWriteBulkObject(\u0026aof,\u0026key) == 0) goto werr; if (rioWriteBulkLongLong(\u0026aof,expiretime) == 0) goto werr; } /* Read some diff from the parent process from time to time. */ if (aof.processed_bytes \u003e processed+1024*10) { processed = aof.processed_bytes; aofReadDiffFromParent(); } } dictReleaseIterator(di); di = NULL; } if (fflush(fp) == EOF) goto werr; if (fsync(fileno(fp)) == -1) goto werr; /* Read again a few times to get more data from the parent. * We can't read forever (the server may receive data from clients * faster than it is able to send data to the child), so we try to read * some more data in a loop as soon as there is a good chance more data * will come. If it looks like we are wasting time, we abort (this * happens after 20 ms without new data). */ int nodata = 0; mstime_t start = mstime(); while(mstime()-start \u003c 1000 \u0026\u0026 nodata \u003c 20) { if (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, 1) \u003c= 0) { nodata++; continue; } nodata = 0; /* Start counting from zero, we stop on N *contiguous* timeouts. */ aofReadDiffFromParent(); } /* Ask the master to stop sending diffs. */ if (write(server.aof_pipe_write_ack_to_parent,\"!\",1) != 1) goto werr; if (anetNonBlock(NULL,server.aof_pipe_read_ack_from_parent) != ANET_OK) goto werr; /* We read the ACK from the server using a 10 seconds timeout. Normally * it should reply ASAP, but just in case we lose its reply, we are sure * the child will eventually get terminated. */ if (syncRead(server.aof_pipe_read_ack_from_parent,\u0026byte,1,5000) != 1 || byte != '!') goto werr; redisLog(REDIS_NOTICE,\"Parent agreed to stop sending diffs. Finalizing AOF...\"); /* Read the final diff if any. */ aofReadDiffFromParent(); /* Write the received diff to the file. */ redisLog(REDIS_NOTICE, \"Concatenating %.2f MB of AOF diff received from parent.\", (double) sdslen(server.aof_ch","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/:3:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-AOF持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"AOF后台重写 与RDB一样，AOF也提供一个fork线程后台重写的功能，异步调用的实现类似与RDB。 在子线程完成重写之后(创建一个新文件)，调用backgroundRewriteDoneHandler()，再调用aofRewriteBufferWrite(),将子线程执行重写过程中产生的新AOF数据写入新文件，然后改名覆盖源文件。 ","date":"2017-07-16","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/:4:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-AOF持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aof%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"Redis的发布与订阅主要是实现客户端订阅一个频道或者模式，当某客户端向一个频道发送消息时，该频道或者匹配模式订阅者都能够收到消息。 ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/:0:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-订阅与发布","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/"},{"categories":["源码阅读"],"content":"频道的订阅与退订 Redis在服务器结构体中的pubsub_channels字典中保存了所有的频道订阅关系。pubsub_channels键为频道，值为订阅的客户端组成的链表。 客户端结构体的pubsub_channels保存了客户端订阅的所有频道，pubsub_channels的键为频道，值为空。 struct redisServer { // ... dict *pubsub_channels; // 保存所有的频道订阅关系 // ... } struct redisClient { // ... dict *pubsub_channels; // 记录客户端订阅的频道 // ... } ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/:1:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-订阅与发布","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/"},{"categories":["源码阅读"],"content":"订阅 源码如下 // 订阅命令处理函数 void subscribeCommand(redisClient *c) { int j; // 遍历指令中的所有频道 for (j = 1; j \u003c c-\u003eargc; j++) pubsubSubscribeChannel(c,c-\u003eargv[j]); c-\u003eflags |= REDIS_PUBSUB; } // 设置客户端c订阅频道channel int pubsubSubscribeChannel(redisClient *c, robj *channel) { dictEntry *de; list *clients = NULL; int retval = 0; /* Add the channel to the client -\u003e channels hash table */ // 将channels加倒c-\u003ec-\u003epubsub_channels的字典里 if (dictAdd(c-\u003epubsub_channels,channel,NULL) == DICT_OK) { retval = 1; incrRefCount(channel); /* Add the client to the channel -\u003e list of clients hash table */ // 找出服务器中的频道 de = dictFind(server.pubsub_channels,channel); // 不存在就添加一个频道 // 获取客户端链表 if (de == NULL) { clients = listCreate(); dictAdd(server.pubsub_channels,channel,clients); incrRefCount(channel); } else { clients = dictGetVal(de); } // 添加到客户端链表尾部 listAddNodeTail(clients,c); } /* Notify the client */ // 回复客户端 addReply(c,shared.mbulkhdr[3]); addReply(c,shared.subscribebulk); addReplyBulk(c,channel); addReplyLongLong(c,clientSubscriptionsCount(c)); return retval; } ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/:2:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-订阅与发布","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/"},{"categories":["源码阅读"],"content":"退订 源码如下 void unsubscribeCommand(redisClient *c) { if (c-\u003eargc == 1) { // 退订所有频道 pubsubUnsubscribeAllChannels(c,1); } else { int j; // 遍历频道一一退订 for (j = 1; j \u003c c-\u003eargc; j++) pubsubUnsubscribeChannel(c,c-\u003eargv[j],1); } if (clientSubscriptionsCount(c) == 0) c-\u003eflags \u0026= ~REDIS_PUBSUB; } // 退订所有频道 int pubsubUnsubscribeAllChannels(redisClient *c, int notify) { dictIterator *di = dictGetSafeIterator(c-\u003epubsub_channels); dictEntry *de; int count = 0; // 遍历一一退订 while((de = dictNext(di)) != NULL) { robj *channel = dictGetKey(de); count += pubsubUnsubscribeChannel(c,channel,notify); } /* We were subscribed to nothing? Still reply to the client. */ if (notify \u0026\u0026 count == 0) { addReply(c,shared.mbulkhdr[3]); addReply(c,shared.unsubscribebulk); addReply(c,shared.nullbulk); addReplyLongLong(c,dictSize(c-\u003epubsub_channels)+ listLength(c-\u003epubsub_patterns)); } dictReleaseIterator(di); return count; } // 客户端退订频道 int pubsubUnsubscribeChannel(redisClient *c, robj *channel, int notify) { dictEntry *de; list *clients; listNode *ln; int retval = 0; /* Remove the channel from the client -\u003e channels hash table */ incrRefCount(channel); /* channel may be just a pointer to the same object we have in the hash tables. Protect it... */ // 移除客户端字典中频道的订阅 if (dictDelete(c-\u003epubsub_channels,channel) == DICT_OK) { retval = 1; /* Remove the client from the channel -\u003e clients list hash table */ // 找到服务器频道 de = dictFind(server.pubsub_channels,channel); redisAssertWithInfo(c,NULL,de != NULL); clients = dictGetVal(de); // 获取链表 ln = listSearchKey(clients,c); // 寻找链表中的订阅 redisAssertWithInfo(c,NULL,ln != NULL); listDelNode(clients,ln); // 删除节点 if (listLength(clients) == 0) { /* Free the list and associated hash entry at all if this was * the latest client, so that it will be possible to abuse * Redis PUBSUB creating millions of channels. */ // 删除节点后 链表为空 删除字典中的节点 dictDelete(server.pubsub_channels,channel); } } /* Notify the client */ // 回复客户端 if (notify) { addReply(c,shared.mbulkhdr[3]); addReply(c,shared.unsubscribebulk); addReplyBulk(c,channel); addReplyLongLong(c,dictSize(c-\u003epubsub_channels)+ listLength(c-\u003epubsub_patterns)); } decrRefCount(channel); /* it is finally safe to release it */ return retval; } ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/:3:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-订阅与发布","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/"},{"categories":["源码阅读"],"content":"模式的订阅与退订 Redis在服务器结构体中的pubsub_patterns链表中保存了所有订阅模式关系。使用pubsubPattern结构的数据作为节点。 客户端结构体的pubsub_patterns保存了客户端订阅的所有模式，节点使用pubsubPattern结构的数据。 struct redisServer { // ... list *pubsub_patterns; // 所有订阅模式关系 // ... } struct redisClient { // ... list *pubsub_patterns; // 订阅模式关系 // ... } typedef struct pubsubPattern { client *client; // 订阅模式的客户端 robj *pattern; // 被订阅模式 } pubsubPattern; ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/:4:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-订阅与发布","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/"},{"categories":["源码阅读"],"content":"订阅 // 订阅模式 void psubscribeCommand(redisClient *c) { int j; // 遍历命令中的模式 for (j = 1; j \u003c c-\u003eargc; j++) pubsubSubscribePattern(c,c-\u003eargv[j]); c-\u003eflags |= REDIS_PUBSUB; } // 设置客户端c订阅模式pattern int pubsubSubscribePattern(redisClient *c, robj *pattern) { int retval = 0; // 客户端模式链表中查找模式 // 为空则创建 if (listSearchKey(c-\u003epubsub_patterns,pattern) == NULL) { retval = 1; pubsubPattern *pat; // 客户端模式链表尾部添加模式 listAddNodeTail(c-\u003epubsub_patterns,pattern); incrRefCount(pattern); // 服务端模式链表尾部添加模式 pat = zmalloc(sizeof(*pat)); pat-\u003epattern = getDecodedObject(pattern); pat-\u003eclient = c; listAddNodeTail(server.pubsub_patterns,pat); } /* Notify the client */ addReply(c,shared.mbulkhdr[3]); addReply(c,shared.psubscribebulk); addReplyBulk(c,pattern); addReplyLongLong(c,clientSubscriptionsCount(c)); return retval; } ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/:5:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-订阅与发布","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/"},{"categories":["源码阅读"],"content":"退订 // 退订模式 void punsubscribeCommand(redisClient *c) { if (c-\u003eargc == 1) { // 退订所有模式 pubsubUnsubscribeAllPatterns(c,1); } else { int j; // 退订命令中的模式 for (j = 1; j \u003c c-\u003eargc; j++) pubsubUnsubscribePattern(c,c-\u003eargv[j],1); } if (clientSubscriptionsCount(c) == 0) c-\u003eflags \u0026= ~REDIS_PUBSUB; } // 退订客户端c订阅的所有模式 int pubsubUnsubscribeAllPatterns(redisClient *c, int notify) { listNode *ln; listIter li; int count = 0; // 遍历，一一退订 listRewind(c-\u003epubsub_patterns,\u0026li); while ((ln = listNext(\u0026li)) != NULL) { robj *pattern = ln-\u003evalue; count += pubsubUnsubscribePattern(c,pattern,notify); } if (notify \u0026\u0026 count == 0) { /* We were subscribed to nothing? Still reply to the client. */ addReply(c,shared.mbulkhdr[3]); addReply(c,shared.punsubscribebulk); addReply(c,shared.nullbulk); addReplyLongLong(c,dictSize(c-\u003epubsub_channels)+ listLength(c-\u003epubsub_patterns)); } return count; } // 取消客户端c对模式pattern的订阅 int pubsubUnsubscribePattern(redisClient *c, robj *pattern, int notify) { listNode *ln; pubsubPattern pat; int retval = 0; incrRefCount(pattern); /* Protect the object. May be the same we remove */ // 订阅了才进行操作 if ((ln = listSearchKey(c-\u003epubsub_patterns,pattern)) != NULL) { retval = 1; // 从客户端订阅中删除 listDelNode(c-\u003epubsub_patterns,ln); pat.client = c; pat.pattern = pattern; // 从服务端订阅中删除 ln = listSearchKey(server.pubsub_patterns,\u0026pat); listDelNode(server.pubsub_patterns,ln); } /* Notify the client */ if (notify) { addReply(c,shared.mbulkhdr[3]); addReply(c,shared.punsubscribebulk); addReplyBulk(c,pattern); addReplyLongLong(c,dictSize(c-\u003epubsub_channels)+ listLength(c-\u003epubsub_patterns)); } decrRefCount(pattern); return retval; } ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/:6:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-订阅与发布","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/"},{"categories":["源码阅读"],"content":"发送消息 // 发布消息 void publishCommand(redisClient *c) { int receivers = pubsubPublishMessage(c-\u003eargv[1],c-\u003eargv[2]); // 暂时不考虑集群 if (server.cluster_enabled) clusterPropagatePublish(c-\u003eargv[1],c-\u003eargv[2]); else forceCommandPropagation(c,REDIS_PROPAGATE_REPL); addReplyLongLong(c,receivers); } // 将消息发送到所有订阅了频道的客户端 int pubsubPublishMessage(robj *channel, robj *message) { int receivers = 0; dictEntry *de; listNode *ln; listIter li; /* Send to clients listening for that channel */ // 先查找订阅了频道的 de = dictFind(server.pubsub_channels,channel); if (de) { // 获取链表 list *list = dictGetVal(de); listNode *ln; listIter li; // 遍历链表 发送消息 listRewind(list,\u0026li); while ((ln = listNext(\u0026li)) != NULL) { redisClient *c = ln-\u003evalue; addReply(c,shared.mbulkhdr[3]); addReply(c,shared.messagebulk); addReplyBulk(c,channel); addReplyBulk(c,message); receivers++; } } /* Send to clients listening to matching channels */ if (listLength(server.pubsub_patterns)) { // 遍历模式链表 listRewind(server.pubsub_patterns,\u0026li); channel = getDecodedObject(channel); while ((ln = listNext(\u0026li)) != NULL) { pubsubPattern *pat = ln-\u003evalue; // 匹配模式 发送消息 if (stringmatchlen((char*)pat-\u003epattern-\u003eptr, sdslen(pat-\u003epattern-\u003eptr), (char*)channel-\u003eptr, sdslen(channel-\u003eptr),0)) { addReply(pat-\u003eclient,shared.mbulkhdr[4]); addReply(pat-\u003eclient,shared.pmessagebulk); addReplyBulk(pat-\u003eclient,pat-\u003epattern); addReplyBulk(pat-\u003eclient,channel); addReplyBulk(pat-\u003eclient,message); receivers++; } } decrRefCount(channel); } return receivers; } ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/:7:0","tags":["redis","源码阅读"],"title":"Redis源码阅读-订阅与发布","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/"},{"categories":["源码阅读"],"content":"Redis是一个内存数据库，数据存储在内存之中。有一个问题就是如果数据不存储到硬盘，那么在服务器进程退出之后，服务器中所有的数据库数据就会丢失。 Redis为了解决这个问题，提供了持久化功能，目前有两种一种是RDB持久化，一种是AOF持久化。 RDB持久化是生成一个RDB文件，该文件是一个经过压缩的二进制文件，通过该文件可以还原数据库的状态。 ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-RDB持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"RDB文件的保存命令 Redis有两个命令可以生成RDB文件一个是SAVE，一个是BGSAVE。 SAVE命令调用saveCommand进行处理 void saveCommand(redisClient *c) { // 判断是否正在执行BGSAVE，是则退出 if (server.rdb_child_pid != -1) { addReplyError(c,\"Background save already in progress\"); return; } //调用rdbSave生成RDB文件 if (rdbSave(server.rdb_filename) == REDIS_OK) { addReply(c,shared.ok); } else { addReply(c,shared.err); } } BGSAVE调用bgsaveCommand进行处理 void bgsaveCommand(redisClient *c) { // 判断是否已经在执行BGSAVE if (server.rdb_child_pid != -1) { addReplyError(c,\"Background save already in progress\"); } else if (server.aof_child_pid != -1) { // 判断是否在执行BGREWRIEAOF addReplyError(c,\"Can't BGSAVE while AOF log rewriting is in progress\"); // 执行rdbSaveBackground 生成RDB文件 } else if (rdbSaveBackground(server.rdb_filename) == REDIS_OK) { addReplyStatus(c,\"Background saving started\"); } else { addReply(c,shared.err); } } int rdbSaveBackground(char *filename) { pid_t childpid; long long start; // 如果BGSAVE正在执行直接返回 if (server.rdb_child_pid != -1) return REDIS_ERR; // 获取dirty数据 执行时间 server.dirty_before_bgsave = server.dirty; server.lastbgsave_try = time(NULL); // fork() 开始前时间 start = ustime(); // 调用fork，克隆该进程 if ((childpid = fork()) == 0) { int retval; /* Child */ closeListeningSockets(0); redisSetProcTitle(\"redis-rdb-bgsave\"); // 执行保存操作 retval = rdbSave(filename); // 打印 copy-on-write 时使用的内存数 if (retval == REDIS_OK) { size_t private_dirty = zmalloc_get_private_dirty(); if (private_dirty) { redisLog(REDIS_NOTICE, \"RDB: %zu MB of memory used by copy-on-write\", private_dirty/(1024*1024)); } } // 向父进程发送信号 exitFromChild((retval == REDIS_OK) ? 0 : 1); } else { /* Parent */ // 计算 fork() 执行的时间 server.stat_fork_time = ustime()-start; server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */ latencyAddSampleIfNeeded(\"fork\",server.stat_fork_time/1000); // 执行fork()错误信息 if (childpid == -1) { server.lastbgsave_status = REDIS_ERR; redisLog(REDIS_WARNING,\"Can't save in background: fork: %s\", strerror(errno)); return REDIS_ERR; } redisLog(REDIS_NOTICE,\"Background saving started by pid %d\",childpid); // 记录数据库开始BGSAVE时间 server.rdb_save_time_start = time(NULL); // 子进程ID 类型 server.rdb_child_pid = childpid; server.rdb_child_type = REDIS_RDB_CHILD_TYPE_DISK; // 关闭自动Rehash updateDictResizePolicy(); return REDIS_OK; } return REDIS_OK; /* unreached */ } 那么怎么才能够知道BGSAVE执行完毕，BGSAVE执行完毕后使用exitFromChild((retval == REDIS_OK) ? 0 : 1);向父进程发送信号。父进程调用serverCron接收该信号。 以下是处理函数的部分代码，处理BGREWRITEAOF与BGSAVE的完成信号。最终调用backgroundSaveDoneHandler根据返回信号信息进行对应处理。 int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) { \\\\ ... // 检查 BGSAVE 或者 BGREWRITEAOF 是否已经执行完毕 if (server.rdb_child_pid != -1 || server.aof_child_pid != -1) { int statloc; pid_t pid; // 接收子进程发来的信号 if ((pid = wait3(\u0026statloc,WNOHANG,NULL)) != 0) { int exitcode = WEXITSTATUS(statloc); int bysignal = 0; if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc); // BGSAVE 执行完毕 if (pid == server.rdb_child_pid) { backgroundSaveDoneHandler(exitcode,bysignal); // BGREWRITEAOF 执行完毕 } else if (pid == server.aof_child_pid) { backgroundRewriteDoneHandler(exitcode,bysignal); } else { redisLog(REDIS_WARNING, \"Warning, detected child with unmatched pid: %ld\", (long)pid); } updateDictResizePolicy(); } } \\\\ ... /* A background saving child (BGSAVE) terminated its work. Handle this. * This function covers the case of actual BGSAVEs. */ void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) { // 成功 if (!bysignal \u0026\u0026 exitcode == 0) { redisLog(REDIS_NOTICE, \"Background saving terminated with success\"); server.dirty = server.dirty - server.dirty_before_bgsave; server.lastsave = time(NULL); server.lastbgsave_status = REDIS_OK; // 出错 } else if (!bysignal \u0026\u0026 exitcode != 0) { redisLog(REDIS_WARNING, \"Background saving error\"); server.lastbgsave_status = REDIS_ERR; } else { mstime_t latency; redisLog(REDIS_WARNING, \"Background saving terminated by signal %d\", bysignal); latencyStartMonitor(latency); rdbRemoveTempFile(server.rdb_c","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-RDB持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"rdbSave int rdbSave(char *filename);是SAVE与BGSAVE命令执行时正在用来生成RDB文件的函数 int rdbSave(char *filename) { char tmpfile[256]; FILE *fp; rio rdb; int error; // 生成临时文件 snprintf(tmpfile,256,\"temp-%d.rdb\", (int) getpid()); fp = fopen(tmpfile,\"w\"); if (!fp) { redisLog(REDIS_WARNING, \"Failed opening .rdb for saving: %s\", strerror(errno)); return REDIS_ERR; } // 初始化I/O rioInitWithFile(\u0026rdb,fp); // 生成RDB文件 if (rdbSaveRio(\u0026rdb,\u0026error) == REDIS_ERR) { errno = error; goto werr; } // 确保缓存中没有数据 if (fflush(fp) == EOF) goto werr; if (fsync(fileno(fp)) == -1) goto werr; if (fclose(fp) == EOF) goto werr; // 使用RENAME改名 if (rename(tmpfile,filename) == -1) { redisLog(REDIS_WARNING,\"Error moving temp DB file on the final destination: %s\", strerror(errno)); unlink(tmpfile); return REDIS_ERR; } // 日志 设置状态 redisLog(REDIS_NOTICE,\"DB saved on disk\"); server.dirty = 0; server.lastsave = time(NULL); server.lastbgsave_status = REDIS_OK; return REDIS_OK; werr: // 异常处理 fclose(fp); unlink(tmpfile); redisLog(REDIS_WARNING,\"Write error saving DB on disk: %s\", strerror(errno)); return REDIS_ERR; } 实际是调用rdbSaveRio执行写入 int rdbSaveRio(rio *rdb, int *error) { dictIterator *di = NULL; dictEntry *de; char magic[10]; int j; long long now = mstime(); uint64_t cksum; // 设置校验和 if (server.rdb_checksum) rdb-\u003eupdate_cksum = rioGenericUpdateChecksum; // 写入REDIS版本号 snprintf(magic,sizeof(magic),\"REDIS%04d\",REDIS_RDB_VERSION); if (rdbWriteRaw(rdb,magic,9) == -1) goto werr; // 遍历数据库 for (j = 0; j \u003c server.dbnum; j++) { redisDb *db = server.db+j; dict *d = db-\u003edict; // 跳过空数据库 if (dictSize(d) == 0) continue; // 键空间迭代器 di = dictGetSafeIterator(d); if (!di) return REDIS_ERR; /* Write the SELECT DB opcode */ // 写入DB选择器 if (rdbSaveType(rdb,REDIS_RDB_OPCODE_SELECTDB) == -1) goto werr; if (rdbSaveLen(rdb,j) == -1) goto werr; /* Iterate this DB writing every entry */ // 遍历数据库，写入键值对 while((de = dictNext(di)) != NULL) { sds keystr = dictGetKey(de); robj key, *o = dictGetVal(de); long long expire; initStaticStringObject(key,keystr); expire = getExpire(db,\u0026key); // 写入键值对 if (rdbSaveKeyValuePair(rdb,\u0026key,o,expire,now) == -1) goto werr; } dictReleaseIterator(di); } di = NULL; /* So that we don't release it again on error. */ /* EOF opcode */ // 写入 EOF 代码 if (rdbSaveType(rdb,REDIS_RDB_OPCODE_EOF) == -1) goto werr; /* CRC64 checksum. It will be zero if checksum computation is disabled, the * loading code skips the check in this case. */ // CRC64 校验和。 cksum = rdb-\u003ecksum; memrev64ifbe(\u0026cksum); if (rioWrite(rdb,\u0026cksum,8) == 0) goto werr; return REDIS_OK; werr: if (error) *error = errno; if (di) dictReleaseIterator(di); return REDIS_ERR; } ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/:1:1","tags":["redis","源码阅读"],"title":"redis源码阅读-RDB持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"自动保存 redis能够配置自动保存条件，当满足的情况下执行BGSAVE。 依赖上次保存时间和dirty计数。 // serverCron函数 if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 || ldbPendingChildren()) { // 为之前处理BGSAVE完成的部分的代码 } else { // 检查所有保存条件 for (j = 0; j \u003c server.saveparamslen; j++) { struct saveparam *sp = server.saveparams+j; // 检查某个保存条件是否符合 if (server.dirty \u003e= sp-\u003echanges \u0026\u0026 server.unixtime-server.lastsave \u003e sp-\u003eseconds \u0026\u0026 (server.unixtime-server.lastbgsave_try \u003e CONFIG_BGSAVE_RETRY_DELAY || server.lastbgsave_status == C_OK)) { serverLog(LL_NOTICE,\"%d changes in %d seconds. Saving...\", sp-\u003echanges, (int)sp-\u003eseconds); // 保存 rdbSaveBackground(server.rdb_filename); break; } } // ... } ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-RDB持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"RDB的文件载入 rdbload()用于将RDB文件从硬盘载入 int rdbLoad(char *filename) { uint32_t dbid; int type, rdbver; redisDb *db = server.db+0; char buf[1024]; long long expiretime, now = mstime(); FILE *fp; rio rdb; // 打开rdb文件 if ((fp = fopen(filename,\"r\")) == NULL) return REDIS_ERR; // 初始化rio rioInitWithFile(\u0026rdb,fp); rdb.update_cksum = rdbLoadProgressCallback; rdb.max_processing_chunk = server.loading_process_events_interval_bytes; if (rioRead(\u0026rdb,buf,9) == 0) goto eoferr; buf[9] = '\\0'; // 校验版本号 if (memcmp(buf,\"REDIS\",5) != 0) { fclose(fp); redisLog(REDIS_WARNING,\"Wrong signature trying to load DB from file\"); errno = EINVAL; return REDIS_ERR; } rdbver = atoi(buf+5); if (rdbver \u003c 1 || rdbver \u003e REDIS_RDB_VERSION) { fclose(fp); redisLog(REDIS_WARNING,\"Can't handle RDB format version %d\",rdbver); errno = EINVAL; return REDIS_ERR; } // 标记开始载入 startLoading(fp); while(1) { robj *key, *val; expiretime = -1; /* Read type. */ // 读取类型 if ((type = rdbLoadType(\u0026rdb)) == -1) goto eoferr; // 过期时间 秒为单位 if (type == REDIS_RDB_OPCODE_EXPIRETIME) { // 过期时间 if ((expiretime = rdbLoadTime(\u0026rdb)) == -1) goto eoferr; /* We read the time so we need to read the object type again. */ // 键值对 if ((type = rdbLoadType(\u0026rdb)) == -1) goto eoferr; /* the EXPIRETIME opcode specifies time in seconds, so convert * into milliseconds. */ expiretime *= 1000; } else if (type == REDIS_RDB_OPCODE_EXPIRETIME_MS) { /* Milliseconds precision expire times introduced with RDB * version 3. */ // 过期时间 毫秒但闻 if ((expiretime = rdbLoadMillisecondTime(\u0026rdb)) == -1) goto eoferr; /* We read the time so we need to read the object type again. */ if ((type = rdbLoadType(\u0026rdb)) == -1) goto eoferr; } // EOF if (type == REDIS_RDB_OPCODE_EOF) break; /* Handle SELECT DB opcode as a special case */ // 读取切换数据库指示 if (type == REDIS_RDB_OPCODE_SELECTDB) { // 数据库号 if ((dbid = rdbLoadLen(\u0026rdb,NULL)) == REDIS_RDB_LENERR) goto eoferr; // 校验 if (dbid \u003e= (unsigned)server.dbnum) { redisLog(REDIS_WARNING,\"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\\n\", server.dbnum); exit(1); } // 切换数据库 db = server.db+dbid; continue; } /* Read key */ // 读取键 if ((key = rdbLoadStringObject(\u0026rdb)) == NULL) goto eoferr; /* Read value */ // 读取值 if ((val = rdbLoadObject(type,\u0026rdb)) == NULL) goto eoferr; /* Check if the key already expired. This function is used when loading * an RDB file from disk, either at startup, or when an RDB was * received from the master. In the latter case, the master is * responsible for key expiry. If we would expire keys here, the * snapshot taken by the master may not be reflected on the slave. */ if (server.masterhost == NULL \u0026\u0026 expiretime != -1 \u0026\u0026 expiretime \u003c now) { decrRefCount(key); decrRefCount(val); continue; } /* Add the new object in the hash table */ // 将键值关联到数据库内 dbAdd(db,key,val); /* Set the expire time if needed */ // 设置过期时间 if (expiretime != -1) setExpire(db,key,expiretime); decrRefCount(key); } /* Verify the checksum if RDB version is \u003e= 5 */ // 校验和比较 if (rdbver \u003e= 5 \u0026\u0026 server.rdb_checksum) { uint64_t cksum, expected = rdb.cksum; if (rioRead(\u0026rdb,\u0026cksum,8) == 0) goto eoferr; memrev64ifbe(\u0026cksum); if (cksum == 0) { redisLog(REDIS_WARNING,\"RDB file was saved with checksum disabled: no check performed.\"); } else if (cksum != expected) { redisLog(REDIS_WARNING,\"Wrong RDB checksum. Aborting now.\"); exit(1); } } // 结束 fclose(fp); stopLoading(); return REDIS_OK; eoferr: /* unexpected end of file is handled here with a fatal exit */ redisLog(REDIS_WARNING,\"Short read or OOM loading DB. Unrecoverable error, aborting now.\"); exit(1); return REDIS_ERR; /* Just to avoid warning */ } ","date":"2017-07-12","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-RDB持久化","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-rdb%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["源码阅读"],"content":"服务器 redis运行存在一个redis服务器结构，一个服务器中保存着n个数据库。 dbnum由服务器配置决定，默认值为16。 struct redisServer { redisDb *db; // Redis的数据库 // ... int dbnum; // 表明数据库的数量 // ... } typedef struct redisDb { dict *dict; /* 数据库键字典 */ dict *expires; /* 键过期时间字典 */ dict *blocking_keys; /* 处于阻塞状态的键 */ dict *ready_keys; /* 可以解除阻塞的键 */ dict *watched_keys; /* 被watch的键 */ struct evictionPoolEntry *eviction_pool; /* Eviction pool of keys */ int id; /* 数据库编号 */ long long avg_ttl; /* 数据库键的平均时间*/ } redisDb; ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"切换数据库 每个redis客户端都有自己的目标数据库，当客户端执行数据库读写命令，目标数据库是这些命令的操作对象。 redis提供select命令来切换数据库，redisClient typedef struct redisClient { int fd; // 套接字描述符 redisDb *db; // 当前正在使用的数据库 // ... } int selectDb(redisClient *c, int id) { // 校验id if (id \u003c 0 || id \u003e= server.dbnum) return REDIS_ERR; // 切换客户端数据库 c-\u003edb = \u0026server.db[id]; return REDIS_OK; } ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"数据库键空间 Redis数据库存放的数据都是以键值对形式存在，redisDB结构的dict字典保存数据库中的所有键值对，这个字典被成为键空间。 typedef struct redisDb { dict *dict; /* 数据库键字典 */ // ... } redisDb; 键空间的键就是数据库的键，每个键都是一个字符串对象。 键空间的值就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象、有序集合对象中任意一种。 ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"键空间的操作 /* db.c -- Keyspace access API */ int removeExpire(redisDb *db, robj *key);// 移除键的过期时间 void propagateExpire(redisDb *db, robj *key); // int expireIfNeeded(redisDb *db, robj *key); // 检查是否过期，是则删除键 long long getExpire(redisDb *db, robj *key); // 获取过期时间 void setExpire(redisDb *db, robj *key, long long when); // 设定过期时间 robj *lookupKey(redisDb *db, robj *key); // 从db中取出键key的值 robj *lookupKeyRead(redisDb *db, robj *key); // 从db中取出键key的值 robj *lookupKeyWrite(redisDb *db, robj *key); // 从db中取出键key的值 robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply); // 从db中取出键key的值 robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply);// 从db中取出键key的值 void dbAdd(redisDb *db, robj *key, robj *val);// 尝试将键值对key\\val添加到数据库中 void dbOverwrite(redisDb *db, robj *key, robj *val); // 重写指定键的值,键不存在的话终止 void setKey(redisDb *db, robj *key, robj *val);// 设定指定键的值，不管存不存在 int dbExists(redisDb *db, robj *key); // 判断指定键是否存在 robj *dbRandomKey(redisDb *db); // 随机从数据库中取出一个键，并以字符串对象的方式返回这个键 int dbDelete(redisDb *db, robj *key); // 从数据库中删除给定的键 robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o); long long emptyDb(void(callback)(void*));// 情况所有数据 int selectDb(redisClient *c, int id); // 切换db void signalModifiedKey(redisDb *db, robj *key); void signalFlushedDb(int dbid); unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count); unsigned int countKeysInSlot(unsigned int hashslot); unsigned int delKeysInSlot(unsigned int hashslot); int verifyClusterConfigWithData(void); void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor); int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor); ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:4:0","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"键空间的初始化 /* Db-\u003edict, keys are sds strings, vals are Redis objects. */ // 键空间的类型 dictType dbDictType = { dictSdsHash, /* hash function */ NULL, /* key dup */ NULL, /* val dup */ dictSdsKeyCompare, /* key compare */ dictSdsDestructor, /* key destructor */ dictRedisObjectDestructor /* val destructor */ }; // 服务器初始化的同时初始化键空间 void initServer() { // ... /* Create the Redis databases, and initialize other internal state. */ // 创建并初始化数据库结构 for (j = 0; j \u003c server.dbnum; j++) { server.db[j].dict = dictCreate(\u0026dbDictType,NULL); // ... server.db[j].id = j; // ... } // ... }; ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:4:1","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"查找 有五个和查找相关的接口，代码如下。 robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply) { robj *o = lookupKeyWrite(c-\u003edb, key); if (!o) addReply(c,reply); return o; } robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply) { // 查找 robj *o = lookupKeyRead(c-\u003edb, key); // 发送信息 if (!o) addReply(c,reply); return o; } robj *lookupKeyWrite(redisDb *db, robj *key) { // 删除过期键 expireIfNeeded(db,key); // 查找并返回对象 return lookupKey(db,key); } robj *lookupKeyRead(redisDb *db, robj *key) { robj *val; // 删除过期键 expireIfNeeded(db,key); // 查找对象 val = lookupKey(db,key); // 更新命中/不命中信息 if (val == NULL) server.stat_keyspace_misses++; else server.stat_keyspace_hits++; // 返回值 return val; } robj *lookupKey(redisDb *db, robj *key) { // 查找 dictEntry *de = dictFind(db-\u003edict,key-\u003eptr); if (de) { // 取出值 robj *val = dictGetVal(de); // 更新时间信息 if (server.rdb_child_pid == -1 \u0026\u0026 server.aof_child_pid == -1) val-\u003elru = LRU_CLOCK(); // 返回值 return val; } else { return NULL; } } ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:4:2","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"添加新键 void dbAdd(redisDb *db, robj *key, robj *val) { sds copy = sdsdup(key-\u003eptr); // 复制键名 int retval = dictAdd(db-\u003edict, copy, val); // 尝试添加 redisAssertWithInfo(NULL,key,retval == REDIS_OK); // 已经存在则停止 if (val-\u003etype == REDIS_LIST) signalListAsReady(db, key); if (server.cluster_enabled) slotToKeyAdd(key); } ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:4:3","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"修改键 两种方式一种重写，一种设定不管存不存在。 void dbOverwrite(redisDb *db, robj *key, robj *val); // 重写指定键的值,键不存在的话终止 void setKey(redisDb *db, robj *key, robj *val);// 设定指定键的值，不管存不存在 void dbOverwrite(redisDb *db, robj *key, robj *val) { dictEntry *de = dictFind(db-\u003edict,key-\u003eptr); // 查找 redisAssertWithInfo(NULL,key,de != NULL); // 不存在，终止 dictReplace(db-\u003edict, key-\u003eptr, val); // 修改旧值 } void setKey(redisDb *db, robj *key, robj *val) { if (lookupKeyWrite(db,key) == NULL) { dbAdd(db,key,val); // 找不到就添加 } else { dbOverwrite(db,key,val); // 找到就重写 } incrRefCount(val); // 增加引用计数 removeExpire(db,key); // 移除过期时间 signalModifiedKey(db,key); // 发送键修改通知 } ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:4:4","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"删除键 int dbDelete(redisDb *db, robj *key) { /* Deleting an entry from the expires dict will not free the sds of * the key, because it is shared with the main dictionary. */ // 删除键的过期时间 if (dictSize(db-\u003eexpires) \u003e 0) dictDelete(db-\u003eexpires,key-\u003eptr); // 删除键值对 if (dictDelete(db-\u003edict,key-\u003eptr) == DICT_OK) { if (server.cluster_enabled) slotToKeyDel(key); return 1; } else { return 0; } } ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:4:5","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"键的生存时间或过期时间 与键空间类似redis建立了一个字典，存放每个键的对应的过期时间。在初始化的时候创建 dictType keyptrDictType = { dictSdsHash, /* hash function */ NULL, /* key dup */ NULL, /* val dup */ dictSdsKeyCompare, /* key compare */ NULL, /* key destructor */ NULL /* val destructor */ }; void initServer() { // ... // 创建并初始化数据库结构 for (j = 0; j \u003c server.dbnum; j++) { server.db[j].expires = dictCreate(\u0026keyptrDictType,NULL); // ... server.db[j].id = j; // ... } // ... }; ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:5:0","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"设定键的过期时间 void setExpire(redisDb *db, robj *key, long long when) { dictEntry *kde, *de; kde = dictFind(db-\u003edict,key-\u003eptr); // 查找键 redisAssertWithInfo(NULL,key,kde != NULL); // 在过期时间字典中查找，没有则添加 de = dictReplaceRaw(db-\u003eexpires,dictGetKey(kde)); dictSetSignedIntegerVal(de,when); // 设置过期时间 } ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:5:1","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"获取键的过期时间 long long getExpire(redisDb *db, robj *key) { dictEntry *de; // 如果不存在直接返回 if (dictSize(db-\u003eexpires) == 0 || (de = dictFind(db-\u003eexpires,key-\u003eptr)) == NULL) return -1; redisAssertWithInfo(NULL,key,dictFind(db-\u003edict,key-\u003eptr) != NULL); // 返回过期时间 return dictGetSignedIntegerVal(de); } ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:5:2","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"删除键的过期时间 int removeExpire(redisDb *db, robj *key) { // 确保键有过期时间 redisAssertWithInfo(NULL,key,dictFind(db-\u003edict,key-\u003eptr) != NULL); return dictDelete(db-\u003eexpires,key-\u003eptr) == DICT_OK; // 删除 } ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:5:3","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"过期键的删除策略 三种策略： 定时删除。定时删除占用cpu，可能使服务器长期无响应。但是对内存友好。 惰性删除，对键进行操作时，才删除。缺点是对内存不友好，过期键过多的话，没有及时清理。 定期删除。间隔依据算法确定。两者结合，主要看算法选择。 redis采用定期和惰性两种删除方式。 惰性删除 redis在很多操作前都会调用expireIfNeeded进行惰性删除。例如lookupKeyRead。 int expireIfNeeded(redisDb *db, robj *key) { mstime_t when = getExpire(db,key); mstime_t now; // 无过期时间 if (when \u003c 0) return 0; /* No expire for this key */ // 正在加载不删除 if (server.loading) return 0; /* If we are in the context of a Lua script, we claim that time is * blocked to when the Lua script started. This way a key can expire * only the first time it is accessed and not in the middle of the * script execution, making propagation to slaves / AOF consistent. * See issue #1525 on Github for more information. */ now = server.lua_caller ? server.lua_time_start : mstime(); /* If we are running in the context of a slave, return ASAP: * the slave key expiration is controlled by the master that will * send us synthesized DEL operations for expired keys. * * Still we try to return the right information to the caller, * that is, 0 if we think the key should be still valid, 1 if * we think the key is expired at this time. */ if (server.masterhost != NULL) return now \u003e when; // 没过期，返回0 if (now \u003c= when) return 0; // 删除 server.stat_expiredkeys++; propagateExpire(db,key); notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED, \"expired\",key,db-\u003eid); return dbDelete(db,key); } 定期删除 redis服务器周期性操作serverCron函数执行时，activeExpireCycle被调用，它在规定时间内分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。 ","date":"2017-07-10","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/:5:4","tags":["redis","源码阅读"],"title":"redis源码阅读-服务器","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["源码阅读"],"content":"之前阅读了redis用到的主要的数据结构，这些数据结构是redis对象基础。redis在这些基础数据结构之上创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象五种类型的对象。 redis执行命令前，先判断命令是否能够执行给定命令。根据不同场合选择使用不同的数据结构。 ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"对象的类型与编码 redis使用对象来表示数据库中的键值，创建一个键值对时，会创建至少两个对象，一个对象用作键值对的键，一个对象用作键值对的值。 ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"对象的结构体 typedef struct redisObject { unsigned type:4; // 类型 unsigned encoding:4; // 编码 unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */ int refcount; // 引用计数 void *ptr; // 值 } robj; redis结构体使用位段结构节省空间 类型type 记录redis对象类型，五种类型 #define REDIS_STRING 0 // 字符串对象 #define REDIS_LIST 1 // 列表对象 #define REDIS_SET 2 // 哈希对象 #define REDIS_ZSET 3 // 集合对象 #define REDIS_HASH 4 // 有序集合对象 编码encoding 记录redis对象的编码 // 对象编码 #define REDIS_ENCODING_RAW 0 /* 简单动态字符串 */#define REDIS_ENCODING_INT 1 /* long类型的整数 */#define REDIS_ENCODING_HT 2 /* 字典 */#define REDIS_ENCODING_ZIPMAP 3 /* zipmap 3.2.5不再使用 */#define REDIS_ENCODING_LINKEDLIST 4 /* 双端队列 */#define REDIS_ENCODING_ZIPLIST 5 /* 压缩列表 */#define REDIS_ENCODING_INTSET 6 /* 整数集合 */#define REDIS_ENCODING_SKIPLIST 7 /* 跳跃表 */#define REDIS_ENCODING_EMBSTR 8 /* EMBSTR编码的简单字符串 */ 每种类型对应至少两种不同的编码。 对象类型 编码方式 REDIS_STRING REDIS_ENCODING_RAW ,REDIS_ENCODING_INT ,REDIS_ENCODING_EMBSTR REDIS_LIST REDIS_ENCODING_LINKEDLIST ,REDIS_ENCODING_ZIPLIST REDIS_SET REDIS_ENCODING_INTSET ,REDIS_ENCODING_HT REDIS_ZSET REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_SKIPLIST REDIS_HASH REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_HT 访问时间 表示对象的最后一次访问时间。 引用计数 常见的管理方式，引用计数为0时回收。 ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:1:1","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"对象的API void decrRefCount(robj *o); // 引用计数-1，降为0时释放对象 void decrRefCountVoid(void *o); // 用于特定数据结构的释放 void incrRefCount(robj *o); // 引用计数+1 robj *resetRefCount(robj *obj); // 设置引用计数为0 void freeStringObject(robj *o); // 释放字符串对象 void freeListObject(robj *o); // 释放列表对象 void freeSetObject(robj *o); // 释放集合对象 void freeZsetObject(robj *o); // 释放有序集合对象 void freeHashObject(robj *o); // 释放hash对象 robj *createObject(int type, void *ptr); // 创建一个新robj对象 robj *createStringObject(char *ptr, size_t len); // 创建一个字符串对象，根据大小选择编码 robj *createRawStringObject(char *ptr, size_t len);// 创建一个 REDIS_ENCODING_RAW 编码的字符对象 robj *createEmbeddedStringObject(char *ptr, size_t len);// 创建一个 REDIS_ENCODING_EMBSTR 编码的字符对象 robj *dupStringObject(robj *o); // 复制一个字符串对象 int isObjectRepresentableAsLongLong(robj *o, long long *llongval); // 检查对象的值是否为Long long robj *tryObjectEncoding(robj *o); // 尝试对字符串对象编码，以节约内存 robj *getDecodedObject(robj *o); // 返回一个对象的编码版本 size_t stringObjectLen(robj *o); // 返回字符串对象的字符串值的长度 robj *createStringObjectFromLongLong(long long value); // 根据传入的值，创建一个字符串对象 robj *createStringObjectFromLongDouble(long double value, int humanfriendly); // 根据传入的值，创建一个字符串对象 robj *createListObject(void); // 创建一个linkedlist编码的列表对象 robj *createZiplistObject(void); // 创建一个ziplist编码的列表对象 robj *createSetObject(void); // 创建一个ht编码的集合对象 robj *createIntsetObject(void); // 创建一个intset编码的集合对象 robj *createHashObject(void); // 创建一个ziplist编码的哈希对象 robj *createZsetObject(void); // 创建一个skiplist编码的有序集合 robj *createZsetZiplistObject(void); // 创建一个ziplist编码的有序集合 int getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg); // 尝试从对象中获取Long类型值 int checkType(redisClient *c, robj *o, int type); // 检查对象0的类型是否和type相同 int getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg); // 尝试从对象中取出整数值 int getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg); // 尝试从对象中取出double值 int getLongLongFromObject(robj *o, long long *target); // 尝试从对象中获取整数值 int getLongDoubleFromObject(robj *o, long double *target); // 尝试从对象获取long double值 int getLongDoubleFromObjectOrReply(redisClient *c, robj *o, long double *target, const char *msg); // 尝试从对象获取long double值 char *strEncoding(int encoding); // 返回编码的字符串表示 int compareStringObjects(robj *a, robj *b); // 二进制方式比较两个字符串对象 int collateStringObjects(robj *a, robj *b); // 以collation方式比较两个字符串对象 int equalStringObjects(robj *a, robj *b); // 判断是否相同两个字符串对象 unsigned long long estimateObjectIdleTime(robj *o); // 计算对象的闲置时间 ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"对象的创建 对象的创建都比较类似，一般创建底层数据结构，然后创建对象。然后初始化。 以string对象为例 // 创建字符串对象 robj *createStringObject(char *ptr, size_t len) { // 长度小于39时使用EMBSTR if (len \u003c= REDIS_ENCODING_EMBSTR_SIZE_LIMIT) return createEmbeddedStringObject(ptr,len); else return createRawStringObject(ptr,len); } // 创建一个embstr编码的字符串对象 robj *createEmbeddedStringObject(char *ptr, size_t len) { // 直接分配一个连续空间长度为redis和字符串结构+字符串保存内存 robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr)+len+1); struct sdshdr *sh = (void*)(o+1); // 找到字符串的起始位置 // 初始化字符串 o-\u003etype = REDIS_STRING; o-\u003eencoding = REDIS_ENCODING_EMBSTR; o-\u003eptr = sh+1; o-\u003erefcount = 1; o-\u003elru = LRU_CLOCK(); sh-\u003elen = len; sh-\u003efree = 0; if (ptr) { memcpy(sh-\u003ebuf,ptr,len); sh-\u003ebuf[len] = '\\0'; } else { memset(sh-\u003ebuf,0,len+1); } return o; } // 创建一个 REDIS_ENCODING_RAW 编码的字符对象 // 对象的指针指向一个 sds 结构 robj *createRawStringObject(char *ptr, size_t len) { // sdsnewlen新建字符串 return createObject(REDIS_STRING,sdsnewlen(ptr,len)); } // 创建一个新对象 robj *createObject(int type, void *ptr) { robj *o = zmalloc(sizeof(*o)); o-\u003etype = type; o-\u003eencoding = REDIS_ENCODING_RAW; o-\u003eptr = ptr; o-\u003erefcount = 1; /* Set the LRU to the current lruclock (minutes resolution). */ o-\u003elru = LRU_CLOCK(); return o; } ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:2:1","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"对象的释放 以字符串对象为例子，redis采用引用计数进行对象的释放，当对象不再使用时调用decrRefCount减少引用计数，在引用计数减到0后，释放对象。 void decrRefCount(robj *o) { if (o-\u003erefcount \u003c= 0) redisPanic(\"decrRefCount against refcount \u003c= 0\"); if (o-\u003erefcount == 1) { switch(o-\u003etype) { // 根据类型释放 各个函数会调用各自的释放函数释放 case REDIS_STRING: freeStringObject(o); break; case REDIS_LIST: freeListObject(o); break; case REDIS_SET: freeSetObject(o); break; case REDIS_ZSET: freeZsetObject(o); break; case REDIS_HASH: freeHashObject(o); break; default: redisPanic(\"Unknown object type\"); break; } zfree(o); // 释放对象内存 } else { o-\u003erefcount--; } } // 如果时RAW编码调用sdsfree释放，否则在释放robj时就释放了，因为采用了embstr编码 void freeStringObject(robj *o) { if (o-\u003eencoding == REDIS_ENCODING_RAW) { sdsfree(o-\u003eptr); } } ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:2:2","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"字符串对象 字符串编码可以是Int、raw或者embstr。 字符串对象为整数值，可以用long long类型表示，则为int编码。 字符串对象为浮点数，能够用long double类型表示，使用embstr还是raw根据长度来定。 如果一个字符串对象小于等于REDIS_ENCODING_EMBSTR_SIZE_LIMIT则用embstr编码。 大于REDIS_ENCODING_EMBSTR_SIZE_LIMIT采用raw编码。 int编码在执行一个会将int转变为字符串值时，编码变为raw。 embstr为只读的，当尝试修改时会转换为raw。 ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"列表对象 列表对象编码是ziplist或者linkedlist。 满足以下两个条件使用ziplist： 保存的字符串长度都小于64 元素数量小于512 ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:4:0","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"哈希对象 哈希对象编码是ziplist或者hashtable。 如果采用的是ziplist那么添加键值时，先将键推入压缩列表表尾部，再将值推入压缩列表表尾。 如果采用hashtable编码，那么字典的键就是键值对的键的字符串对象，字典的值时键值对的值。 满足以下两个条件使用ziplist： 保存的字符串长度都小于64 元素数量小于512 ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:5:0","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"集合对象 集合的编码是inset或者hashtable 满足以下条件使用intset编码： 集合对象保存的值都为整数 集合对象保存的元素不超过512个 ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:6:0","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"有序集合对象 有序集合编码是ziplist或者skiplist。 skiplist编码使用一个zskiplist和dict作为底层实现。zskiplist按照分值从大到小保存集合元素。dict保存从成员到分值的映射。 满足以下条件使用ziplist编码： 有序集合保存的元素小于128个。 有序集合保存的所有元素成员的长度都小于64字节。 ","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:7:0","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"命令 对象的命令处理在redis.h中。 执行命令之前会检查对象的类型，是否能够执行该命令。 如果能就调用对象的命令处理函数,否则返回错误。 在调用了对象的命令处理函数之后，则根据命令具体的编码，去选择使用什么底层数据结构的接口来实现。 /* Commands prototypes */ void authCommand(redisClient *c); void pingCommand(redisClient *c); void echoCommand(redisClient *c); void setCommand(redisClient *c); void setnxCommand(redisClient *c); void setexCommand(redisClient *c); void psetexCommand(redisClient *c); void getCommand(redisClient *c); void delCommand(redisClient *c); void existsCommand(redisClient *c); void setbitCommand(redisClient *c); void getbitCommand(redisClient *c); void setrangeCommand(redisClient *c); void getrangeCommand(redisClient *c); void incrCommand(redisClient *c); void decrCommand(redisClient *c); void incrbyCommand(redisClient *c); void decrbyCommand(redisClient *c); void incrbyfloatCommand(redisClient *c); void selectCommand(redisClient *c); void randomkeyCommand(redisClient *c); void keysCommand(redisClient *c); void scanCommand(redisClient *c); void dbsizeCommand(redisClient *c); void lastsaveCommand(redisClient *c); void saveCommand(redisClient *c); void bgsaveCommand(redisClient *c); void bgrewriteaofCommand(redisClient *c); void shutdownCommand(redisClient *c); void moveCommand(redisClient *c); void renameCommand(redisClient *c); void renamenxCommand(redisClient *c); void lpushCommand(redisClient *c); void rpushCommand(redisClient *c); void lpushxCommand(redisClient *c); void rpushxCommand(redisClient *c); void linsertCommand(redisClient *c); void lpopCommand(redisClient *c); void rpopCommand(redisClient *c); void llenCommand(redisClient *c); void lindexCommand(redisClient *c); void lrangeCommand(redisClient *c); void ltrimCommand(redisClient *c); void typeCommand(redisClient *c); void lsetCommand(redisClient *c); void saddCommand(redisClient *c); void sremCommand(redisClient *c); void smoveCommand(redisClient *c); void sismemberCommand(redisClient *c); void scardCommand(redisClient *c); void spopCommand(redisClient *c); void srandmemberCommand(redisClient *c); void sinterCommand(redisClient *c); void sinterstoreCommand(redisClient *c); void sunionCommand(redisClient *c); void sunionstoreCommand(redisClient *c); void sdiffCommand(redisClient *c); void sdiffstoreCommand(redisClient *c); void sscanCommand(redisClient *c); void syncCommand(redisClient *c); void flushdbCommand(redisClient *c); void flushallCommand(redisClient *c); void sortCommand(redisClient *c); void lremCommand(redisClient *c); void rpoplpushCommand(redisClient *c); void infoCommand(redisClient *c); void mgetCommand(redisClient *c); void monitorCommand(redisClient *c); void expireCommand(redisClient *c); void expireatCommand(redisClient *c); void pexpireCommand(redisClient *c); void pexpireatCommand(redisClient *c); void getsetCommand(redisClient *c); void ttlCommand(redisClient *c); void pttlCommand(redisClient *c); void persistCommand(redisClient *c); void slaveofCommand(redisClient *c); void debugCommand(redisClient *c); void msetCommand(redisClient *c); void msetnxCommand(redisClient *c); void zaddCommand(redisClient *c); void zincrbyCommand(redisClient *c); void zrangeCommand(redisClient *c); void zrangebyscoreCommand(redisClient *c); void zrevrangebyscoreCommand(redisClient *c); void zrangebylexCommand(redisClient *c); void zrevrangebylexCommand(redisClient *c); void zcountCommand(redisClient *c); void zlexcountCommand(redisClient *c); void zrevrangeCommand(redisClient *c); void zcardCommand(redisClient *c); void zremCommand(redisClient *c); void zscoreCommand(redisClient *c); void zremrangebyscoreCommand(redisClient *c); void zremrangebylexCommand(redisClient *c); void multiCommand(redisClient *c); void execCommand(redisClient *c); void discardCommand(redisClient *c); void blpopCommand(redisClient *c); void brpopCommand(redisClient *c); void brpoplpushCommand(redisClient *c); void appendCommand(redisClient *c); void strlenCommand(redisClient *c); void zrankCommand(redisClient *c); void zrevrankCommand(redisClient *c); void hsetCommand(redisClient *c)","date":"2017-07-09","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/:8:0","tags":["redis","源码阅读"],"title":"redis源码阅读-对象","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["源码阅读"],"content":"压缩列表时列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么是小整数，要么是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"压缩列表的构成 压缩列表是redis为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数组。 《redis设计与实现》 空白 ziplist 示例图 area |\u003c---- ziplist header ----\u003e|\u003c-- end --\u003e| size 4 bytes 4 bytes 2 bytes 1 byte +---------+--------+-------+-----------+ component | zlbytes | zltail | zllen | zlend | | | | | | value | 1011 | 1010 | 0 | 1111 1111 | +---------+--------+-------+-----------+ ^ | ZIPLIST_ENTRY_HEAD \u0026 address ZIPLIST_ENTRY_TAIL \u0026 ZIPLIST_ENTRY_END 非空 ziplist 示例图 area |\u003c---- ziplist header ----\u003e|\u003c----------- entries -------------\u003e|\u003c-end-\u003e| size 4 bytes 4 bytes 2 bytes ? ? ? ? 1 byte +---------+--------+-------+--------+--------+--------+--------+-------+ component | zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend | +---------+--------+-------+--------+--------+--------+--------+-------+ ^ ^ ^ address | | | ZIPLIST_ENTRY_HEAD | ZIPLIST_ENTRY_END | ZIPLIST_ENTRY_TAIL zlbytes记录整个压缩列表占用的字节数。 zltail记录压缩列表尾节点距离压缩列表的起始地址有多少字节。 zzlen记录压缩列表包含的节点数量。 entryX列表节点，数量不定。 zlend特殊值0xff，标记压缩列表末端。 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"压缩列表节点的构成 每个压缩列表可以保存一个字节数组或者一个整数值，字节数组可以有三种长度： 长度小于等于63字节的字节数组 长度小于等于16383字节的字节数组 长度小于等于4294967295字节的字节数组 每个压缩列表节点由previous_entry_length、encoding、content三个部分组成。 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"previous_entry_length 节点previous_entry_length属性以字节为单位，记录一个压缩列表节点的长度。previous_entry_length属性的长度可以是1字节或者5字节： 如果前一节点的长度小于254字节，长度为1,前一节点长度保存在这个字节里面。 如果前一节点的长度大于 等于254字节，长度为5：属性的第一个字节被设置为0xfe，而之后的四个字节用于保存前一 节点的长度。 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:2:1","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"encoding 记录节点的content属性所保存数据类型以及长度： 一字节、两字节或者五字节长，值的最高位为00、01或者10的是 字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录 一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数数值，整数值的类型和长度由编码除去最高两位之后的其他位记录。 编码 编码长度 content属性保存的值 00bbbbbb 1 bytes \u003c= 63 bytes的字节数组 01bbbbbb xxxxxxxx 2 bytes \u003c= 16383 bytes字节数组 10**__** aaaaaaaa bbbbbbbb cccccccc dddddddd 5 bytes \u003c= 4294967295 bytes字节数组 编码 编码长度 content属性保存的值 11000000 1 int16_t（2 bytes）类型整数 11010000 1 int32_t（4 bytes）类型整数 11100000 1 int64_t（8 bytes）类型整数 11110000 1 24位有符整数 11111110 1 8位有符整数 1111xxxx 1 0~12 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:2:2","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"content 节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:2:3","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"连锁更新 previous_entry_length属性的长度可以是1字节或者5字节： 如果前一节点的长度小于254字节，长度为1,前一节点长度保存在这个字节里面。 如果前一节点的长度大于 等于254字节，长度为5：属性的第一个字节被设置为0xfe，而之后的四个字节用于保存前一 节点的长度。 那么一种情况：在压缩列表中，有多个连续的长度介于250字节到253字节之间的节点e1至eN。 在e1前插入一个大于254字节的节点，此时要更新e1的previous_entry_length属性，由于前一个节点大于254，那么要扩容，重新设置好压缩列表。之后又发现e2需要更新previous_entry_length属性，依旧大于254。产生了连锁反应。 同理删除节点也可能发生这种情况。 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"压缩列表API ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:4:0","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"创建空ziplist // 创建一个空的ziplist unsigned char *ziplistNew(void) { // ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小 // 1 字节是表末端 ZIP_END 的大小 unsigned int bytes = ZIPLIST_HEADER_SIZE+1; unsigned char *zl = zmalloc(bytes); ZIPLIST_BYTES(zl) = intrev32ifbe(bytes); // 设置ziplist所占字节数，如有必要进行大小端转换 ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE); // 设定尾节点相对头部的偏移量 ZIPLIST_LENGTH(zl) = 0; // 设定ziplist的节点数 zl[bytes-1] = ZIP_END; // 设定尾部字节位0xff return zl; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:4:1","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"插入节点 unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) { return __ziplistInsert(zl,p,s,slen); } // 将长度为slen的字符串s插入到z1中，位置为p前 static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) { size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen; // 当前ziplist长度，插入后的长度 unsigned int prevlensize, prevlen = 0; // 前置节点长度和编码该长度所需要的长度 size_t offset; int nextdiff = 0; unsigned char encoding = 0; long long value = 123456789; /* initialized to avoid warning. Using a value that is easy to see if for some reason we use it uninitialized. */ zlentry tail; /* Find out prevlen for the entry that is inserted. */ // 找到待插入节点的前置节点长度 if (p[0] != ZIP_END) { // 不为末尾解码长度 ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); } else { // 指向末尾则表示ziplist为空 unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl); if (ptail[0] != ZIP_END) { // 计算尾节点长度 prevlen = zipRawEntryLength(ptail); } } // 判断编码是否为整数 if (zipTryEncoding(s,slen,\u0026value,\u0026encoding)) { // 该节点编码为整数，通过encoding来获取编码长度 reqlen = zipIntSize(encoding); } else { // 使用字符串来编码节点 reqlen = slen; } // 计算前置节点长度所需的大小 reqlen += zipPrevEncodeLength(NULL,prevlen); // 计算编码当前节点值所需要的大小 reqlen += zipEncodeLength(NULL,encoding,slen); // 保存新旧编码之间的字节差 nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0; offset = p-zl; // 保存偏移 // 重分配长度 zl = ziplistResize(zl,curlen+reqlen+nextdiff); p = zl+offset; if (p[0] != ZIP_END) { // 移动元素，为新元素腾出位置 memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff); // 将新节点的长度编码到后置节点 zipPrevEncodeLength(p+reqlen,reqlen); // 更新尾部的偏移量 ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen); /* When the tail contains more than one entry, we need to take * \"nextdiff\" in account as well. Otherwise, a change in the * size of prevlen doesn't have an effect on the *tail* offset. */ tail = zipEntry(p+reqlen); if (p[reqlen+tail.headersize+tail.len] != ZIP_END) { ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff); } } else { /* This element will be the new tail. */ ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl); } /* When nextdiff != 0, the raw length of the next entry has changed, so * we need to cascade the update throughout the ziplist */ // 判断是不是需要连锁更新 if (nextdiff != 0) { offset = p-zl; zl = __ziplistCascadeUpdate(zl,p+reqlen); p = zl+offset; } /* Write the entry */ // 写入节点前置节点长度 p += zipPrevEncodeLength(p,prevlen); // 节点值的长度写入节点 p += zipEncodeLength(p,encoding,slen); // 写入节点值 if (ZIP_IS_STR(encoding)) { memcpy(p,s,slen); } else { zipSaveInteger(p,value,encoding); } // 更新节点计数器 ZIPLIST_INCR_LENGTH(zl,1); return zl; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:4:2","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"根据给定索引，遍历列表，并返回索引指定节点的指针。 unsigned char *ziplistIndex(unsigned char *zl, int index) { unsigned char *p; unsigned int prevlensize, prevlen = 0; // index为负从尾部，正从头部 if (index \u003c 0) { index = (-index)-1; // 获取尾部指针 p = ZIPLIST_ENTRY_TAIL(zl); if (p[0] != ZIP_END) { // 解码前置节点长度 ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); while (prevlen \u003e 0 \u0026\u0026 index--) { p -= prevlen; // 偏移 // 解码前置节点长度 ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); } } } else { p = ZIPLIST_ENTRY_HEAD(zl); // 头部 while (p[0] != ZIP_END \u0026\u0026 index--) { p += zipRawEntryLength(p); // 移动 } } // 返回 return (p[0] == ZIP_END || index \u003e 0) ? NULL : p; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:4:3","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"删除给定节点 unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) { size_t offset = *p-zl; zl = __ziplistDelete(zl,*p,1); /* Store pointer to current element in p, because ziplistDelete will * do a realloc which might result in a different \"zl\"-pointer. * When the delete direction is back to front, we might delete the last * entry and end up with \"p\" pointing to ZIP_END, so check this. */ *p = zl+offset; return zl; } static unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) { unsigned int i, totlen, deleted = 0; size_t offset; int nextdiff = 0; zlentry first, tail; // 计算被删除节点总共占用的内存字节数 // 删除的节点总数 first = zipEntry(p); for (i = 0; p[0] != ZIP_END \u0026\u0026 i \u003c num; i++) { p += zipRawEntryLength(p); deleted++; } totlen = p-first.p; // 被删除节点总共占用内存字节数 if (totlen \u003e 0) { if (p[0] != ZIP_END) { // 计算新旧前置节点字节数差 nextdiff = zipPrevLenByteDiff(p,first.prevrawlen); p -= nextdiff; // 有需要将p后退nextdiff字节，为新header空出空间 zipPrevEncodeLength(p,first.prevrawlen); // 将first的前置节点长度编码至p中 /* Update offset for tail */ // 更新尾部偏移 ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen); /* When the tail contains more than one entry, we need to take * \"nextdiff\" in account as well. Otherwise, a change in the * size of prevlen doesn't have an effect on the *tail* offset. */ // 被删除节点之后还存在节点，就需要将nextdiff计算在内 tail = zipEntry(p); if (p[tail.headersize+tail.len] != ZIP_END) { ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff); } /* Move tail to the front of the ziplist */ // 将删除节点后面内存空间移动到删除节点之后 memmove(first.p,p, intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1); } else { /* The entire tail was deleted. No need to move memory. */ // 被删除节点后无节点，不需要移动 ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe((first.p-zl)-first.prevrawlen); } /* Resize and update length */ // 更新ziplist长度 offset = first.p-zl; zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff); ZIPLIST_INCR_LENGTH(zl,-deleted); p = zl+offset; /* When nextdiff != 0, the raw length of the next entry has changed, so * we need to cascade the update throughout the ziplist */ // 看看是否需要连锁更新 if (nextdiff != 0) zl = __ziplistCascadeUpdate(zl,p); } return zl; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:4:4","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"小结 整体上ziplist设计出来的目的是为了节省内存，采用了在连续内存空间上建立一个双向列表来实现。 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/:5:0","tags":["redis","源码阅读"],"title":"redis源码阅读-压缩列表ziplist","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"},{"categories":["源码阅读"],"content":"创建一个只包含整数值元素的集合，同时元素数量不多时，redis会使用整数集合作为键的底层实现。 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-整数集合","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"},{"categories":["源码阅读"],"content":"整数集合的实现 typedef struct intset { uint32_t encoding; // 编码方式 uint32_t length; // 元素数量 int8_t contents[]; // 保存元素的数组 } intset; encoding表示整数集合的编码模式，目前提供三种模式 #define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-整数集合","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"},{"categories":["源码阅读"],"content":"升级 整数集合有三种编码模式，为了能够节省空间，一般采用能够符合所有元素要求的编码。 当新添加元素比整数集合中现有元素类型都长，那么就需要进行升级，将编码位数提升，负荷新添加元素类型长度。 步骤： 根据新元素的类型，扩展整数集合底层数组空间大小，并为新元素分配空间。 将底层数组现有的所有元素都转换为新元素相同的类型，并将类型转换后的元素放置到正确的位置上。 将新元素添加到数组中。 static intset *intsetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u003eencoding); // 当前编码 uint8_t newenc = _intsetValueEncoding(value); // 获取编码 int length = intrev32ifbe(is-\u003elength); // 元素数量 int prepend = value \u003c 0 ? 1 : 0; // 根据情况判断添加到数组的最前还是最后（要升级只有这种可能） is-\u003eencoding = intrev32ifbe(newenc); // 更新编码方式 // 重新分配空间 is = intsetResize(is,intrev32ifbe(is-\u003elength)+1); // 从后往前重新编码 while(length--) _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc)); // 根据情况添加到尾部后者头部 if (prepend) _intsetSet(is,0,value); else _intsetSet(is,intrev32ifbe(is-\u003elength),value); is-\u003elength = intrev32ifbe(intrev32ifbe(is-\u003elength)+1); return is; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-整数集合","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"},{"categories":["源码阅读"],"content":"整数集合API ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-整数集合","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"},{"categories":["源码阅读"],"content":"创建 intset *intsetNew(void) { // 分配空间 intset *is = zmalloc(sizeof(intset)); // 设置初始编码 is-\u003eencoding = intrev32ifbe(INTSET_ENC_INT16); // 初始化元素数量 is-\u003elength = 0; return is; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/:3:1","tags":["redis","源码阅读"],"title":"redis源码阅读-整数集合","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"},{"categories":["源码阅读"],"content":"添加元素 判断数据大小，如果超出现有编码的范围，升级。 如果没有，则插入到指定位置。 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算新插入值编码 uint32_t pos; if (success) *success = 1; // 如果需要则升级 if (valenc \u003e intrev32ifbe(is-\u003eencoding)) { return intsetUpgradeAndAdd(is,value); } else { // 查找，如果存在返回失败信息 if (intsetSearch(is,value,\u0026pos)) { if (success) *success = 0; return is; } // 重新分配空间 is = intsetResize(is,intrev32ifbe(is-\u003elength)+1); // 如果插入中间位置，则将该位置之后的值移动到尾部 if (pos \u003c intrev32ifbe(is-\u003elength)) intsetMoveTail(is,pos,pos+1); } // 设置值 _intsetSet(is,pos,value); // 计数器增加 is-\u003elength = intrev32ifbe(intrev32ifbe(is-\u003elength)+1); return is; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/:3:2","tags":["redis","源码阅读"],"title":"redis源码阅读-整数集合","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"},{"categories":["源码阅读"],"content":"移除数据 intset *intsetRemove(intset *is, int64_t value, int *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算编码方式 uint32_t pos; if (success) *success = 0; // 查找值，并删除 if (valenc \u003c= intrev32ifbe(is-\u003eencoding) \u0026\u0026 intsetSearch(is,value,\u0026pos)) { uint32_t len = intrev32ifbe(is-\u003elength); // 删除成功标志 if (success) *success = 1; // 删除数据 if (pos \u003c (len-1)) intsetMoveTail(is,pos+1,pos); // 调整内存大小 is = intsetResize(is,len-1); // 更新length值 is-\u003elength = intrev32ifbe(len-1); } return is; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/:3:3","tags":["redis","源码阅读"],"title":"redis源码阅读-整数集合","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"},{"categories":["源码阅读"],"content":"其他API intsetFind 判断值是否在集合中 intsetRandom 随机返回整数集合中的一个数 intsetGet 取出底层数组在给定索引上的元素 intsetLen 返回整数集合中的元素个数 intsetloblen 返回整数集合占用的内存字节数 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/:3:4","tags":["redis","源码阅读"],"title":"redis源码阅读-整数集合","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"},{"categories":["源码阅读"],"content":"跳跃表一种有序数据结构，每个节点维护多个指向其他节点的指针，达到快速访问节点的目的。 大部分情况下跳跃表的效率可以和平衡数媲美，实现比平衡树简单，不少程序使用跳跃表来代替平衡树。 跳跃表有时会作为有序集合的实现。以分值排序。 ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-跳跃表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/"},{"categories":["源码阅读"],"content":"结构体 // 跳跃表节点 typedef struct zskiplistNode { robj *obj; // 保存的对象 double score; // 分值 跳跃表按照分值进行排序 struct zskiplistNode *backward; // 上一节点 struct zskiplistLevel { struct zskiplistNode *forward; // 前进指针 unsigned int span; // 跨度 记录两个节点之间的距离 } level[]; // 层 } zskiplistNode; // 跳跃表 typedef struct zskiplist { struct zskiplistNode *header, *tail; // 头、尾指针 PORT_ULONG length; // 跳跃表长度 int level; // 层数最大节点层数 } zskiplist; ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-跳跃表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/"},{"categories":["源码阅读"],"content":"跳跃表的创建 // 创建节点 zskiplistNode *zslCreateNode(int level, double score, robj *obj) { // 申请内存 zskiplistNode *zn = zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel)); zn-\u003escore = score; // 赋值分数 zn-\u003eobj = obj; // 设定成员对象 return zn; } // 创建跳跃表 zskiplist *zslCreate(void) { int j; zskiplist *zsl; // 申请内存 zsl = zmalloc(sizeof(*zsl)); zsl-\u003elevel = 1; // 设置层数初始为1 zsl-\u003elength = 0; // 设置长度初始为0 // 创建头节点 层数为32 分数为0 zsl-\u003eheader = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL); // 将每层的forward指针指向null，跨度0 for (j = 0; j \u003c ZSKIPLIST_MAXLEVEL; j++) { zsl-\u003eheader-\u003elevel[j].forward = NULL; zsl-\u003eheader-\u003elevel[j].span = 0; } // 设定backward指向null zsl-\u003eheader-\u003ebackward = NULL; zsl-\u003etail = NULL; return zsl; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-跳跃表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/"},{"categories":["源码阅读"],"content":"插入节点 逻辑是先找到节点插入位置，插入位置前一个节点的信息。 插入，并更新前一节点信息。 // 创建一个成员为obj，分值为score的新节点 // 将新节点插入到跳跃表中 zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) { // updata[]数组记录每一层位于插入节点的前一个节点 zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; // rank[]记录每一层位于插入节点的前一个节点的排名 unsigned int rank[ZSKIPLIST_MAXLEVEL]; int i, level; redisAssert(!isnan(score)); x = zsl-\u003eheader; // 表头节点 // 从最高层开始查找 for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { // i == (zsl-\u003elevel-1) 为0 //否则第i层起始rank值为i+1的rank值 // 最终rank[0]的值+1就是新节点的前置节点排位 rank[i] = i == (zsl-\u003elevel-1) ? 0 : rank[i+1]; // 沿着前几指针遍历跳跃表 while (x-\u003elevel[i].forward \u0026\u0026 // 比对分值 (x-\u003elevel[i].forward-\u003escore \u003c score || // 比对成员 (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 compareStringObjects(x-\u003elevel[i].forward-\u003eobj,obj) \u003c 0))) { // 记录沿途跨越多少节点 rank[i] += x-\u003elevel[i].span; // 移动到下一个指针 x = x-\u003elevel[i].forward; } // 记录将要和新节点相连接的节点 update[i] = x; } * // zslInsert() 的调用者会确保同分值且同成员的元素不会出现， // 所以这里不需要进一步进行检查，可以直接创建新元素。 // 获取一个随机值作为新节点的层数 level = zslRandomLevel(); // 如果新节点的层数比其他节点层数大 if (level \u003e zsl-\u003elevel) { // 初始化未使用层 for (i = zsl-\u003elevel; i \u003c level; i++) { rank[i] = 0; update[i] = zsl-\u003eheader; update[i]-\u003elevel[i].span = zsl-\u003elength; } zsl-\u003elevel = level; } // 创建新节点 x = zslCreateNode(level,score,obj); // 将前面记录的指针指向新节点，并做相应的设置 for (i = 0; i \u003c level; i++) { // 设置新节点的前进指针 x-\u003elevel[i].forward = update[i]-\u003elevel[i].forward; update[i]-\u003elevel[i].forward = x; // 将沿途记录的各个节点的前进指针指向新节点 /* update span covered by update[i] as x is inserted here */ // 计算新节点跨越的节点数量 x-\u003elevel[i].span = update[i]-\u003elevel[i].span - (rank[0] - rank[i]); // 更新新节点插入后，沿途节点的span值 update[i]-\u003elevel[i].span = (rank[0] - rank[i]) + 1; } /* increment span for untouched levels */ // 未接触的节点的span值也需要增加1，这些节点从表头指向新节点 for (i = level; i \u003c zsl-\u003elevel; i++) { update[i]-\u003elevel[i].span++; } // 设置新节点的后退指针 x-\u003ebackward = (update[0] == zsl-\u003eheader) ? NULL : update[0]; if (x-\u003elevel[0].forward) x-\u003elevel[0].forward-\u003ebackward = x; else zsl-\u003etail = x; // 长度+1 zsl-\u003elength++; return x; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-跳跃表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/"},{"categories":["源码阅读"],"content":"删除节点 Redis提供三种删除跳跃表节点的方式： 根据给定分值和成员来删除节点，zslDelete。 根据给定分值来删除节点，zslDeleteByScore。 根据给定排名来删除节点，zslDeleteByRank。 删除操作均由zslDeleteNode执行。 void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) { int i; // 更新所有和被删除节点x有关的节点指针，解除它们之间的关系 for (i = 0; i \u003c zsl-\u003elevel; i++) { if (update[i]-\u003elevel[i].forward == x) { update[i]-\u003elevel[i].span += x-\u003elevel[i].span - 1; update[i]-\u003elevel[i].forward = x-\u003elevel[i].forward; } else { update[i]-\u003elevel[i].span -= 1; } } // 更新被删除节点x的前进后退指针 if (x-\u003elevel[0].forward) { x-\u003elevel[0].forward-\u003ebackward = x-\u003ebackward; } else { zsl-\u003etail = x-\u003ebackward; } // 更新跳跃表的最大层数 while(zsl-\u003elevel \u003e 1 \u0026\u0026 zsl-\u003eheader-\u003elevel[zsl-\u003elevel-1].forward == NULL) zsl-\u003elevel--; // 计数器-1 zsl-\u003elength--; } 根据节点的分值和成员删除节点,其余两种情况只是查找方法与判断方式不同。 int zslDelete(zskiplist *zsl, double score, robj *obj) { zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; int i; // 遍历跳跃表，查找目标节点，并记录所有沿途及节点 x = zsl-\u003eheader; for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score || (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 compareStringObjects(x-\u003elevel[i].forward-\u003eobj,obj) \u003c 0))) x = x-\u003elevel[i].forward; update[i] = x; } // 分值和对象相同时，将其删除 x = x-\u003elevel[0].forward; if (x \u0026\u0026 score == x-\u003escore \u0026\u0026 equalStringObjects(x-\u003eobj,obj)) { zslDeleteNode(zsl, x, update); zslFreeNode(x); return 1; } return 0; /* not found */ } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/:4:0","tags":["redis","源码阅读"],"title":"redis源码阅读-跳跃表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/"},{"categories":["源码阅读"],"content":"查找给定分值和成员对象的节点在跳跃表中的排位 unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) { zskiplistNode *x; unsigned long rank = 0; int i; // 遍历整个跳跃表 x = zsl-\u003eheader; for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { // 遍历节点并对比元素 while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score || // 比对分值 (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 // 比对成员对象 compareStringObjects(x-\u003elevel[i].forward-\u003eobj,o) \u003c= 0))) { // 累积跨越的节点数量 rank += x-\u003elevel[i].span; // 沿着前进指针遍历跳跃表 x = x-\u003elevel[i].forward; } // 必须确保不仅分值相等，而且成员对象也要相等 if (x-\u003eobj \u0026\u0026 equalStringObjects(x-\u003eobj,o)) { return rank; } } // 没找到 return 0; } ","date":"2017-07-08","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/:5:0","tags":["redis","源码阅读"],"title":"redis源码阅读-跳跃表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/"},{"categories":["源码阅读"],"content":"Redis字典由哈希表实现的保存键值对的抽象数据结构。 实现文件在dict.h\\dict.c中。 ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"哈希表 Redis字典结构体定义。 typedef struct dictEntry { void *key;// key 键 union { void *val; uint64_t u64; int64_t s64; double d; } v;// 值，支持多种类型,使用联合。 struct dictEntry *next;// 下一个点 采用链式来解决索引冲突问题 } dictEntry; typedef struct dictType { unsigned int (*hashFunction)(const void *key);// hash函数 void *(*keyDup)(void *privdata, const void *key);// key复制函数 void *(*valDup)(void *privdata, const void *obj);// value复制函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2);// key比较函数 void (*keyDestructor)(void *privdata, void *key);// key释放函数 void (*valDestructor)(void *privdata, void *obj);// value释放函数 } dictType; /* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */ typedef struct dictht { dictEntry **table;// 指针的数组头的指针 unsigned long size;// 大小 unsigned long sizemask;// 大小的掩码 总是等于size-1 unsigned long used;// 被使用的节点数 } dictht;// hash表 typedef struct dict { dictType *type;// 绑定的函数 void *privdata;// 私有数据 dictht ht[2];// hash表，一般只使用[0]，在rehash的时候使用[1] long rehashidx; // 记录rehash的进度，不进行rehash的时候为-1 int iterators; /* number of iterators currently running */ } dict;// 字典 /* If safe is set to 1 this is a safe iterator, that means, you can call * dictAdd, dictFind, and other functions against the dictionary even while * iterating. Otherwise it is a non safe iterator, and only dictNext() * should be called while iterating. */ typedef struct dictIterator { dict *d; long index; int table, safe; dictEntry *entry, *nextEntry; /* unsafe iterator fingerprint for misuse detection. */ long long fingerprint; } dictIterator;// 迭代器 ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"哈希算法 确认一个键值插入到字典的位置是哪，需要调用hash算法 //计算key的hash值 hash = dict-\u003etype-\u003ehashFunction(key); //按位与确认在hash表中的位置 //根据情况，可能是ht[0]或者ht[1] index = hash \u0026 dict-\u003eht[x].sizemask; 字典在redis中使用MurmurHash2算法进行计算键的哈希值。有点在于计算速度非常快，即使输入的键有规律也能够很好的给出一个随机分布。 ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"键的冲突解决 在key获取的index相同的情况下，产生了键的冲突。redis采用链式解决冲突，新的键值放在链的头部。 ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"rehash 随着hash表不断插入删除数据，hash表的负载因子会不断变化。当负载因子在一个不合理的范围内，则redis的会对hash表进行rehash。 ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:4:0","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"渐进式 rehash 渐进式rehash的目的是为了防止一次性rehash的情况下，服务器停止响应。 redis渐进式rehash的步骤: 1）为ht[1]分配空间，让字典同时持有 ht[0]和ht[1]两个哈希表 2）在字典位置一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。 3）在rehash进行期间，每次对字典执行删除、添加、查找或者更新操作时候，程序除了执行指定的操作外，还顺便将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后将rehashidx属性的值增加1 4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehsh至ht[1]，这时程序将rehashidx属性值设为-1，表示rehash操作已完成。 渐进式rehash过程中，字典会同时对ht[0]和ht[1]两个哈希表进行操作，字典在删除、查找、更新等操作会在两个哈希表进行。 在渐进式rehash执行期间，新添加到字典的键值对一律会被保存在ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减少不增加，并随着rehash操作的执行最终变为空。 rehash有两种方式，一种是单步，在字典没有安全迭代器的情况下能够执行。一种是执行一段时间跳出。两种方法均调用int dictRehash(dict *d, int n) 完成。 static void _dictRehashStep(dict *d) { if (d-\u003eiterators == 0) dictRehash(d,1); } int dictRehashMilliseconds(dict *d, int ms) { // 开始时间 long long start = timeInMilliseconds(); int rehashes = 0; while(dictRehash(d,100)) { rehashes += 100; // 时间到达，跳出 if (timeInMilliseconds()-start \u003e ms) break; } return rehashes; } int dictRehash(dict *d, int n) 算法 //执行N步渐进式rehash操作，rehash之后如果旧表还存在数据，则返回1，不存在返回0 int dictRehash(dict *d, int n) { int empty_visits = n*10; // 最大允许访问的空桶值 if (!dictIsRehashing(d)) return 0; // 判断是否允许rehash while(n-- \u0026\u0026 d-\u003eht[0].used != 0) { dictEntry *de, *nextde; // rehashidx不能大于哈希表的大小 assert(d-\u003eht[0].size \u003e (unsigned long)d-\u003erehashidx); // 跳过空节点 while(d-\u003eht[0].table[d-\u003erehashidx] == NULL) { d-\u003erehashidx++; // 超过空节点最大值，直接跳出 if (--empty_visits == 0) return 1; } // 获取需要rehash的节点 de = d-\u003eht[0].table[d-\u003erehashidx]; // 将该桶下所有节点移动到新表 while(de) { unsigned int h; nextde = de-\u003enext; // 获取新表中hash索引 h = dictHashKey(d, de-\u003ekey) \u0026 d-\u003eht[1].sizemask; de-\u003enext = d-\u003eht[1].table[h]; d-\u003eht[1].table[h] = de; d-\u003eht[0].used--; d-\u003eht[1].used++; de = nextde; } d-\u003eht[0].table[d-\u003erehashidx] = NULL; d-\u003erehashidx++; } // 判断是否都迁移完成，完成返回0 if (d-\u003eht[0].used == 0) { // 释放旧表,将rehashidx设置为-1 zfree(d-\u003eht[0].table); d-\u003eht[0] = d-\u003eht[1]; _dictReset(\u0026d-\u003eht[1]); d-\u003erehashidx = -1; return 0; } // 未完成返回1 return 1; } ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:5:0","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"dict部分API dict *dictCreate(dictType *type, void *privDataPtr); // 创建一个新字典 int dictExpand(dict *d, unsigned long size); // 在字典中创建一个新hash表 int dictAdd(dict *d, void *key, void *val); // 尝试将给定键值添加到字典中 dictEntry *dictAddRaw(dict *d, void *key); // 尝试将给定键插入到字典中，键已经存在则返回null int dictReplace(dict *d, void *key, void *val); // 将给定键值添加到字典中，如果已经存在就替换 dictEntry *dictReplaceRaw(dict *d, void *key); // 将给定键值添加到字典中，如果已经存在则不添加，返回已经存在的值 int dictDelete(dict *d, const void *key); // 删除字典中给定键的节点 int dictDeleteNoFree(dict *d, const void *key);// 删除包含给定键的及诶单，但是不释放 void dictRelease(dict *d); // 删除并释放整个字典 dictEntry * dictFind(dict *d, const void *key); // 查找节点 void *dictFetchValue(dict *d, const void *key); // 获取包含给定键的节点值 int dictResize(dict *d); // 缩小字典，使得已用节点和字典大小比率接近1:1 dictIterator *dictGetIterator(dict *d); // 创建并返回给定字典的不安全迭代器 dictIterator *dictGetSafeIterator(dict *d); // 创建并返回给定节点的安全迭代器 dictEntry *dictNext(dictIterator *iter); // 返回当前节点，指向下个节点 void dictReleaseIterator(dictIterator *iter); // 释放迭代器 dictEntry *dictGetRandomKey(dict *d); // 随机返回字典中一个节点 void dictEmpty(dict *d, void(callback)(void*)); // 清空字典中所有哈希表节点，并重置属性 void dictEnableResize(void); // 开启自动rehash void dictDisableResize(void); // 关闭自动rehash ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:6:0","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"创建dict 使用dictCreate创建字典。 // 创建字典 dict *dictCreate(dictType *type, void *privDataPtr) { // 分配空间 dict *d = zmalloc(sizeof(*d)); // 初始化字典 _dictInit(d,type,privDataPtr); return d; } static void _dictReset(dictht *ht) { ht-\u003etable = NULL; ht-\u003esize = 0; ht-\u003esizemask = 0; ht-\u003eused = 0; } // 初始化字典 int _dictInit(dict *d, dictType *type, void *privDataPtr) { // 重置hash表 _dictReset(\u0026d-\u003eht[0]); _dictReset(\u0026d-\u003eht[1]); d-\u003etype = type; // 设置字典类型 d-\u003eprivdata = privDataPtr; d-\u003erehashidx = -1; // 初始为-1，表明没有进行rehash d-\u003eiterators = 0; //正在使用的迭代器数量 return DICT_OK; } ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:6:1","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"添加键值对 使用int dictAdd(dict *d, void *key, void *val)添加键值对 // 添加一个键值对到dict中 int dictAdd(dict *d, void *key, void *val) { // 往字典中添加一个只有key的键值对 dictEntry *entry = dictAddRaw(d,key); // 添加失败，则返回错误 if (!entry) return DICT_ERR; //使用宏，添加成功则设置key键值对的值 dictSetVal(d, entry, val); return DICT_OK; } // 添加键到字典中 // 键存在则返回null // 不存在则创建节点，与键关联，并返回节点 dictEntry *dictAddRaw(dict *d, void *key) { int index; dictEntry *entry; dictht *ht; // 尝试进行单步式rehash if (dictIsRehashing(d)) _dictRehashStep(d); // 尝试获取hash表中的索引值，返回-1表示键已经存在 if ((index = _dictKeyIndex(d, key)) == -1) return NULL; // rehash使用1号哈希表，不在rehash使用0号 ht = dictIsRehashing(d) ? \u0026d-\u003eht[1] : \u0026d-\u003eht[0]; // 分配空间，将节点添加到链表表头 entry = zmalloc(sizeof(*entry)); entry-\u003enext = ht-\u003etable[index]; ht-\u003etable[index] = entry; ht-\u003eused++; // 使用宏，设置新节点的键 dictSetKey(d, entry, key); return entry; } ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:6:2","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"替换键值对 // 如果键值不存在，返回1 //存在，更新键值，返回0 int dictReplace(dict *d, void *key, void *val) { dictEntry *entry, auxentry; // 添加成功返回1 if (dictAdd(d, key, val) == DICT_OK) return 1; // 查找键 entry = dictFind(d, key); // 更新键值 auxentry = *entry; dictSetVal(d, entry, val); // 释放原值 dictFreeVal(d, \u0026auxentry); return 0; } ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:6:3","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"查找键值对 dictEntry *dictFind(dict *d, const void *key) { dictEntry *he; unsigned int h, idx, table; // hash表大小为0，表名无值 if (d-\u003eht[0].size == 0) return NULL; /* We don't have a table at all */ // 如果在rehash，则单步rehash if (dictIsRehashing(d)) _dictRehashStep(d); // 查找索引 h = dictHashKey(d, key); // 遍历索引下的键 for (table = 0; table \u003c= 1; table++) { idx = h \u0026 d-\u003eht[table].sizemask; he = d-\u003eht[table].table[idx]; while(he) { if (dictCompareKeys(d, key, he-\u003ekey)) return he; he = he-\u003enext; } // 如果没有进行rehash，则不再查找ht[1] if (!dictIsRehashing(d)) return NULL; } return NULL; } ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:6:4","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"删除键值对 // 删除该键值对，并释放键和值 int dictDelete(dict *ht, const void *key) { return dictGenericDelete(ht,key,0); } // 删除该键值对，不释放键和值 int dictDeleteNoFree(dict *ht, const void *key) { return dictGenericDelete(ht,key,1); } // 查找并删除对应的键值对 static int dictGenericDelete(dict *d, const void *key, int nofree) { unsigned int h, idx; dictEntry *he, *prevHe; int table; // 空则直接返回错误信息 if (d-\u003eht[0].size == 0) return DICT_ERR; /* d-\u003eht[0].table is NULL */ // rehash时，进行一次rehash if (dictIsRehashing(d)) _dictRehashStep(d); h = dictHashKey(d, key); // 获取hash索引 for (table = 0; table \u003c= 1; table++) { idx = h \u0026 d-\u003eht[table].sizemask; he = d-\u003eht[table].table[idx]; prevHe = NULL; // 查找，遍历整个链表 while(he) { if (dictCompareKeys(d, key, he-\u003ekey)) { /* Unlink the element from the list */ if (prevHe) prevHe-\u003enext = he-\u003enext; else d-\u003eht[table].table[idx] = he-\u003enext; if (!nofree) { // 根据传入参数是否释放键值 dictFreeKey(d, he); dictFreeVal(d, he); } zfree(he); d-\u003eht[table].used--; return DICT_OK; } prevHe = he; he = he-\u003enext; } // 没有进行rehash则不查找ht[1] if (!dictIsRehashing(d)) break; } return DICT_ERR; /* not found */ } ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:6:5","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["源码阅读"],"content":"字典删除 // 清理释放整个字典 void dictRelease(dict *d) { // 释放ht[0] _dictClear(d,\u0026d-\u003eht[0],NULL); // 释放ht[1] _dictClear(d,\u0026d-\u003eht[1],NULL); // 释放字典 zfree(d); } int _dictClear(dict *d, dictht *ht, void(callback)(void *)) { unsigned long i; // 释放所有元素 for (i = 0; i \u003c ht-\u003esize \u0026\u0026 ht-\u003eused \u003e 0; i++) { dictEntry *he, *nextHe; if (callback \u0026\u0026 (i \u0026 65535) == 0) callback(d-\u003eprivdata); if ((he = ht-\u003etable[i]) == NULL) continue; while(he) { nextHe = he-\u003enext; // 释放键值对 dictFreeKey(d, he); dictFreeVal(d, he); zfree(he); ht-\u003eused--; he = nextHe; } } // 释放hash表 zfree(ht-\u003etable); // 重置hsh表 _dictReset(ht); return DICT_OK; /* never fails */ } ","date":"2017-06-30","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/:6:6","tags":["redis","源码阅读"],"title":"redis源码阅读-字典","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/"},{"categories":["读书笔记"],"content":"【美】Susan Lammers 第1篇　查尔斯•西蒙尼 2017-04-30 采访者：编程是一种技巧或技能吗？ 西蒙尼：什么是编程？人们对此一直各持己见。有人说它是科学，有人说它是艺术，还有人称之为技能或手艺。我认为这三方面兼而有之。我们喜欢说它蕴含大量艺术成分，但是我们都知道它里面更多的是科学。 孩子们在学校里学习数学，高中毕业时，他们会以为数学就是加法和乘法，甚或代数和微积分。其实，算术，即使简单如加法的运算，背后也有令人难以置信的科学理论作支持。 计算机编程背后也有大量科学理论作支持。例如，哥德尔定理的数学证明冗长而复杂，但是如果借用计算机科学的图灵定理，证明起来不费吹灰之力。信息理论和计算机科学其他领域对数学影响巨大，反之亦然。 编程包含有大量科学，同时，它也有点像手艺。实际上，在许多人看来，编程是一项复杂的技能，这跟工具制造很像，需要精雕细琢。我认为，只要将科学、艺术和技能这三者拿捏得恰到好处，你就能取得一些引人瞩目的成绩。 2017-04-30 别人读几段你的源代码，有没有可能断定“这代码是查尔斯·西蒙尼写的”？ 西蒙尼：噢，是的，毫无疑问。是不是我本人写的可能很难分辨，但有一点是确定无疑的：只要看了代码，你就能知道它是不是我的团队写的，或者是不是受我的影响写的。这是因为我从1972年起写的代码都遵循特定的命名规范，许多人称之为“匈牙利命名法”。你一眼就能分辨出哪些代码是受我的影响写出来的，包括Microsoft Word、Multiplan和Bravo，以及其他许多遵循这些规范写成的程序。 註: 原来是他 2017-04-30 进入公司第一天，程序员就会拿到几本书。其中一本是数学家乔治·波利亚写的《怎样解题》。（西蒙尼边说边从他办公桌旁的书柜里取出那本书，翻到某一页。）这两页很重要。这本书的其余内容就是基于这两页展开的。这就像一张问题求解的检查单。这是起飞前、起飞和着陆检查单。它不会教你如何飞行，但是如果不照做，即使你已经懂得怎么飞行，也有可能会坠机身亡。 求解问题时，我们遵循以下四个步骤：首先理解问题，然后拟定计划，接着执行计划，最后回顾整个过程。这样的书我们大概有四本，我觉得我们能使程序员比刚加入公司时变得更加优秀。 第2篇　巴特勒•兰普森 2017-04-30 但是我坚持认为，如果你打算在研究生院攻读计算机科学，那么本科学习计算机科学就是犯了大忌。 采访者：为什么？ 兰普森：因为从长远来看，你学的内容大部分都没什么价值。你学不到施展聪明才智的新方法，而这些方法对你来说，要比学习如何编写编译器的细枝末节有 用得多，尽管后者可能是你本科念计算机科学时的学习内容。我认为，要是所有计算机科学研究生院联合起来，一致决定不接受本科念计算机科学的毕业生，世界会变得更好。学校应当要求这些人补习一年，学习数学或历史等科目，才能继续攻读计算机科学的研究生。不过，我还没看到有学校这么做的。 2017-04-30 举例来说，鲍勃·斯普劳尔（Bob Sproull）和我花了大量时间设计Interpress项目，那是一种印刷标准。我为此投入了很大精力，原本衷心希望施乐公司接受并促使所有人采纳。相反，他们完全把它搞砸了。结果，参与开发的部分人员离职并创办了Adobe系统公司，开发出一种类似的产品PostScript。很显然，后者成了大家现在都会采用的标准。这种事情很恼人，但是研究实验室的主要产品就是创意。 註: 这不就和盛大研究院一样 2017-04-30 ：程序员需要具备什么样的素质才能写出成功的程序？ 兰普森：最重要的素质是能够把问题的解决方案组织成容易操控的结构，其中每个组件都可以用简单的方式说明。有时，成功的程序员可以做到这一点，但他们无法解释自己做了什么，因为他们看不到那个结构。有些人之所以成为出色的程序员，是因为他们可以比多数人处理更多的细节。 2017-04-30 你有没有看到20年后每个指尖上都有一台计算机会出现什么问题？ 兰普森：我不觉得那有什么问题。显然每只手腕上都会有计算机。计算机的存在是予人帮助，我希望它们会给人们带来正面的影响。 註: 手机 第3篇　约翰•沃诺克 2017-05-01 你编程有什么诀窍？ 沃诺克：我不知道能不能归结到几点上。我前面提到过一些。不要早作绑定，尽可能推迟决定时间。眼界放宽一些，设计要比你自认为需要的程度更加灵活，因为从长远看你最终会需要这样。快速让某样东西工作起来，然后还能弃之不用。 从小的开始实验而不是大的入手学习。不要一头扎进周期长达两年且中间不出什么成果的开发当中。最好每两个月就要出点成果，这样你才能进行评估、重组和重新开始。程序员经常在一开始时过度定义他们的方法。他们可能会从一个中心构思着手，从第一天就开始编码。然后他们发现自己陷入重围，每件东西都开始膨胀，因为它们依赖于太多其他因素。应当反其道而行之，如果让过程较为宽松，保持一定的自由度，并在最后阶段加快速度，长远来说，你会做出更好的产品。 第4篇　加里•基尔代尔 2017-05-01 你说编程对很多人来说也是一种宗教体验，这是什么意思呢？ 基尔代尔：嗯，如果你和一群使用相同编程语言的程序员谈论编程的话，他们几乎可以成为那种编程语言的传教士。他们组成了一个紧密结合的社群，坚持一定的信念，在编程时遵循一定的规则。就像是一个把编程语言当作是圣经的教会。 FORTH是一个很好的例子，它是一种编程语言，对于很多人来说，可能很接近宗教的体验。当FORTH刚出来的时候，其信徒就声称它做任何算法都能快上十倍。这是一个典型的宣言。如果你在这点或其他任何方面有异议，你会发现自己是对牛弹琴，而且你是绝对不会被容许加入“教会”的。我并不想贬低使用这一种语言的人。那是一个非常能给人帮助的团体，所用的也是一种非常有效的语言，但他们没有基于理性去讨论问题，他们是基于信仰的。说过这句话，我可能会收到一千封有关FORTH及人们对其宗教体验的邮件。但是就算我能整天鼓吹LISP的神奇，我也不会把自己归到一个特殊的派别中。 註: 哈哈。php 第5篇　比尔•盖茨 2017-05-01 不，我认为在过了最初的三四年后，就会非常明显地显现出你是否是一个优秀的程序员。刚开始的几年中，你可能会更多地知道怎样去管理大型项目和不同个性的人，但在三四年后，就能很清楚地看出你会成为什么样的程序员了。在微软没有哪个程序员是在平庸了几年之后突然间一鸣惊人的。我和一个人谈谈他的程序，马上就能知道他是否是个好程序员。如果他真的很棒，每个细节他都会脱口而出。 就像下棋的人一样。如果你特别喜欢下棋，会很容易记住10盘棋中的每一步，因为你已置身其中了。其他人看到国际象棋选手或程序员能记住每个细节时，觉得他们像个怪物。其实这很正常。即使到了今天，在我写了微软的BASIC程序10年后，我仍可以在黑板上大段大段写出当时的源代码。 2017-05-01 编程需要非常大量的精力，所以大多数程序员都比较年轻。这就会带来一个问题，因为编程需要很多的训练。在年轻时，目标不是很持久，可能会被这样那样的事分心。但是年轻的程序员应当坚持下去，他们会变得更出色。作为程序员，我认为自己在1975年到1980年之间的提高是最明显的。在1975年，我会说：“嘿，看看，我什么事情都能做。”我真的认为自己可以，因为我读了大量代码，从来没有发现哪段代码是我无法快速读懂的。今天我仍旧认为检验编程能力的最好方法之一就是给程序员一本30来页的代码，看看他阅读和理解的速度有多快 第6篇　约翰•佩奇 2017-05-01 从一个计算机程序员转变到运营一个庞大的公司，你觉得困难吗？ 佩奇：这个角色转换是一个非常平缓的过程，因为我已经做了二十多年的管理人员，我可以告诉你真相，最难的是从管理者重新变成程序员。在创办公司前，我 在惠普已经习惯于领导很多人了。再回到编程工作时，我被迫完全依靠自己。真是让人一震。事实上这有点儿可怕——我不知道自己是否还能编程。但是，就像骑自行车一样——你永远都不会忘记的，只要一踏脚蹬，车就奔着夕阳去了。 2017-05-01 独自一人编程和一个团队合作编程有什么不同？ 佩奇：如果一个产品需要四到五个人开发，那和你自己一个人编程时采取的方法是不同的。我坚信只能由一个人来做产品和高层结构的设计，最多不能超过两个人。所有的设计出于一个头脑，才能够实现和谐与一致。如果试图取悦于所有人，让一个委员会来做设计，你的方向就错了。那绝对是致命的。 所以我在定义阶段会用一个人数非常少的团队来工作，然后如果有必要，再扩大团队来实施编程设计。实施设计方案所需要的队伍越大，就越必须严格地把整个系统划分成可管理的模块，并定义好相互间的接 口。除非一个程序大到必须由两三个人以上来做，否则不必编写很多结构化程序报告，也不用为每个步骤都编写文档。 有些系统，例如设计一个控制航天飞机的程序，需要上百名程序员。那就必须严格地把结构划分成可管理的模块才行。一个小系统的架构可能会过于大，一个大系统的架构可能会过于小——使用的技术必须与问题的规模相匹配。我就是这样做的。 2017-05-01 有些人觉得完成项目真是太过瘾了，他们做完一个项目就接着又做另一个了。这样会把自己累垮的。如果连续开始新的项目，情况会变得很糟。 另外，当你在复杂的程序上艰苦工作时，锻炼身体是很重要的。大部分程序员都缺乏身体锻炼，这样会失去敏锐的思维。往往在连续完成了第二个或第三个工作后，身体就虚弱了，以至于你会产生幻灭感，你会对着镜子说：“上帝啊，看看我，我为什么要这样做呢？ 第7篇　C.韦恩•莱特莱夫 2017-05-01 另一方面，非常有意思的是专家系统。我的预测是，在两三年之内，专家系统不必再和人","date":"2017-05-04","objectID":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95/:0:0","tags":["杂谈"],"title":"读书摘录-编程大师访谈录","uri":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95/"},{"categories":["读书笔记"],"content":"【美】阿甘斯 第3章 理解系统 2017-04-07 你必须掌握系统的工作原理以及它是如何设计的。在某些情况下，还要知道为什么这样设计。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方。（这不仅仅是“墨菲定律”的问题，如果你不能理解你所设计的系统，你的工作可能会变得一团糟。） 3.1 阅读手册 2017-04-07 如果你是一位工程师，正在调试自己公司的产品，那么你需要读一读内部手册。工程师们设计它是用来做什么的？读一下功能说明以及所有的设计规范，研究一下图表、时序图和状态机。分析它们的代码，还要读一下注释。（是的，读一下注释，这非常重要。）一定要检查产品的设计。查明构建它的工程师们打算用它来做什么（除了用它来赚钱买辆宝马车以外）。 注意，手册上的信息也不可全信。手册（以及那些只想着赚钱买宝马车的工程师们）可能也是错的，很多难以发现的bug就出现在这里。但你仍需要了解他们的想法，哪怕其中有些信息是很难接受的。 3.2 逐字逐句阅读整个手册 2017-04-07 参考设计和样本程序给出了产品的一种使用方式，有时这些就是能获得的全部文档了。但是，在使用这些设计时一定要注意，创建它们的人往往只了解他们的产品，而没有遵循好的设计实践，或者不是为真实应用而设计的（最常见的缺点是不能进行错误恢复）。不要照搬这些设计，如果你没有在开始的时候发现bug，那么将来也会发现。此外，即使是最好的参考设计可能也不会完全符合应用程序的特定需求，而不符合的地方可能就是出问题的地方。当我照搬了朋友的微处理器设计时，就发生了问题，因为他的设计无法处理中 3.3 知道什么是正常的 2017-04-07 当你检查系统时，必须知道系统的正常工作状态。如果你不知道低位字节首先由使用了Intel芯片的PC程序来处理，那么你会认为所有长字（longword）都是随意处理的。如果你不知道缓存是干什么的，就会非常奇怪有些数据为什么没有马上写入内存。如果你不了解三态（tri-state）数据总线的工作原理，你将会认为它们可能是主板上的故障信号。如果你从未听说过电锯，你可能会认为那个发出讨厌的嗡嗡声的东西一定是出了什么毛病。知道什么是正常的可以帮助你注意到什么是不正常的。 你必须掌握一些你所工作的技术领域的基础知识。如果我不知道时钟选通脉冲和地址线是做什么的，那么即使我读了手册之后也无法理解中断问题。本书中几乎所有的（即使不是全部的话）示例都假定人们已经掌握了系统工具原理的一些基本知识。（如果我在前面使你误认为读完本书就可以调试任何技术领域的bug，那么请恕我无心之过。如果你是一位游戏编程人员，最好不要去管核电厂的调试。如果你不是医生，那么就不要试图诊断你手臂上的灰绿色斑点是什么。如果你是一位政客，那么就不要介入任何有关bug的事情。） 3.7 小结 2017-04-07 理解系统 这是第一条规则，因为它是最重要的。 阅读手册。它会告诉你在使用除草机时，要在除草头上涂润滑油，这样除草绳就不会被烧化。 仔细阅读每个细节。有关微处理器如何处理中断的详细信息就隐藏在数据手册的第37页。 掌握基础知识。电锯本来就会发出很大的噪声。 了解工作流程。引擎的转速可能与轮胎的转速不同，这是由传动轴造成的。 了解工具。弄清楚体温计的哪一端才是用来测量体温的，弄清楚Glitch-O-Matic逻辑分析器的强大功能是如何使用的。 查阅细节。连爱因斯坦都会去查阅细节，而Kneejerk却盲目相信自己的记忆力 第4章 制造失败 2017-04-09 “当你发现一个故障时该怎么办？”他会回答说：“试着让它再次发生。”（Charlie是一位训练有素的调试人员）。这样做有3个原因。 可以观察它。要观察错误（下一节将更详细地讨论这个问题），就必须使它发生。我们必须尽可能有规律地制造失败。在前面讲的电视游戏的例子中，当问题发生时我可以集中注意力观察示波器（虽然当时我已经很疲倦）。 可以专心查找原因。准确地知道问题在什么条件下会发生，有助于集中精力查找原因（但是请注意，有时这会产生误导，例如，“烤箱只有在你把面包放进去的时候才会把面包烤焦，因此问题就出在面包上。”这个问题后文也会详细讨论。） 可以判断是否已修复问题。当你认为已经修复了问题时，如何才能确信它确实已被修复呢？那就是明确知道问题是如何发生的。当问题没有修复时，如果你执行X操作，失败率为100%；在修复问题后，再执行X操作，如果失败率为0，那么你知道bug确实已被修复。（我这么说并不多余。很多时候，开发人员在修复bug时会修改软件，然后在一个与当初发现bug的不同条件下测试新软件。软件当然能运行，即使他在代码中输入一行打油诗，而他也高兴地回家了。然而，几星期后，在测试过程中，或者更糟，在客户现场，软件再次失败。后文将讨论更多这方面的内容。 4.4 不要模拟失败 2017-04-09 记住，这并不意味着不能用自动化过程来引发失败，也不意味着在这个过程中不能采用一些起到放大效果的措施。自动测试能够使间歇性的问题更快发生，例如电视游戏的例子。放大效果可以使得细微的问题更明显，例如在修窗户的例子中，我可以用喷水管来找到漏雨的窗户，而不用等待偶尔才有的暴风雨来检查。这两种技术都有助于引发失败，而不是模拟失败的机理。所做的改变应该是一些高层次的改变，只影响错误发生的频率，而不影响错误的发生方式。 此外，还要注意不要画蛇添足，引发新的问题。不要因为假设芯片的问题是由于热量引起的，就用热风枪来给芯片加热以模拟错误，这样只会把芯片烧化，然后你会误认为bug完全就是电路板上那堆被烧化的塑料。如果我用消防用的水龙来检查漏雨问题，可能会断定问题显然就是出在被击碎的窗子上。 4.9 小结 2017-04-10 制造失败 虽然看起来很简单，但如果不制造失败的话，调试就会变得很困难。 制造失败。目的是为了观察它，找到原因，并检查是否已修复。 从头开始。修车工需要知道汽车车窗在被冻结之前你洗过车。 引发失败。用喷水管向漏雨的那扇窗子喷水。 但不要模拟失败。用喷水管向漏雨的那扇窗子喷水，而不要向另一扇不同的、“类似的”窗子喷水。 查找不受你控制的条件（正是它导致了间歇性失败）。改变能够改变的每件事情，振动、摇晃、扭曲，直到再现失败。 记录每件事情，并找到间歇性bug的特征。我们的绑定系统总是只在呼叫顺序错乱时才会失败。 不要过于相信统计数据。绑定问题看起来与时间段有关，但实际上真正的原因是当地的年轻人占用了电话线路。 要认识到“那”是可能会发生的。甚至冰淇淋的口味也会影响汽车的发动。 永远不要丢掉一个调试工具。自动击球板可能在某一天就会派上用场。 5.6 猜测只是为了确定搜索的重点目标 2017-04-11 不要想，而要看”并不意味着不能做任何猜想。事实上猜测是好事，特别是当你理解了系统之后。你的猜测可能很接近事实，但猜测只是为了确定搜索的重点。在尝试修复问题之前，仍需要再次看到失败，以便确认你的猜测是正确的。 5.7 小结 2017-04-11 不要想，而要看 凭空想象，问题可能有几千条原因。而实际的原因只有去看了才能发现。 观察失败。高级工程师看到了真实的问题，并且能够找到原因。而初级工程师们认为他们知道错误发生在哪里，结果他们修复的地方根本没有出错。 查看细节。听到水泵似乎发出声音时不要停下来。到地下室查明是哪个水泵。 植入插装工具。使用源代码调试器、调试日志、状态消息、信号灯和臭鸡蛋的气味。 添加外部插装工具。使用分析器、示波器、量表、金属检测仪、心电图仪和肥皂泡。 不要害怕深入研究。虽然它是软件成品，但它出问题了，你必须打开并修复它。 注意海森堡效应。不要让仪器影响了系统。 猜测只是为了确定搜索的重点。大胆地猜测内存时序发生了错误，但在修复之前应该先查看它。 6.4 修复已知bug 2017-04-12 有时，我们很难相信一个系统中会有多个bug，就像在旅店预订的例子中一样。这使得用“分而治之”原则隔离每个bug变得更加困难。因此，如果同时出现了多个问题，当你确实查明了其中的一个问题时，应该立即修复它，然后再查找其他问题。我总听人们说“那里出问题了，但它不可能影响我们正在查找的问题。”事实上，它确实（而且经常）会产生影响。如果你修复了已知的错误，就可以专心致志地查找其他问题。在旅店预订系统中，技术人员只有在修复了转接盒中的双向电阻阻值过高的问题之后，才能够发现速度最慢的那台终端的接线问题。 有时修复了一个问题，另一个问题也解决了，两个问题实际上是同一个bug。 此外，如果修复某个问题对其他的问题有影响，一定要首先修复它之后再测试其他的问题。如果修复了一个问题后将会引发新的问题，那么你可以尽早发现，并有更多时间处理新的问题。 6.5 首先消除噪声干扰 2017-04-12 人们也很容易成为一个“完美主义者”，为了达到全面的高质量把你发现的所有不好的设计都“修复”一遍。你可能只是因为先前的程序员编写的GOTO语句看起来很差劲就删掉它们，但是，如果它们并没有实际引起问题，最好还是保留它们吧。 6.6 小结 2017-04-12 分而治之 当bug的藏身之地不断被缩小一半时，它将很难再隐藏下去。 通过逐次逼近缩小搜索范围。猜测1～100内的一个数字，只需7次。 确定范围。如果数字是135而你却认为它在1～100内，那么你必须扩大范围。 确定你位于bug的哪一侧。如果你所在的位置有排放物，则排放管就在上游。如果没有排放物，则排放管就在下游。 使用易于查看的测试模式。从干净、清澈的水开始，以便当排放物进入河流中时很容易看到它。 从有问题的一端开始搜索。如果你验证的是正确的部分，那么需要验证的地方太多了。","date":"2017-04-30","objectID":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B9%8B%E9%81%93/:0:0","tags":["杂谈"],"title":"读书摘录-调试九法：软硬件错误的排查之道","uri":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B9%8B%E9%81%93/"},{"categories":["技巧"],"content":"先安装vs2005，后安装vs2017，vs2017无法运行 原因：vs2005注册了Microsoft.VisualStudio.Shell.Interop.8.0.dll，优先于vs2017需要的dll。导致运行错误。 解决方法： 复制 C:\\Program_Files_(x86)\\Microsoft_Visual Studio\\2017\\Enterprise\\Common7\\IDE\\PublicAssemblies\\Microsoft.VisualStudio.Shell.Interop.8.0.dll 到 C:\\Windows\\assembly\\GAC\\Microsoft.VisualStudio.Shell.Interop.8.0\\8.0.0.0__b03f5f7f11d50a3a\\Microsoft.VisualStudio.Shell.Interop.8.0.dll ","date":"2017-04-16","objectID":"/vs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/:0:0","tags":["技巧"],"title":"vs2017与vs2005冲突解决","uri":"/vs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/"},{"categories":["源码阅读"],"content":"C语言程序由于没有标准库的存在，各种造轮子。Redis为了满足需求，同样写了一个链表。 实现文件在adlist.h/adlist.c中。 ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-链表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8/"},{"categories":["源码阅读"],"content":"结构体定义 和普通的C写的双向链表差不多。没有什么特点。 typedef struct listNode { struct listNode *prev; // 前节点 struct listNode *next; // 后节点 void *value; // 值 } listNode; // 迭代器 typedef struct listIter { listNode *next;// 下一个节点 int direction;// 方向 } listIter; typedef struct list { listNode *head; // 头 listNode *tail; // 尾 void *(*dup)(void *ptr); // 自定义节点复制函数 void (*free)(void *ptr); // 自定义节点释放函数 int (*match)(void *ptr, void *key); // 自定义节点匹配函数 unsigned long len; // 链表长度 } list; ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-链表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8/"},{"categories":["源码阅读"],"content":"宏 定义了一些快速操作的宏 /* Functions implemented as macros */ #define listLength(l) ((l)-\u003elen) // 获取list长度 #define listFirst(l) ((l)-\u003ehead) // 获取list头节点指针 #define listLast(l) ((l)-\u003etail) // 获取list尾节点指针 #define listPrevNode(n) ((n)-\u003eprev) // 获取当前节点前一个节点 #define listNextNode(n) ((n)-\u003enext) // 获取当前节点后一个节点 #define listNodeValue(n) ((n)-\u003evalue) // 获取当前节点的值 #define listSetDupMethod(l,m) ((l)-\u003edup = (m)) // 设定节点值复制函数 #define listSetFreeMethod(l,m) ((l)-\u003efree = (m)) // 设定节点值释放函数 #define listSetMatchMethod(l,m) ((l)-\u003ematch = (m)) // 设定节点值匹配函数 #define listGetDupMethod(l) ((l)-\u003edup) // 获取节点值赋值函数 #define listGetFree(l) ((l)-\u003efree) // 获取节点值释放函数 #define listGetMatchMethod(l) ((l)-\u003ematch) // 获取节点值匹配函数 ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8/:1:1","tags":["redis","源码阅读"],"title":"redis源码阅读-链表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8/"},{"categories":["源码阅读"],"content":"API 都是些链表常用的API，比较有特点的是迭代器的C语言实现。 /* Prototypes */ list *listCreate(void); void listRelease(list *list); list *listAddNodeHead(list *list, void *value); list *listAddNodeTail(list *list, void *value); list *listInsertNode(list *list, listNode *old_node, void *value, int after); void listDelNode(list *list, listNode *node); listIter *listGetIterator(list *list, int direction); listNode *listNext(listIter *iter); void listReleaseIterator(listIter *iter); list *listDup(list *orig); listNode *listSearchKey(list *list, void *key); listNode *listIndex(list *list, long index); void listRewind(list *list, listIter *li); void listRewindTail(list *list, listIter *li); void listRotate(list *list); ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-链表","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8/"},{"categories":["源码阅读"],"content":"Redis没有使用c语言的字符串结构，自己设计了一个简单的动态字符串。特点是：修改时大小不足则扩容，大小足够直接使用不缩小。末尾使用‘\\0’，与c语言字符串兼容。 sds的源代码在sds.h与sds.c中。 ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"sds的定义 typedef char *sds;// 兼容C struct sdshdr { unsigned int len;// 字符串长度 unsigned int free;// 未分配的空间 char buf[];// 末尾'/0'的C风格字符串 };// SDS的实际结构，兼容char*则返回buf地址 ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"SDS这样设计的优点： 重用部分C字符串库函数的函数。 在常数复杂度的情况下获取字符串长度(以下代码)。 杜绝缓冲区溢出，通过获取空余空间函数，来进行处理(sdscat函数)。 减少字符串内存的重分配。不足则分配更大的空间，足够也不减少空间，而是记录新的len、free值。 二进制兼容。C字符串以空字符结尾，而某些二进制数据中间可能存在空字符。SDS兼容该种数据。 ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"SDS API ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"获取长度 // 获取字符串长度 static inline size_t sdslen(const sds s) { struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); return sh-\u003elen; } // 获取空余空间 static inline size_t sdsavail(const sds s) { struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); return sh-\u003efree; } ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:3:1","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"SDS创建 有两个函数，一个定长创建，一个是不定长创建。 sds sdsnewlen(const void *init, size_t initlen) { struct sdshdr *sh; if (init) { //为空则使用malloc sh = zmalloc(sizeof(struct sdshdr)+initlen+1); } else { //不为空使用calloc分配 sh = zcalloc(sizeof(struct sdshdr)+initlen+1); } if (sh == NULL) return NULL;// 分配失败处理 //设定sds的参数 sh-\u003elen = initlen; sh-\u003efree = 0; //值的复制 if (initlen \u0026\u0026 init) memcpy(sh-\u003ebuf, init, initlen); sh-\u003ebuf[initlen] = '\\0';// 尾部结束符 return (char*)sh-\u003ebuf; } // 复制一个char* sds sdsnew(const char *init) { size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen); } // 生成一个空sd sds sdsempty(void) { return sdsnewlen(\"\",0); } // 复制一个sds sds sdsdup(const sds s) { return sdsnewlen(s, sdslen(s)); } ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:3:2","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"sds释放函数 先获取sdshdr的首地址，使用zfree释放。 void sdsfree(sds s) { if (s == NULL) return; // 获取真实首地址释放 zfree(s-sizeof(struct sdshdr)); } ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:3:3","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"sds动态空间调整 // 空间增长 sds sdsMakeRoomFor(sds s, size_t addlen) { struct sdshdr *sh, *newsh; size_t free = sdsavail(s); size_t len, newlen; if (free \u003e= addlen) return s;// 空间足够直接返回 len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); newlen = (len+addlen);// 新的长度 if (newlen \u003c SDS_MAX_PREALLOC)// 不足1MB直接翻倍分配 newlen *= 2; else// 超过1MB，多分配1MB空余空间 newlen += SDS_MAX_PREALLOC; newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);// 分配空间 if (newsh == NULL) return NULL; // 分配失败 // 设置参数 newsh-\u003efree = newlen - len; return newsh-\u003ebuf; } // 空间的重分配 sds sdsRemoveFreeSpace(sds s) { struct sdshdr *sh; sh = (void*) (s-(sizeof(struct sdshdr))); sh = zrealloc(sh, sizeof(struct sdshdr)+sh-\u003elen+1); sh-\u003efree = 0; return sh-\u003ebuf; } ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:3:4","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"sds连接操作 sds sdscatlen(sds s, const void *t, size_t len) { struct sdshdr *sh; size_t curlen = sdslen(s); // 获取字符串长度 s = sdsMakeRoomFor(s,len);// 扩展字符串 if (s == NULL) return NULL; sh = (void*) (s-(sizeof(struct sdshdr))); memcpy(s+curlen, t, len);// 连接字符串到末尾 sh-\u003elen = curlen+len;// 设置长度 sh-\u003efree = sh-\u003efree-len; s[curlen+len] = '\\0';// 设置尾部 return s; } sds sdscat(sds s, const char *t) { return sdscatlen(s, t, strlen(t)); } ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:3:5","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"sds复制 sds sdscpylen(sds s, const char *t, size_t len) { struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); size_t totlen = sh-\u003efree+sh-\u003elen; // 空间不足，分配空间 if (totlen \u003c len) { s = sdsMakeRoomFor(s,len-sh-\u003elen); if (s == NULL) return NULL; sh = (void*) (s-(sizeof(struct sdshdr))); totlen = sh-\u003efree+sh-\u003elen; } // 复制 memcpy(s, t, len); s[len] = '\\0'; sh-\u003elen = len; sh-\u003efree = totlen-len; return s; } sds sdscpy(sds s, const char *t) { return sdscpylen(s, t, strlen(t)); } ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:3:6","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["源码阅读"],"content":"一些其他接口 sds sdscatfmt(sds s, char const *fmt, ...);// 格式化输出 sds sdstrim(sds s, const char *cset); // 去除cset中所含字符 void sdsrange(sds s, int start, int end);// 获取指定区间字符串 void sdsupdatelen(sds s); // 更新字符串长度 void sdsclear(sds s); // 清空字符串 int sdscmp(const sds s1, const sds s2); // 字符串比较 // 依据sep将s分割，返回 一个二维数组 sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count); // 释放由sdssplitlen函数解析的二维数组 void sdsfreesplitres(sds *tokens, int count); void sdstolower(sds s); // 转小写 void sdstoupper(sds s); // 转大写 sds sdsfromlonglong(long long value);// ll转sds sds sdsjoin(char **argv, int argc, char *sep); // 以分隔符连接字符串子数组构成新的字符串 ","date":"2017-03-26","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/:3:7","tags":["redis","源码阅读"],"title":"redis源码阅读-动态字符串sds","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"},{"categories":["读书笔记"],"content":"2.2 德雷福斯模型的5个阶段 2017-01-24 但是，如果给新手提供与情境无关的规则去参照，他们就会变得能干起来。也就是说，需要这种形式的规则：“当X发生时，执行Y。”换言之，需要一份指令清单。 图2-2　玉米饼食谱，不过你知道需要烹饪多长时间吗 这就是呼叫中心的工作原理。你可以雇用一大批对当前技术没有很多经验的人，然后让他们按照一个决策树按部就班地执行下去。 3.3 L型和R型的特征 2017-02-06 事实上，综合是一项非常强大的学习技术，以至于麻省理工学院媒体实验室的尼葛洛庞蒂在Don’t Dissect the Frog, Build It [Neg94]中建议，真正想要了解一只青蛙，传统的解剖不是办法，更好的方式是构造一只青蛙。 也就是说，要求学生构造一个具有青蛙特征的生物。这是一种伟大的方式，可以真正了解到，什么使青蛙成之为青蛙，以及青蛙如何适应其特定环境。这是一个综合学习的绝佳例子。 4.4 收获R型线索 2017-02-08 这种方法为什么会起作用？我认为这是因为晨写让毫无防备的大脑倾倒想法。早上刚起床时，你还没有像你想的那样清醒。潜意识仍然占主角。你还没有提起所有防备，也还未适应有限的现实世界。你可以直接连通R型，至少一小会儿。 2017-02-08 你需要培养一种非目标驱动的思维方式。正如庞加莱所做，把一切都写在纸上（或者编辑器中，如果你必须得这么做的话），然后不去管它。不要试图思考。记住它，如布朗所说，不要关注它。只要简单地记住它。让事实和问题自由地搅和、浸泡（我们将在8.2节讨论这一话题） 4.5 收获模式 2017-02-08 “在开始练习武术之后，我感觉到我的注意力持续时间和控制能力（比如在糟糕的环境下集中注意力）都有了提高。我一直在向软件开发人员和其他知识工作者推荐我的实践经验。它就是气功，它既有武术的一面，也包含太极、冥想和呼吸的方面。 注 跑步应该也行的。 6.2 瞄准SMART目标 2017-03-05 使用SMART方法实现你的目标。 在这里，SMART代表具体的、可度量的、可实现的、相关的和时间可控的（Specific, Measurable, Achievable, Relevant, and Time-boxed）。对于任何目标（减肥、炒老板鱿鱼、征服世界等），你都需要制定一个计划，定出一系列帮助你实现目标的任务（objective）。每一个任务都应该具有SMART特性。 6.3 建立一个务实的投资计划 2017-03-05 就像任何投资一样——无论是金融还是艺术上的——都必须时刻进行管理。 很多年来，戴维·托马斯（Dave Thomas）和我一直把实用投资计划作为咨询实践的一部分，在这里我简单地介绍一下这些内容。实用投资计划基于一种非常简单但是有效的理念：像管理你的金融投资一样小心管理你的知识投资。 6.4 使用你的原生学习模式 2017-03-05 很多教育家把学习者分为三大类：视觉型、听觉型和动觉型。 视觉型学习者需要看到学习资料和老师。图片和图表对视觉型学习者都很有效，他们对肢体语言和面部表情也很敏感。 听觉型学习者必须听到学习材料。讲座、研讨会和播客都很有效。他们对语气、语速和其他细节都很敏感。 动觉型学习者通过活动和触摸来学习。他们需要亲身感受学习材料。特别是对运动、艺术和 工艺等领域，你都需要通过动手来学习。 6.9 利用文档的真正力量 2017-03-05 创建低层次的设计文档，简单地反映代码的细节（几乎很快就会过时）对任何人都没有意义。但是其他形式的文档可能是有价值的，即使没有明确的读者。 6.10 以教代学 2017-03-05 为了省掉你的同事过来，我们建议你在桌子上摆一只黄色橡皮鸭作替身，当你遇到问题时，先和它 聊聊。 另一种有用的办法是尝试向一个孩子或者你所在领域之外的人解释你的东西。诀窍就是用他们能理解的话语进行解释。这是一个向你的Edna大婶解释你的工作的好机会，也是一个练习从听众角度观察问题并创建隐喻的好机会，这些隐喻有助于解释、阐明你的工作。你可能会在这个过程中惊奇地发现一些新的收获和领悟。 第7章 积累经验 2017-03-05 我们应该小心翼翼地从实践中获得智慧并适可而止，否则我们就会像不慎坐在热炉子上的猫一样，它再也不会坐在热炉子上——这还好，但是它也再也不会坐在冷炉子上。 ——马克·吐温 7.3 正确对待实践中的失败 2017-03-05 你可以在公司范围之外尝试，比如在家里做开源项目。这起码会减少产生负面结果的风险。但是仅仅这样不足以为你建立一个积极的学习环境。不论是在公司团队还是在黑夜里偷偷进行的独自实验，你都需要做到以下几点。 7.4 了解内在诀窍 2017-03-05 在采取纠正行动之前完全知道“这是什么”对于调试非常重要。太多程序员（包括我自己）往往在没有完全明白真正的错误是什么之前就着急修正它。匆忙地作出判断或者过早地进行修补。你需要首先完全明白系统的原理，然后再判断哪部分错了，最后提供解决方案。也就说，不要动手做，而是要袖手旁观。琼·金姆介绍下述方法来帮助大家充分了解。 8.2 通过分散注意力来集中注意力 2017-03-05 怎么区分你是在浸泡思想还是在拖延、浪费时间呢？ 我总是把拖延称为“做纸娃娃”。一个密友（姓名保密）第二天有一门重要的考试，但是前一天晚上，她并不学习，而是坐在沙发上剪纸娃娃。当时这在我看来就是典型的耗费时间：一个无关的非生产性的活动阻碍了你需要做的真正工作。 但也许我错了。也许这不是拖延。这是一个高级触觉练习，也许是她浸泡思想的方法。她通过了测验并以优异成绩毕业。 如果某个任务你真的不想做，那么任何分散注意力的努力都很可能只是耗费时间。如果你仍然有兴趣，但感觉“困难”，那么思想其实是在继 续发酵，这当然没问题。 8.6 保持足够大的情境 2017-03-05 事实上，保持情境中任务相关的东西很有益处。不论你如何衡量生产力，仅仅多使用一台显示器就可以让你的生产力提升20%~30%。 这是为什么？ 适合你的不是桌面隐喻，而是Frederick Brooks在几年前描述的拥挤的飞机座位隐喻。在一个大桌面上，你可以展开你的工作，看到你在做什么——同时看到所有的。在拥挤的飞机座位上，你没有足够的空间同时看两份以上的文档（或者文档的一部分）。你必须来回地切换文档。 我敢打赌，让你去Staples或者Office Depot等办公用品店寻找一张17英寸的办公桌，你找不到，因为这个尺寸实在是太小了。然而，大多数显示器都是17到21英寸。这点空间就是我们办公的地方。你不得不在活动窗口和应用程序之间切换，因为你无法在如此小的空间里保持足够的情境。 你知道Alt-Tab组合键（Mac上的Command-Tab）称为什么吗?情境切换。正如我们看到的，情景切换扼杀生产力。即使是类似使用Alt-Tab切换不同窗口的小动作也会花费时间、短期记忆力和精力。 2017-03-05 在最先进的操作系统上你可以使用虚拟桌面切换器，允许你拥有很多不同的屏幕，你可以使用特殊键随意切换。每一个屏幕都是独立的，称为工作空间。秘诀在于你如何在工作空间中分配应用。 9.2 明天上午做什么 2017-03-05 现在就开始吧！你选择开始做什么并不特别重要，重要的是主动尝试本书中提到的知识，这是你明天一大早要做的第一件事。 下面是对第一步的一些建议。 开始承担责任，不要害怕问“为什么”，也不要害怕问“你怎么知道的”或者“我怎么知道的”，同样要大方地回答“我目前还不知道”。 挑两件帮助你维持情境、免受干扰的事情，立即实施。 创建一个实用投资计划，设定SMART目标。 弄清楚你在所属专业领域中所处的位置（从新手到专家）和你期望的位置。保证诚实。你需要更多的诀窍还是更多的情境？更多规则还是更多直觉？ 实践。某段代码遇到问题了吗？尝试用五种不同的方式编写。 允许犯更多错误——错误是许可的，要从中学习教训。 携带一个笔记本（最好不带横线）。涂鸦，做思维导图，记笔记。让你的思想自由地流动。 打开心扉接收美感和其他的感官输入。不论是 你的房间、桌面还是代码，关注它们是多么地赏心悦目。 开始在私人wiki上记录你感兴趣的事情。 开始写博客。为你读过的书写评论。阅读更多书，你会有更多可写的东西。使用SQ3R和思维导图。 让散步成为你每天生活的一部分。 启动一个读书小组。 再拿一个显示器，开始使用虚拟桌面。 回顾每章的“实践单元”，尝试去做。 9.3 超越专家 2017-03-05 达芬奇在600年前抱怨说：“人们看却没有看见，听却没有听见，吃却没有味觉，接触却没有触觉，说话却没有思考。” ","date":"2017-03-26","objectID":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/:0:0","tags":["杂谈"],"title":"读书摘录-程序员的思维方式","uri":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"},{"categories":["源码阅读"],"content":"redis的内存分配主要就是对malloc和free进行了一层简单的封装。具体的实现在zmalloc.h和zmalloc.c中。 ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"内存分配器的选择 redis支持多种内存分配器，可以选择的分配器tcmalloc、jemalloc、dlmalloc、malloc/malloc.h(apple)，这几个分配器自带内存大小的记录。如果不进行设置，则默认使用malloc进行分配。 // zmalloc.h // 选择使用的内存分配器，分别为tcmalloc、jemalloc、dlmalloc、malloc/malloc.h // 同时设置HAVE_MALLOC_SIZE为真，内存分配器自带大小统计。 // 如果不选择内存分配器，则使用默认的malloc，同时同时设置HAVE_MALLOC_SIZE为假。 // 指定zmalloc_size #if defined(USE_TCMALLOC) #define ZMALLOC_LIB (\"tcmalloc-\" __xstr(TC_VERSION_MAJOR) \".\" __xstr(TC_VERSION_MINOR)) #include \u003cgoogle/tcmalloc.h\u003e#if (TC_VERSION_MAJOR == 1 \u0026\u0026 TC_VERSION_MINOR \u003e= 6) || (TC_VERSION_MAJOR \u003e 1) #define HAVE_MALLOC_SIZE 1 #define zmalloc_size(p) tc_malloc_size(p) #else #error \"Newer version of tcmalloc required\" #endif #elif defined(USE_JEMALLOC) #define ZMALLOC_LIB (\"jemalloc-\" __xstr(JEMALLOC_VERSION_MAJOR) \".\" __xstr(JEMALLOC_VERSION_MINOR) \".\" __xstr(JEMALLOC_VERSION_BUGFIX)) #include \u003cjemalloc/jemalloc.h\u003e#if (JEMALLOC_VERSION_MAJOR == 2 \u0026\u0026 JEMALLOC_VERSION_MINOR \u003e= 1) || (JEMALLOC_VERSION_MAJOR \u003e 2) #define HAVE_MALLOC_SIZE 1 #define zmalloc_size(p) je_malloc_usable_size(p) #else #error \"Newer version of jemalloc required\" #endif #elif defined(__APPLE__) #include \u003cmalloc/malloc.h\u003e#define HAVE_MALLOC_SIZE 1 #define zmalloc_size(p) malloc_size(p) #elif defined(USE_DLMALLOC) #include \"Win32_Interop/win32_dlmalloc.h\"#define ZMALLOC_LIB (\"dlmalloc-\" __xstr(2) \".\" __xstr(8) ) #define HAVE_MALLOC_SIZE 1 #define zmalloc_size(p) g_msize(p) #endif #ifndef ZMALLOC_LIB #define ZMALLOC_LIB \"libc\" #endif // zmalloc.c // 依据选择的内存分配器，设定好宏定义，否则使用系统默认分配。 #if defined(USE_TCMALLOC) #define malloc(size) tc_malloc(size) #define calloc(count,size) tc_calloc(count,size) #define realloc(ptr,size) tc_realloc(ptr,size) #define free(ptr) tc_free(ptr) #elif defined(USE_JEMALLOC) #define malloc(size) je_malloc(size) #define calloc(count,size) je_calloc(count,size) #define realloc(ptr,size) je_realloc(ptr,size) #define free(ptr) je_free(ptr) #elif defined(USE_DLMALLOC) #define malloc(size) g_malloc(size) #define calloc(count,size) g_calloc(count,size) #define realloc(ptr,size) g_realloc(ptr,size) #define free(ptr) g_free(ptr) #endif ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"功能函数一栏 void *zmalloc(size_t size);// 调用malloc，分配size大小的空间 void *zcalloc(size_t size);// 调用calloc，分配size大小的空间 void *zrealloc(void *ptr, size_t size);// 调用realloc，重新分配size大小的空间 void zfree(void *ptr);// 释放ptr char *zstrdup(const char *s);// c风格字符串copy size_t zmalloc_used_memory(void); // 获取当前占用的内存大小 void zmalloc_enable_thread_safeness(void); // 设置线程安全 void zmalloc_set_oom_handler(void (*oom_handler)(size_t)); // 设置内存分配失败的处理方法 float zmalloc_get_fragmentation_ratio(size_t rss);// 获取所给内存和已经使用的内存大小之比 size_t zmalloc_get_rss(void); // 获取RSS信息（Resident Set Size） size_t zmalloc_get_private_dirty(void);// 获取实际内存大小 size_t zmalloc_get_smap_bytes_by_field(char *field);// 获取/proc/self/smaps字段的字节数 void zlibc_free(void *ptr); // 获取物理内存大小 WIN32_ONLY(void zmalloc_free_used_memory_mutex(void);) //原始系统free的释放方法 ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"统计使用的内存总数 redis每次分配内存、释放内存都会进行记录。用来统计redis使用的总内存。 size_t zmalloc_used_memory(void) {// 获取使用的内存，直接获取used_memory的变量的值。 size_t um; if (zmalloc_thread_safe) {// 线程安全 #if defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC) um = update_zmalloc_stat_add(0); #else pthread_mutex_lock(\u0026used_memory_mutex); um = used_memory; pthread_mutex_unlock(\u0026used_memory_mutex); #endif } else {// 非线程安全 um = used_memory; } return um; } static size_t used_memory = 0;// 定义了一个全局变量，用来记录使用的内存数量。 static int zmalloc_thread_safe = 0;// 默认不线程安全，调用zmalloc_enable_thread_safeness进行设置为线程安全。 #ifdef _WIN32// 根据系统选择多线程锁。 pthread_mutex_t used_memory_mutex; #else pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER; #endif // __ATOMIC_RELAXED提供原子加减操作 #if defined(__ATOMIC_RELAXED) #define update_zmalloc_stat_add(__n) __atomic_add_fetch(\u0026used_memory, (__n), __ATOMIC_RELAXED) #define update_zmalloc_stat_sub(__n) __atomic_sub_fetch(\u0026used_memory, (__n), __ATOMIC_RELAXED) #elif defined(HAVE_ATOMIC)// GCC提供的原子加减操作 #define update_zmalloc_stat_add(__n) __sync_add_and_fetch(\u0026used_memory, (__n)) #define update_zmalloc_stat_sub(__n) __sync_sub_and_fetch(\u0026used_memory, (__n)) #else// 使用多线程锁来实现多线程加减操作 #define update_zmalloc_stat_add(__n) do { \\ pthread_mutex_lock(\u0026used_memory_mutex); \\ used_memory += (__n); \\ pthread_mutex_unlock(\u0026used_memory_mutex); \\ } while(0) #define update_zmalloc_stat_sub(__n) do { \\ pthread_mutex_lock(\u0026used_memory_mutex); \\ used_memory -= (__n); \\ pthread_mutex_unlock(\u0026used_memory_mutex); \\ } while(0) #endif // 增加redis内存计数 #define update_zmalloc_stat_alloc(__n) do { \\ size_t _n = (__n); \\ if (_n\u0026(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n\u0026(sizeof(PORT_LONG)-1)); \\ // 将n调整为sizeof(PORT_LONG)的整数倍 if (zmalloc_thread_safe) { \\ // 开启线程安全 update_zmalloc_stat_add(_n); \\ } else { \\ used_memory += _n; \\ // 不开启线程安全 } \\ } while(0) // 减少redis内存计数 #define update_zmalloc_stat_free(__n) do { \\ size_t _n = (__n); \\ if (_n\u0026(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n\u0026(sizeof(PORT_LONG)-1)); \\ // 将n调整为sizeof(PORT_LONG)的整数倍 if (zmalloc_thread_safe) { \\ update_zmalloc_stat_sub(_n); \\// 开启线程安全 } else { \\ used_memory -= _n; \\// 不开启线程安全 } \\ } while(0) ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:3:0","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"内存管理函数 ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:4:0","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"异常处理函数 异常处理函数, 在内存分配失败时进行调用。 默认使用zmalloc_default_oom，也可以通过zmalloc_set_oom_handler进行设置异常处理方式。 static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom; void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) { zmalloc_oom_handler = oom_handler; } static void zmalloc_default_oom(size_t size) { fprintf(stderr, \"zmalloc: Out of memory trying to allocate %Iu bytes\\n\", WIN_PORT_FIX /* %zu -\u003e %Iu */ size);// 打印日志 fflush(stderr); abort();// 中断退出 } ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:4:1","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"zmalloc zmalloc用来分配指定大小的内存。实际上对malloc进行了一层封装，加入了异常处理和内存统计。 void *zmalloc(size_t size) { // 调用malloc进行内存分配 // 多出的PREFIX_SIZE大内存用来记录该段内存大小。 void *ptr = malloc(size+PREFIX_SIZE); // 分配失败的异常处理 if (!ptr) zmalloc_oom_handler(size); // 统计内存使用 #ifdef HAVE_MALLOC_SIZE // 内存分配器自带内存大小 update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr; #else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE; #endif } ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:4:2","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"zcalloc calloc是分配内存，并初始化为0。封装的和zmalloc类似。 void *zcalloc(size_t size) { // 分配内存 void *ptr = calloc(1, size+PREFIX_SIZE); // 分配失败的异常处理 if (!ptr) zmalloc_oom_handler(size); // 统计内存使用 #ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr; #else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE; #endif } ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:4:3","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"zrealloc zrealloc用来重新调整分配的内存大小。 void *zrealloc(void *ptr, size_t size) { #ifndef HAVE_MALLOC_SIZE void *realptr; #endif size_t oldsize; void *newptr; // ptr为空，直接使用zmalloc进行分配size大小内存。 if (ptr == NULL) return zmalloc(size); #ifdef HAVE_MALLOC_SIZE oldsize = zmalloc_size(ptr); // 获取ptr指向的内存大小 newptr = realloc(ptr,size); // 重新分配内存 if (!newptr) zmalloc_oom_handler(size); // 异常处理 update_zmalloc_stat_free(oldsize);// 先减 update_zmalloc_stat_alloc(zmalloc_size(newptr));// 后加 return newptr; #else realptr = (char*)ptr-PREFIX_SIZE; oldsize = *((size_t*)realptr);// 获取ptr指向的内存大小 newptr = realloc(realptr,size+PREFIX_SIZE);// 重新分配内存 if (!newptr) zmalloc_oom_handler(size);// 异常处理 *((size_t*)newptr) = size; update_zmalloc_stat_free(oldsize);// 先减 update_zmalloc_stat_alloc(size);// 后加 return (char*)newptr+PREFIX_SIZE; #endif } ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:4:4","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"zfree 释放函数 void zfree(void *ptr) { #ifndef HAVE_MALLOC_SIZE void *realptr; size_t oldsize; #endif if (ptr == NULL) return;// 空直接返回 #ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_free(zmalloc_size(ptr));// 减少统计数量 free(ptr);// 释放 #else realptr = (char*)ptr-PREFIX_SIZE; // 获取真实的指针 oldsize = *((size_t*)realptr);// 获取大小 update_zmalloc_stat_free(oldsize+PREFIX_SIZE);// 减少统计数量 free(realptr);// 释放 #endif } ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:4:5","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"zmalloc_size 获取指针指向内存大小，在内存分配器不自带该函数时定义。 // zmalloc.h #ifndef HAVE_MALLOC_SIZE size_t zmalloc_size(void *ptr); #endif // zmalloc.c #ifndef HAVE_MALLOC_SIZE size_t zmalloc_size(void *ptr) { void *realptr = (char*)ptr-PREFIX_SIZE; size_t size = *((size_t*)realptr); /* Assume at least that all the allocations are padded at sizeof(PORT_LONG) by * the underlying allocator. */ if (size\u0026(sizeof(PORT_LONG)-1)) size += sizeof(PORT_LONG)-(size\u0026(sizeof(PORT_LONG)-1)); return size+PREFIX_SIZE; } #endif ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/:4:6","tags":["redis","源码阅读"],"title":"redis源码阅读-内存分配","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":["源码阅读"],"content":"自本博客之后的文章大概都是依照《Redis设计与实现》对Redis的源码进行阅读的记录。目的是为了对于Redis有一个了解，同时对之后需要使用Redis的项目上能够有所帮助。 ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B/:0:0","tags":["redis","源码阅读"],"title":"redis源码阅读-开始","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B/"},{"categories":["源码阅读"],"content":"Redis的介绍 redis是一个使用C编写的key-value数据库。性能极高且支持丰富的数据类型。它所有的操作都是原子性的。代码精简，只有3w行不到，利于阅读。 ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B/:1:0","tags":["redis","源码阅读"],"title":"redis源码阅读-开始","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B/"},{"categories":["源码阅读"],"content":"阅读顺序 如何阅读Redis源码？阅读的顺序主要还是按照黄建宏老师所建议的顺序进行阅读,暂时不看多机部分的实现。 阅读数据结构的实现。 阅读内存编码数据结构的实现。 阅读数据类型的实现。 阅读数据库实现相关代码。 阅读客户端和服务端相关代码。 至此将Redis阅读完毕。 ","date":"2017-03-21","objectID":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B/:2:0","tags":["redis","源码阅读"],"title":"redis源码阅读-开始","uri":"/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B/"},{"categories":["游戏"],"content":"悲伤。 逆序的故事，抽丝剥茧式的把一个人的人生整个展现在你的面前。 明明在一起的两个人，却由于种种心相隔很远。 丽芙的一生都在通过各种暗示，希望主人公能够找回过去。 主人公终于在临终前的愿望中，抓到那么一个记忆碎片，无来由的想要去月球。 当，记忆被重新排列，故事里的两人有了圆满的结局。 回过头来看，这不过是程序的重新编排。而现实中的两人，却一生都没能找到最初相遇的那个瞬间。 ","date":"2017-03-12","objectID":"/%E5%8E%BB%E6%9C%88%E7%90%83/:0:0","tags":["游戏"],"title":"《去月球》","uri":"/%E5%8E%BB%E6%9C%88%E7%90%83/"},{"categories":["技巧"],"content":"建立一个长期分支，就是master，master分支上的版本都是能够编译运行的版本。 整个工作流程如下。 第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。 第二步：新分支开发完成后，或者需要讨论的时候，先从master合并到分支，解决冲突，然后向master发起一个pull request（简称PR）。 第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。 第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。） 建立测试项目 新建一个项目用于测试工作流。 演示项目地址：http://10.10.10.98/MekaYangyi/workflow 设置分支保护 新建项目默认master用户才能够push和merge。 其余用户只能新建分支，在分支测试完毕后，再发起Merge Requests。发起后，由master进行审核后合并。 设置开发成员 项目创建者在项目页面选择Member。 设置开发人员分为两种，一种是直接设置用户，一种是设置一Group都为指定权限。 权限分为四类： Guest Reporter Developer Master 一般开发人员指定为Developer。 具体权限在http://10.10.10.98/help/user/permissions.md查看。 设置用户权限 设置整个Group的权限 建立本地分支 在项目文件夹右键，选择TortoiseGit→Create Branch。 填写信息 切换分支 在项目文件夹右键，选择TortoiseGit→Switch/Checkout。 选择OK。 Commit 分出分支后，可以在本地进行Commit，知道一个功能开发完毕后，再上传到服务器。 修改本地的文件，Commit。 填写上传备注，Commit。 将Master向Test_WorkFlow合并 先从服务器pull最新版本，然后将master向Test_WorkFlow合并，防止master在分支分出之后被修改导致的冲突。 从服务器pull最新版本。 将master向Test_WorkFlow合并。 合并解决冲突。 push 上传成功后选择push。 确认。 成功。 发起Merge Request 在项目页面找到分支，选择Merge Request 填写相关信息，Submit merge request 检视代码并讨论 选择Merge Request。 单击测试分支合并功能这一个Merge Request 弹出页面。 检视代码 ","date":"2017-01-29","objectID":"/gitlab-workflow/:0:0","tags":["gitlab"],"title":"gitlab workflow","uri":"/gitlab-workflow/"},{"categories":["技巧"],"content":"Commit，查看修改记录。 图中红色区域单击可以Diff与查看源文件。 单击任意版本提交记录，增加检视意见，在diff时，任意处可以添加讨论。或者在页面底部对整个修改进行评价。 ","date":"2017-01-29","objectID":"/gitlab-workflow/:1:0","tags":["gitlab"],"title":"gitlab workflow","uri":"/gitlab-workflow/"},{"categories":["技巧"],"content":"Changes，查看版本区别。 ## Discusion，填写建议 填写建议后，选择Comment可以互相讨论。 或者选择Close merge request关闭请求。 ## Accept merge request或者Close merge request ## 合并完成 选择Accept Merge Request,同时选择合并时将分支删除。 合并结果。 # 本地pull 在本地项目进行pull,同步服务器版本。 本地同步结果。 # 删除本地分支 由于远程分支与本地分支没有关系，那么当远程正式Merge之后，需要删除本地分支，防止以后分支一直增加，不减少。 在项目文件夹右键，选择TortoiseGit→Switch/Checkout，先把分支切换到本地master。 切换完成后，再次进入该界面选择.... 删除分支 Issue Issue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。 ","date":"2017-01-29","objectID":"/gitlab-workflow/:2:0","tags":["gitlab"],"title":"gitlab workflow","uri":"/gitlab-workflow/"},{"categories":["技巧"],"content":"新建Issue 选择New Issue 填写相关信息。 功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如\"1-测试Issue\"。 新建完成,每一个Issue都有一个编号，本Issue的编号为#1。 在分支开发完成后，在commit message里面，可以写上\"fixes #14\"或者\"closes #67\"。 Github规定，只要commit message里面有下面这些动词 + 编号，就会关闭对应的issue。 close closes closed fix fixes fixed resolve resolves resolved 这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是username/repository#issue_number。 Pull Request被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。 ","date":"2017-01-29","objectID":"/gitlab-workflow/:3:0","tags":["gitlab"],"title":"gitlab workflow","uri":"/gitlab-workflow/"},{"categories":["技巧"],"content":"查看结果 ","date":"2017-01-29","objectID":"/gitlab-workflow/:4:0","tags":["gitlab"],"title":"gitlab workflow","uri":"/gitlab-workflow/"},{"categories":["技巧"],"content":"安装git 版本差别不大，目前使用的版本git2.11.0.3。 一路下一步,不修改安装位置，直接使用默认设置。 安装TortoiseGit 一路下一步，不修改安装位置，直接使用默认设置。 登录账户 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:0:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"管理员创建账户 Admin→New User。新建账户、并设置密码。同时设置该用户所属Group。 name：上传显示的名字，可以经常更改，使用中文名好。 username：登陆的用户名，不可修改，用于账户登陆。 email：账户email，内网联系email。 password：密码，牢记，root用户可修改。 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:1:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"登录 登陆内网gitlab，目前网址：10.10.10.98。 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:2:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"修改密码 登录后会要求修改密码，自己输入即可。 设置TortoiseGit 将注册的用户填入TortoiseGit中,设置为全局账号。 添加ssh 如果不添加shh，每次修改都会要求输入账号密码，比较麻烦。添加后与设备绑定，修改不再需要填写账号密码。如果不再使用一个设备，请删除ssh。 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:3:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"生成ssh 任意空白处，选择git bash。 窗口中输入，一路按回车。 ssh-keygen -t rsa -C \"你注册的email地址\" 生成后的公钥会存放在 C:/Users/You_User_Name/.ssh/id_rsa.pub。 用记事本打开，复制。 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:4:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"将ssh加入gitlab 浏览器转到http://10.10.10.98/profile/keys。 将复制的Key粘贴，Add key。 新建一个项目 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:5:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"新建一个私有项目 新建一个私有项目进行实验，gitlab是否能够正常上传。 选择new project。 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:6:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"填写基本信息 Project name：项目名称。 Project description：项目描述。 Visibility Level：项目级别，内网使用只选择public与private。private除了项目成员不可见，public在内网均可见。 选择Create project创建项目。 Clone项目 项目创建完成，复制项目地址。 复制浏览器的项目地址：http://10.10.10.98/test/test_project。 选择计算机一个文件夹，右键，选择git clone。 clone之前复制地址项目，确认，输入用户名与密码，clone成功，会新建一个文件夹。 第一次push 在该文件夹中建立一个README.md文件。 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:7:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"add 右键add，确认，ok。 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:8:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"commit commit将修改更新到本地。 在项目文件夹空白处右键，选择git commit。 填写上传理由，commit。 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:9:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["技巧"],"content":"push 选择push，push能够将修改push到服务器。 确认。 成功界面。 查看结果 成功在网页端看到修改记录(之前误上传为.md.txt文件，修改为.md文件网页端会显示文字)。 ","date":"2017-01-28","objectID":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/:10:0","tags":["gitlab"],"title":"第一次使用gitlab","uri":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/"},{"categories":["读书笔记"],"content":"大致上是将STL源码剖析看过了一篇。 前三章看到比较认真，后面几章就看到比较粗略了。 我想STL的精髓正是在内存配置、迭代器、容器中。 至于后面的一些关联式容器，用的红黑树稍复杂，不过在之前的数据结构的基础上和前几章对stl的一些常用方法是熟悉下，其实也就简单了。算法，利用迭代器，同时特化不同的版本。仿函数则是模仿函数效果的对象。整体上都算简单了。 我的计划是在未来的一小段日子里实现一个小型的stl，所谓实现，可能也不过是重新将sgi的代码打一遍罢了。不过对于整个stl的理解，我相信会更好一些。 之后我应该会更新一些写小型stl遇到的问题和解决方案。 项目的地址： https://github.com/MekaYangyi/STL/ ","date":"2016-11-21","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 总结","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["读书笔记"],"content":"容器分类 vector vector还是比较简单，也就是一个动态数组，提供了些操作，带三个指针，start/finish/end 核心就是动态调整内存的方法，也就是满了开大一倍空间，拷贝过去。 push_back等操作都是值语义的，拷贝传进来的内容放入到vector中。 因为是连续的空间，所有元素连续存储在一整块内存上，迭代器直接用的原始指针。 list list复杂些. 模型和常见的list是一致的，动态创建节点，插入。 struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_prev; }; template \u003cclass _Tp\u003e struct _List_node : public _List_node_base { _Tp _M_data; }; //迭代器base struct _List_iterator_base { typedef size_t size_type; typedef ptrdiff_t difference_type; typedef bidirectional_iterator_tag iterator_category; _List_node_base* _M_node;//节点指针 _List_iterator_base(_List_node_base* __x) : _M_node(__x) {} _List_iterator_base() {} void _M_incr() { _M_node = _M_node-\u003e_M_next; } void _M_decr() { _M_node = _M_node-\u003e_M_prev; } bool operator==(const _List_iterator_base\u0026 __x) const { return _M_node == __x._M_node; } bool operator!=(const _List_iterator_base\u0026 __x) const { return _M_node != __x._M_node; } }; //迭代器,重载了++ -- == * -\u003e等操作 template\u003cclass _Tp, class _Ref, class _Ptr\u003e struct _List_iterator : public _List_iterator_base { typedef _List_iterator\u003c_Tp,_Tp\u0026,_Tp*\u003e iterator; typedef _List_iterator\u003c_Tp,const _Tp\u0026,const _Tp*\u003e const_iterator; typedef _List_iterator\u003c_Tp,_Ref,_Ptr\u003e _Self; typedef _Tp value_type; typedef _Ptr pointer; typedef _Ref reference; typedef _List_node\u003c_Tp\u003e _Node; _List_iterator(_Node* __x) : _List_iterator_base(__x) {} _List_iterator() {} _List_iterator(const iterator\u0026 __x) : _List_iterator_base(__x._M_node) {} reference operator*() const { return ((_Node*) _M_node)-\u003e_M_data; } #ifndef __SGI_STL_NO_ARROW_OPERATOR pointer operator-\u003e() const { return \u0026(operator*()); } #endif /* __SGI_STL_NO_ARROW_OPERATOR */ _Self\u0026 operator++() { this-\u003e_M_incr(); return *this; } _Self operator++(int) { _Self __tmp = *this; this-\u003e_M_incr(); return __tmp; } _Self\u0026 operator--() { this-\u003e_M_decr(); return *this; } _Self operator--(int) { _Self __tmp = *this; this-\u003e_M_decr(); return __tmp; } }; deque 双向开头的连续空间 比较特别的地方是用一个双指针维护了一个多个连续的空间 迭代器保持连续的方式 ```cpp inline size_t __deque_buf_size(size_t __size) { return __size template \u003cclass _Tp, class _Ref, class _Ptr\u003e struct _Deque_iterator { typedef _Deque_iterator\u003c_Tp, _Tp\u0026, _Tp*\u003e iterator; typedef _Deque_iterator\u003c_Tp, const _Tp\u0026, const _Tp*\u003e const_iterator; static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); } ….. _Tp* _M_cur; _Tp* _M_first; _Tp* _M_last; _Map_pointer _M_node; _Deque_iterator(_Tp* __x, _Map_pointer __y) : _M_cur(__x), _M_first(*__y), _M_last(*__y + _S_buffer_size()), _M_node(__y) {} _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {} _Deque_iterator(const iterator\u0026 __x) : _M_cur(__x._M_cur), _M_first(__x._M_first), _M_last(__x._M_last), _M_node(__x._M_node) {} reference operator*() const { return *_M_cur; } #ifndef __SGI_STL_NO_ARROW_OPERATOR pointer operator-\u003e() const { return _M_cur; } #endif /* __SGI_STL_NO_ARROW_OPERATOR */ difference_type operator-(const _Self\u0026 __x) const { return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - 1) + (_M_cur - _M_first) + (__x._M_last - __x._M_cur); } //++ _Self\u0026 operator++() { ++_M_cur; if (_M_cur == _M_last) { //到尾部了就进入下一个区域 _M_set_node(_M_node + 1);//_M_node + 1就是下一个区域 _M_cur = _M_first; } return *this; } …… //重置first等指针 void _M_set_node(_Map_pointer __new_node) { _M_node = __new_node; _M_first = *__new_node; _M_last = _M_first + difference_type(_S_buffer_size()); } }; 如果map不足，分配空间 ```cpp template \u003cclass _Tp, class _Alloc\u003e class _Deque_base { .... protected: _Tp** _M_map; size_t _M_map_size; //记录的map的大小 iterator _M_start; iterator _M_finish; .... }; 空间不足分配空间 void push_back(const value_type\u0026 __t) { if (_M_finish._M_cur != _M_finish._M_last - 1) { construct(_M_finish._M_cur, __t); ++_M_finish._M_cur; } else _M_push_back_aux(__t); } ... template \u003cclass _Tp, class _Alloc\u003e void deque\u003c_Tp,_Alloc\u003e::_M_push_back_aux(const value_type\u0026 __t) { value_type __t_copy = __t; _M_reserve_map_at_back(); *(_M_finish._M_node + 1) = _M_allocate_node(); __STL_TRY { construct(_M_finish._M_cur, __t_copy);","date":"2016-11-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/:0:0","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第四章 序列式容器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"},{"categories":["读书笔记"],"content":"push_heap push操作,后调整树，查看父节点是不是符合要求 __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value) { _Distance __parent = (__holeIndex - 1) / 2;//父节点 while (__holeIndex \u003e __topIndex \u0026\u0026 *(__first + __parent) \u003c __value) { //调整节点 *(__first + __holeIndex) = *(__first + __parent); __holeIndex = __parent; __parent = (__holeIndex - 1) / 2;//再判断父节点 } *(__first + __holeIndex) = __value;//把新值移动到新位置 } template \u003cclass _RandomAccessIterator, class _Distance, class _Tp\u003e inline void __push_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance*, _Tp*) { __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), _Tp(*(__last - 1))); } //push_heap算法，这个时候值已经插入heap的最尾端，调用此函数调整heap template \u003cclass _RandomAccessIterator\u003e inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) { __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator); __STL_REQUIRES(typename iterator_traits\u003c_RandomAccessIterator\u003e::value_type, _LessThanComparable); __push_heap_aux(__first, __last, __DISTANCE_TYPE(__first), __VALUE_TYPE(__first)); } ","date":"2016-11-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/:1:0","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第四章 序列式容器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"},{"categories":["读书笔记"],"content":"pop_heap 调整相关节点，使得上部全部填满，最底层空出区域。 template \u003cclass _RandomAccessIterator, class _Distance, class _Tp\u003e void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value) { _Distance __topIndex = __holeIndex; _Distance __secondChild = 2 * __holeIndex + 2; while (__secondChild \u003c __len) { if (*(__first + __secondChild) \u003c *(__first + (__secondChild - 1))) __secondChild--; *(__first + __holeIndex) = *(__first + __secondChild); __holeIndex = __secondChild; __secondChild = 2 * (__secondChild + 1); } if (__secondChild == __len) { *(__first + __holeIndex) = *(__first + (__secondChild - 1)); __holeIndex = __secondChild - 1; } __push_heap(__first, __holeIndex, __topIndex, __value); } template \u003cclass _RandomAccessIterator, class _Tp, class _Distance\u003e inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Tp __value, _Distance*) { //把first放到last-1 *__result = *__first; //重新整理first到last-1之间重新成为heap __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value); } template \u003cclass _RandomAccessIterator, class _Tp\u003e inline void __pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*) { //pop出的是最大值，也就是删除掉first，把first放到last-1，然后重新整理first到last-1之间重新成为heap //这样之后只要去取last-1的值，就是弹出的值了。 __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __DISTANCE_TYPE(__first)); } //pop template \u003cclass _RandomAccessIterator\u003e inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) { __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator); __STL_REQUIRES(typename iterator_traits\u003c_RandomAccessIterator\u003e::value_type, _LessThanComparable); __pop_heap_aux(__first, __last, __VALUE_TYPE(__first)); } ","date":"2016-11-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/:2:0","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第四章 序列式容器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"},{"categories":["读书笔记"],"content":"make_heap 不断调用__adjust_heap调整heap的话，最终会是一个heap template \u003cclass _RandomAccessIterator, class _Tp, class _Distance\u003e void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*, _Distance*) { if (__last - __first \u003c 2) return; _Distance __len = __last - __first; _Distance __parent = (__len - 2)/2; while (true) { __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent))); if (__parent == 0) return; __parent--; } } template \u003cclass _RandomAccessIterator\u003e inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) { __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator); __STL_REQUIRES(typename iterator_traits\u003c_RandomAccessIterator\u003e::value_type, _LessThanComparable); __make_heap(__first, __last, __VALUE_TYPE(__first), __DISTANCE_TYPE(__first)); } ","date":"2016-11-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/:3:0","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第四章 序列式容器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"},{"categories":["读书笔记"],"content":"sort_heap 对一个heap一直pop，最大值移到末尾，那么就是增序序列 了。 template \u003cclass _RandomAccessIterator\u003e void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) { __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator); __STL_REQUIRES(typename iterator_traits\u003c_RandomAccessIterator\u003e::value_type, _LessThanComparable); while (__last - __first \u003e 1) pop_heap(__first, __last--); } priority_queue 优先弹出权值高的项目，用上面的max_heap就能够实现。 操作不多。 template \u003cclass _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector\u003c_Tp\u003e), class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less\u003ctypename _Sequence::value_type\u003e) \u003e class priority_queue { ...... protected: _Sequence c; _Compare comp; public: priority_queue() : c() {} explicit priority_queue(const _Compare\u0026 __x) : c(), comp(__x) {} priority_queue(const _Compare\u0026 __x, const _Sequence\u0026 __s) : c(__s), comp(__x) { make_heap(c.begin(), c.end(), comp); } ..... bool empty() const { return c.empty(); } size_type size() const { return c.size(); } const_reference top() const { return c.front(); } void push(const value_type\u0026 __x) { __STL_TRY { c.push_back(__x); push_heap(c.begin(), c.end(), comp); } __STL_UNWIND(c.clear()); } void pop() { __STL_TRY { pop_heap(c.begin(), c.end(), comp); c.pop_back(); } __STL_UNWIND(c.clear()); } }; ","date":"2016-11-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/:4:0","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第四章 序列式容器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"},{"categories":["读书笔记"],"content":"迭代器是一种抽象的设计概念。iterator模式：提供一种方法，使能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表述方式。 迭代器的设计思维-stl关键所在 STL的中心思想在于：将数据容器和算法分开，彼此独立设计。容器和算法的泛型化。 迭代器就是扮演着粘胶角色。 迭代器是一种smart pointer list迭代器stl的实现 //listnode的基础类 struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_prev; }; //listnode template \u003cclass _Tp\u003e struct _List_node : public _List_node_base { _Tp _M_data; }; //迭代器基础类 struct _List_iterator_base { typedef size_t size_type; typedef ptrdiff_t difference_type; typedef bidirectional_iterator_tag iterator_category; _List_node_base* _M_node;//包含一个node _List_iterator_base(_List_node_base* __x) : _M_node(__x) {} _List_iterator_base() {} void _M_incr() { _M_node = _M_node-\u003e_M_next; } void _M_decr() { _M_node = _M_node-\u003e_M_prev; } bool operator==(const _List_iterator_base\u0026 __x) const { return _M_node == __x._M_node; } bool operator!=(const _List_iterator_base\u0026 __x) const { return _M_node != __x._M_node; } }; //迭代器 template\u003cclass _Tp, class _Ref, class _Ptr\u003e struct _List_iterator : public _List_iterator_base { typedef _List_iterator\u003c_Tp,_Tp\u0026,_Tp*\u003e iterator; typedef _List_iterator\u003c_Tp,const _Tp\u0026,const _Tp*\u003e const_iterator; typedef _List_iterator\u003c_Tp,_Ref,_Ptr\u003e _Self; typedef _Tp value_type; typedef _Ptr pointer; typedef _Ref reference; typedef _List_node\u003c_Tp\u003e _Node; _List_iterator(_Node* __x) : _List_iterator_base(__x) {} _List_iterator() {} _List_iterator(const iterator\u0026 __x) : _List_iterator_base(__x._M_node) {} reference operator*() const { return ((_Node*) _M_node)-\u003e_M_data; } #ifndef __SGI_STL_NO_ARROW_OPERATOR pointer operator-\u003e() const { return \u0026(operator*()); } #endif /* __SGI_STL_NO_ARROW_OPERATOR */ //重载了几个操作实现了迭代器，不是很复杂 //++i _Self\u0026 operator++() { this-\u003e_M_incr(); return *this; } //i++ _Self operator++(int) { _Self __tmp = *this; this-\u003e_M_incr(); return __tmp; } _Self\u0026 operator--() { this-\u003e_M_decr(); return *this; } _Self operator--(int) { _Self __tmp = *this; this-\u003e_M_decr(); return __tmp; } }; Traits编程技法 之前就见到用过，通过类型获取，其余的类型。 template \u003cclass _Category, class _Tp, class _Distance = ptrdiff_t, class _Pointer = _Tp*, class _Reference = _Tp\u0026\u003e struct iterator { typedef _Category iterator_category; typedef _Tp value_type; typedef _Distance difference_type; typedef _Pointer pointer; typedef _Reference reference; }; template \u003cclass _Iterator\u003e struct iterator_traits { typedef typename _Iterator::iterator_category iterator_category; typedef typename _Iterator::value_type value_type; typedef typename _Iterator::difference_type difference_type; typedef typename _Iterator::pointer pointer; typedef typename _Iterator::reference reference; }; //对原生指针特化 template \u003cclass _Tp\u003e struct iterator_traits\u003c_Tp*\u003e { typedef random_access_iterator_tag iterator_category; typedef _Tp value_type; //ptrdiff_t是C/C++标准库中定义的一个与机器相关的数据类型。ptrdiff_t类型变量通常用来保存两个指针减法操作的结果。ptrdiff_t定义在stddef.h（cstddef）这个文件内。ptrdiff_t通常被定义为long int类型。 typedef ptrdiff_t difference_type; typedef _Tp* pointer; typedef _Tp\u0026 reference; }; template \u003cclass _Tp\u003e struct iterator_traits\u003cconst _Tp*\u003e { typedef random_access_iterator_tag iterator_category; typedef _Tp value_type; typedef ptrdiff_t difference_type; typedef const _Tp* pointer; typedef const _Tp\u0026 reference; }; 迭代器的分类： input iter：只读iter output iter:只写iter forward iter:允许写入型算法在这种迭代器所形成的区间操作，前向迭代器 bidirectional iterator：双向移动iter。 random access iter：前三种支持++,第四种支持++ –。这种支持所有指针的算术能力。 typedef typename _Iterator::iterator_category iterator_category;的作用就是能够在编译器发现迭代器的类型，选用最合适的函数版本。 ```cpp struct input_iterator_tag {}; struct output_iterator_tag {}; struct forward_iterator_tag : public input_iterator_tag {}; struct bidirectional_iterator_tag : public forward_iterator_tag {}; struct random_access_iterator_tag : public bidirectional_iterator_tag {}; ``` 例子 ```cpp template inline void __advance(_InputIter\u0026 __i, _Distance __n, input_iterator_tag) { while (__n--) ++__i; } template \u003cclass _BidirectionalIterator, class _Distance\u003e inline void __advance(_BidirectionalIterator\u0026 __i, _Distance __n, bidirectional_iterator_tag) { __STL_REQUIRES(_Bidirectio","date":"2016-11-17","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8/:0:0","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第三章 迭代器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["读书笔记"],"content":"概论 第一章基本都是C++基础的知识，读了《C++ Primer》的话都懂。关于各种C++的特性、STL特性都有。 ","date":"2016-11-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/:0:0","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第一章、第二章 概论、内存配置器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/"},{"categories":["读书笔记"],"content":"STL六大组件 功能与运用 STL提供六大组件，彼此可以组合套用 容器：各种数据结构。Vector,list,deque,set,map 算法：各种常用算法如sort,search,copy,erase 迭代器：扮演容器与算法之间的粘合剂，所谓的泛型指针。五种类型 仿函数：行为类似函数，可以作为算法的某种策略。仿函数是重载了()的class或者class template，一般函数指针可视为狭义的仿函数 配接器：一种用来修饰容器或者仿函数或迭代器接口的东西。 配置器：负责控件的配置与管理。 # 空间配置器 SGI STL时间了一个专属的，拥有次层配置能力的、效率优越的特殊配置器。 SGI STL的缺省分配器都是其自己的分配器。 ## SGI特殊的空间配置器 std::alloc 使用::construct() ::destroy()构造和析构 使用alloc::allocate() alloc::deallocate()分配 释放 ```cpp //直接利用这个类能够用指定类型指针，转换为其他引用等 template struct iterator_traits{ typedef random_access_iterator_tag iterator_category; typedef _Tp value_type; typedef ptrdiff_t difference_type; typedef const _Tp* pointer; typedef const _Tp\u0026 reference; }; ``` ```cpp //如果有non-trivial 析构函数 template void __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type) { for ( ; __first != __last; ++__first) destroy(\u0026*__first); } //如果没有non-trivial 析构函数 template inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) {} template \u003cclass _ForwardIterator, class _Tp\u003e inline void __destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*) { typedef typename __type_traits\u003c_Tp\u003e::has_trivial_destructor _Trivial_destructor; __destroy_aux(__first, __last, _Trivial_destructor());//_Trivial_destructor()将会是_true_type 或者_false_type //利用模板和特化 } template inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) { __destroy(__first, __last, __VALUE_TYPE(__first));//__VALUE_TYPE(__first)获取到了类型的指针，然后调用上面函数 //利用模板和特化 } ## 空间的配置与释放 std::alloc sgi设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略。 当分配大于128bytes时候调用第一级，小于128时候，为了降低额外负担，使用负责的memory pool整理方式。 ### 第一级配置器 __malloc_alloc_template剖析 以malloc free realloc实现。 然后自己实现了一个new handler机制。 ```cpp template \u003cint __inst\u003e void* __malloc_alloc_template\u003c__inst\u003e::_S_oom_malloc(size_t __n) { void (* __my_malloc_handler)(); void* __result; for (;;) { __my_malloc_handler = __malloc_alloc_oom_handler; if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; } (*__my_malloc_handler)(); __result = malloc(__n); if (__result) return(__result); } } ","date":"2016-11-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/:1:0","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第一章、第二章 概论、内存配置器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/"},{"categories":["读书笔记"],"content":"第二级配置器 SIG第二级配置器的做法，如果区块够大，超过128bytes时候，就移交第一级配置器处理。当区块小鱼128bytes时候，则以内存池管理。每次配置一大块内存，并维护对应之自由链表，下次若再有相同大小的内存需求从free-lists中拨出。如果客端释放小额区块，就由配置器回收到fres-lists中。 分配区块时候，自动上调到8的倍数，并维护16个fres-lists,分别管理大小为8/16/24/32/40/48/56/64/72/80/88/96/104/112/120/128的小额区块。 其实这里和公司用的NG_malloc是一样的策略。ng_malloc之前对于大小的区分是256k的样子，更大。后来又改写了，支持更大的内存块了。 节点如下 __PRIVATE: union _Obj { union _Obj* _M_free_list_link; char _M_client_data[1]; /* The client sees this. */ }; 使用union的话，可以不用每次都去转换。char _M_client_data的存在是，方便去取首地址。实际上下面用到的就是_M_free_list_link，用来作为链表。这样的话，就可以用一个4字节的空间(32位机器指针大小)，实现两个功能。而不是使用struct，因为那样就会浪费空间。 空间配置函数allocate() 功能：判断大小，大于128用第一级分配，小于128就查找free list。如果free list中有可用的区块，就直接拿来用，如果没有就将区块大小上调至8的倍数边界，然后调用refill()，准备为free list重新填充空间。 static void* allocate(size_t __n) { void* __ret = 0; //超过设定的最大值就调用第一级配置器，STL设置为128 if (__n \u003e (size_t) _MAX_BYTES) { __ret = malloc_alloc::allocate(__n); } else { //寻找合适的free lists中适当的一个 _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); // Acquire the lock here with a constructor call. // This ensures that it is released in exit or during stack // unwinding. # ifndef _NOTHREADS /*REFERENCED*/ //多线程锁 _Lock __lock_instance; # endif _Obj* __RESTRICT __result = *__my_free_list; if (__result == 0) //没找到的话，就重新填充free list __ret = _S_refill(_S_round_up(__n)); else { //指向后一个成员 *__my_free_list = __result -\u003e _M_free_list_link; __ret = __result; } } return __ret; }; 空间释放函数 deallocate() 先判断大小，大于128调用第一级，小于128找出对应的free list，将区块回收。 /* __p may not be 0 */ static void deallocate(void* __p, size_t __n) { if (__n \u003e (size_t) _MAX_BYTES) malloc_alloc::deallocate(__p, __n); else { _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __q = (_Obj*)__p; // acquire lock # ifndef _NOTHREADS /*REFERENCED*/ _Lock __lock_instance; # endif /* _NOTHREADS */ __q -\u003e _M_free_list_link = *__my_free_list; *__my_free_list = __q; // lock is released here } } 重新填充free lists template \u003cbool __threads, int __inst\u003e void* __default_alloc_template\u003c__threads, __inst\u003e::_S_refill(size_t __n) { int __nobjs = 20; //尝试分配空间 __nobjs是引用传递，作为返回值 char* __chunk = _S_chunk_alloc(__n, __nobjs); _Obj* __STL_VOLATILE* __my_free_list; _Obj* __result; _Obj* __current_obj; _Obj* __next_obj; int __i; //对只分配出一个的时候的优化 if (1 == __nobjs) return(__chunk); __my_free_list = _S_free_list + _S_freelist_index(__n); //形成链表 /* Build free list in chunk */ __result = (_Obj*)__chunk; *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); for (__i = 1; ; __i++) { __current_obj = __next_obj; __next_obj = (_Obj*)((char*)__next_obj + __n); if (__nobjs - 1 == __i) { __current_obj -\u003e _M_free_list_link = 0; break; } else { __current_obj -\u003e _M_free_list_link = __next_obj; } } return(__result); } 内存池 从内存池中取空间给free list 使用，是chunk_alloc的工作 template \u003cbool __threads, int __inst\u003e char* __default_alloc_template\u003c__threads, __inst\u003e::_S_chunk_alloc(size_t __size, int\u0026 __nobjs) { char* __result;//返回值 size_t __total_bytes = __size * __nobjs;//需要分配的空间大小 size_t __bytes_left = _S_end_free - _S_start_free;//内存池剩余空间 if (__bytes_left \u003e= __total_bytes) { __result = _S_start_free;//返回 _S_start_free += __total_bytes;//内存池可用空间起始处后移 return(__result); } else if (__bytes_left \u003e= __size) {//能够分配一部分空间 __nobjs = (int)(__bytes_left/__size);//判断能够分配的块数 __total_bytes = __size * __nobjs; __result = _S_start_free; _S_start_free += __total_bytes;//与上同 return(__result); } else {//不能够分配一块的大小 size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size \u003e\u003e 4); // Try to make use of the left-over piece. if (__bytes_left \u003e 0) {//把剩余空间，分配到合适的free list _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left); ((_Obj*)_S_start_free) -\u003e _M_free_list_link = *__my_free_list; *__my_free_list = (_Obj*)_S_start_free; } //从堆上重新分配出部分空间 _S_start_free = (char*)malloc(__bytes_to_get); if (0 == _S_start_free) { size_t __i; _Obj* __STL_VOLATILE* __my_free_list; _Obj* __p; // Try to make do with what we have. That can't // hurt. We do not try smaller requests, sinc","date":"2016-11-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/:1:1","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第一章、第二章 概论、内存配置器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/"},{"categories":["读书笔记"],"content":"内存基本处理工具 uninitialized_copy、uninitialized_fill、uninitialized_fill_n用来处理一些特殊的复制构造的情况。 uninitialized_fill_n实现 template \u003cclass _ForwardIter, class _Size, class _Tp\u003e inline _ForwardIter uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp\u0026 __x) { return __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first)); } template \u003cclass _ForwardIter, class _Size, class _Tp, class _Tp1\u003e inline _ForwardIter __uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp\u0026 __x, _Tp1*) { typedef typename __type_traits\u003c_Tp1\u003e::is_POD_type _Is_POD; return __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());//判断有没有复制构造函数，调用不同的函数处理 } //没有复制构造函数的版本 template \u003cclass _ForwardIter, class _Size, class _Tp\u003e inline _ForwardIter __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n, const _Tp\u0026 __x, __true_type) { return fill_n(__first, __n, __x); } //有复制构造函数的版本 template \u003cclass _ForwardIter, class _Size, class _Tp\u003e _ForwardIter __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n, const _Tp\u0026 __x, __false_type) { _ForwardIter __cur = __first; __STL_TRY { for ( ; __n \u003e 0; --__n, ++__cur) _Construct(\u0026*__cur, __x); return __cur; } __STL_UNWIND(_Destroy(__first, __cur)); } uninitialized_copy、uninitialized_fill的实现类似 ","date":"2016-11-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/:1:2","tags":["stl源码剖析"],"title":"[读书笔记] stl源码剖析 第一章、第二章 概论、内存配置器","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/"},{"categories":["读书笔记"],"content":"事情的起因 好的东西就是这样，你每次看都能够有新的收获。 这次也一样，读了一遍谷歌编程规范，又有些新的理解，也有一些需要重新让自己记住的点。 遂记录下来，成此博文。 头文件 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:0:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"#define保护 谷歌的格式是 当是： _ _ H 为保证唯一性，头文件的命名应基于其所在项目源代码树的全路径。例如，项目 foo 中的头 文件 foo/src/bar/baz.h 按如下方式保护： #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 比较起来我们的格式是使用项目前缀来防止重复，考虑到我们项目的规模一般是不会重复的，因为文件命名上就不一致。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:1:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"头文件依赖 尽量使用前置声明减少头文件的依赖。 因为引入一个新的头文件，头文件改变时，包含这个头文件的其他头文件也会被重新编译。 1.强数据成员声明为Foo* Foo\u0026 2.参数、返回值类型为Foo的函数，只是声明 3.今天数据成员的类型可以被声明为Foo，因为静态数据成员定义在类定义之外 至于使用指针成员替代成员对象，则会降低可读性，执行效率，不要这样做。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:2:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"内联函数 少于十行的函数定义为内联函数。 小巧的代码更好的利用指令缓存。 短小的内联函数直接放在.h文件中，对于比较复杂的内联应该放在-inl.h文件中 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:3:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"函数参数的顺序 输入参数在前，输出在后。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:4:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"包含文件顺序 C库 C++库 其他库 项目内的 头文件应该有带有目录信息,不要使用当前目录和父目录 举例来说， google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下 ： #include \"foo/public/fooserver.h\" // 优先位置 #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e #include \u003chash_map\u003e #include \u003cvector\u003e #include \"base/basictypes.h\" #include \"base/commandlineflags.h\" #include \"foo/public/bar.h\" 作用域 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:5:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"命名空间 在.CC文件中，允许甚至提倡使用不具名命名空间，以避免运行时候的命名冲突。 最好不要使用using，不要声明命名空间std下的恩和内容。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:6:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"嵌套类 公开嵌套类作为接口的一部分时候，虽然可以直接放在全局作用域中，但是最好还是放在命名空间里。 使用起来的话， ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:7:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"非成员函数、静态成员函数和全局函数 尽量放在命名空间里。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:8:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"局部变量 将函数变量尽可能置于最小作用域内，在声明变量时候将其初始化。靠近第一次使用，利于阅读。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:9:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"全局变量 全局变量的构造函数、西沟函数以及初始化操作的调用顺序只是被部分规定，每次生产可能会有变化。 很多可以用单例模式替代。 类 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:10:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。 构造函数的问题是，没有异常处理。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:11:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"明确的构造函数 使用explicit，防止自动转换。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:12:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"拷贝构造函数 大量类并不要拷贝构造函数，所以应该使用DISALLOW_COPY_AND_ASSIGN来防止拷贝构造函数的自动生成 // 禁止使用拷贝构造函数和赋值操作的宏 // 应在类的 private:中使用 #define DISALLOW_COPY_AND_ASSIGN(TypeName) \\ TypeName(const TypeName\u0026); \\ void operator=(const TypeName\u0026) class Foo { public: Foo(int f); ~Foo(); private: DISALLOW_COPY_AND_ASSIGN(Foo); }; ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:13:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"继承 使用组合一般都比使用继承合适，继承只使用public继承 虚析构函数只在有继承同时有虚函数的时候使用。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:14:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"接口 接口是指满足特定条件的类，这些类以Interface为后缀 定义：纯接口 只有纯虚函数和静态函数 没有非静态数据成员 没有定义任何构造函数，如果有，也不含参数，并且为protected 如果是子类，也只能继承满足上述条件并以Interface为后缀的类 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:15:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"操作符重载 除了少数特定环境外，不要重载操作符。 缺点 混淆你的直觉，让你误以为费时的操作和内建操作一样轻巧 查找重载操作符的调用处困难 有的操作符可以对指针进行操作 重载的副作用，重载操作符\u0026的类不能被前置声明 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:16:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"声明次序 在类中使用特定的声明次序：public:在 private:之前，成员函数在数据成员（变量）前。 定义次序如下：public:、protected:、private:，如果那一块没有，直接忽略即可。 每一块中，声明次序一般如下： typedefs 和 enums； 常量； 构造函数； 析构函数； 成员函数，含静态成员函数； 数据成员，含静态数据成员。 宏 DISALLOW_COPY_AND_ASSIGN 置于 private:块之后，作为类的最后部分。参考 拷 贝构造函数。 .cc 文件中函数的定义应尽可能和声明次序一致。 不要将大型函数内联到类的定义中，通常，只有那些没有特别意义的或者性能要求高的，并 且是比较短小的函数才被定义为内联函数。更多细节参考译文第一篇的 内联函数。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:17:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"编写短小函数 超过40行，考虑分割。 Google特有的风情 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:18:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"智能指针 需要使用智能指针的话scoped_ptr完全可以胜任。特殊情况下使用share_ptr。不要使用auto_ptr。 倾向于设计对象隶属明确的代码。最明确的对象隶属是根本不使用指针，直接将对象作为一个域或者局部变量使用。 其他C++特征 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:19:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"引用参数 所有按引用传递的参数必须加上const ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:20:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"缺省参数 禁止使用缺省函数参数，所有参数必须明确指定的话，避免程序员不知道存在的缺省参数。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:21:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"编程数组和alloca 禁止使用变长数组。使用安全的分配器。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:22:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"友元 将一个单元测试用类声明为待测类的友元，很方便。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:23:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"不使用C++异常 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:24:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"不使用RTTI 直接利用虚函数处理不同类型就好了。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:25:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"类型转换 使用 static_cast 比较好处理，直接查找static_cast，就能找到哪里用了转换。C语言转换语义模糊。 static_cast：和 C 风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上 转换； const_cast：移除 const 属性； reinterpret_cast：指针类型和整型或其他指针间不安全的相互转换，仅在你对所做一 切了然于心时使用； dynamic_cast：除测试外不要使用，除单元测试外，如果你需要在运行时确定类型信 息，说明设计有缺陷（参考 RTTI）。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:26:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"流 streams 只在记录日志的时候使用。 其他时候使用printf替代。 估计是stream的构造使用成本高，printf简单直接。 然后steam重载«会产生很多意想不到的错误，在深入理解C++面向对象的书里面也有提到。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:27:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"前置自增和自减 效率更高。 对于简单数值来说无所谓，但是对于迭代器这种，前置更好。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:28:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"const的使用 在能够使用const的时候使用const. ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:29:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"整型 C++中使用 stdint.h中的确定大小整型 不要使用无符号，使用断言声明变量非负数。也就是在传参的时候，在执行前断言判断。 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:30:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"预处理宏 宏尽量被内联函数、枚举和常量替代 下面给出的用法模式可以避免一些使用宏的问题，供使用宏时参考： 不要在.h 文件中定义宏； 使用前正确#define，使用后正确#undef； 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称； 不使用会导致不稳定的 C++构造（unbalanced C++ constructs，译者注） 的宏， 至少文档说明其行为。 像我们项目里的宏，完全应该被替代，起码使用一个命名空间，防止污染全局空间事情的发生。 命名约定 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:31:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"通用命名规则 不缩写 易于理解第一 注释 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:32:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"TODO注释 // TODO(kl@gmail.com): Use a \"*\" here for concatenation operator. // TODO(Zeke) change this to use relations. 格式 ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:33:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["读书笔记"],"content":"swich 如果 default 永不会执行，可以简单的使用 assert： switch (var) { case 0: { // 2 space indent ... // 4 space indent break; } case 1: { ... break; } default: { assert(false); } } ","date":"2016-11-06","objectID":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:34:0","tags":["google","编程规范"],"title":"阅读谷歌编程规范","uri":"/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["技巧"],"content":"事情的起因 这几天为了搭一个PyQt的生产环境遇到了好一些坑。 本身搭建PyQt的目的是为了进行试验，使用PyQt开发曾经开发过的项目的难度。 原项目是使用MFC开发，利用自己开发的折线绘制控件，进行高速的工控数据采集后，显示到界面上。难点主要在，高速采集之后，绘图的效率问题。 最终通过自己开发了一套平移显示绘图控件，在新增数据的时候，每一次只绘制一部分数据，然后通过平移之前的图像与之后的链接在一起，这样达到比较高的绘图效率，才解决了问题。但是MFC界面开发复杂，在MFC界面上花费过多的时间。同时本身绘图控件的开发，可能可以利用现有开源控件进行开发来避免重复造轮子。 于是利用PyQt+guiqwt绘图库来开发的方案构建起来。guiqwt本身是QT下常用的绘图控件，效率足够高，经过一些优化是能够使用的。相对Python经常使用的matplotlib来说不够漂亮，但是进行实时数据的平移绘图，效率高出很多。PyQt是模仿QT写的图形库，可以利用QTCreate进行快速的界面构建，而Python相对C++来说，需要处理的坑更少，出现各类崩溃的异常的情况会更少一些。 本文主要讲的是PyQt+guiqwt在windows上的搭建。 目的是在之后能够通过本文进行快速的开发环境的搭建。 开始搭建 ","date":"2016-10-19","objectID":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/:0:0","tags":["windows","环境搭建"],"title":"windows下Pyqt + guiqwt环境的搭建","uri":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["技巧"],"content":"安装Python Python官网 通过Python官网下载相应版本的Python,我这里下载的是：python-3.5.2-amd64。 64位版本，记住版本号，用于之后的库的选择。 ","date":"2016-10-19","objectID":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/:1:0","tags":["windows","环境搭建"],"title":"windows下Pyqt + guiqwt环境的搭建","uri":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["技巧"],"content":"安装PyQt PyQt有完整的安装包，过程中会自动安装PyQt+Qt等完整的依赖库。 PyQt下载站点 浏览所有文件找到对应的PyQt完整安装包。 我下的是下面网址中的64位版本。 PyQt5-5.6-gpl-Py3.5-Qt5.6.0-x64-2 PyQt完整安装包下载 安装一路下一步完成。 ","date":"2016-10-19","objectID":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/:2:0","tags":["windows","环境搭建"],"title":"windows下Pyqt + guiqwt环境的搭建","uri":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["技巧"],"content":"安装NumPy 为了能够使用guiqwt必须安装依赖的库。 首先安装numpy，注意的是需要安装+mk1的numpy库，否则scipy无法正常安装后使用。 下载地址 搜索Numpy找到相应的位置。 我选择下载的是，与Python版本对应：numpy-1.11.2+mkl-cp35-cp35m-win_amd64.whl 使用pip3.5安装 ","date":"2016-10-19","objectID":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/:3:0","tags":["windows","环境搭建"],"title":"windows下Pyqt + guiqwt环境的搭建","uri":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["技巧"],"content":"安装scipy 同上，在上面的网站找到scipy。 版本我选择的是：scipy-0.18.1-cp35-cp35m-win_amd64 使用pip3.5在numpy之后安装 ","date":"2016-10-19","objectID":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/:4:0","tags":["windows","环境搭建"],"title":"windows下Pyqt + guiqwt环境的搭建","uri":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["技巧"],"content":"安装guiqwt 安装guiqwt 上面网站搜索guiqwt 选择guiqwt-3.0.3-cp35-cp35m-win_amd64。 在sicpy之后使用pip3.5安装 ","date":"2016-10-19","objectID":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/:5:0","tags":["windows","环境搭建"],"title":"windows下Pyqt + guiqwt环境的搭建","uri":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["技巧"],"content":"安装eric6 下载地址 我选择的是：eric6-6.1.10和eric6-i18n-zh_CN-6.1.10 解压，放到python的安装目录下：python35/eric6 运行python35/eric6、install.py进行安装。 运行Python35\\Scripts\\eric6.bat 就打开了eric6 至此开发环境搭建完成。 ","date":"2016-10-19","objectID":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/:6:0","tags":["windows","环境搭建"],"title":"windows下Pyqt + guiqwt环境的搭建","uri":"/windows%E4%B8%8Bpyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["读书笔记"],"content":"有效的程序综合还需要一些组织原则，它们能够指导我们系统化地完成系统的整体设计。特别的需要一些能够帮助我们构造起模块化的大型系统策略，也就是说，使这些系统能够“自然地”划分为一些具有内聚力的部分，使这些部分可以分别进行开发和维护。 有一种非常强有力的设计策略，特别适合用于构造那类模拟真实物理系统的程序，那就是基于被模拟程序的结构去设计程序的结构。那么有关的物理系统里的每一个对象，我们构造起一个与之对象的计算对象；对该系统里的每种活动，我们在自己的计算系统里顶一种符号操作。采用这一策略时的希望是，在需要针对系统中的新对象或者新活动扩充对应的计算模型时候，我们能够不必对程序的组织方面做得很成功，那么在需要添加新特城或者排除旧东西里的错误时候，就只需要在系统里的一些小局部中工作。 本章研究两种特点鲜明的策略。第一种策略将注意力集中在对象上，将大型系统看成一大批对象，它们的行为可能随着时间的进展而不断的变化。另一种组织策略将注意力集中在流过的系统的信息流上，非常像电子工程师观察一个信号处理系统。 对于对象途径而言，我们必须关注计算对象可以怎样变化而又同时保持其标识。这将迫使我们抛弃老的计算的代换模型，转向更机械式的，理论上也更不同意把握的计算的环境模型。在处理对象、变化和标识时，各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗。如果允许程序并发指向的可能性，事情会变得更困难许多。流方式特别能用于松解在我们模型中对时间的模拟与计算机求值过程中的各种时间发生的顺序。我们将通过一种称为延时求值的技术做到这一点。 赋值和局部状态 一个由许多对象组成的系统里，其中的这些对象极少会是完全独立的。每个对象都可能通过交互作用，影响其他对象的状态，所谓交互就是建立起一个对象的状态变量与其他对象的状态变量之间的联系。确实如果一个系统中的状态变量可以分组，形成一些内部紧密结合的子系统，每个子系统与其他子系统之间只存在松散的练习，此时将这个系统看作是由一些独立对象组成的观点就会特别有用。 对于一个系统的这种观点，有可能成为组织这一系统的计算模型的有力框架。要使这样的一个模型成为模块化的，就要求它能够分解为一批计算对象，使它们能够模拟系统里的实际对象。每个计算对象必须有它自己的一些局部状态变量，用于描述实际对象的状态。对于被模拟系统里的对象的状态是随着时间的变化的，与它们对象的计算对象的状态也必须变化。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:0:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"局部状态变量 (set! \u003cname\u003e \u003cnew-value\u003e);设置值 (begin \u003cexp1\u003e \u003cexp2\u003e);顺序求值 (define balance 100) (define (withdraw amount) (if (\u003e= balance amount) (begin (set! balance (- balance amount)) balance) \"Insufficient funds\")) 上面使用了全局变量 下面使用局部变量 (define new-withdraw (let ((balance 100)) (lambda (amount) (if (\u003e= balance amount) (begin (set! balance (- balance amount)) balance) \"Insufficient funds\")))) 构建一个提款机 (define (make-withdraw balance) (lambda (amount) (if (\u003e= balance amount) (begin (set! balance (- balance amount)) balance) \"Insufficient funds\"))) 创建一个账户 (define (make-withdraw balance) (define (withdraw amount) (if (\u003e= balance amount) (begin (set! balance (- balance amount)) balance) \"Insufficient funds\")) (define (deposit amount) (set! balance (+ balance amount)) balance) (define (dispatch m) (cond ((eq? m 'withdraw) withdraw) ((eq? m 'deposit) deposit) (else (error \"Unknoew request --MAKE-ACCOUNT\" m)))) dispatch) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:1:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"引进赋值带来的收益 能够简化一部分需要变量状态的过程。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:2:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"引进赋值的代价 相比函数是编程，输入什么结果就是什么。显然引进赋值让程序变得更复杂。 需要存在一个位置存储变量。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:3:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"命令式程序设计的缺陷 与函数式程序设计相对，广泛采用的赋值程序设计被称为命令是程序设计。 求值顺序需要保证。 求值的环境模型 类似于C++的区域。 过程也是对象。 调用过程就会产生新的上下文环境，过程内的是过程内的环境。过程外全局环境等。 过程应用的环境模型两条规则： 将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在构造起的这一新环境的上下文中求 相对于一个给定的环境求值一个lambda表达式，将创建其一个过程对象，这个过程对象是一个序对，由该lambda表达式的征文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时候的环境。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:3:1","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"简单过程的应用 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:4:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"将框架看做局部状态的展台 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:5:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"内部定义 局部过程的名字不会与包容它们的过程之外的名字互相干扰，这是因为这些局部过程名 都是该过程运行时创建的框架里约束的，而不是在全局环境里约束的。 局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数，这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属。 用变动的数据做模拟 (define (append! x y) (set-cdr! (last-pair x) y) x) (define (last-pair x) (if (null? (cdr x)) x (last-pair (cdr x)))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:6:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"共享与相等 共享会导致多个对象都拥有同一个对象，修改一个会导致另外的也跟着被修改。 (eq? x y);检查是不是一个对象 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:6:1","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"改变也就是赋值 主要是构建了一前一后两个指针。 (define (cons x y) (define (set-x! v) (set! x v)) (define (set-y! v) (set! y v)) (define (dispatch m) (cond ((eq? m 'car) x) ((eq? m 'cdr) y) ((eq? m 'set-car!) set-x!) ((eq? m 'set-cdr!) set-y!) (else (error \"Undefined operation -- CONS\" m)))) dispatch) (define (car z) (z 'car)) (define (cdr z) (z 'cdr)) (define (set-car! z new-value) ((z 'set-car!) new-value) z) (define (set-cdr! z new-value) ((z 'set-cdr!) new-value) z) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:6:2","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"队列的表示 ;构造函数 (define (make-queue) (cons '() '())) ;选择函数 (define (front-queue queue) (if (empty-queue? queue) (error \"FRONT called with an empty queue\" queue) (car (front-ptr queue)))) ;检测队列是否为空 (define (empty-queue? queue) (null? (front-ptr queue))) ;改变函数 (define (insert-queue! queue item) (let ((new-pair (cons item '()))) (cond ((empty-queue? queue) (set-front-ptr! queue new-pair) (set-rear-ptr! queue new-pair) queue) (else (set-cdr! (rear-ptr queue) new-pair) (set-rear-ptr! queue new-pair) queue)))) (define (delete-queue! queue) (cond ((empty-queue? queue) (error \"DELETE! called with an empty queue\" queue)) (else (set-front-ptr! queue (cdr (front-ptr queue))) queue))) (define (front-ptr queue) (car queue)) (define (rear-ptr queue) (cdr queue)) (define (set-front-ptr! queue item) (set-car! queue item)) (define (set-rear-ptr! queue item) (set-car! queue item)) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:7:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"表格的表示 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table)))))) (define (make-table) (list '*table*)) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:8:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"数字电路的模拟器 并发：时间本质是个问题 和普通的并发问题是一致的。 串行化共享部分。 (define s make-serializer) (define (make-account balance) (define (withdraw amount) (if (\u003e= balance amount) (begin (set! balance (= balance amount)) balance) \"Insufficient funds\")) (define (deposit amount) (set! balance (+ balance amount)) balance) (let ((protected (make-serializer))) (define (dispatch m) (cond ((eq? m 'withdraw) (protected withdraw)) ((eq? m 'deposit) (protected deposit)) ((eq? m 'balance) balance) (else (error \"Unknown request --MAKE-ACCOUNT\" m)))) dispatch)) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:9:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"串行化的实现 互斥元同步机制。 (define (make-serializer) (let ((mutex (make-mutex))) (lambda (p) (define (serialized-p . args) (mutex 'acquire) (let ((val (apply p args))) (mutex 'release) val)) serialized-p))) (define (make-mutex) (let ((cell (list false))) (define (the-mutex m) (cond ((eq? m 'acquire) (if (test-and-set! cell) (the-mutex 'acquire))) ((eq? m 'release) (clea! cell)))) the-mutex)) (define (test-and-set! cell) (if (car cell) true (begin (set-car! cell true) false))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/:10:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第三章 模块化 对象和状态","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/"},{"categories":["读书笔记"],"content":"通用型算术运算 (define (add x y) (apply-generic 'add x y)) (define (sub x y) (apply-generic 'sub x y)) (define (mul x y) (apply-generic 'mul x y)) (define (div x y) (apply-generic 'div x y)) (define (install-scheme-number-package) (define (tag x) (attach-tag 'scheme-number x)) (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y)))) (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y)))) (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y)))) (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y)))) (put 'make '(scheme-number scheme-number) (lambda (x) (tag x))) 'done) (define (make-scheme-number n) ((get 'make 'scheme-number) n)) 利用同样的方法可以加入有理数/复数等操作 不同类型数据的组合 处理跨类型的操作。 为每一种跨类型操作提供专门的过程处理，是可以，但是太麻烦。每添加一种类型，要增加太多过程。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E6%9C%89%E9%80%9A%E7%94%A8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F/:0:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 带有通用型操作的系统","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E6%9C%89%E9%80%9A%E7%94%A8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F/"},{"categories":["读书笔记"],"content":"强制 类型转换处理能够解决一部分问题。 ;实数转虚数 (define (scheme-number-\u003ecomplex n) (make-complex-from-real-imag (contents n) 0)) 将这些强制过程安装到一个特护的表格里，用两个类型的名字作为索引。 (put-coercion 'scheme-number 'complex scheme-number-\u003ecomplex) (define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (if (= (length args) 2) (let ((type1 (car type-tags)) (type2 (cadr type-tags)) (a1 (car args)) (a2 (cadr args))) (let ((t1-\u003et2 (get-coercion type1 type2)) (t2-\u003et1 (get-coercion type2 type1))) (cond (t1-\u003et2 (apply-generic op (t1-\u003et2 a1) a2)) (t2-\u003et1 (apply-generic op a1 (t2-\u003et1 a2))) (else (error \"No method for these types\" (list op type-tags)))))) (error \"No method for these types\" (list op type-tags))))))) 类型的层次结构 就是继承嘛。子类型有父类型的所有操作。 #层次结构的不足 可能产生菱形的层次结构。 在设计大型系统时，处理好一大批相互有关的类型而同时又能保持模块性，这是一个困难的问题，也是当前正在继续研究的领域。 编者注：这句话出现在书的第一版本。它的现在就像20年前写出时候正确。开发出一种有用的，具有一般意义的框架，以描述不同类型对象之间的关系(哲学中本体论)，看来是一件极其困难的工作。在10年前存在的混乱和今天存在的混乱之间的主要差异在于，今天已经有了一批各式各样的并不合适的本体理论，它们已经嵌入数量过多而又先天不足的各种程序设计语言里。举例来说，面向对象语言的大部分复杂性-以及当前各种面向对象语言之间细微的而且诗人迷惑的差异-的核心，就是类型之间通用型操作的处理。我们在第三章有关计算性对象的讨论中完全避免了这些问题。熟悉面向对象程序涉及到读者将会注意到，在第三章里关于局部状态说了许多东西，但是却根本没有提到“类”或者“继承”。事实上，我们的猜想是，如果没有知识表示和自动推理工作的帮助，这些问题是无法仅仅通过计算机语言设计的方式合理处理的。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E6%9C%89%E9%80%9A%E7%94%A8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F/:1:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 带有通用型操作的系统","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E6%9C%89%E9%80%9A%E7%94%A8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F/"},{"categories":["读书笔记"],"content":"对于一个数据对象可以能存在多种有用的表示形式，而且我们也希望所涉及的系统能够处理多种表示形式。 例子：复数的极坐标形式和直角坐标的形式 构造通用型过程：可以在不止一种数据表示上操作的过程。采用的技术：让它们在带有类型标志的数据对象上工作。也就是说，让数据对象包含着它们应该如何处理的明确信息。 复数的表示 为一个数据提供了多种操作，存在多种形式 (define (real-part z) (car z)) (define (imag-part z) (cdr z)) (define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z))))) (define (angle z) (atan (imag-part z) (real-part z))) (define (make-from-real-imag x y) (cons x y)) (define (make-from-mag-ang r a) (cons (* r (cos a)) (* r (sin a)))) (define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2)))) (define (sub-complex z1 z2) (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2)))) (define (mul-complex z1 z2) (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2)))) (define (div-complex z1 z2) (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2)))) 带标志数据 认识数据抽象的一种方式是将其看做”最小允诺原则“的一个应用。在实现上面的复数系统的时候，采用两种形式，由选择函数和构造函数形成的抽象屏障，使我们可以把为自己所用的数据对象选择具体表现形式的事情尽量往后推，而且还能够保持系统设计的最大灵活性。 方式，利用类型标志，来确定什么类型，选择什么函数。 增加类型标示 (define (attach-tag type-tag contents) (cons type-tag contents)) (define (type-tag datum) (if (pair? datum) (car datum) (error \"Bad tagged datum -- TYPE-TAG\" datum))) (define (contents datum) (if (pair? datum) (cdr datum) (error \"Bad tagged datum -- CONTENTS\" datum))) (define (rectangular? z) (eq? (type-tag z) 'rectangular)) (define (polar? z) (eq? (type-tag z) 'polar)) 修改新的直角坐标表示 (define (real-part-rectangular z) (car z)) (define (imag-part-rectangular z) (cdr z)) (define (magnitude-rectangular z) (sqrt (+ (square (real-part-rectangular z)) (square (imag-part-rectangular z))))) (define (angle-rectangular z) (atan (imag-part-rectangular z) (real-part-rectangular z))) (define (make-from-real-imag-rectangular x y) (attach-tag 'rectangular (cons x y))) (define (make-from-mag-ang-rectangular r a) (attach-tag 'rectangular (cons (* r (cos a)) (* r (sin a))))) 修改极坐标的表现形式 (define (real-part-polat z) (* (magnitude-polat z) (cos (angle-polat z)))) (define (imag-part-polat z) (* (magnitude-polat z) (sin (angle-polat z)))) (define (magnitude-polat z) (car z)) (define (angle-polat z) (cdr z)) (define (make-from-real-imag-polatr x y) (attach-tag 'polar (cons (sqrt (+ (square x) (square y))) (atan y x)))) (define (make-from-mag-ang-polat r a) (attach-tag 'polar (cons r a))) 在通用选择函数都添加检查类型的标志，调用合适的函数。 (define (real-patr z) (cond ((rectangular? z) (real-part-rectangular (contents z))) ((polar? z) (real-part-polat (contents z))) (else (error \"Unknown type -- REAL-PART\" z)))) (define (imag-patr z) (cond ((rectangular? z) (imag-part-rectangular (contents z))) ((polar? z) (imag-part-polat (contents z))) (else (error \"Unknown type -- IMAG-PART\" z)))) (define (magnitude z) (cond ((rectangular? z) (magnitude-rectangular (contents z))) ((polar? z) (magnitude-polat (contents z))) (else (error \"Unknown type -- MAGNITUDE\" z)))) (define (angle z) (cond ((rectangular? z) (angle-rectangular (contents z))) ((polar? z) (angle-polat (contents z))) (else (error \"Unknown type -- ANGLE\" z)))) 实现算数操作的时候不需要改变。还是原来的形式就可以。 (define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2)))) 需要修改下构造函数 (define (make-from-real-imag x y) (make-from-real-imag-rectangular x y)) (define (make-from-mag-ang r a) (make-from-mag-ang-polat r a)) 数据导向的程序设计和可加性 检查一个数据项的类型，并据此去调用某个适当的过程称为基于类型的分派。 在系统设计中，这是一种获得模块性的强有力策略（可能oo是更好的方式，检测类型还是比较麻烦的）。 存在两个弱点： 其中的通用型接口过程，必须知道素有的不同表示。需要检测类型，选择适当函数 独立的表现形式分别设计，需要拥有不同的名字。 那么这就导致，这种实现不具有可加性。在每一次增加一种新形式的时候，需要去修改原过程，修改类型判断，增加代码，修改过程名字。 现在我们需要的是一种能够将系统设计进一步模块化的方法。一种称为数据导向的程序设计都编程技术提供了这种能力（其实在数据中保存能够处理数据的过程，就能够不用选择函数直接处理了嘛）。 （实际上这里讲的是一种注册机制） 假定存在put get来制造表格 (define (install-rectangular-package) ;internal procedures (define (real-part z) (car z)) (define (imag-part z) (cdr z)) (define (make-from-real-imag x y) (cons x y)) (define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z))))) (define (angle z) (at","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA/:0:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 抽象数据的多重表示","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA/"},{"categories":["读书笔记"],"content":"消息传递 数据导向的程序设计，最关键的思想是通过显式的操作-类型表格的方式，管理程序中的各种通用性操作。上面使用的程序设计风格是一种基于类型进行分派的组织方式，其中让每个操作管理自己的分派。从效果上看，这种方式就是将操作-类型表哥格分解位一行一行，每个通用型过程表示表格中的一行。 另一种实现策略是将这一表格按列进行分解，不是采用一批“只能”操作区基于数据类型进行分派，而是采用“只能数据对象”，让它们基于操作名完成所需要的分派工作。 需要做的，将每一个数据对象表示为一个过程。（实际上类似于数据封装，每个数据对象保存专有的函数，利用虚函数就行了。思想是一致的。stl） (define (make-from-real-imag x y) (define (dispatch op) (cond ((eq? op 'real-part) x) ((eq? op 'iamg-part) y) ((eq? op 'magnitude) (sqrt (+ (square x) (square y)))) ((eq? op 'angle) (atan y x)) (else (error \"Unkonown op -- MAKE-FROM-REAL-IMAG\" op)))) dispatch) ;查找函数 (define (apply-generic op arg) (arg op)) 这种风格的程序设计称为消息传递，将数据对象设想位一个实体，它以消息的方式接受所需要操作的名字。（设计模式里面有一种这种模式）。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA/:1:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 抽象数据的多重表示","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA/"},{"categories":["读书笔记"],"content":" (list 'a 'b) (eq? a b) 符号求导 ;e是变量吗 (define (variable? x) (symbol? x));symbol?判断变量是不是符号 ;v1和v2是同一个变量吗 (define (same-variable? v1 v2) (and (variable? v1) (variable? v2) (eq? v1 v2))) ;e是和式吗 (define (sum? x) (and (pair? x) (eq? (car x) '+))) ;e的被加数 (define (addend s) (cadr s)) ;e的加数 (define (augend s) (caddr s)) ;构造起a1和a2的和式 (define (make-sum a1 a2) (list '+ a1 a2)) ;e是乘式吗 (define (product? x) (and (pair? x) (eq? (car x) '*))) ;e的被乘数 (define (multiplier p) (cadr p)) ;e的乘数 (define (multiplicand p) (caddr p)) ;构造起来m1与m2的乘式 (define (make-product m1 m2) (list '* m1 m2)) ;求导 (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) ((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))) ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp)))) (else (error \"unknown expression type -- DERIV\" exp)))) (deriv '(+ x 3) 'x) (deriv '(* x y) 'x) (deriv '(* (* x y) (+ x 3)) 'x) '(+ 1 0) '(+ (* x 0) (* 1 y)) '(+ (* (* x y) (+ 1 0)) (* (+ (* x 0) (* 1 y)) (+ x 3))) 集合的表示 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/:0:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 符号数据","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/"},{"categories":["读书笔记"],"content":"集合作为未排序的表 ;判断是不是表成员 (define (element-of-set? x set) (cond ((null? set) false) ((equal? x (car set)) true) (else (element-of-set? x (cdr set))))) ;向表增加一项 (define (adjoin-set x set) (if (element-of-set? x set) set (cons x set))) ;合并 (define (intersection-set set1 set2) (cond ((or (null? set1) (null? set2)) '()) ((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))) (else (intersection-set (cdr set1) set2)))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/:1:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 符号数据","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/"},{"categories":["读书笔记"],"content":"集合作为排序的表 排序的存在的好处就是减少复杂度 (define (element-of-set? x set) (cond ((null? set) false) ((= x (car set)) true) ((\u003c x (car set)) false) (else (element-of-set? x (cdr set))))) (define (intersection-set set1 set2) (if (or (null? set1) (null? set2)) '() (let ((x1 (car set1)) (x2 (car set2))) (cond ((= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2)))) ((\u003c x1 x2) (intersection-set (cdr set1) set2)) ((\u003c x2 x1) (intersection-set set (cdr set2))))))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/:2:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 符号数据","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/"},{"categories":["读书笔记"],"content":"集合作为二叉树 有序二叉树 (define (entry tree) (car tree)) (define (left-branch tree) (cadr tree)) (define (right-branch tree) (caddr tree)) (define (make-tree entry left right) (list entry left right)) (define (element-of-set? x set) (cond ((null? set) false) ((= x (entry set)) true) ((\u003c x (entry set)) (element-of-set? x (left-branch set))) ((\u003e x (entry set)) (element-of-set? x (right-branch set))))) ;插入要找到正确位置 (define (adjoin-set x set) (cond ((null? set) (make-tree x '() '())) ((= x (entry set)) set) ((\u003c x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))) ((\u003e x (entry set)) (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))))) huffman编码树 ;树的表示 ;leaf 符号 权重 (define (make-leaf symbol weight) (list 'leaf symbol weight)) (define (leaf? object) (eq? (car object) 'leaf)) (define (symbol-leaf x) (cadr x)) (define (weight-leaf x) (caddr x)) (define (make-code-tree left right) (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right)))) (define (left-branch tree) (car tree)) (define (right-branch tree) (cadr tree)) (define (symbols tree) (if (leaf? tree) (list (symbol-leaf tree)) (caddr tree))) (define (weight tree) (if (leaf? tree) (weight-leaf tree) (caddr tree))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/:3:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 符号数据","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/"},{"categories":["读书笔记"],"content":"解码过程 (define (decode bits tree) (define (decode-1 bits current-branch) (if (null? bits) '() (let ((next-branch (choose-branch (car bits) current-branch))) (if (leaf? next-branch) (cons (symbol-leaf next-branch) (decode-1 (cdr bits) tree)) (decode-1 (cdr bits) next-branch))))) (decode-1 bits tree)) (define (choose-branch bit branch) (cond ((= bit 0) (left-branch branch)) ((= bit 1) (right-branch branch)) (else (error \"bad bit -- CHOOSE-BRANCH\" bit)))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/:4:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 符号数据","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/"},{"categories":["读书笔记"],"content":"带权重的集合 (define (adjoin-set x set) (cond ((null? set) (list x)) ((\u003c (weight x) (weight (car set))) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set)))))) (define (make-leaf-set pairs) (if (null? pairs) '() (let ((pair (car pairs))) (adjoin-set (make-leaf (car pair) (cadr pair)) (make-leaf-set (cdr pairs)))))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/:5:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 符号数据","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/"},{"categories":["读书笔记"],"content":"第一章关注的是计算过程，以及过程在程序中所扮演的角色。 本章，讲将数据对象组合起来，形成复合数据的方式。 复合数据：能够提升我们在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。 将程序中处理数据对象的表示的部分与处理数据对象的使用部分相互 隔离的技术，称为数据抽象。 复合数据中的一个关键性思想是闭包的概念，也就是说，用于组合数据对象的粘合剂不但能用于组合基本的数据对象，也能组合复合数据对象。 复合数据对象能够称为以混合与匹配的方式组合程序模块的方便接口。 数据抽象引导 数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在抽象数据上操作一样。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:0:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"有理数的算数运算 假定存在构造函数与选择函数 (make-rat n d);返回一个有理数，分子是整数n，分母是整数d (numer x);返回有理数x的分子 (denom x));返回有理数x的分母 那么可以定义以下的规则 ;加法 (define (add-rat x y) (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y)))) ;减法 (define (sub-rat x y) (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y)))) ;乘法 (define (mul-rat x y) (make-rat (* (numer x) (numer y)) (* (denom x) (denom y)))) ;除法 (define (div-rat x y) (make-rat (* (numer x) (denom y)) (* (denom x) (numer y)))) ;等于？ (define (equal-rat? x y) (= (* (numer x) (denom y)) (* (numer y) (denom x)))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:1:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"序对 lisp存在基本过程cons，car,cdr。存在下列关系 (define x (cons 1 2)) (car x) 1 (cdr x) 2 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:1:1","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"有理数的表示 利用序对完成有理数的实现 (define (make-rat n d) (cons n d)) (define (numer x) (car x)) (define (denom x) (cdr x)) 打印有理数 (define (print-rat x) (newline) (display (numer x)) (display \"/\") (display (denom x))) 化简有理数 (define (make-rat n d) (let ((g (gcd n d))) (cons (/ n g) (/ d g)))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:1:2","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"抽象屏障 每一个层次中国策构成了所定义的抽象 屏障的接口，联系起系统中的不同层次。使得系统简单，修改容易。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:2:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"数据意味着什么 一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及使这些过程成为一套合法的表示，它们必须满足一组特定的条件。 使用过程实现cons car cdr (define (cons x y) (define (dispatch m) (cond ((= m 0) x) ((= n 1) y) (else (error \"Argument not 0 or 1 -- CONS\" m)))) dispatch) (define (car z) (z 0)) (define (cdr z) (z 1)) 尽管实际语言的实现不是上面的形式，但是我们定义的函数已经能够正常完成工作了。过程和数据的界限被模糊，满足关于序对的描述。 层次性数据和闭包性质 某种组合数据对象的操作满足闭包性质，那就是说，通过它组合起数据对象得到的结果本身可以通过同样的操作再进行组合。闭包性质是任何一种组合功能的威力的关键要素，因为它使我们能够建立起层次性的结构，这种结构由一些部分构成，而其中的各个部分又是由它们的部分构成，并且可以继续下去。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:3:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"序列的表示 (list \u003ca1\u003e \u003ca2\u003e...\u003can\u003e) ;等于 (cons \u003ca1\u003e (cons \u003ca2\u003e (cons ... (cons \u003can\u003e nil)...))) nil是拉丁词汇nihil的缩写，拉丁语表示什么也没有，表示序对的链结束，代表一个不包含任何元素的序对，空表。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:4:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"表操作 ;第n个元素 (define (list-ref items n) (if (= n 0) (car items) (list-ref (cdr items) (- n 1)))) (define squares (list 1 4 9 16 25)) (list-ref squares 3) 16 ;表长 递归 (define (length items) (if (null? items) 0 (+ 1 (length (cdr items))))) ;表长 迭代 (define (length items) (define (length-iter a count) (if (null? a) count (length-iter (cdr a) (+ 1 count)))) (length-iter items 0)) (length squares) 5 (define odds (list 1 3 5 7)) ;组合两个表 (define (append list1 list2) (if (null? list1) list2 (cons (car list1) (append (cdr list1) list2)))) (append odds squares) '(1 3 5 7 1 4 9 16 25) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:4:1","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"对表的映射 ;DrRacket中未定义nil，若要使用nil (define nil '()) ;缩放 (define (scale-list items factor) (if (null? items) nil (cons (* (car items) factor) (scale-list (cdr items) factor)))) (scale-list (list 1 2 3 4 5) 10) '(10 20 30 40 50) ;更一般的过程 (define (map proc items) (if (null? items) nil (cons (proc (car items)) (map proc (cdr items))))) (define (scale-list items factor) (map (lambda (x) (* x factor)) items)) map构建一层抽象屏障，将实现表变换的过程的实现，与如何提取表中元素以及组合结果的细节隔离开。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:4:2","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"层次性结构 树的分支，而那些本身也是序列的元素就形成了树中的子树。 实现count-leaver (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:5:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"对树的映射 (define (sacle-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (sacle-tree (car tree) factor) (sacle-tree (cdr tree) factor))))) (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:6:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"序列作为一种约定的接口 强有力的设计原理-使用约定的接口。 考虑下面的过程，它以一棵树为参数，计算出那些值为奇数的叶子的平方和。 (define (sum-odd-squares tree) (cond ((null? tree) 0) ((not (pair? tree)) (if (odd? tree) (square tree) 0)) (else (+ (sum-odd-squares (car tree)) (sum-odd-squares (cdr tree)))))) 偶数的斐波那契数列的表。 (define (even-fibs n) (define (next k) (if (\u003e k n) nil (let ((f (fib k))) (if (even? f) (cons f (next (+ k l))) (next (+ k 1)))))) (next 0)) 虽然表面上结构差异大，但是计算的抽象描述存在极大的相似性。 都是从枚举器开始，产生给定的树的树叶组成的信号。信号流过过滤器，过滤掉不符合规则的信号。通过一个映射，转换每一个元素。积累器把所有的元素组合起来。 但是上面的程序是将以上的操作混合在一起。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:7:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"序列操作 修改map过程 (map square (list 1 2 3 4 5)) (1 4 9 16 25) 过滤器 (define (filter predicate sequence) (cond ((null? sequence) nil) ((predicate (car sequence)) (cond (car sequence);真就保留 (filter predicate (cdr sequence)))) (else (filter predicate (cdr sequence))))) 积累器 (define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) fib枚举器 (define (enumerate-interval low high) (if (\u003e low high) nil (cons low (enumerate-interval (+ low 1) high)))) 树叶枚举器 (define (enumerate-tree tree) (cond ((null? tree) nil) ((not (pair? tree)) (list tree)) (else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree)))))) 重构 (define (sum-odd-squares tree) (accumulate + 0 (map square (filter odd? (enumerate-tree tree))))) (define (even-fibs n) (accumulate cons nil (filter even? (map fib (enumerate-interval 0 n))))) 通过提供一个标准不见的库，并使这些不见都有着一些能以灵活方式互相连接的约定接口，将能够进一步推动模块化设计。 在工程设计中，模块化结构是控制复杂性的一种威力巨大的策略。（类似西门子的自动化软件 plc等） ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:7:1","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第二章 构造数据抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"关于读书的目的 很多时候对于一本比较复杂的书，你在到达一定阶段的时候是难以读进去的。Sicp我曾经在几个月前尝试的去读了第一章。很快就读完的，但是对于其的理解实在浅薄。 我希望在这一次的阅读的过程中能够顺利的过一次不本书有所收获。 在接下来的日子里，我会记录下读书笔记以及习题的解答。 这是一个开始。 构造过程抽象 每一种强有力的语言为此提供了三种机制 基本的表达形式， 用于表示语言所关心的最简单的个体。 组合的方法，通过它们可以从简单的东西出发构建出复合的元素。 抽象的方法，通过它们可以为 复合对象命名，并将它们作为单元去操作。 在程序设计中，我们需要处理两类元素：过程和数据。非形式的说，数据是一种我们希望去操作的”东西“，而过程是有关操作这些数据的规则的描述。 (* ( + 2 ( * 5 6 )) ( + 3 5 7)) (define (square x) (* x x)) (square 21) 441 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:0:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"过程应用的带换模型 对于符合过程，过程的应用的计算过程是： 将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程求值。 (f 5) (sum-of-squares(+ 5 1) (* 5 2)) (+ (square 6) (square 10)) (+ (* 6 6) (* 10 10)) (+ 36 100) 136 这种计算过程称为过程应用的代换模型。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:1:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"应用系和正则序 完全展开而后归约的求值模型是正则序求值。 先求值参数而后应用的方式为应用序求值。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:1:1","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"条件语法 (define (abs x) (cond ((\u003e x 0) x) (( = x 0) 0) (( \u003c x 0) (- x)))) (define (abs x) (cond (( \u003c x 0) (- x)) (else x))) (define (abs x) (if ( \u003c x 0) (- x) x)) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:1:2","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"过程与它们所产生的计算 一个过程也就是一种模式，它描述了一个计算过程的局部演化方法。 两种描述阶乘的方式。（lisp的迭代不是说形式上的迭代，实际上如果说调用本身的层面上还是递归，但是思想是迭代的思想，应用序来看的话。） (define (factorial n) (if (= n 1) 1 (* n (factorial (- n 1))))) ;迭代的形式 (define (factorial n) (fact-iter 1 1 n)) ;应用序的话会优先求值，那么就不会有上面的方式那么深的层次，尝试求值都能够求出来。 (define (fact-iter product counter max-count) (if (\u003e counter max-count) product (fact-iter (* counter product) (+ counter 1) max-count))) 迭代计算过程就是那种其状态可以用固定数据的状态变量描述的计算过程，而与此同时，又存在着一套固定的规则，描述了计算过程从一个状态到下一个状态的转换时候，这些变量的更新方式。还有一个结束检测，它描述着一计算过程应该终止的条件。 在计算n!时候，所需要的计算不走随着n线性增长，这种过程称为线性迭代过程。 在迭代的情况下，在计算过程中的任何一点，那几个程序变量都提供了有关计算状态的一个完整描述。而递归计算过程而言，这里存在着另外的一些隐含信息，它们并未保存在程序变量里面，而是由解释器维持着，指明了在所推迟的运算所形成的链条里的漫游中，这以计算过程处在合出。链条越长，需要保存的信息越多。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:2:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"换零钱的实现 采用递归过程： 将总数为a的现金换成n中硬币的不同方式的数目等于 将现金数a换成除第一种硬币之外的所有其他硬币的不同方式数目，加上 将现金数a-d换成所有种类的硬币的不同数目，其中d是第一种硬币的币值 (define (first-denomination kinds-of-coins) (cond ((= kinds-of-coins 1) 1) ((= kinds-of-coins 2) 5) ((= kinds-of-coins 3) 10) ((= kinds-of-coins 4) 25) ((= kinds-of-coins 5) 50))) (define (cc amount kinds-of-coins) (cond ((= amount 0) 1) ((or (\u003c amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins))))) (define (count-change amount) (cc amount 5)) (count-change 100) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:2:1","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"增长的阶 空间与时间的消耗。大O记号 一个例子求幂 (define (square n) (* n n)) (define (fast-expt b n) (cond ((= n 0) 1) ((even? n) (square (fast-expt b (/ n 2)))) (else (* b (fast-expt b (- n 1)))))) (fast-expt 2 2) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:2:2","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"最大公约数 (define (gcd a b) (if ( = b 0) a (gcd b (remainder a b)))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:2:3","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"素数检测 两种计算方法 (define (square n) (* n n)) (define (smallest-divisor n) (find-divisor n 2)) ;寻找最小因子 (define (find-divisor n test-divisor) (cond ((\u003e (square test-divisor) n) n);根号n为检测上限 ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1)))));查找下一个 (define (divides? a b) (= (remainder b a) 0)) ;最小因子等于本身的时候为素数 (define (prime n) (= n (smallest-divisor n))) 费马检测 (define (square n) (* n n)) (define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) (define (try-it a n) (= (expmod a n n) a)) ;使用随机数来测试 (define (fermat-test n) (try-it (+ 1 (random (- n 1))) n)) ;通过多次的费马测试来概率的推断是不是位素数 (define (fast-prime? n times) (cond ((= times 0) true) ((fermat-test n) (fast-prime? n (- times 1))) (else false))) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:2:4","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"高阶函数抽象 以过程作为参数。以过程作为返回值。这类操作过程的过程称为高阶过程。 #lang racket (define (cube n) (* n n n)) (define (sum term a next b) (if (\u003e a b) 0 (+ (term a) (sum term (next a) next b)))) (define (inc n) (+ n 1)) (define (sum-cubes a b) (sum cube a inc b)) (sum-cubes 1 10) (define (integral f a b dx) (define (add-dx x) (+ x dx)) (* (sum f (+ a (/ dx 2.0)) add-dx b))) (integral cube 0 1 0.01) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:3:0","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"用lambda构造过程 ((lambda (x) (+ 4 x))) 匿名的过程，对于一些简单的过程构造适合 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:3:1","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"用let创建局部变了 一种方法是利用辅助过程去约束局部变量 (define (f x y) (let ((a (+ 1 x)) (b (+ 2 y))) (+ a b))) (f 1 2) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:3:2","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"过程作为一般性的方法 通过区间折半寻找方程的根 (define(close-enough? x y) (\u003c (abs (- x y)) 0.001)) (define (average x y) (/ (+ x y) 2)) (define (search f neg-point pos-point) (let ((midpoint (average neg-point pos-point))) (if (close-enough? neg-point pos-point) midpoint (let ((test-value (f midpoint))) (cond ((positive? test-value) (search f neg-point midpoint)) ((negative? test-value) (search f midpoint pos-point)) (else midpoint)))))) (define (half-interval-method f a b) (let ((a-value (f a)) (b-value (f b))) (cond ((and (negative? a-value) (positive? b-value)) (search f a )) ((and (negative? b-value) (positive? a-value)) (search f b a)) (else (error \"Values are not of opposite sign\" a b))))) (half-interval-method sin 2.0 4.0) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:3:3","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"寻找函数不动点 (define tolerance 0.00001) (define (average x y) (/ (+ x y) 2)) (define (fixed-point f first-guess) (define (close-enought? v1 v2) (\u003c (abs (- v1 v2)) tolerance)) (define (try guess) (let ((next (f guess))) (if (close-enought? guess next) next (try next)))) (try first-guess)) (fixed-point cos 1.0) ;不收敛 (define (sqrt x) (fixed-point (lambda (y) (/ x y)) 1.0)) ;引入阻尼 (define (sqrt x) (fixed-point (lambda (y) (average y (/ x y))) 1.0)) ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:3:4","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"过程作为返回值 新的开方方法 (define (average-damp f) (lambda (x) (average x (f x)))) (define (sqrt x) (fixed-point (average-damp (lambda(y) (/ x y))))) 新的牛顿法 (define (deriv g) (lambda (x) (/ (- (+ x dx) (g x)) dx))) (define (newton-transform g) (lambda (x) (- x (/ (g x) ((deriv g) x))))) 抽象和第一级过程 复合过程是一种至关重要的抽象机制，因为它使得我们能将一般性的计算方法，用这一程序设计语言里的元素明确描述。现在我们又看到，高阶函数能如何去操作这一些一般性的方法，以便建立起进一步的抽象。 作为编程者，我们应该对这类可能性保持高度敏感，设法从中识别出程序里的基本抽象，基于它们去进一步构造，程序设计专家指导的如何根据工作中的情况，去选择合适的抽象层次。但是，能够基于这种抽象去思考确实是最重要的，只有这样才可能在新的上下文中去应用它们。高阶的过程的重要性，就在于使我们能够显式的用程序设计语言的要素去描述这些抽象，使我们能够像操作其他计算元素一样去操作它们。 一般而言，程序设计语言总会对计算元素的可能使用方式强加上某些显式。带有最少限制的元素被称为具有第一级状态。第一级元素的某些权利与特权包括: 可以用变量命名 可以提供给过程作为参数 可以由过程作为结果返回 可以包含在数据结构中 lisp给了过程完全的第一级的状态。 ","date":"2016-09-10","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/:3:5","tags":["sicp","计算机程序的构造与解释"],"title":"[读书笔记] sicp 第一章 构造过程抽象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"},{"categories":["读书笔记"],"content":"2016-08-31 08:09:42 为什么小孩子会这样做呢？ 　一部分原因是，青少年在心理上还没有摆脱儿童状态，许多人都会残忍地对待他人。他们折磨书呆子的原因就像拔掉一条蜘蛛腿一样，觉得很好玩。在一个人产生良知之前，折磨就是一种娱乐。 　孩子们欺负书呆子的另一个原因是为了让自己感到好受一些。当你踩水的时候，你把水踩下去，你的身体就会被托起来。同样，在任何社会等级制度中，那些对自己没自信的人就会通过虐待他们眼中的下等人来突显自己的身份。我已经意识到，正是因为这个原因，在美国社会中底层白人是对待黑人最残酷的群体。 2016-08-31 08:12:26 我认为，真实世界的关键并非在于它是由成年人组成的，而在于它的庞大规模使得你做的每件事都能产生真正意义上的效果。学校、监狱、上流社会的女士午餐会，都做不到这一点。这些场合的成员都好像关在封闭的泡沫之中，所作所为只对泡沫内部有影响，对外部没有影响。那么很自然地，这些场合就会产生野蛮的做法。因为它们不具备实际功能，所以也就无所谓采用的形式^。 2016-08-31 08:13:16 真实世界的特点是，它极其庞大。如果总体足够大，即使是人数最少的少数派，只要聚集在一起，也能产生可观的力量。在真实世界中，书呆子在某些地方聚集起来，形成自己的社区，智力因素成为那里最被看重的东西。有时，这种因素甚至会以相反的形式表现出来，特别是在大学的数理学系，书呆子甚至会夸大笨拙，以显示自己的聪明。约翰·纳什^非常钦佩诺伯特·维纳^^就学维纳的样子，经过走廊的时候都用手扶着墙走路。 2016-08-31 08:14:01 书呆子感到不适应的真正原因是其他人都是疯子。我记得读髙中的时候，有一次在体育馆观看校运动队的出征大会，啦啦队把对手的模拟像扔到看台上，观众一哄而起，把它撕成碎片。我感到自己仿佛是一个探险家，正在目睹某种奇特的部落仪式。 2016-08-31 08:15:36 为什么人们要搬到郊区去住？为了养育下一代！难怪郊区生活是如此地乏味和贫瘠。整个镇子就像一个巨大的幼儿园，所有一切都是为了教育下一代而有意识地造出来的。 　在我生长的这个地方，感觉整个世界就是这么大，你根本没有别的地方可去，没有别的事情可做。这一点都不令人意外。郊区就是故意这样设计的，与外部世界隔离，不让儿童沾染到外界有害的东西。 　至于学校，不过是这个虚假环境中关住牲口的围栏。表面上，学校的使命是教育儿童。事实上，学校的真正目的是把儿童都关在同一个地方，以便大人们白天可以腾出手来把事情做完。我对这一点没有意见，在一个高度工业化的社会，对孩子不加管束，让他们四处乱跑，无疑是一场灾难。 　让我困扰的，不是把孩子关在监狱里，而是（a）不告诉他们这一点，（b）把这监狱的大部分交给犯人来管理。孩子们被送进来，花6年时间，记住一些毫无意义的事实，还要身处在一个由四肢发达的小巨人管理的世界，那些巨人们只知道追逐一个椭圆形的、棕色的球^，好像这是全世界最天经地义的事情。这简直就像一场超现实的鸡尾酒化妆晚会，如果孩子畏缩不前、瑟瑟发抖，他们就会被视为怪人。 2016-09-01 08:17:47 但是，流行的道德观念不是这样，它们往往不是偶然产生的，而是被刻意创造出来的。如果有些观点我们不能说出口，原因很可能是某些团体不允许我们说。 　那些团体神经越紧张，它们所产生的禁止力量就越大。伽利略因为宣传日心说而遭到教廷的审判，这件事讽刺的地方在于，他只是在宣传哥白尼的观点，而后者却安然无恙。事实上，哥白尼不仅不反对教廷，还是一个虔诚的天主教教士，他把自己的著作献给教皇。不幸的是，伽利略正赶上教廷内部反对派上台，宗教改革被压制，任何非正统的思想遭受到前所未有的严厉控制和禁止。 　为了在全社会制造出一个禁忌，负责实施的团体必定既不是特别强大也不是特别弱小。如果一个团体强大到无比自信，它根本不会在乎别人的抨击。美国人或者英国人对外国媒体的诋毁就毫不在意。但是，如果一个团体太弱小，就会无力推行禁忌。有一种行为怪癖叫做“嗜粪症”（coprophila），它的患者人数以及影响势力眼下似乎就不太强大，无法把自己的观点推广给其他人。 注: 穆斯林 女权 2016-09-01 08:28:17 各种各样的标签可能是外部线索的最大来源，帮助你发现这个时代流行的是什么。如果一个命题是错的，这就是它所能得到的最坏评价，足够批判它了，根本不用再加上任何其他标签。伹是，如果一个命题不是错的，却被加上各种标签，进行压制和批判，那就有问题。因为只要不是错的观点，就不应该被压制讨论。所以每当你看到有些话被攻击为出自XX分子或XX主义，这就是一个明确的信号，表明背后有问题。不管在1630年还是在2030年，都是如此。当你听到有人在用这样的标签，就要问为什么。 2016-09-01 19:31:06 《人月神话》（The Mythical Man-Month）是布鲁克斯（Frederick Brooks）所写的一本软件项目管理名著。所谓“人月”就是一个人在一个月内所能完成的工作量。假如某个项目预估需要12个人月，那么派4个人处理这个项目，理论上需要3个月，派6个人则只需要2个月。但是，布鲁克斯认为这种换算机制在软件业行不通，是一个神话，因为软件项目是交互关系复杂的工作，需要大量的沟通成本，人力的增加会使沟通成本急剧上升，反而无法达到缩短工期的目的。在本质上，软件项目的人力与工期是无法互换的，当项目进度落后时，光靠增加人力到该项目中，并不会加快进度，反而有可能使进度更加延后。 2016-09-01 19:35:16 没有盗版是一种“优势”，但也是一个问题。一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。 2016-09-01 19:42:05 你可能会问，如果Mac电脑真那么出色，为什么后来它的市场表现不佳？还是那个老生常谈的原因：成本太高。微软公司把所有精力都集中在软件上面，所以很多厂商只要专攻硬件就可以了，把硬件成本降了下来。单单是微软的软件或者第三方厂商的硬件都不足以赢得市场优势，但是它们结合起来，就在个人电脑出现后一段关键时期中主导了市场。苹果公司同时做软件和硬件，所以成本上没有优势。（但是，苹果公司还没有失败，如果它能把iPod升级成手机，并且将网络浏览器包括在其中，那么微软公司就有大麻烦了。）（译者注：这段话写于2001年9月，苹果公司的iPhone手机已于2007年6月上市。 2016-09-02 19:23:17 高级语言比汇编语言更接近人类语言，而某些高级语言又比其他语言更进一步。举例来说，C语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言，而Lisp语言的层次则是相当高。 　如果高层级语言比汇编语言更有利于编程，你也许会认为语言的层次越高越好。一般情况下确实如此，但不是绝对的。编程语言可以变得很抽象，完全脱离硬件，但也有可能走错了方向。比如，我觉得Prolog语言就有这个问题。它的抽象能力强得不可思议，但是只能用来解决2%的问题，其余时间你苦思冥想、运用这些抽象能力写出来的程序实际上就是Pascal语言的程序。 　另一个你会用到低层次语言的原因就是效率问题。如果你非常关注运行速度，那么最好使用接近机器的语言。大多数操作系统都是用C语言写的，这并非偶然。不过，硬件的运行速度越来越快了，所以使用C这样的低层次语言开发应用程序的必要性正在不断减少，但是大家似乎还是要求操作系统越快越好。（另一种可能是，人们还是希望“缓存区溢出攻击”继续存在下去，以便让大家时时保持警惕）^。 2016-09-02 19:29:39 不仅编程语言有这种现象，这实际上是一种普遍的历史趋势。随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。30年前的人要是看到我们今天如此随意地使用长途电话，一定会感到震惊。100年前的人要是看到一个普通的包裹竟然也能享受一天内从波士顿发件、途经孟菲斯、抵达纽约的待遇，恐怕就要更震惊了。 2016-09-03 08:03:35 Lisp比图灵机表达起来更简洁。证明这一点的一种方法就是写一个Lisp通用函数，证明它比图灵机的一般性描述更短、更易僅。这个Lisp函数就是eval……它用来计算Lisp表达式的值……。编写eval函数需要发明一种表示法，能够把Lisp函数表示成Lisp数据。设计这种书写法完全是为了满足论文写作的需要。（我）根本没有想过用它来编写Lisp程序并在计算机上运行。 2016-09-03 08:07:56 Lisp语言诞生的时候就包含了9种新思想。其中一些我们今天已经习以为常，另一些则刚刚在其他高级语言中出现，至今还有2种是Lisp独有的。按照被大众接受的程度，这9种思想依次如下排列。 条件结构（即if-then-else结构）。现在大家都觉得这是理所当然的，但是Fortran I就没有这个结构，它只有基于底层机器指令的goto结构。 函数也是一种数据类型。在Lisp语言中，函数与整数或字符串一样，也属于数据类型的一种。它有自己的字面表示形式（literal representation），能够存储在变量中，也能当作参数传递。一种数据类型应该有的功能，它都有。 递归。Lisp是第一种支持递归函数的高级语言^。 ^「Lisp语言的许多特性（比如，把程序写成列表形式以及实现某种形式的递归）都在20世纪50年代的IPL-V语言中出现过。但是，IPL-V更像是汇编语言，它的程序中","date":"2016-09-03","objectID":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/:0:0","tags":["杂谈"],"title":"[读书摘录] 黑客与画家","uri":"/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/"},{"categories":["读书笔记"],"content":"执行期语意学 以下一个简单的式子 if (yy == xx.getValue) xx yy定义如下 X xx; Y yy; class Y { public: Y(); ~Y(); bool operator==(const\u0026 Y) const; }; class X { public: X(); ~X(); operator Y() const; X getValue(); }; 那么编译器在我们之后做了什么呢 if(yy == xx.getValue()) //转换为 if(yy.operator==(xx.getValue()) //接着转换 if(yy.operator==(xx.getValue().operator Y())) //接着转换 X temp1 = xx.getValue(); Y temp2 = temp1.operator Y(); int temp3 = (yy.operator==(temp2)); if(temp3) temp2.y::~Y(); temp1.x::~X(); ","date":"2016-08-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/:0:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第六章 执行期语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"对象的构造与析构 ","date":"2016-08-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第六章 执行期语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"局部对象 { Point p; // p.Point::Point(); ... //p.Point::~Point(); } 如果一个函数拥有多个离开点，那么会在每一个离开点之前对对象进行析构。 ","date":"2016-08-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:1","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第六章 执行期语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"全局对象 Matrix identity; main() { Matrix ml = identity; ... return 0; } C++ 保证一定会在main()中第一次用到identity之前把 didentity构造出来，在main()函数结束之前销毁。 C++程序中所有全局对象都被防止在程序的data segment中，如果明确指定给它一个值,object将以该值为初值。否咋object所配置到的内存内容为0。 class object在编译器可以被放置与data sement中并且为0,但是它的构造函数需要在程序激活的时候才会被实施。(也就是说全局对象的初始化的问题，对于类对象的有些门道。) ￼ （还是不是很清楚全局对象是如何初始化的） ### 局部静态对象 ```cpp const Matrix\u0026 identity() { static Matrix mat_identity; ... return mat_identity; } ``` 对于局部静态的变量，他们的构造和析构必须只施行一次。 编译器的策略是，导入一个临时性的对象以保护mat_identity的初始化操作。第一次处理identity()时候，这临时对象被评估为false，于是构造函数被调用，然后临时对象改为true。同理析构也是如此。 （但是具体现代编译器怎么操作的我还是不清楚。）。 ### 对象数组 ```cpp Point knots[10]; ``` 需要做什么。如果是一个没有构造函数的，也没有析构函数的。那么工作不会比建立一个内建类型所组成的数组更多。 如果有的话，那么整齐的操作必须施行与每一个元素上。 在cfront中，使用一个命名为vec_new()的函数，产生以class objects构造而成的数组。 ```cpp void* ver_new( void *array, //数组的起始位置 size_t elem_size, //一个对象的大小 int elem_count, //数组的元素个数 void (*constructor)( void*), void (*destructor)(void*, char) ) ``` 调用操作 Point knots[10]; ver_new(\u0026knots, sizeof(Point), 10, \u0026Point::Point, 0); 同样如果Point有一个析构函数会有一个类似ver_delete()的函数 void* ver_delete( void *array, //数组的起始位置 size_t elem_size, //一个对象的大小 int elem_count, //数组的元素个数 void (*destructor)(void*, char) ) 不同的编译器会有不同的实现。 如果数组部分被赋予了初值的，那么会产生什么转换 Point knots[10] = { Point(), Point(1.0, 1.0, 0.5), -1.0 }; 对于有了初值的元素ver_new不必要，但是未被初始化的部分会调用vec_new。 Point knots[10] = { Point(), Point(1.0, 1.0, 0.5), -1.0 }; //明确的初始化前三个 Point::Point(\u0026knots[0]); Point::Point(\u0026knots[1], 1.0, 1.0, 0.5); Point::Point(\u0026knots[2], -1.0, 0.0, 0.0); ver_new(\u0026knots + 3, sizeof(Point), 7, \u0026Point::Point, 0); ","date":"2016-08-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:2","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第六章 执行期语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"default Constructors和数组 为了支持 complex:: complex(double = 0.0, double = 0.0); complext c_array[10]; //编译器最终调用 vec_new(\u0026c_array, sizeof(complex), 10, \u0026complex::complex, 0); //cfront采用如下方法支持 //产生一个默认构造函数 调用带默认参数的构造函数 complex::complex() { complex(0.0,0.0); } //来完成调用 （有一个问题，那么这个不就是产生了两个不带参数的构造函数吗，虽然一个有参数，但是都用默认的。怎么解决的。不过大部分构造过程都是在编译期间，那么都是静态指定调用的话，还是解决掉了的。不是很清楚这个问题。） ","date":"2016-08-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:3","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第六章 执行期语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"new delete运算符 运算符new的使用，之前的几章一直都有。 会转换成两步，一步是使用适当的函数，分配内存。 后一步是给对象设置初值，类对象的话，调用的对应的构造函数等等 extern void* operator new( size_t size ) { if( size == 0 ) size = 1; // 这里保证像 new T[0] 这样得语句也是可行的 void *last_alloc; while( !(last_alloc = malloc( size )) ) { if( _new_handler ) ( *_new_handler )(); //调用handler函数 else return 0; } return last_alloc; } extern void operator delete( void *ptr ) { if(ptr) // 从这里可以看出，删除一个空指针是安全的 free( (char*)ptr ); } ","date":"2016-08-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/:2:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第六章 执行期语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"针对数组的new语意 内建的或者没有默认构造函数的，直接默认的new就能完成任务。 对于有默认构造函数的，某些版本的vec_new()就会被调用。 ","date":"2016-08-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/:2:1","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第六章 执行期语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"临时性对象 很多简短的代码实际上都会产生一些临时对象。 是不是真的产生，需要看编译器的具体实现了。 ","date":"2016-08-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/:3:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第六章 执行期语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"临时性对象的迷思","date":"2016-08-20","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/:3:1","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第六章 执行期语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"构造、解构、拷贝语意学 ","date":"2016-08-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/:0:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"纯虚函数的存在 纯虚函数能够被静态的调用，不能经过虚拟机制调用。 虚析构函数不能定义为纯虚的，一定要有定义，否则即使可以编译，但是链接的时候会有错误。因为其子类会静态调用上一层的析构函数。如果说上一层的析构函数是一个纯虚函数的话，那么链接的时候会失败。 ","date":"2016-08-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/:0:1","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"虚拟规格的存在 不应该把所有的函数都声明为虚函数，然后靠编译器去优化操作吧virtual invocation去除。 ","date":"2016-08-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/:0:2","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"虚拟规格中的const的存在 实际上你很难知道一个类的子类对于这个函数是不是应该定义为const，因为即使现在你不需要修改类的内容，但子类可能需要修改，你没法预料到。那么最好不要定义一个有const函数的基类了。 ","date":"2016-08-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/:0:3","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"“无继承”情况下的对象构造 typedef struct { float x,y,z; } Point; 编译器会分析声明，贴上Plaint OI' Data的卷标，被贴上该卷标的类，不会有构造函数或者析构函数的调用了。直接使用C的方式。 ","date":"2016-08-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"继承体系下的对象构造 T object; 定义一个object如上时候，实际会发生什么。如果T有一个construct，它会被调用。 Constructor可能带有大量 隐藏码，因为编译器会扩充每一个constructor，扩充程度视class T的继承体系而定，一般而言编译器所做的扩充操作大约如下： 记录在member initialization list中的data members初始化操作会被放进constructor函数本身，并以members的声明顺序为顺序。 如果有一个member没有出现在member initialization list中，但是它有一个default constructor, 那么该default construtor必须被调用。 在那之前，如果class object有virtual table pointer(s)，它们必须被设定初值。指向适合的virtual table(s) 在那之前，所有上一层的base class constructirs必须被调用，以base class的声明顺序为顺序 如果base class被列于初始化列表中，那么任何明确的指定参数都应该传递过去 如果base class 没有被列于初始化列表中，而它有默认构造函数，那么调用之 如果base class 是多重继承下的第二或者后继的base class那么this指针必须被调整 在那之前，所有的virtual base class constructor必须被调用，从左到右，从最深到最浅 如果class被列于初始化列表中，那么如果有任何明确指定的参数，都应该传递过去。若没有在list中，而class有默认构造函数，也应该调用 此外，class中的每一个virtual base class subobject的偏移量必须在执行期间可被存取 如果class object是最底层的class，其构造函数可能被调用。某些用以支持这个行为的机制被加入 虚函数不见得一定有运行期绑定，如果能够编译期确定的，编译期乐于去进行静态的调用。 ","date":"2016-08-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/:2:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"虚拟继承 ￼ 有如上图的继承结构。 Vertex的构造函数必须调用Point的构造函数。但是Vertex和P哦Point3d同为Vertex3d的 subobjects的时候，它们对Point的构造函数的调用操作一定不可以发生，取而代之的是，作为底层的class，Vertex3d有责任将Point初始化，而更往后的继承，则由PVertex,而不是Vertex3d来负责完成共享的Point subobject的构造. ```cpp Point3d* Point3d::Point3d(Point3d *this, bool __most__derived, float x, float y, float z) { if(__most_derived != false) this-Point::Point(x,y); this-__vptr_Point3d = __vtbl_Pint3d; this-__vptr_Point3d__Point = __vtbl_Point3d__Point; this-_z = rhs._z; return this; } ``` Vertex3d* Vertex3d::Vertex3d( Vertex3d *this, bool __most_deriver, float x, float y, float z) { if(__most_derived != false) this-\u003ePoint::Point(x,y); this-\u003ePoint3d::Point3d(false, x, y, z); this-\u003eVertex::Vertex (false, x, y); //设定vptrs //安插USER CODE return this; } ##vptr 初始化语意学 当我们定义一个PVertex object的时候，构造函数的调用顺序是 Point() Point3d() Vertex() Vertex3d() PVertex() 构造函数调用成员函数会决议为静态的，不会使用多态机制。主要是考虑到构造函数中对象可能是不完整的，编译器需要找到合适的函数对象来调用，只能调用到此时能够起作用的函数。 在派生类的构造函数中，所有的Virtual base classes以及上一层base class的constructors会被调用 上述完成之后，对象的vptr(s)被初始化，指向相关的虚表 如果有初始化列表的话，将在构造函数内扩展开来，这必须在vptr设定之后进行，以免一个virtual member function调用 最后执行程序员所提供的的代码 构造函数： PVertex::PVertex(float x, float y, float z) : _next(0), Vertex3d(x, y, z), Point(x, y) { if (spyOn) cerr \u003c\u003c \"within Point3d::Point3d()\" \u003c\u003c \" size: \" \u003c\u003c size() \u003c\u003c endl; } 会被编译器扩展为： PVertex* PVertex::PVertex( Pvertex* this, bool __most_derived, float x, float y, float z ) { //有条件地调用virtual base class的ctor if ( __most_derived != false ) this-\u003ePoint::Point( x, y ); //无条件地调用上一层的base class的ctor this-\u003eVertex3d::Vertex3d( x, y, z ); //初始化vptr this-\u003e__vptr__PVertex = __vtbl__PVertex; this-\u003e__vptr__Point__PVertex = __vtbl__Point__PVertex; //显式的用户代码 if ( spyOn ) // 虚拟机制调用size()函数 cerr \u003c\u003c \"within Point3d::Point3d()\"\u003c\u003c \" size: \" \u003c\u003c (*this-\u003e__vptr__PVertex[ 3 ].faddr)(this) \u003c\u003c endl; return *this; } ","date":"2016-08-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/:2:1","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"对象复制语意学 bitwise copy不够的情况和之前几章记录的一致。 inline Point\u0026 Point::operator= (const Point \u0026p) { _x = p._x; _y = p._y; } //派生一个类 classPoint3d : virtual public Point { public: Point3d( float x = 0.0, y = 0.0, float z = 0.0 ); ... protected: float _z; }; //编译器会合成一个 inline Point3d\u0026 Point3d::operator=( Point3d *constthis, const Point3d \u0026p ) { //调用base class的operator= this-\u003ePoint::operator=( p ); // memberwise copy the derived class members _z = p._z; return *this; } 但是考虑到上面那个虚拟继承层次的结构的话。 怎么在虚拟继承中去处理复制这个问题。 事实上，copy assignment operator在虚拟继承的情况下行为不佳，需要小心的设计和说明，许多编译器甚至不尝试取得正取的语意，造成多次调用虚拟基类的copy assignment operator的多个实体被调用。（我的话，好像多次调用并不会产生大的问题，只是重复复制罢了，实际上没产生什么错误，效率貌似有下降。） ","date":"2016-08-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/:3:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"析构语意学 如果class没有定义析构函数，那么只有在class内带的成员对象有析构函数的情况下，编译器才会自动合成析构函数，否则析构函数视为不需要的。即使它拥有一个虚函数等。 也就是构造函数和析构函数并不是一定要成对的出现，没必要定义了构造函数，就定义出析构函数。 析构函数的扩展 析构函数的本身被执行，user code 如果class拥有成员类对象，而后者拥有析构函数，声明顺序的相反顺序调用其析构函数 如果对象有vptr需要重新被设定，指向合适的base class的vtbl 如果任何一个直接的nonvirtual base classes拥有析构函数，它们会以声明次序的相反顺序被调用 如果任何virtual base classes拥有析构 函数，而当前讨论的这个class是最尾端的class,那么会以其原来的构造函数相反的顺序被调用 ","date":"2016-08-16","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/:4:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"第三章：Function语意学 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:0:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Member的各种调用方式 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Nonstatic Member Functions C++的设计准则之一就是:nonstatic member function 至少必须和一般的nonmember function有相同的效率。 nonstatic member function会转换为nonmember形式。 改写函数原型，安插一个额外的参数，也就是this指针。 将每一个对“nonstatic data member的存取操作\"改为经由this指针来存取。 将member function重写成一个外部函数，对函数名称进行“mangling\"处理，使它在程序中成为一个独一无二的词汇。 void normalize__7Point3dFv(register const Point3d *const this, Point3d \u0026__result) { register float mag = this-\u003emagnitude(); __result.Point3d::Point3d(); __result._x = this-\u003e_x/mag; } ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:1","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"名称的特殊处理 一般而言，member的名称前面会加上class名称，形成独一无二的命名。 class Bar{ public: int ival; ...}; //其中ival有可能变成这样 ival__3Bar 主要考虑是存在继承的问题。 //防止函数的重名 //加入类名 //加入参数链，使得支持重载 //cfront采用的编码方式 class Point{ public: void x__5PointFf(float newX); float x__5PointFv(); } ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:2","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Virtual Member Functions 如果normalize()是virtual member function //函数会变成 ptr-\u003e normalize() (*ptr-\u003evptr[1])(ptr); //1为vtbl slot的索引值，关联到normalize ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:3","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Static Member Function 你可能会看到形如以下的调用 ((Point3d*)0)-\u003etest(); 这种调用在test中没有对类对象的数据成员存储时候是不会出错的。 因为根据之前的转化形式看，没有是还用this指针进行操作。 这个式子的功能实际上就是实现static 成员函数的功能。在static member function成为c++的标准之前。 函数的转化 void Point3d::object_cout() { } //转化为 void object_cout__5Point3dSFv() { } ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:4","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Virtual Member Functions 对于多态的class object身上增加两个members 一个字符串或者数字，表示class的类型 一个指针，指向某表格，表格中带有程序的virtual functions的执行地址 一个class只会有一个virtual table，每个table内含其对应的class object中所有active virtual functions函数实体地址。这些active virtual functions包括： 这个class所定义的函数实体。它会改写一个可能存在的Base class virtual function函数实体 继承自base class的函数实体。这是派生类不改写的部分 一个Pure_virtual_called()函数实体，它既扮演pure virtual function的空间保卫者角色，也可以作为执行期异常处理函数（有时候会用到） ￼ ### 多重继承下的Virtual Functions 在多重继承中支持virtual functions，其复杂度围绕在第二个以及后继的base classes中，以及必须在执行期间调整的this指针这一点。 ```cpp class C : public A,B... A* pA = new C; B* pB = new C; // C* pC = new C; B* pB = pC; //转化 B* pB = pB ? pB + sizeof(A) : 0; // delete pB; delete 操作会要求调用合适的虚析构函数，那么就要求指针再一次被调整。使得指针再次指向C对象的头。 thunk是小段assembly代码，来完成这个工作。 ```cpp pbase2_dtor_thunk: this += sizeof(base1); Derived::~Derived(this); ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:2:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"多重继承下的Virtual Functions 没讲明白 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:2:1","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"函数的效能 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:3:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"指向Member Function的指针 //指向成员函数的指针声明 double (Point :: *coord) () = \u0026Point :: x; coord = \u0026Point::y; //要想要调用，需要 (origin.*coord)(); (ptr-\u003e*coord)(); //操作会自动被编译器转化 (coord) (\u0026origin); (coord)(ptr); 指向member function的指针的声明语法，以及指向member selection运算符的指针，其作用是作为this指针的空间保留者。这就是为什么static member functions的类型是函数指针，而不是指向member function指针的原因。 利用上述方式去获取一个虚函数的指针，一样能够支持多态。因为实际上获取的是一个索引值，指向虚表的内容。 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:4:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"在多重继承下，指向member funcitons的指针 为了让指向member funcitons的指针能够支持多重继承和虚拟继承，Stroustrup设计了下面一个机构体 index faddr分别带有virtual table和nonvirtual member function地址（为了方便，index不指向virtual table时候会被设为-1）。 struct __mpter { int delta; int index; union { ptrtofunc faddr; int v_offset; } } //在该模型之下，像这样的操作 (ptr-\u003e*pmf)(); //转变为 (pmf.index \u003c 0) ? (*pmf.faddr)(ptr)// nonvirtual invocation : (*ptr-\u003evptr[pmf.index](ptr));//virtual invocation ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/:4:1","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++对象模型 第四章 Function语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"第三章：Data语意学 class的大小： 内存对齐 空Class需要1byte来占位，说明是独一无二的存在 有虚函数时候会有虚表指针 static 成员不属于类对象，不占空间 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:0:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Data Member的绑定 早期的编译器可能看不到Class后面的内容，导致数据成员的用了外层的同名的。现在已经没有这种情况了。 typedef long long length; class Point3d { public: length x;//是long long typedef int length; length y;//是 int }; ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Data Member的布局 Nonstatic data members在class object中的排列顺序是和声明顺序一致的。 但是没有规定多个access sections中的数据成员的排列，可以自由排列。实际上的编译器处理来看，还是按照顺序来的。这些顺序成员依靠声明次序在一个连续的区域里。 虚表也有强制的规定放在尾部还是头部等位置。 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:2:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Data Member的存取 下面的一段代码中的x的存取成本 Point3d origin; origin.x = 0.0; 需要视x和Point3d如何声明而定。 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:3:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Static Data Member的存取 Static Data Member实际上是一种全局变量，放在类对象之外。每一个Static Data Member对象的存取操作都会转化为： Point3d::x == 250;//不论是. 或者-\u003e来存取 不论该class是单一的类还是继承有虚函数的类或者多重继承，Static Data Member的路径仍然是这么直接。 编译器会给每一个Static Data Member暗中编码指定独一无二的名字。 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:4:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"NonStatic Data Member的存取 NonStatic Data Member是存放在每一个类对象中的，除非经由明确的或者暗喻的类对象，否则么有办法直接存取它们。 void Point3d::translate() { x = 1; y = 2; z = 3; } 实际上都会转化为 void Point3d::translate(Point3d *const this) { this-\u003e x = 1; this-\u003ey = 2; this-\u003ez = 3; } 欲对一个NonStatic Data Member访问必须在类对象的起始地址加上一个数据成员的偏移值。 origin._y = 0.0; //origin._y的地址实际上等于 \u0026origin + (\u0026Point3d::_y - 1); 存取这种数据成员和一个struct的成员是一致的。除了虚拟继承，此种情况下会引入一层间接性。 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:5:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"继承与Data Member 在C++中的继承模型中，一个derived class object所表现出来的东西，是其自己的members加上其base lass members的总和。 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:6:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"只要继承不要多态 base class的padding也会随之而来。这种设计是为了防止把派生类赋值给基类对象的时候导致基类对象的后面部位有数据而不是0（如果不保留padding的话，而是直接接上去） ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:6:1","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"加上多态 加上多态的额外负担： 导入一个相关的virtual table,用来存放它所声明的每一个虚函数的地址。这个table元素的数目一般而言是被声明的虚函数的数目，再加上一个或者两个slots（用来支持runtime type idetification）。 在每一个类对象中导入一个vptr，提供执行器的连接，使每一个对象能够找到对应的vittual table。 加强构造函数 加强虚构函数 vptr的放置没有强制规定。 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:6:2","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"多重继承 多重继承实际上对于第一继承没什么影响，主要是对于第二或者后继的base class Vertex3d v3d; Vertex *pv; Point2d *p2d; Point3d *p3d; pv = \u0026v3d; //需要这样的内部转化 pv = (Vertex*)(((char*)\u0026v3d + sizeof(Point3d)); //下面的只要简单的拷贝地址就行 p2d = \u0026v3d; pv = pv3d; //要考虑pv3d位0的情况 pv = pv3d ? (Vertex*)(((char*)\u0026v3d + sizeof(Point3d : 0; 多重继承的存储模型，没有规定怎么存储，但是大部分编译器都是采用下面的方式存储的。 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:6:3","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"虚拟继承 一般的实现方法：class如果含有一个或者多个virtual base class，分割为亮哥部分:一个是不变的局部，一个是共享的局部。不变的局部中的数据，不管后继如何衍化，总有固定的offset，所以这一部分数据可以被直接存取。至于共享局部，所表现的是virtual base class suboject.这一部分的数据，其位置会因为每次的派生操作而变化，所以它们只可以被间接存取。 例子继承体系 微软的解决方案：引入所谓的virtual base class table.每一个类对象如果有一个或者多个virtual base classes就会由编译器安插一个指针，指向virtual base class table。至于真正的virtual base class指针，被安放在这个表格中。 第二种解决方案 在virtula function table中放置 virtula base class的offset。 如同虚函数的指针，虚函数指针的在虚表中是正的offset，负的部分就给了虚基类。 (this +__vptr__Point3d[-3]-\u003e_x += (\u0026rhs + +__vptr__Point3d[-3]-\u003e_x) Point3d *p2d = pv3d; //转换为 Point3d *p2d = pv3d ? pv3d +__vptr__Point3d[-3] : 0; 一般而言，virtual base class 最有效的一种运行形势是：一个抽象的virtual base class，没有任何data members。 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:6:4","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"对象成员的效率 ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:7:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"指向Data Members的指针 \u0026 Point3d::z;的值为z在class object中的偏移量。 书上的代码试了在VS2015，并没有偏移量增加1的出现 printf(\"%d\", (\u0026Point3d::x));//4 printf(\"%d\", (\u0026Point3d::y));//8 printf(\"%d\", (\u0026Point3d::z));//c ","date":"2016-08-14","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/:8:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记] 深入探索C++对象模型 第三章 Data语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"第二章：构造函数语意学 由于C++的编译器在程序员之外做了太多事情，导致会产生很多意料之外的错误。 例子 Conversion运算符。 //为了支持 if(cin); //定义了一个perator int() //但是导致了以下错误的代码能够正常运行 int inVal; cin \u003c\u003c inVal; //此处\u003c\u003c被解释为左移操作符 int temp = cin.operator int(); temp \u003c\u003c intVal; Default Constructor的构建操作 默认构造函数只在编译器认为需要的时候才创建。 class Foo{public: int val; Foo *pnext}; int main() { Foo test; return 0; ] 这种情况实际没有默认构造函数，编译器什么都没做。 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:0:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"带有Default Constructor的 Member class Object 如果一个Class没有任何构造函数，但是包含一个member object，而后者又有default constructor，那么会在constructor真正被调用时合成出一个默认构造函数。 classFoo {public: Foo(),Foo(int);...}; classBar {public: Foofoo; char *str;}; void foo_bar(){ Bar bar; //Bar::foo应在此处被初始化 if(str){...} } 此时的Bar合成默认构造函数会调用Foo的默认构造函数。 Bar::Bar() { foo.Foo::Foo(); //合成出的 //但是str等成员是不会管的 } 如果已经写了一个默认构造函数，那么就会扩张该函数。 Bar::Bar() { foo.Foo::Foo(); //扩展的 str=0;//程序员代码 } C++会以member objects在class中声明的次序来调用各个构造函数，由编译器完成。如果成员没有默认构造函数的话，就不会有扩张。 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:1:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"带有Default Constructor的 Base Class 一个没有任何构造函数的类派生子一个带有默认构造函数的基类，那么会合成出一个一个默认构造函数，调用上一层的默认构造函数（根据声明次序）。 如果是一个有多个构造函数的类，但是没有默认构造函数，则会扩张每一个构造函数，加入有必要的基类部分的默认构造。 但是不会合成默认构造函数，因为已经存在了程序员编写的构造函数。 如果也存在带有构造函数的成员，那么会在基类的部分构造之后，调用这些成员的构造函数。 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:2:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"带有一个Virtual Function的 Class 另有两种情况，也需要合成出default constructor class声明（或者继承）一个virtual function class派生自一个继承串链，其中有一个或者更多的virtual base classes 如果程序员没有声明自己的构造函数，编译器就会详细记录合成一个default constructor的必要信息。 编译器需要做以下的几个功能： 一个virtual function table会被编译器产生出来，内放class的virtual function地址。 在每一个class object中，一个额外的pointer member会被编译器合成，内含相关的classs vtbl的地址。 此外如果必要，虚函数表的部分会被重写，以改变为需要的情况。 为了支持这种功能，编译器必须为每个w对象设置它的vptr（这是成员变量，此时需要指向合适的vtbl），因此编译器需要在default ctor中安插一些代码来完成这种工作。 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:3:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"带有一个Virtual Base Class 的Class classX { public: inti; }; classA : publicvirtualX { public: intj; }; classB : publicvirtualX { public: doubled; }; classC : publicA, publicB { public: intk; }; //无法在编译期间解析出 pa-\u003ei 的位置（给一个pa无法确定i的地址）。 void foo( constA* pa ) { pa-\u003ei = 1024; } main() { foo( new A ); foo( new C ); // ... } //由于pa的真正类型不确定，所以某些编译器会记录一个指针例（如 __vbcX）来记录X，然后通过这个指针来定位pa指向的i。 //上述 void foo( constA* pa ) { pa-\u003ei = 1024; } //变成了： void foo( constA* pa ) { pa-\u003e __vbcX -\u003ei = 1024; } 其中__vbcX标示编译器产生的指针，指向 virtual base class X。 __vbcX需要在每一个构造函数按错那么“允许每一个 virtual base class的执行期间存取操作“的码。如果class没有声明任何构造函数，就需要合成一个默认构造函数。 Copy Constructor的构建操作 有三种情况会执行拷贝构造函数： 显式的使用 = 传参 返回 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:4:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"Default Memberwise Initialization 一个class没有提供显式的拷贝构造函数的话，那么利用Memberwise Initialization(对每一个成员将源对象所有的member复制给目标对象) ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:5:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"非逐位拷贝 这个类的某个member object有拷贝构造函数。（不管成员的拷贝构造函数是合成的还是显式的定义的，都需要合成一个拷贝构造函数）。 这个类继承自某个有copy ctor的base class。（同上）。 这个类声明了若干个virtual function。（如果继承的基类有virtual function那么一定有拷贝构造函数，符合第二条。） 这个类派生自的继承链中有virtual base class。 第三四种情况需要合成的复制构造函数构建正确的虚表指针给每一个对象。 因为复制构造函数可以 派生类赋值给基类。那么派生类的虚表指针是没法用逐位拷贝来赋值，需要一个合成的复制构造函数正确的设定虚表指针。 程序转化语意学 X foo() { X xx; return xx; } 一个人可能会做出以下假设： 每次foo()调用，就会传回xx的值. 如果class X定义了一个拷贝构造函数，那么每次调用foo()，保证该拷贝构造函数也会被调用。 均不一定。move语意和外面没有接收的可能导致以上假设不一定。 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:6:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"明确的初始化操作 X x0; void foo_bar(){ X x1(x0); //定义了x1 X x2 = x0; //定义了x2 X x3 = X(x0); //定义了x3 } //转化的两个动作 //即变成了 void foo_bar(){ X x1; //定义被重写，初始化操作被剥除 X x2; //定义被重写，初始化操作被剥除 X x3; //定义被重写，初始化操作被剥除 //编译器安插X copy ctor。 x1.X::X( x0 ); x2.X::X( x0 ); x3.X::X( x0 ); } 其中: x1.X::X( x0 ); 会表现为对拷贝构造函数的调用： X::X( constX\u0026 xx);） ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:7:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"参数的初始化 如下代码的变化 void foo(X x0); //... X xx; foo(xx) 这种方式把函数的参数变成了引用，然后将拷贝构造函数构造的参数传入。 变成了 void foo(X\u0026 x0); //... X __tmp; __tmp.X::X( XX ); foo(__tmp); 其中X声明了destructor，它在foo调用完成后销毁暂时性的对象。 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:8:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"返回初始值 X bar(){ X xx; //... return xx; } 先添加一个额外的引用参数，然后在返回之前调用一个复制构造函数构造这个返回对象。 于是变成了 void bar(X\u0026 _result){ X xx; //... _result.X::X(xx); return; } X xx = bar(); //转换为 X xx; bar(xx); bar().memfunc(); //可能转换为 X _temp0; (bar(_temp0), _temp0).memfunc(); ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:9:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"在使用者层面的优化 X bar(const T \u0026y, const T \u0026z) { X xx; //... return xx; } 而是定义一个新的构造函数，这样在转换之后效率更高 X bar(const T \u0026y, const T \u0026z) { return X(y , z); } 转换后 void bar(X \u0026_result, const T \u0026y, const T \u0026z) { _result X::X(y, z); return; } ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:10:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"在编译器层面优化 就是上面那个转换代码 理论上合成的拷贝构造函数就能够正常的工作了。某些情况不会有合成的拷贝构造函数，而是直接逐位拷贝。这样的情况下，就没法实施，上面的编译器层面的优化。 那么我们应该预见这个类是不是有很多传值的操作，比如上面的函数的参数，返回值。如果有，那么提供一个，编译器才能够实施优化。 成员们的初始化队伍 构造函数初始化列表 初始化一个引用成员（不这样做出错） 初始化一个const成员（不这样做出错） 调用一个base class的构造函数，而它拥有一组参数时（不这样做出错） 调用一个member class的构造函数，而它拥有一组参数时（比赋值更有效率） 编译器会一一操作初始化列表，以适当次序（成员的声明次序）在构造函数之内安插初始化操作，并且在任何显式写的代码之前完成操作。 初始化列表能够使用成员函数来初始化一个成员。（这里如果比较复杂的初始化能够使用这种方式提高初始化的效率，但是要注意该函数使用的变量是不是在调用前都被初始化了。合法的原因是此时this指针已经创建好了。） ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/:11:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/"},{"categories":["读书笔记"],"content":"阅读的目的 在阅读《C++ primer》的时候，书里面写了各种各样的情况下，C++的处理方式。囫囵吞枣的记下后，也就不求甚解了。而C++在工作中的使用已经有了那么一段时间。但是对于C++的很多现象，却依旧是只知道是这样，却不知道为什么是这样。 那么阅读这本同样是 Lippman的书籍，就是为了解惑，为什么C++会导致我们看到的现象，而不是其他情况。 我希望，通过这么本书，能够解答我的一部分疑问。 序 工作里常听到的对于C++的抱怨是C++的编译器为程序员做了太多的服务，导致很多情况不受控制。不像C,大部分都需要手动去执行，可以明确的知道，什么时候做了什么。 我想这部分抱怨一方面来源于对于C++的不熟悉，一方面又来源于C++的特性。那么当对C++怎么实现各种特性了解后，对于编译器的行为有了概念后，我相信我应该能够解答很多疑问了。 就像Lippman在本书贴出的一封信件一般 他希望这本书是这些问题的解答。 第一章：关于对象 本章主要是对于对象模型的一个大概浏览，但是对多重继承和虚拟继承等情况没有太多的观察 C语言，数据和处理数据操作是分开声明的，语言本身没有支持数据和函数的关联性。由一组分布在各个以功能为导向的函数中的算法所驱动，它们的处理的是共同的外部数据。 C++的实现使用的是ADT classPoint { public: Point(float x); private: float _x; }; 这种形式将数据和函数相关联，数据封装。 那么这样的数据封装有成本吗？没有 所有的Class只会生成出一个函数实体。data members则是直接包含在class object中与C的struct一致。 C++的布局和存储时间的额外负担是由virtual引起的： virtual function机制 用来支持一个有效率的“执行期绑定”。 virtual base class 用来实现“多次出现在继承体系中的base class,有一个单一而被共享的实体”。 此外，还有一些多重继承下的额外负担。 C++的对象模型 C++中存在两种数据成员 static、nostatic，三种成员函数 static、nostatic、virtual。 classPoint { public: Point(float xval); virtual ~Point(); float x() const; staticint PointCount(); protected: virtual ostream\u0026 print(ostream \u0026os) const; float_x; staticint_point_count; }; 上图为C++的对象模型： nostatic data members 被配置在每一个class object之内。 static data members 被存放在所有的class object之外。 staitic 和 nostatic function members存放在class object之外。 virtual functions以两个步骤支持： ①每一个class产生出一堆指向virtual functions 的指针，放在表格之中。也就是虚表。 ②每一个class object被添加了一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设和重置由每一个classd constructor destructor 和 copy assignmemt运算符自动完成。每一个class所关联的type_info object用意支持runtiome tyoe identification，rtti也经由virtual table被指出来，通常是放在第一个slot处。 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/:0:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++ 对象模型 第一章 关于对象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["读书笔记"],"content":"加上继承 c++支持单一继承、多重继承、虚拟继承。 具体的讨论需要3.4中见到。 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/:1:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++ 对象模型 第一章 关于对象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["读书笔记"],"content":"对象模型如何影响程序 class X定义了一个拷贝构造函数，一个虚析构函数，一个虚函数foo(); X foobar() { X xx; X *px = new X; xx.foo(); px-\u003efoo(); delete px; return x; } 这个函数可能在内部转换为 //可能的内部转换结果 //虚拟C++码 void foobar(X\u0026 _result) { //使用引用返回，属于编译器的优化了。 //构造 _result.X::X(); //申请内存 px = _new(sizeof(X)); //调用构造函数 if( px != 0) px-\u003eX::X(); //成员函数的形式的转换，成员函数就是普通函数不过有一个this指针 foo(\u0026_result); //虚函数的基本调用方式，通过vptr来调用 (*px-\u003evtbl[2])(px); //调用虚析构函数 if( px != 0) { (*px-\u003evtbl[1])(px); _delete(px); } //不需要使用named return statement //不需要摧毁Local object xx //而是使用了传入参数_result return; } 关键词所带来的差异 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/:2:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++ 对象模型 第一章 关于对象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["读书笔记"],"content":"策略性正确的struct 把单一元素的数组放在一个struct的尾端，于是每个 struct objects 可以拥有可变大小的数组： struct mumble { char pc[1]; }; //获取一个字符串，然后为struct本身和该字符串配置足够的内存 struct mumble *pmumbl = (struct mumble*)malloc(sizeof(struct mumble) + strlen(string) + 1); strcpy(pmumbl-\u003epc, string); 这在C++中是很有问题的。不一定在pc后面就没有存放数据。 对象的差异 C++支持多种程序设计典范：程序模型、抽象数据类型模型、面向对象模型 ","date":"2016-08-07","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/:3:0","tags":["C++","理论","读书笔记"],"title":"[读书笔记]深入探索C++ 对象模型 第一章 关于对象","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["读书笔记"],"content":"阅读的活力与艺术 阅读存在很多个层次：娱乐、获取资讯、加深理解力。 本书更多的是为了读者能够加深理解力而写的书籍，教导人们如何通过各种手段，来阅读一本值得阅读的书籍。 阅读是一种主动的学习方式。而教师的教导等方式更多的是被动的接受。阅读作为主动的学习方式。这里的主动是你主动去获取知识，比如编程的书籍，看了不代表主动，需要更多的实践，这就是主动。不断的去实践、检测书籍中的内容，这样才能够对于艰深的书籍有更多的理解。 作者的观点里存在四个阅读的层次：(这里的层次更多的是阅读方法上的分类) 基础阅读 基础阅读：认识字,能够读大部分读物，能够大概的描述阅读的内容说的是什么。 检视阅读 这一个层次要求能够快速的、准确的通过各种方式抓住一本书的重点。 分为两类 有系统的略读： 1、看书名、序言。了解整个书讲的什么。 2、研究目录，对书的骨架有了了解。 3、看索引，能够快速的知道本书内容的范围。 4、阅读其他人写的介绍。 5、抽取部分篇章阅读。 6、不要忽略最后几页 粗浅的阅读： 1、快速的阅读，即使对很多内容不理解也要将书籍读完。这样才不会停滞不前。 2、提高阅读速度的方式，不断移动眼球，不要后退暂停。大脑要跟上阅读的速度。 3、需要判断不同的书籍类型，不同的种类使用不同的阅读速度。 如何做一个自我要求的读者 主动阅读需要提出的四个问题，在整个阅读的过程中需要不断的去尝试的回答这些问题： 1、整体而言，这本书到底谈些什么？ 2、作者细部说了什么，怎么说的？ 3、这本书说都有道理吗？是全部由道理，还是部分有道理？ 4、这本书跟你有什么关系？ 如何让一本书真正属于你自己 想要真正拥有一本书，不是花钱买了它。而是阅读它，做好笔记，实践书中的内容。 笔记是一个能够提升阅读主动性的存在，有与有笔记的存在，阅读者能够不断提醒自己，不至于打瞌睡，同时对内容的输出也是加深对书籍理解的方式，它迫使你不断的去思考，组织语言回应一个又一个事实。 存在三种笔记： 结构笔记：这种笔记的目的是记录下全书的架构，而不是内容。 概念笔记：书中一般会有很多新的概念或者其他你了解过的概念。这里记录的是作者的想法，与结构无关。 辩证笔记：对于更高层次的读者，已经不是全部接受作者观点了，他们需要的是对于本书已有的观点事实进行讨论，那么记录的笔记更多的是辩证的性质。 分析阅读 分析阅读的三个阶段 第一个阶段：找出一本书在谈些什么 1、依照书的种类与主题分类。 2、使用最简短的问题说明一本书谈什么。 3、将主要部分按照顺序与关联性列举出来。将全书的大纲列举出来，并将各个部分的大纲也列出来。 4、确定作者想要解决的问题。 第二个阶段：诠释一本书的内容 1、诠释作者使用的关键字，与作者达成共识。 2、从最重要的句子中抓住作者的重要主旨 3、找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。 4、确定作者已经解决了哪些问题，还有哪些是未解决的。未解决的问题中，确定哪些是作者认为自己无法解决的问题。 第三个阶段：像是沟通知识一样地评论一本书的规则 A．智慧礼节的一般规则 （9）除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。（在你说出：“我读懂了！”之前，不要说你同意、不同意或暂缓评论。） （10）不要争强好胜，非辩到底不可。 （11）在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。 B．批评观点的特别标准 （12）证明作者的知识不足。 （13）证明作者的知识错误。 （14）证明作者不合逻辑。 （15）证明作者的分析与理由是不完整的。 批评式阅读条件 本章的三个规则说明的是批评式阅读的条件，而在这样的阅读中，读者应该能够与作者“辩论”。 第一，要求读者先完整地了解一本书，不要急着开始批评。 第二，恳请读者不要争强好辩或盲目反对。 第三，将知识上的不同意见看作是大体上可以解决的问题。这个规则再进一步的话，就是要求读者要为自己不同的意见找到理论基础，这样这个议题才不只是被说出来，而且会解释清楚。 ","date":"2016-08-06","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/:0:0","tags":["杂谈","杂书","读书笔记"],"title":"[读书笔记] 《如何阅读一本书》","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"},{"categories":["读书笔记"],"content":"序章部分都是周先生之前的一些经验之谈，感觉在实际编程过程中还是比较有用的，程序里经常遇到这么些问题。 1、参数校验 参数校验，大部分函数开始和使用传进来的参数的都是都是需要参数校验的。有时候不知道该不该校验，怎么样才能划分这部分工作是函数使用者的工作，还是函数设计者的工作呢。一直比较迷糊吧。 *对于在大循环里调用的函数，不需要再函数内校验。比如链表的遍历，如果校验的话，每一个链表的节点都需要校验，那么函数的效率就要大幅度下降了。 *底层的函数调用频度都比较高，一般不校验？这个为什么不校验了，是因为调用频度高？ *如果在一个函数中多次使用这个底层函数，实际上只要在调用函数之前，一次性校验一次就行了。而不需要在底层函数中进行校验，否则多次校验，影响效率。 *调用频率低的校验，和上面一条类似，调用频率低了，自然自带校验好。 *执行时间开销很大，参数校验对于函数运行时间来说忽略不计。 *可以大幅度提高软件的稳定性的。 2、return语句的使用 函数对于return语句的使用，多次使用该语句的话，要对资源进行回收完全，但实际情况中，经常会忘记写一些，这样就造成内存泄露比较容易发生。但是你不用return语句的话，一般写程序条件过多，分支过多，读程序的困难就比较大的提升了。 *参数校验失败后直接return，并对资源回收 *函数内不同的出错，要使用不同的return来表示不同的出错原因 *函数内部同类出错，尽量使用同一个return语句，尽量不要让两个return返回同一个返回值 3、while循环和for循环的问题 死循环时，在pc-lint中会检测成错误？ 普通时候，循环变量在循环中改变的话，用while，在循环后改变用for 4、if语句多个判断的问题 需要校验多个参数时候，把条件放在一个if中，这要就少了return。当然，这些条件要产生不容的return结果的时候，就需要分开了。 5、goto语句的使用 我看周先生在一些代码中还是使用的一些goto语句的，根据之前的描述看，就是运用在出错的时候，跳转到资源回收时，比较方便使用。 但是goto的语句使用有一些原则goto语句只能goto到同一函数内，而不能从一个函数里goto到另一个函数里使用goto语句在同一个函数内goto时候，goto的起点应该是函数内一小段功能结束处，目的地是一小段功能开始处，而不是乱跳不能从一段复杂的执行状态中的位置goto，这样很容易遗漏东西。 6、swich…case if else if区别 一般swich效率更高些，但是实际情况是，每一个条件存在不同概率时候，把概率大的放最前的话，效率最高。 7、任意数据类型的处理方式 C 数据类型几乎存在无限种组合了，c++使用模板，而在c语言中使用void指针是很不错的方法。其实在C++中也经常用到void指针，因为可以指向任意类型的数据。C使用void*时候不知道适合该数据结构的一些操作，所以需要使用回调函数，来传进这些操作。 *数据的比较 *数据的资源释放 *数据的访问 *数据的拷贝 *数据的一些其他计算操作 例子 *typedef void (*DESTROYFUNC)( void *pArgs); ","date":"2016-08-06","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:0:0","tags":["杂谈","数据结构"],"title":"[读书笔记]多任务下的数据结构与算法 序章","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["游戏"],"content":"关于结局 ","date":"2016-07-26","objectID":"/the-last-of-us/:0:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":["游戏"],"content":"1、我不信任马琳。 可以确定的是他们确实是想要找到疫苗，即使马琳在爱丽出身开始就在她的旁边，也要杀死爱丽。马琳是抛弃了爱丽的，从最初的国会大厦，到玛利亚医院，她存活下来之后，才开始在其记录的本子录音中关心起爱丽来，当然更多的是关心有免疫体的爱丽。其实作为爱丽没有必要跟着马琳走的，完全可以在波士顿生活下去，爱丽是重情，而马琳就不是了。 ","date":"2016-07-26","objectID":"/the-last-of-us/:1:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":["游戏"],"content":"2、火萤是一个怎么样的组织呢？ 从剧情看乔尔的弟弟在离开乔尔之后，加入了火萤，然后从火萤离开，到达森林之中构筑起他的小村落。火萤能不能给人类带来新的希望呢，我觉得是不能的，在长期的对抗之下，火萤显然是从最初的想要找回原来国家秩序的组织退化了，也是由于这个原因让汤米出走，寻找自己的出路，最后汤米接近于实现他的想法。 ","date":"2016-07-26","objectID":"/the-last-of-us/:2:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":["游戏"],"content":"3、汤米的村落才是人类的希望。 汤米的村落才是真正的人类希望。不论是军事管理区、猎人、还是火萤，都让这个国家的秩序不再存在了。从整个游戏的不断对抗之中我们能够发现的是，往往人类比感染者更加难缠，乔尔与爱丽最惊险的时刻还是在与猎人、军政府、火萤的对抗的时候。实际上感染者，可能并没有那么可怕。汤米的小村落，在回归秩序之后，需要担心的更多是猎人，而不是感染者能够说明，如果社会重新回归秩序，那么感染者并没有那么可怕，可怕的更多的是人心。 关于细节 ","date":"2016-07-26","objectID":"/the-last-of-us/:3:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":["游戏"],"content":"1、汤米和乔尔的分裂是必然的。 在游戏开场的时候，汤米开车载着乔尔和萨拉，路上有人求救，汤米想要停下来载人，乔尔是强烈反对的。乔尔要求开车冲过人群，不管前面不断涌来的人流，汤米是不愿意的。就如后面剧情所描述的那般，乔尔成为了走私客，当过猎人。帮助他与汤米活了下来。而对于汤米来说，这对他是一场噩梦。两个人的处事原则不一致，导致了他们最终的分裂。而从这一点来看，乔尔为了救爱丽，杀医生与马琳这么些中性的人物也就不奇怪了。 ","date":"2016-07-26","objectID":"/the-last-of-us/:4:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":["游戏"],"content":"2、关于火萤的疫苗研究。 当乔尔一行躲过军队的追击时，问爱丽火萤的安排的时候，爱丽说火萤有着自己的隔离区正在研究疫苗，乔尔与泰丝不屑一顾。说明火萤研究疫苗人尽皆知，但从来不知道真假。 ","date":"2016-07-26","objectID":"/the-last-of-us/:5:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":["游戏"],"content":"3、泰丝无声的死亡 当军队追击到来，泰丝希望能够阻止一会。乔尔与爱丽刚到达二楼，就是一声参加。当我们终于在二楼解决掉敌人的时候，回过头来，泰丝的尸体就躺在了那里。没有太多反抗能力的，无声的死去了。所有关于她的故事，精彩的一生，就这样消失了。带给我的是孤寂。 ","date":"2016-07-26","objectID":"/the-last-of-us/:6:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":["游戏"],"content":"4、山姆与亨利 当终于躲过了猎人与感染者的追击，乔尔爱丽与黑人兄弟建立起来友谊。夜晚来临，亨利对于未来充满想象，愉快的吃着东西讨论着哈雷机车，让我没想到的是，这会是最后一个夜晚了。亨利饮弹自尽，十多秒的黑屏，让我思考很久。 ","date":"2016-07-26","objectID":"/the-last-of-us/:7:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":["游戏"],"content":"5、爱丽梦到飞机 当快要到达旅途的终点，爱丽在一个飞机的海报之前停了下来。描述着之前她做的梦。失去控制的飞机，没有机长的机长室，只能由她来拯救这一飞机上的人，她试图驾驶，但飞机却要坠落了。失控的飞机代表着这个失控的世界，而爱丽就是拯救世界的关键人物，没人可以给与她指引，只能她自己去摸索，但是终究可能会坠落，她害怕失去朋友，害怕完成不了自己的使命。 ","date":"2016-07-26","objectID":"/the-last-of-us/:8:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":["游戏"],"content":"6、两人关系进展的一些点 乔尔在电梯处，掉了下去之后，他问爱丽是不是OK，爱丽回答“NO,你吓到我了” 爱丽在乔尔差点被猎人溺死的情况下拯救了乔尔，但是乔尔嘴硬的不愿意承认，爱丽直说乔尔怎么就不知道感谢。游戏设计上立马设计一个乔尔一个人推不动的钢琴，需要爱丽与他一起。同时接着就是乔尔需要爱丽进行掩护攻击猎人。 躲避机车的关卡，乔尔没有爬山去的情况下，爱丽直接跳下来与乔尔一起面对难关。在关键时刻需要跳桥的情况下，乔尔关心的是爱丽不会游泳，而爱丽信任他，一句不要让我沉下去，就果断跳了。 乔尔寻找会出走的爱丽，爱丽直言，她害怕失去，所有她关心的人都离她而去，除了乔尔。她不需要什么更懂行的汤米，只需要乔尔，只有这样她才能够心安。 爱丽打败大卫，疯狂的痛砍大卫的尸体的时候，乔尔及时的出现，像安慰女儿一样安慰着爱丽（神态语气如同萨拉死去的时候一般），同时抚平了自己的内心。 ","date":"2016-07-26","objectID":"/the-last-of-us/:9:0","tags":["RPG","PS4","游戏"],"title":"《The Last Of Us》","uri":"/the-last-of-us/"},{"categories":null,"content":" 游戏服务端开发。 C++。 Gamer,RPG爱好者。 ","date":"2016-07-25","objectID":"/about/:0:0","tags":null,"title":"关于杨一","uri":"/about/"},{"categories":null,"content":"新的博客 Hello World ","date":"2016-07-24","objectID":"/hello-world/:0:0","tags":null,"title":"Hello World","uri":"/hello-world/"}]