<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[redis源码阅读-RDB持久化]]></title>
      <url>%2F%2Fblog%2F2017%2F07%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-RDB%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
      <content type="text"><![CDATA[Redis是一个内存数据库，数据存储在内存之中。有一个问题就是如果数据不存储到硬盘，那么在服务器进程退出之后，服务器中所有的数据库数据就会丢失。 Redis为了解决这个问题，提供了持久化功能，目前有两种一种是RDB持久化，一种是AOF持久化。 RDB持久化是生成一个RDB文件，该文件是一个经过压缩的二进制文件，通过该文件可以还原数据库的状态。 RDB文件的保存命令Redis有两个命令可以生成RDB文件一个是SAVE，一个是BGSAVE。SAVE命令调用saveCommand进行处理 123456789101112131415void saveCommand(redisClient *c) &#123; // 判断是否正在执行BGSAVE，是则退出 if (server.rdb_child_pid != -1) &#123; addReplyError(c,"Background save already in progress"); return; &#125; //调用rdbSave生成RDB文件 if (rdbSave(server.rdb_filename) == REDIS_OK) &#123; addReply(c,shared.ok); &#125; else &#123; addReply(c,shared.err); &#125;&#125; BGSAVE调用bgsaveCommand进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485void bgsaveCommand(redisClient *c) &#123; // 判断是否已经在执行BGSAVE if (server.rdb_child_pid != -1) &#123; addReplyError(c,"Background save already in progress"); &#125; else if (server.aof_child_pid != -1) &#123; // 判断是否在执行BGREWRIEAOF addReplyError(c,"Can't BGSAVE while AOF log rewriting is in progress"); // 执行rdbSaveBackground 生成RDB文件 &#125; else if (rdbSaveBackground(server.rdb_filename) == REDIS_OK) &#123; addReplyStatus(c,"Background saving started"); &#125; else &#123; addReply(c,shared.err); &#125;&#125;int rdbSaveBackground(char *filename) &#123; pid_t childpid; long long start; // 如果BGSAVE正在执行直接返回 if (server.rdb_child_pid != -1) return REDIS_ERR; // 获取dirty数据 执行时间 server.dirty_before_bgsave = server.dirty; server.lastbgsave_try = time(NULL); // fork() 开始前时间 start = ustime(); // 调用fork，克隆该进程 if ((childpid = fork()) == 0) &#123; int retval; /* Child */ closeListeningSockets(0); redisSetProcTitle("redis-rdb-bgsave"); // 执行保存操作 retval = rdbSave(filename); // 打印 copy-on-write 时使用的内存数 if (retval == REDIS_OK) &#123; size_t private_dirty = zmalloc_get_private_dirty(); if (private_dirty) &#123; redisLog(REDIS_NOTICE, "RDB: %zu MB of memory used by copy-on-write", private_dirty/(1024*1024)); &#125; &#125; // 向父进程发送信号 exitFromChild((retval == REDIS_OK) ? 0 : 1); &#125; else &#123; /* Parent */ // 计算 fork() 执行的时间 server.stat_fork_time = ustime()-start; server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */ latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000); // 执行fork()错误信息 if (childpid == -1) &#123; server.lastbgsave_status = REDIS_ERR; redisLog(REDIS_WARNING,"Can't save in background: fork: %s", strerror(errno)); return REDIS_ERR; &#125; redisLog(REDIS_NOTICE,"Background saving started by pid %d",childpid); // 记录数据库开始BGSAVE时间 server.rdb_save_time_start = time(NULL); // 子进程ID 类型 server.rdb_child_pid = childpid; server.rdb_child_type = REDIS_RDB_CHILD_TYPE_DISK; // 关闭自动Rehash updateDictResizePolicy(); return REDIS_OK; &#125; return REDIS_OK; /* unreached */&#125; 那么怎么才能够知道BGSAVE执行完毕，BGSAVE执行完毕后使用exitFromChild((retval == REDIS_OK) ? 0 : 1);向父进程发送信号。父进程调用serverCron接收该信号。 以下是处理函数的部分代码，处理BGREWRITEAOF与BGSAVE的完成信号。最终调用backgroundSaveDoneHandler根据返回信号信息进行对应处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;\\ ... // 检查 BGSAVE 或者 BGREWRITEAOF 是否已经执行完毕 if (server.rdb_child_pid != -1 || server.aof_child_pid != -1) &#123; int statloc; pid_t pid; // 接收子进程发来的信号 if ((pid = wait3(&amp;statloc,WNOHANG,NULL)) != 0) &#123; int exitcode = WEXITSTATUS(statloc); int bysignal = 0; if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc); // BGSAVE 执行完毕 if (pid == server.rdb_child_pid) &#123; backgroundSaveDoneHandler(exitcode,bysignal); // BGREWRITEAOF 执行完毕 &#125; else if (pid == server.aof_child_pid) &#123; backgroundRewriteDoneHandler(exitcode,bysignal); &#125; else &#123; redisLog(REDIS_WARNING, "Warning, detected child with unmatched pid: %ld", (long)pid); &#125; updateDictResizePolicy(); &#125; &#125;\\ ... /* A background saving child (BGSAVE) terminated its work. Handle this. * This function covers the case of actual BGSAVEs. */void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) &#123; // 成功 if (!bysignal &amp;&amp; exitcode == 0) &#123; redisLog(REDIS_NOTICE, "Background saving terminated with success"); server.dirty = server.dirty - server.dirty_before_bgsave; server.lastsave = time(NULL); server.lastbgsave_status = REDIS_OK; // 出错 &#125; else if (!bysignal &amp;&amp; exitcode != 0) &#123; redisLog(REDIS_WARNING, "Background saving error"); server.lastbgsave_status = REDIS_ERR; &#125; else &#123; mstime_t latency; redisLog(REDIS_WARNING, "Background saving terminated by signal %d", bysignal); latencyStartMonitor(latency); rdbRemoveTempFile(server.rdb_child_pid); latencyEndMonitor(latency); latencyAddSampleIfNeeded("rdb-unlink-temp-file",latency); /* SIGUSR1 is whitelisted, so we have a way to kill a child without * tirggering an error conditon. */ if (bysignal != SIGUSR1) server.lastbgsave_status = REDIS_ERR; &#125; // 更新状态 server.rdb_child_pid = -1; server.rdb_child_type = REDIS_RDB_CHILD_TYPE_NONE; server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start; server.rdb_save_time_start = -1; /* Possibly there are slaves waiting for a BGSAVE in order to be served * (the first stage of SYNC is a bulk transfer of dump.rdb) */ updateSlavesWaitingBgsave((!bysignal &amp;&amp; exitcode == 0) ? REDIS_OK : REDIS_ERR, REDIS_RDB_CHILD_TYPE_DISK);&#125; rdbSaveint rdbSave(char *filename);是SAVE与BGSAVE命令执行时正在用来生成RDB文件的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int rdbSave(char *filename) &#123; char tmpfile[256]; FILE *fp; rio rdb; int error; // 生成临时文件 snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid()); fp = fopen(tmpfile,"w"); if (!fp) &#123; redisLog(REDIS_WARNING, "Failed opening .rdb for saving: %s", strerror(errno)); return REDIS_ERR; &#125; // 初始化I/O rioInitWithFile(&amp;rdb,fp); // 生成RDB文件 if (rdbSaveRio(&amp;rdb,&amp;error) == REDIS_ERR) &#123; errno = error; goto werr; &#125; // 确保缓存中没有数据 if (fflush(fp) == EOF) goto werr; if (fsync(fileno(fp)) == -1) goto werr; if (fclose(fp) == EOF) goto werr; // 使用RENAME改名 if (rename(tmpfile,filename) == -1) &#123; redisLog(REDIS_WARNING,"Error moving temp DB file on the final destination: %s", strerror(errno)); unlink(tmpfile); return REDIS_ERR; &#125; // 日志 设置状态 redisLog(REDIS_NOTICE,"DB saved on disk"); server.dirty = 0; server.lastsave = time(NULL); server.lastbgsave_status = REDIS_OK; return REDIS_OK;werr: // 异常处理 fclose(fp); unlink(tmpfile); redisLog(REDIS_WARNING,"Write error saving DB on disk: %s", strerror(errno)); return REDIS_ERR;&#125; 实际是调用rdbSaveRio执行写入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int rdbSaveRio(rio *rdb, int *error) &#123; dictIterator *di = NULL; dictEntry *de; char magic[10]; int j; long long now = mstime(); uint64_t cksum; // 设置校验和 if (server.rdb_checksum) rdb-&gt;update_cksum = rioGenericUpdateChecksum; // 写入REDIS版本号 snprintf(magic,sizeof(magic),"REDIS%04d",REDIS_RDB_VERSION); if (rdbWriteRaw(rdb,magic,9) == -1) goto werr; // 遍历数据库 for (j = 0; j &lt; server.dbnum; j++) &#123; redisDb *db = server.db+j; dict *d = db-&gt;dict; // 跳过空数据库 if (dictSize(d) == 0) continue; // 键空间迭代器 di = dictGetSafeIterator(d); if (!di) return REDIS_ERR; /* Write the SELECT DB opcode */ // 写入DB选择器 if (rdbSaveType(rdb,REDIS_RDB_OPCODE_SELECTDB) == -1) goto werr; if (rdbSaveLen(rdb,j) == -1) goto werr; /* Iterate this DB writing every entry */ // 遍历数据库，写入键值对 while((de = dictNext(di)) != NULL) &#123; sds keystr = dictGetKey(de); robj key, *o = dictGetVal(de); long long expire; initStaticStringObject(key,keystr); expire = getExpire(db,&amp;key); // 写入键值对 if (rdbSaveKeyValuePair(rdb,&amp;key,o,expire,now) == -1) goto werr; &#125; dictReleaseIterator(di); &#125; di = NULL; /* So that we don't release it again on error. */ /* EOF opcode */ // 写入 EOF 代码 if (rdbSaveType(rdb,REDIS_RDB_OPCODE_EOF) == -1) goto werr; /* CRC64 checksum. It will be zero if checksum computation is disabled, the * loading code skips the check in this case. */ // CRC64 校验和。 cksum = rdb-&gt;cksum; memrev64ifbe(&amp;cksum); if (rioWrite(rdb,&amp;cksum,8) == 0) goto werr; return REDIS_OK;werr: if (error) *error = errno; if (di) dictReleaseIterator(di); return REDIS_ERR;&#125; 自动保存redis能够配置自动保存条件，当满足的情况下执行BGSAVE。 依赖上次保存时间和dirty计数。 1234567891011121314151617181920212223242526// serverCron函数if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 || ldbPendingChildren())&#123; // 为之前处理BGSAVE完成的部分的代码&#125; else &#123; // 检查所有保存条件 for (j = 0; j &lt; server.saveparamslen; j++) &#123; struct saveparam *sp = server.saveparams+j; // 检查某个保存条件是否符合 if (server.dirty &gt;= sp-&gt;changes &amp;&amp; server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp; (server.unixtime-server.lastbgsave_try &gt; CONFIG_BGSAVE_RETRY_DELAY || server.lastbgsave_status == C_OK)) &#123; serverLog(LL_NOTICE,"%d changes in %d seconds. Saving...", sp-&gt;changes, (int)sp-&gt;seconds); // 保存 rdbSaveBackground(server.rdb_filename); break; &#125; &#125; // ...&#125; RDB的文件载入rdbload()用于将RDB文件从硬盘载入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138int rdbLoad(char *filename) &#123; uint32_t dbid; int type, rdbver; redisDb *db = server.db+0; char buf[1024]; long long expiretime, now = mstime(); FILE *fp; rio rdb; // 打开rdb文件 if ((fp = fopen(filename,"r")) == NULL) return REDIS_ERR; // 初始化rio rioInitWithFile(&amp;rdb,fp); rdb.update_cksum = rdbLoadProgressCallback; rdb.max_processing_chunk = server.loading_process_events_interval_bytes; if (rioRead(&amp;rdb,buf,9) == 0) goto eoferr; buf[9] = '\0'; // 校验版本号 if (memcmp(buf,"REDIS",5) != 0) &#123; fclose(fp); redisLog(REDIS_WARNING,"Wrong signature trying to load DB from file"); errno = EINVAL; return REDIS_ERR; &#125; rdbver = atoi(buf+5); if (rdbver &lt; 1 || rdbver &gt; REDIS_RDB_VERSION) &#123; fclose(fp); redisLog(REDIS_WARNING,"Can't handle RDB format version %d",rdbver); errno = EINVAL; return REDIS_ERR; &#125; // 标记开始载入 startLoading(fp); while(1) &#123; robj *key, *val; expiretime = -1; /* Read type. */ // 读取类型 if ((type = rdbLoadType(&amp;rdb)) == -1) goto eoferr; // 过期时间 秒为单位 if (type == REDIS_RDB_OPCODE_EXPIRETIME) &#123; // 过期时间 if ((expiretime = rdbLoadTime(&amp;rdb)) == -1) goto eoferr; /* We read the time so we need to read the object type again. */ // 键值对 if ((type = rdbLoadType(&amp;rdb)) == -1) goto eoferr; /* the EXPIRETIME opcode specifies time in seconds, so convert * into milliseconds. */ expiretime *= 1000; &#125; else if (type == REDIS_RDB_OPCODE_EXPIRETIME_MS) &#123; /* Milliseconds precision expire times introduced with RDB * version 3. */ // 过期时间 毫秒但闻 if ((expiretime = rdbLoadMillisecondTime(&amp;rdb)) == -1) goto eoferr; /* We read the time so we need to read the object type again. */ if ((type = rdbLoadType(&amp;rdb)) == -1) goto eoferr; &#125; // EOF if (type == REDIS_RDB_OPCODE_EOF) break; /* Handle SELECT DB opcode as a special case */ // 读取切换数据库指示 if (type == REDIS_RDB_OPCODE_SELECTDB) &#123; // 数据库号 if ((dbid = rdbLoadLen(&amp;rdb,NULL)) == REDIS_RDB_LENERR) goto eoferr; // 校验 if (dbid &gt;= (unsigned)server.dbnum) &#123; redisLog(REDIS_WARNING,"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\n", server.dbnum); exit(1); &#125; // 切换数据库 db = server.db+dbid; continue; &#125; /* Read key */ // 读取键 if ((key = rdbLoadStringObject(&amp;rdb)) == NULL) goto eoferr; /* Read value */ // 读取值 if ((val = rdbLoadObject(type,&amp;rdb)) == NULL) goto eoferr; /* Check if the key already expired. This function is used when loading * an RDB file from disk, either at startup, or when an RDB was * received from the master. In the latter case, the master is * responsible for key expiry. If we would expire keys here, the * snapshot taken by the master may not be reflected on the slave. */ if (server.masterhost == NULL &amp;&amp; expiretime != -1 &amp;&amp; expiretime &lt; now) &#123; decrRefCount(key); decrRefCount(val); continue; &#125; /* Add the new object in the hash table */ // 将键值关联到数据库内 dbAdd(db,key,val); /* Set the expire time if needed */ // 设置过期时间 if (expiretime != -1) setExpire(db,key,expiretime); decrRefCount(key); &#125; /* Verify the checksum if RDB version is &gt;= 5 */ // 校验和比较 if (rdbver &gt;= 5 &amp;&amp; server.rdb_checksum) &#123; uint64_t cksum, expected = rdb.cksum; if (rioRead(&amp;rdb,&amp;cksum,8) == 0) goto eoferr; memrev64ifbe(&amp;cksum); if (cksum == 0) &#123; redisLog(REDIS_WARNING,"RDB file was saved with checksum disabled: no check performed."); &#125; else if (cksum != expected) &#123; redisLog(REDIS_WARNING,"Wrong RDB checksum. Aborting now."); exit(1); &#125; &#125; // 结束 fclose(fp); stopLoading(); return REDIS_OK;eoferr: /* unexpected end of file is handled here with a fatal exit */ redisLog(REDIS_WARNING,"Short read or OOM loading DB. Unrecoverable error, aborting now."); exit(1); return REDIS_ERR; /* Just to avoid warning */&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-服务器]]></title>
      <url>%2F%2Fblog%2F2017%2F07%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
      <content type="text"><![CDATA[服务器redis运行存在一个redis服务器结构，一个服务器中保存着n个数据库。 dbnum由服务器配置决定，默认值为16。 1234567891011121314151617struct redisServer &#123; redisDb *db; // Redis的数据库 // ... int dbnum; // 表明数据库的数量 // ...&#125;typedef struct redisDb &#123; dict *dict; /* 数据库键字典 */ dict *expires; /* 键过期时间字典 */ dict *blocking_keys; /* 处于阻塞状态的键 */ dict *ready_keys; /* 可以解除阻塞的键 */ dict *watched_keys; /* 被watch的键 */ struct evictionPoolEntry *eviction_pool; /* Eviction pool of keys */ int id; /* 数据库编号 */ long long avg_ttl; /* 数据库键的平均时间*/&#125; redisDb; 切换数据库每个redis客户端都有自己的目标数据库，当客户端执行数据库读写命令，目标数据库是这些命令的操作对象。 redis提供select命令来切换数据库，redisClient 1234567891011121314151617typedef struct redisClient &#123; int fd; // 套接字描述符 redisDb *db; // 当前正在使用的数据库 // ...&#125;int selectDb(redisClient *c, int id) &#123; // 校验id if (id &lt; 0 || id &gt;= server.dbnum) return REDIS_ERR; // 切换客户端数据库 c-&gt;db = &amp;server.db[id]; return REDIS_OK;&#125; 数据库键空间Redis数据库存放的数据都是以键值对形式存在，redisDB结构的dict字典保存数据库中的所有键值对，这个字典被成为键空间。 12345typedef struct redisDb &#123; dict *dict; /* 数据库键字典 */ // ...&#125; redisDb; 键空间的键就是数据库的键，每个键都是一个字符串对象。 键空间的值就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象、有序集合对象中任意一种。 键空间的操作12345678910111213141516171819202122232425262728/* db.c -- Keyspace access API */int removeExpire(redisDb *db, robj *key);// 移除键的过期时间void propagateExpire(redisDb *db, robj *key); // int expireIfNeeded(redisDb *db, robj *key); // 检查是否过期，是则删除键long long getExpire(redisDb *db, robj *key); // 获取过期时间void setExpire(redisDb *db, robj *key, long long when); // 设定过期时间robj *lookupKey(redisDb *db, robj *key); // 从db中取出键key的值robj *lookupKeyRead(redisDb *db, robj *key); // 从db中取出键key的值robj *lookupKeyWrite(redisDb *db, robj *key); // 从db中取出键key的值robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply); // 从db中取出键key的值robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply);// 从db中取出键key的值void dbAdd(redisDb *db, robj *key, robj *val);// 尝试将键值对key\val添加到数据库中void dbOverwrite(redisDb *db, robj *key, robj *val); // 重写指定键的值,键不存在的话终止void setKey(redisDb *db, robj *key, robj *val);// 设定指定键的值，不管存不存在int dbExists(redisDb *db, robj *key); // 判断指定键是否存在 robj *dbRandomKey(redisDb *db); // 随机从数据库中取出一个键，并以字符串对象的方式返回这个键int dbDelete(redisDb *db, robj *key); // 从数据库中删除给定的键robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);long long emptyDb(void(callback)(void*));// 情况所有数据int selectDb(redisClient *c, int id); // 切换dbvoid signalModifiedKey(redisDb *db, robj *key);void signalFlushedDb(int dbid);unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);unsigned int countKeysInSlot(unsigned int hashslot);unsigned int delKeysInSlot(unsigned int hashslot);int verifyClusterConfigWithData(void);void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor);int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor); 键空间的初始化12345678910111213141516171819202122232425/* Db-&gt;dict, keys are sds strings, vals are Redis objects. */// 键空间的类型dictType dbDictType = &#123; dictSdsHash, /* hash function */ NULL, /* key dup */ NULL, /* val dup */ dictSdsKeyCompare, /* key compare */ dictSdsDestructor, /* key destructor */ dictRedisObjectDestructor /* val destructor */&#125;;// 服务器初始化的同时初始化键空间void initServer() &#123; // ... /* Create the Redis databases, and initialize other internal state. */ // 创建并初始化数据库结构 for (j = 0; j &lt; server.dbnum; j++) &#123; server.db[j].dict = dictCreate(&amp;dbDictType,NULL); // ... server.db[j].id = j; // ... &#125; // ...&#125;; 查找有五个和查找相关的接口，代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply) &#123; robj *o = lookupKeyWrite(c-&gt;db, key); if (!o) addReply(c,reply); return o;&#125;robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply) &#123; // 查找 robj *o = lookupKeyRead(c-&gt;db, key); // 发送信息 if (!o) addReply(c,reply); return o;&#125;robj *lookupKeyWrite(redisDb *db, robj *key) &#123; // 删除过期键 expireIfNeeded(db,key); // 查找并返回对象 return lookupKey(db,key);&#125;robj *lookupKeyRead(redisDb *db, robj *key) &#123; robj *val; // 删除过期键 expireIfNeeded(db,key); // 查找对象 val = lookupKey(db,key); // 更新命中/不命中信息 if (val == NULL) server.stat_keyspace_misses++; else server.stat_keyspace_hits++; // 返回值 return val;&#125;robj *lookupKey(redisDb *db, robj *key) &#123; // 查找 dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr); if (de) &#123; // 取出值 robj *val = dictGetVal(de); // 更新时间信息 if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1) val-&gt;lru = LRU_CLOCK(); // 返回值 return val; &#125; else &#123; return NULL; &#125;&#125; 添加新键12345678void dbAdd(redisDb *db, robj *key, robj *val) &#123; sds copy = sdsdup(key-&gt;ptr); // 复制键名 int retval = dictAdd(db-&gt;dict, copy, val); // 尝试添加 redisAssertWithInfo(NULL,key,retval == REDIS_OK); // 已经存在则停止 if (val-&gt;type == REDIS_LIST) signalListAsReady(db, key); if (server.cluster_enabled) slotToKeyAdd(key); &#125; 修改键两种方式一种重写，一种设定不管存不存在。 1234567891011121314151617181920void dbOverwrite(redisDb *db, robj *key, robj *val); // 重写指定键的值,键不存在的话终止void setKey(redisDb *db, robj *key, robj *val);// 设定指定键的值，不管存不存在void dbOverwrite(redisDb *db, robj *key, robj *val) &#123; dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr); // 查找 redisAssertWithInfo(NULL,key,de != NULL); // 不存在，终止 dictReplace(db-&gt;dict, key-&gt;ptr, val); // 修改旧值&#125;void setKey(redisDb *db, robj *key, robj *val) &#123; if (lookupKeyWrite(db,key) == NULL) &#123; dbAdd(db,key,val); // 找不到就添加 &#125; else &#123; dbOverwrite(db,key,val); // 找到就重写 &#125; incrRefCount(val); // 增加引用计数 removeExpire(db,key); // 移除过期时间 signalModifiedKey(db,key); // 发送键修改通知&#125; 删除键1234567891011121314int dbDelete(redisDb *db, robj *key) &#123; /* Deleting an entry from the expires dict will not free the sds of * the key, because it is shared with the main dictionary. */ // 删除键的过期时间 if (dictSize(db-&gt;expires) &gt; 0) dictDelete(db-&gt;expires,key-&gt;ptr); // 删除键值对 if (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123; if (server.cluster_enabled) slotToKeyDel(key); return 1; &#125; else &#123; return 0; &#125;&#125; 键的生存时间或过期时间与键空间类似redis建立了一个字典，存放每个键的对应的过期时间。在初始化的时候创建 1234567891011121314151617181920dictType keyptrDictType = &#123; dictSdsHash, /* hash function */ NULL, /* key dup */ NULL, /* val dup */ dictSdsKeyCompare, /* key compare */ NULL, /* key destructor */ NULL /* val destructor */&#125;;void initServer() &#123; // ... // 创建并初始化数据库结构 for (j = 0; j &lt; server.dbnum; j++) &#123; server.db[j].expires = dictCreate(&amp;keyptrDictType,NULL); // ... server.db[j].id = j; // ... &#125; // ...&#125;; 设定键的过期时间123456789void setExpire(redisDb *db, robj *key, long long when) &#123; dictEntry *kde, *de; kde = dictFind(db-&gt;dict,key-&gt;ptr); // 查找键 redisAssertWithInfo(NULL,key,kde != NULL); // 在过期时间字典中查找，没有则添加 de = dictReplaceRaw(db-&gt;expires,dictGetKey(kde)); dictSetSignedIntegerVal(de,when); // 设置过期时间&#125; 获取键的过期时间123456789101112long long getExpire(redisDb *db, robj *key) &#123; dictEntry *de; // 如果不存在直接返回 if (dictSize(db-&gt;expires) == 0 || (de = dictFind(db-&gt;expires,key-&gt;ptr)) == NULL) return -1; redisAssertWithInfo(NULL,key,dictFind(db-&gt;dict,key-&gt;ptr) != NULL); // 返回过期时间 return dictGetSignedIntegerVal(de);&#125; 删除键的过期时间12345int removeExpire(redisDb *db, robj *key) &#123; // 确保键有过期时间 redisAssertWithInfo(NULL,key,dictFind(db-&gt;dict,key-&gt;ptr) != NULL); return dictDelete(db-&gt;expires,key-&gt;ptr) == DICT_OK; // 删除&#125; 过期键的删除策略三种策略： 定时删除。定时删除占用cpu，可能使服务器长期无响应。但是对内存友好。 惰性删除，对键进行操作时，才删除。缺点是对内存不友好，过期键过多的话，没有及时清理。 定期删除。间隔依据算法确定。两者结合，主要看算法选择。 redis采用定期和惰性两种删除方式。 惰性删除redis在很多操作前都会调用expireIfNeeded进行惰性删除。例如lookupKeyRead。 123456789101112131415161718192021222324252627282930313233343536int expireIfNeeded(redisDb *db, robj *key) &#123; mstime_t when = getExpire(db,key); mstime_t now; // 无过期时间 if (when &lt; 0) return 0; /* No expire for this key */ // 正在加载不删除 if (server.loading) return 0; /* If we are in the context of a Lua script, we claim that time is * blocked to when the Lua script started. This way a key can expire * only the first time it is accessed and not in the middle of the * script execution, making propagation to slaves / AOF consistent. * See issue #1525 on Github for more information. */ now = server.lua_caller ? server.lua_time_start : mstime(); /* If we are running in the context of a slave, return ASAP: * the slave key expiration is controlled by the master that will * send us synthesized DEL operations for expired keys. * * Still we try to return the right information to the caller, * that is, 0 if we think the key should be still valid, 1 if * we think the key is expired at this time. */ if (server.masterhost != NULL) return now &gt; when; // 没过期，返回0 if (now &lt;= when) return 0; // 删除 server.stat_expiredkeys++; propagateExpire(db,key); notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED, "expired",key,db-&gt;id); return dbDelete(db,key);&#125; 定期删除redis服务器周期性操作serverCron函数执行时，activeExpireCycle被调用，它在规定时间内分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-对象]]></title>
      <url>%2F%2Fblog%2F2017%2F07%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1.html</url>
      <content type="text"><![CDATA[之前阅读了redis用到的主要的数据结构，这些数据结构是redis对象基础。redis在这些基础数据结构之上创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象五种类型的对象。 redis执行命令前，先判断命令是否能够执行给定命令。根据不同场合选择使用不同的数据结构。 对象的类型与编码redis使用对象来表示数据库中的键值，创建一个键值对时，会创建至少两个对象，一个对象用作键值对的键，一个对象用作键值对的值。 对象的结构体1234567typedef struct redisObject &#123; unsigned type:4; // 类型 unsigned encoding:4; // 编码 unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */ int refcount; // 引用计数 void *ptr; // 值&#125; robj; redis结构体使用位段结构节省空间 类型type记录redis对象类型，五种类型 12345#define REDIS_STRING 0 // 字符串对象#define REDIS_LIST 1 // 列表对象#define REDIS_SET 2 // 哈希对象#define REDIS_ZSET 3 // 集合对象#define REDIS_HASH 4 // 有序集合对象 编码encoding记录redis对象的编码 12345678910// 对象编码#define REDIS_ENCODING_RAW 0 /* 简单动态字符串 */#define REDIS_ENCODING_INT 1 /* long类型的整数 */#define REDIS_ENCODING_HT 2 /* 字典 */#define REDIS_ENCODING_ZIPMAP 3 /* zipmap 3.2.5不再使用 */#define REDIS_ENCODING_LINKEDLIST 4 /* 双端队列 */#define REDIS_ENCODING_ZIPLIST 5 /* 压缩列表 */#define REDIS_ENCODING_INTSET 6 /* 整数集合 */#define REDIS_ENCODING_SKIPLIST 7 /* 跳跃表 */#define REDIS_ENCODING_EMBSTR 8 /* EMBSTR编码的简单字符串 */ 每种类型对应至少两种不同的编码。 对象类型 编码方式 REDIS_STRING REDIS_ENCODING_RAW ,REDIS_ENCODING_INT ,REDIS_ENCODING_EMBSTR REDIS_LIST REDIS_ENCODING_LINKEDLIST ,REDIS_ENCODING_ZIPLIST REDIS_SET REDIS_ENCODING_INTSET ,REDIS_ENCODING_HT REDIS_ZSET REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_SKIPLIST REDIS_HASH REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_HT 访问时间表示对象的最后一次访问时间。 引用计数常见的管理方式，引用计数为0时回收。 对象的API123456789101112131415161718192021222324252627282930313233343536373839void decrRefCount(robj *o); // 引用计数-1，降为0时释放对象void decrRefCountVoid(void *o); // 用于特定数据结构的释放void incrRefCount(robj *o); // 引用计数+1robj *resetRefCount(robj *obj); // 设置引用计数为0void freeStringObject(robj *o); // 释放字符串对象void freeListObject(robj *o); // 释放列表对象void freeSetObject(robj *o); // 释放集合对象void freeZsetObject(robj *o); // 释放有序集合对象void freeHashObject(robj *o); // 释放hash对象robj *createObject(int type, void *ptr); // 创建一个新robj对象robj *createStringObject(char *ptr, size_t len); // 创建一个字符串对象，根据大小选择编码robj *createRawStringObject(char *ptr, size_t len);// 创建一个 REDIS_ENCODING_RAW 编码的字符对象robj *createEmbeddedStringObject(char *ptr, size_t len);// 创建一个 REDIS_ENCODING_EMBSTR 编码的字符对象robj *dupStringObject(robj *o); // 复制一个字符串对象int isObjectRepresentableAsLongLong(robj *o, long long *llongval); // 检查对象的值是否为Long longrobj *tryObjectEncoding(robj *o); // 尝试对字符串对象编码，以节约内存robj *getDecodedObject(robj *o); // 返回一个对象的编码版本size_t stringObjectLen(robj *o); // 返回字符串对象的字符串值的长度robj *createStringObjectFromLongLong(long long value); // 根据传入的值，创建一个字符串对象robj *createStringObjectFromLongDouble(long double value, int humanfriendly); // 根据传入的值，创建一个字符串对象robj *createListObject(void); // 创建一个linkedlist编码的列表对象robj *createZiplistObject(void); // 创建一个ziplist编码的列表对象robj *createSetObject(void); // 创建一个ht编码的集合对象robj *createIntsetObject(void); // 创建一个intset编码的集合对象robj *createHashObject(void); // 创建一个ziplist编码的哈希对象robj *createZsetObject(void); // 创建一个skiplist编码的有序集合robj *createZsetZiplistObject(void); // 创建一个ziplist编码的有序集合int getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg); // 尝试从对象中获取Long类型值int checkType(redisClient *c, robj *o, int type); // 检查对象0的类型是否和type相同int getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg); // 尝试从对象中取出整数值int getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg); // 尝试从对象中取出double值int getLongLongFromObject(robj *o, long long *target); // 尝试从对象中获取整数值int getLongDoubleFromObject(robj *o, long double *target); // 尝试从对象获取long double值int getLongDoubleFromObjectOrReply(redisClient *c, robj *o, long double *target, const char *msg); // 尝试从对象获取long double值char *strEncoding(int encoding); // 返回编码的字符串表示int compareStringObjects(robj *a, robj *b); // 二进制方式比较两个字符串对象int collateStringObjects(robj *a, robj *b); // 以collation方式比较两个字符串对象int equalStringObjects(robj *a, robj *b); // 判断是否相同两个字符串对象unsigned long long estimateObjectIdleTime(robj *o); // 计算对象的闲置时间 对象的创建对象的创建都比较类似，一般创建底层数据结构，然后创建对象。然后初始化。 以string对象为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 创建字符串对象robj *createStringObject(char *ptr, size_t len) &#123; // 长度小于39时使用EMBSTR if (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT) return createEmbeddedStringObject(ptr,len); else return createRawStringObject(ptr,len);&#125; // 创建一个embstr编码的字符串对象robj *createEmbeddedStringObject(char *ptr, size_t len) &#123; // 直接分配一个连续空间长度为redis和字符串结构+字符串保存内存 robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr)+len+1); struct sdshdr *sh = (void*)(o+1); // 找到字符串的起始位置 // 初始化字符串 o-&gt;type = REDIS_STRING; o-&gt;encoding = REDIS_ENCODING_EMBSTR; o-&gt;ptr = sh+1; o-&gt;refcount = 1; o-&gt;lru = LRU_CLOCK(); sh-&gt;len = len; sh-&gt;free = 0; if (ptr) &#123; memcpy(sh-&gt;buf,ptr,len); sh-&gt;buf[len] = '\0'; &#125; else &#123; memset(sh-&gt;buf,0,len+1); &#125; return o;&#125;// 创建一个 REDIS_ENCODING_RAW 编码的字符对象// 对象的指针指向一个 sds 结构robj *createRawStringObject(char *ptr, size_t len) &#123; // sdsnewlen新建字符串 return createObject(REDIS_STRING,sdsnewlen(ptr,len));&#125;// 创建一个新对象robj *createObject(int type, void *ptr) &#123; robj *o = zmalloc(sizeof(*o)); o-&gt;type = type; o-&gt;encoding = REDIS_ENCODING_RAW; o-&gt;ptr = ptr; o-&gt;refcount = 1; /* Set the LRU to the current lruclock (minutes resolution). */ o-&gt;lru = LRU_CLOCK(); return o;&#125; 对象的释放以字符串对象为例子，redis采用引用计数进行对象的释放，当对象不再使用时调用decrRefCount减少引用计数，在引用计数减到0后，释放对象。 123456789101112131415161718192021222324void decrRefCount(robj *o) &#123; if (o-&gt;refcount &lt;= 0) redisPanic("decrRefCount against refcount &lt;= 0"); if (o-&gt;refcount == 1) &#123; switch(o-&gt;type) &#123; // 根据类型释放 各个函数会调用各自的释放函数释放 case REDIS_STRING: freeStringObject(o); break; case REDIS_LIST: freeListObject(o); break; case REDIS_SET: freeSetObject(o); break; case REDIS_ZSET: freeZsetObject(o); break; case REDIS_HASH: freeHashObject(o); break; default: redisPanic("Unknown object type"); break; &#125; zfree(o); // 释放对象内存 &#125; else &#123; o-&gt;refcount--; &#125;&#125;// 如果时RAW编码调用sdsfree释放，否则在释放robj时就释放了，因为采用了embstr编码void freeStringObject(robj *o) &#123; if (o-&gt;encoding == REDIS_ENCODING_RAW) &#123; sdsfree(o-&gt;ptr); &#125;&#125; 字符串对象字符串编码可以是Int、raw或者embstr。 字符串对象为整数值，可以用long long类型表示，则为int编码。 字符串对象为浮点数，能够用long double类型表示，使用embstr还是raw根据长度来定。 如果一个字符串对象小于等于REDIS_ENCODING_EMBSTR_SIZE_LIMIT则用embstr编码。 大于REDIS_ENCODING_EMBSTR_SIZE_LIMIT采用raw编码。 int编码在执行一个会将int转变为字符串值时，编码变为raw。 embstr为只读的，当尝试修改时会转换为raw。 列表对象列表对象编码是ziplist或者linkedlist。 满足以下两个条件使用ziplist： 保存的字符串长度都小于64 元素数量小于512 哈希对象哈希对象编码是ziplist或者hashtable。 如果采用的是ziplist那么添加键值时，先将键推入压缩列表表尾部，再将值推入压缩列表表尾。 如果采用hashtable编码，那么字典的键就是键值对的键的字符串对象，字典的值时键值对的值。 满足以下两个条件使用ziplist： 保存的字符串长度都小于64 元素数量小于512 集合对象集合的编码是inset或者hashtable 满足以下条件使用intset编码： 集合对象保存的值都为整数 集合对象保存的元素不超过512个 有序集合对象有序集合编码是ziplist或者skiplist。 skiplist编码使用一个zskiplist和dict作为底层实现。zskiplist按照分值从大到小保存集合元素。dict保存从成员到分值的映射。 满足以下条件使用ziplist编码： 有序集合保存的元素小于128个。 有序集合保存的所有元素成员的长度都小于64字节。 命令对象的命令处理在redis.h中。执行命令之前会检查对象的类型，是否能够执行该命令。如果能就调用对象的命令处理函数,否则返回错误。 在调用了对象的命令处理函数之后，则根据命令具体的编码，去选择使用什么底层数据结构的接口来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* Commands prototypes */void authCommand(redisClient *c);void pingCommand(redisClient *c);void echoCommand(redisClient *c);void setCommand(redisClient *c);void setnxCommand(redisClient *c);void setexCommand(redisClient *c);void psetexCommand(redisClient *c);void getCommand(redisClient *c);void delCommand(redisClient *c);void existsCommand(redisClient *c);void setbitCommand(redisClient *c);void getbitCommand(redisClient *c);void setrangeCommand(redisClient *c);void getrangeCommand(redisClient *c);void incrCommand(redisClient *c);void decrCommand(redisClient *c);void incrbyCommand(redisClient *c);void decrbyCommand(redisClient *c);void incrbyfloatCommand(redisClient *c);void selectCommand(redisClient *c);void randomkeyCommand(redisClient *c);void keysCommand(redisClient *c);void scanCommand(redisClient *c);void dbsizeCommand(redisClient *c);void lastsaveCommand(redisClient *c);void saveCommand(redisClient *c);void bgsaveCommand(redisClient *c);void bgrewriteaofCommand(redisClient *c);void shutdownCommand(redisClient *c);void moveCommand(redisClient *c);void renameCommand(redisClient *c);void renamenxCommand(redisClient *c);void lpushCommand(redisClient *c);void rpushCommand(redisClient *c);void lpushxCommand(redisClient *c);void rpushxCommand(redisClient *c);void linsertCommand(redisClient *c);void lpopCommand(redisClient *c);void rpopCommand(redisClient *c);void llenCommand(redisClient *c);void lindexCommand(redisClient *c);void lrangeCommand(redisClient *c);void ltrimCommand(redisClient *c);void typeCommand(redisClient *c);void lsetCommand(redisClient *c);void saddCommand(redisClient *c);void sremCommand(redisClient *c);void smoveCommand(redisClient *c);void sismemberCommand(redisClient *c);void scardCommand(redisClient *c);void spopCommand(redisClient *c);void srandmemberCommand(redisClient *c);void sinterCommand(redisClient *c);void sinterstoreCommand(redisClient *c);void sunionCommand(redisClient *c);void sunionstoreCommand(redisClient *c);void sdiffCommand(redisClient *c);void sdiffstoreCommand(redisClient *c);void sscanCommand(redisClient *c);void syncCommand(redisClient *c);void flushdbCommand(redisClient *c);void flushallCommand(redisClient *c);void sortCommand(redisClient *c);void lremCommand(redisClient *c);void rpoplpushCommand(redisClient *c);void infoCommand(redisClient *c);void mgetCommand(redisClient *c);void monitorCommand(redisClient *c);void expireCommand(redisClient *c);void expireatCommand(redisClient *c);void pexpireCommand(redisClient *c);void pexpireatCommand(redisClient *c);void getsetCommand(redisClient *c);void ttlCommand(redisClient *c);void pttlCommand(redisClient *c);void persistCommand(redisClient *c);void slaveofCommand(redisClient *c);void debugCommand(redisClient *c);void msetCommand(redisClient *c);void msetnxCommand(redisClient *c);void zaddCommand(redisClient *c);void zincrbyCommand(redisClient *c);void zrangeCommand(redisClient *c);void zrangebyscoreCommand(redisClient *c);void zrevrangebyscoreCommand(redisClient *c);void zrangebylexCommand(redisClient *c);void zrevrangebylexCommand(redisClient *c);void zcountCommand(redisClient *c);void zlexcountCommand(redisClient *c);void zrevrangeCommand(redisClient *c);void zcardCommand(redisClient *c);void zremCommand(redisClient *c);void zscoreCommand(redisClient *c);void zremrangebyscoreCommand(redisClient *c);void zremrangebylexCommand(redisClient *c);void multiCommand(redisClient *c);void execCommand(redisClient *c);void discardCommand(redisClient *c);void blpopCommand(redisClient *c);void brpopCommand(redisClient *c);void brpoplpushCommand(redisClient *c);void appendCommand(redisClient *c);void strlenCommand(redisClient *c);void zrankCommand(redisClient *c);void zrevrankCommand(redisClient *c);void hsetCommand(redisClient *c);void hsetnxCommand(redisClient *c);void hgetCommand(redisClient *c);void hmsetCommand(redisClient *c);void hmgetCommand(redisClient *c);void hdelCommand(redisClient *c);void hlenCommand(redisClient *c);void zremrangebyrankCommand(redisClient *c);void zunionstoreCommand(redisClient *c);void zinterstoreCommand(redisClient *c);void zscanCommand(redisClient *c);void hkeysCommand(redisClient *c);void hvalsCommand(redisClient *c);void hgetallCommand(redisClient *c);void hexistsCommand(redisClient *c);void hscanCommand(redisClient *c);void configCommand(redisClient *c);void hincrbyCommand(redisClient *c);void hincrbyfloatCommand(redisClient *c);void subscribeCommand(redisClient *c);void unsubscribeCommand(redisClient *c);void psubscribeCommand(redisClient *c);void punsubscribeCommand(redisClient *c);void publishCommand(redisClient *c);void pubsubCommand(redisClient *c);void watchCommand(redisClient *c);void unwatchCommand(redisClient *c);void clusterCommand(redisClient *c);void restoreCommand(redisClient *c);void migrateCommand(redisClient *c);void askingCommand(redisClient *c);void readonlyCommand(redisClient *c);void readwriteCommand(redisClient *c);void dumpCommand(redisClient *c);void objectCommand(redisClient *c);void clientCommand(redisClient *c);void evalCommand(redisClient *c);void evalShaCommand(redisClient *c);void scriptCommand(redisClient *c);void timeCommand(redisClient *c);void bitopCommand(redisClient *c);void bitcountCommand(redisClient *c);void bitposCommand(redisClient *c);void replconfCommand(redisClient *c);void waitCommand(redisClient *c);void pfselftestCommand(redisClient *c);void pfaddCommand(redisClient *c);void pfcountCommand(redisClient *c);void pfmergeCommand(redisClient *c);void pfdebugCommand(redisClient *c);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-压缩列表ziplist]]></title>
      <url>%2F%2Fblog%2F2017%2F07%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist.html</url>
      <content type="text"><![CDATA[压缩列表时列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么是小整数，要么是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。 压缩列表的构成压缩列表是redis为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数组。 1234567891011121314151617181920212223242526272829303132《redis设计与实现》空白 ziplist 示例图area |&lt;---- ziplist header ----&gt;|&lt;-- end --&gt;|size 4 bytes 4 bytes 2 bytes 1 byte +---------+--------+-------+-----------+component | zlbytes | zltail | zllen | zlend | | | | | |value | 1011 | 1010 | 0 | 1111 1111 | +---------+--------+-------+-----------+ ^ | ZIPLIST_ENTRY_HEAD &amp;address ZIPLIST_ENTRY_TAIL &amp; ZIPLIST_ENTRY_END非空 ziplist 示例图area |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|size 4 bytes 4 bytes 2 bytes ? ? ? ? 1 byte +---------+--------+-------+--------+--------+--------+--------+-------+component | zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend | +---------+--------+-------+--------+--------+--------+--------+-------+ ^ ^ ^address | | | ZIPLIST_ENTRY_HEAD | ZIPLIST_ENTRY_END | ZIPLIST_ENTRY_TAIL zlbytes记录整个压缩列表占用的字节数。 zltail记录压缩列表尾节点距离压缩列表的起始地址有多少字节。 zzlen记录压缩列表包含的节点数量。 entryX列表节点，数量不定。 zlend特殊值0xff，标记压缩列表末端。 压缩列表节点的构成每个压缩列表可以保存一个字节数组或者一个整数值，字节数组可以有三种长度： 长度小于等于63字节的字节数组 长度小于等于16383字节的字节数组 长度小于等于4294967295字节的字节数组 每个压缩列表节点由previous_entry_length、encoding、content三个部分组成。 previous_entry_length节点previous_entry_length属性以字节为单位，记录一个压缩列表节点的长度。previous_entry_length属性的长度可以是1字节或者5字节： 如果前一节点的长度小于254字节，长度为1,前一节点长度保存在这个字节里面。 如果前一节点的长度大于 等于254字节，长度为5：属性的第一个字节被设置为0xfe，而之后的四个字节用于保存前一 节点的长度。 encoding记录节点的content属性所保存数据类型以及长度： 一字节、两字节或者五字节长，值的最高位为00、01或者10的是 字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录 一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数数值，整数值的类型和长度由编码除去最高两位之后的其他位记录。 编码 编码长度 content属性保存的值 00bbbbbb 1 bytes &lt;= 63 bytes的字节数组 01bbbbbb xxxxxxxx 2 bytes &lt;= 16383 bytes字节数组 10__ aaaaaaaa bbbbbbbb cccccccc dddddddd 5 bytes &lt;= 4294967295 bytes字节数组 编码 编码长度 content属性保存的值 11000000 1 int16_t（2 bytes）类型整数 11010000 1 int32_t（4 bytes）类型整数 11100000 1 int64_t（8 bytes）类型整数 11110000 1 24位有符整数 11111110 1 8位有符整数 1111xxxx 1 0~12 content节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。 连锁更新previous_entry_length属性的长度可以是1字节或者5字节： 如果前一节点的长度小于254字节，长度为1,前一节点长度保存在这个字节里面。 如果前一节点的长度大于 等于254字节，长度为5：属性的第一个字节被设置为0xfe，而之后的四个字节用于保存前一 节点的长度。 那么一种情况：在压缩列表中，有多个连续的长度介于250字节到253字节之间的节点e1至eN。 在e1前插入一个大于254字节的节点，此时要更新e1的previous_entry_length属性，由于前一个节点大于254，那么要扩容，重新设置好压缩列表。之后又发现e2需要更新previous_entry_length属性，依旧大于254。产生了连锁反应。 同理删除节点也可能发生这种情况。 压缩列表API创建空ziplist123456789101112// 创建一个空的ziplistunsigned char *ziplistNew(void) &#123; // ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小 // 1 字节是表末端 ZIP_END 的大小 unsigned int bytes = ZIPLIST_HEADER_SIZE+1; unsigned char *zl = zmalloc(bytes); ZIPLIST_BYTES(zl) = intrev32ifbe(bytes); // 设置ziplist所占字节数，如有必要进行大小端转换 ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE); // 设定尾节点相对头部的偏移量 ZIPLIST_LENGTH(zl) = 0; // 设定ziplist的节点数 zl[bytes-1] = ZIP_END; // 设定尾部字节位0xff return zl;&#125; 插入节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) &#123; return __ziplistInsert(zl,p,s,slen);&#125;// 将长度为slen的字符串s插入到z1中，位置为p前static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) &#123; size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen; // 当前ziplist长度，插入后的长度 unsigned int prevlensize, prevlen = 0; // 前置节点长度和编码该长度所需要的长度 size_t offset; int nextdiff = 0; unsigned char encoding = 0; long long value = 123456789; /* initialized to avoid warning. Using a value that is easy to see if for some reason we use it uninitialized. */ zlentry tail; /* Find out prevlen for the entry that is inserted. */ // 找到待插入节点的前置节点长度 if (p[0] != ZIP_END) &#123; // 不为末尾解码长度 ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); &#125; else &#123; // 指向末尾则表示ziplist为空 unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl); if (ptail[0] != ZIP_END) &#123; // 计算尾节点长度 prevlen = zipRawEntryLength(ptail); &#125; &#125; // 判断编码是否为整数 if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123; // 该节点编码为整数，通过encoding来获取编码长度 reqlen = zipIntSize(encoding); &#125; else &#123; // 使用字符串来编码节点 reqlen = slen; &#125; // 计算前置节点长度所需的大小 reqlen += zipPrevEncodeLength(NULL,prevlen); // 计算编码当前节点值所需要的大小 reqlen += zipEncodeLength(NULL,encoding,slen); // 保存新旧编码之间的字节差 nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0; offset = p-zl; // 保存偏移 // 重分配长度 zl = ziplistResize(zl,curlen+reqlen+nextdiff); p = zl+offset; if (p[0] != ZIP_END) &#123; // 移动元素，为新元素腾出位置 memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff); // 将新节点的长度编码到后置节点 zipPrevEncodeLength(p+reqlen,reqlen); // 更新尾部的偏移量 ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen); /* When the tail contains more than one entry, we need to take * "nextdiff" in account as well. Otherwise, a change in the * size of prevlen doesn't have an effect on the *tail* offset. */ tail = zipEntry(p+reqlen); if (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123; ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff); &#125; &#125; else &#123; /* This element will be the new tail. */ ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl); &#125; /* When nextdiff != 0, the raw length of the next entry has changed, so * we need to cascade the update throughout the ziplist */ // 判断是不是需要连锁更新 if (nextdiff != 0) &#123; offset = p-zl; zl = __ziplistCascadeUpdate(zl,p+reqlen); p = zl+offset; &#125; /* Write the entry */ // 写入节点前置节点长度 p += zipPrevEncodeLength(p,prevlen); // 节点值的长度写入节点 p += zipEncodeLength(p,encoding,slen); // 写入节点值 if (ZIP_IS_STR(encoding)) &#123; memcpy(p,s,slen); &#125; else &#123; zipSaveInteger(p,value,encoding); &#125; // 更新节点计数器 ZIPLIST_INCR_LENGTH(zl,1); return zl;&#125; 根据给定索引，遍历列表，并返回索引指定节点的指针。123456789101112131415161718192021222324252627unsigned char *ziplistIndex(unsigned char *zl, int index) &#123; unsigned char *p; unsigned int prevlensize, prevlen = 0; // index为负从尾部，正从头部 if (index &lt; 0) &#123; index = (-index)-1; // 获取尾部指针 p = ZIPLIST_ENTRY_TAIL(zl); if (p[0] != ZIP_END) &#123; // 解码前置节点长度 ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); while (prevlen &gt; 0 &amp;&amp; index--) &#123; p -= prevlen; // 偏移 // 解码前置节点长度 ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); &#125; &#125; &#125; else &#123; p = ZIPLIST_ENTRY_HEAD(zl); // 头部 while (p[0] != ZIP_END &amp;&amp; index--) &#123; p += zipRawEntryLength(p); // 移动 &#125; &#125; // 返回 return (p[0] == ZIP_END || index &gt; 0) ? NULL : p;&#125; 删除给定节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) &#123; size_t offset = *p-zl; zl = __ziplistDelete(zl,*p,1); /* Store pointer to current element in p, because ziplistDelete will * do a realloc which might result in a different "zl"-pointer. * When the delete direction is back to front, we might delete the last * entry and end up with "p" pointing to ZIP_END, so check this. */ *p = zl+offset; return zl;&#125;static unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) &#123; unsigned int i, totlen, deleted = 0; size_t offset; int nextdiff = 0; zlentry first, tail; // 计算被删除节点总共占用的内存字节数 // 删除的节点总数 first = zipEntry(p); for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) &#123; p += zipRawEntryLength(p); deleted++; &#125; totlen = p-first.p; // 被删除节点总共占用内存字节数 if (totlen &gt; 0) &#123; if (p[0] != ZIP_END) &#123; // 计算新旧前置节点字节数差 nextdiff = zipPrevLenByteDiff(p,first.prevrawlen); p -= nextdiff; // 有需要将p后退nextdiff字节，为新header空出空间 zipPrevEncodeLength(p,first.prevrawlen); // 将first的前置节点长度编码至p中 /* Update offset for tail */ // 更新尾部偏移 ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen); /* When the tail contains more than one entry, we need to take * "nextdiff" in account as well. Otherwise, a change in the * size of prevlen doesn't have an effect on the *tail* offset. */ // 被删除节点之后还存在节点，就需要将nextdiff计算在内 tail = zipEntry(p); if (p[tail.headersize+tail.len] != ZIP_END) &#123; ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff); &#125; /* Move tail to the front of the ziplist */ // 将删除节点后面内存空间移动到删除节点之后 memmove(first.p,p, intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1); &#125; else &#123; /* The entire tail was deleted. No need to move memory. */ // 被删除节点后无节点，不需要移动 ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe((first.p-zl)-first.prevrawlen); &#125; /* Resize and update length */ // 更新ziplist长度 offset = first.p-zl; zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff); ZIPLIST_INCR_LENGTH(zl,-deleted); p = zl+offset; /* When nextdiff != 0, the raw length of the next entry has changed, so * we need to cascade the update throughout the ziplist */ // 看看是否需要连锁更新 if (nextdiff != 0) zl = __ziplistCascadeUpdate(zl,p); &#125; return zl;&#125; 小结整体上ziplist设计出来的目的是为了节省内存，采用了在连续内存空间上建立一个双向列表来实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-整数集合]]></title>
      <url>%2F%2Fblog%2F2017%2F07%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88.html</url>
      <content type="text"><![CDATA[创建一个只包含整数值元素的集合，同时元素数量不多时，redis会使用整数集合作为键的底层实现。 整数集合的实现12345typedef struct intset &#123; uint32_t encoding; // 编码方式 uint32_t length; // 元素数量 int8_t contents[]; // 保存元素的数组&#125; intset; encoding表示整数集合的编码模式，目前提供三种模式 123#define INTSET_ENC_INT16 (sizeof(int16_t))#define INTSET_ENC_INT32 (sizeof(int32_t))#define INTSET_ENC_INT64 (sizeof(int64_t)) 升级整数集合有三种编码模式，为了能够节省空间，一般采用能够符合所有元素要求的编码。 当新添加元素比整数集合中现有元素类型都长，那么就需要进行升级，将编码位数提升，负荷新添加元素类型长度。 步骤： 根据新元素的类型，扩展整数集合底层数组空间大小，并为新元素分配空间。 将底层数组现有的所有元素都转换为新元素相同的类型，并将类型转换后的元素放置到正确的位置上。 将新元素添加到数组中。 12345678910111213141516171819202122static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123; uint8_t curenc = intrev32ifbe(is-&gt;encoding); // 当前编码 uint8_t newenc = _intsetValueEncoding(value); // 获取编码 int length = intrev32ifbe(is-&gt;length); // 元素数量 int prepend = value &lt; 0 ? 1 : 0; // 根据情况判断添加到数组的最前还是最后（要升级只有这种可能） is-&gt;encoding = intrev32ifbe(newenc); // 更新编码方式 // 重新分配空间 is = intsetResize(is,intrev32ifbe(is-&gt;length)+1); // 从后往前重新编码 while(length--) _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc)); // 根据情况添加到尾部后者头部 if (prepend) _intsetSet(is,0,value); else _intsetSet(is,intrev32ifbe(is-&gt;length),value); is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1); return is;&#125; 整数集合API创建123456789intset *intsetNew(void) &#123; // 分配空间 intset *is = zmalloc(sizeof(intset)); // 设置初始编码 is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16); // 初始化元素数量 is-&gt;length = 0; return is;&#125; 添加元素判断数据大小，如果超出现有编码的范围，升级。 如果没有，则插入到指定位置。 1234567891011121314151617181920212223242526272829intset *intsetAdd(intset *is, int64_t value, uint8_t *success) &#123; uint8_t valenc = _intsetValueEncoding(value); // 计算新插入值编码 uint32_t pos; if (success) *success = 1; // 如果需要则升级 if (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123; return intsetUpgradeAndAdd(is,value); &#125; else &#123; // 查找，如果存在返回失败信息 if (intsetSearch(is,value,&amp;pos)) &#123; if (success) *success = 0; return is; &#125; // 重新分配空间 is = intsetResize(is,intrev32ifbe(is-&gt;length)+1); // 如果插入中间位置，则将该位置之后的值移动到尾部 if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+1); &#125; // 设置值 _intsetSet(is,pos,value); // 计数器增加 is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1); return is;&#125; 移除数据123456789101112131415161718intset *intsetRemove(intset *is, int64_t value, int *success) &#123; uint8_t valenc = _intsetValueEncoding(value); // 计算编码方式 uint32_t pos; if (success) *success = 0; // 查找值，并删除 if (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123; uint32_t len = intrev32ifbe(is-&gt;length); // 删除成功标志 if (success) *success = 1; // 删除数据 if (pos &lt; (len-1)) intsetMoveTail(is,pos+1,pos); // 调整内存大小 is = intsetResize(is,len-1); // 更新length值 is-&gt;length = intrev32ifbe(len-1); &#125; return is;&#125; 其他API intsetFind 判断值是否在集合中 intsetRandom 随机返回整数集合中的一个数 intsetGet 取出底层数组在给定索引上的元素 intsetLen 返回整数集合中的元素个数 intsetloblen 返回整数集合占用的内存字节数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-跳跃表]]></title>
      <url>%2F%2Fblog%2F2017%2F07%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8.html</url>
      <content type="text"><![CDATA[跳跃表一种有序数据结构，每个节点维护多个指向其他节点的指针，达到快速访问节点的目的。 大部分情况下跳跃表的效率可以和平衡数媲美，实现比平衡树简单，不少程序使用跳跃表来代替平衡树。 跳跃表有时会作为有序集合的实现。以分值排序。 结构体1234567891011121314151617// 跳跃表节点typedef struct zskiplistNode &#123; robj *obj; // 保存的对象 double score; // 分值 跳跃表按照分值进行排序 struct zskiplistNode *backward; // 上一节点 struct zskiplistLevel &#123; struct zskiplistNode *forward; // 前进指针 unsigned int span; // 跨度 记录两个节点之间的距离 &#125; level[]; // 层&#125; zskiplistNode;// 跳跃表typedef struct zskiplist &#123; struct zskiplistNode *header, *tail; // 头、尾指针 PORT_ULONG length; // 跳跃表长度 int level; // 层数最大节点层数&#125; zskiplist; 跳跃表的创建1234567891011121314151617181920212223242526272829303132// 创建节点zskiplistNode *zslCreateNode(int level, double score, robj *obj) &#123; // 申请内存 zskiplistNode *zn = zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel)); zn-&gt;score = score; // 赋值分数 zn-&gt;obj = obj; // 设定成员对象 return zn;&#125;// 创建跳跃表zskiplist *zslCreate(void) &#123; int j; zskiplist *zsl; // 申请内存 zsl = zmalloc(sizeof(*zsl)); zsl-&gt;level = 1; // 设置层数初始为1 zsl-&gt;length = 0; // 设置长度初始为0 // 创建头节点 层数为32 分数为0 zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL); // 将每层的forward指针指向null，跨度0 for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123; zsl-&gt;header-&gt;level[j].forward = NULL; zsl-&gt;header-&gt;level[j].span = 0; &#125; // 设定backward指向null zsl-&gt;header-&gt;backward = NULL; zsl-&gt;tail = NULL; return zsl;&#125; 插入节点逻辑是先找到节点插入位置，插入位置前一个节点的信息。插入，并更新前一节点信息。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 创建一个成员为obj，分值为score的新节点// 将新节点插入到跳跃表中zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) &#123; // updata[]数组记录每一层位于插入节点的前一个节点 zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; // rank[]记录每一层位于插入节点的前一个节点的排名 unsigned int rank[ZSKIPLIST_MAXLEVEL]; int i, level; redisAssert(!isnan(score)); x = zsl-&gt;header; // 表头节点 // 从最高层开始查找 for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123; // i == (zsl-&gt;level-1) 为0 //否则第i层起始rank值为i+1的rank值 // 最终rank[0]的值+1就是新节点的前置节点排位 rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1]; // 沿着前几指针遍历跳跃表 while (x-&gt;level[i].forward &amp;&amp; // 比对分值 (x-&gt;level[i].forward-&gt;score &lt; score || // 比对成员 (x-&gt;level[i].forward-&gt;score == score &amp;&amp; compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; 0))) &#123; // 记录沿途跨越多少节点 rank[i] += x-&gt;level[i].span; // 移动到下一个指针 x = x-&gt;level[i].forward; &#125; // 记录将要和新节点相连接的节点 update[i] = x; &#125; * // zslInsert() 的调用者会确保同分值且同成员的元素不会出现， // 所以这里不需要进一步进行检查，可以直接创建新元素。 // 获取一个随机值作为新节点的层数 level = zslRandomLevel(); // 如果新节点的层数比其他节点层数大 if (level &gt; zsl-&gt;level) &#123; // 初始化未使用层 for (i = zsl-&gt;level; i &lt; level; i++) &#123; rank[i] = 0; update[i] = zsl-&gt;header; update[i]-&gt;level[i].span = zsl-&gt;length; &#125; zsl-&gt;level = level; &#125; // 创建新节点 x = zslCreateNode(level,score,obj); // 将前面记录的指针指向新节点，并做相应的设置 for (i = 0; i &lt; level; i++) &#123; // 设置新节点的前进指针 x-&gt;level[i].forward = update[i]-&gt;level[i].forward; update[i]-&gt;level[i].forward = x; // 将沿途记录的各个节点的前进指针指向新节点 /* update span covered by update[i] as x is inserted here */ // 计算新节点跨越的节点数量 x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]); // 更新新节点插入后，沿途节点的span值 update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1; &#125; /* increment span for untouched levels */ // 未接触的节点的span值也需要增加1，这些节点从表头指向新节点 for (i = level; i &lt; zsl-&gt;level; i++) &#123; update[i]-&gt;level[i].span++; &#125; // 设置新节点的后退指针 x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0]; if (x-&gt;level[0].forward) x-&gt;level[0].forward-&gt;backward = x; else zsl-&gt;tail = x; // 长度+1 zsl-&gt;length++; return x;&#125; 删除节点Redis提供三种删除跳跃表节点的方式： 根据给定分值和成员来删除节点，zslDelete。 根据给定分值来删除节点，zslDeleteByScore。 根据给定排名来删除节点，zslDeleteByRank。 删除操作均由zslDeleteNode执行。123456789101112131415161718192021222324void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) &#123; int i; // 更新所有和被删除节点x有关的节点指针，解除它们之间的关系 for (i = 0; i &lt; zsl-&gt;level; i++) &#123; if (update[i]-&gt;level[i].forward == x) &#123; update[i]-&gt;level[i].span += x-&gt;level[i].span - 1; update[i]-&gt;level[i].forward = x-&gt;level[i].forward; &#125; else &#123; update[i]-&gt;level[i].span -= 1; &#125; &#125; // 更新被删除节点x的前进后退指针 if (x-&gt;level[0].forward) &#123; x-&gt;level[0].forward-&gt;backward = x-&gt;backward; &#125; else &#123; zsl-&gt;tail = x-&gt;backward; &#125; // 更新跳跃表的最大层数 while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL) zsl-&gt;level--; // 计数器-1 zsl-&gt;length--;&#125; 根据节点的分值和成员删除节点,其余两种情况只是查找方法与判断方式不同。123456789101112131415161718192021222324int zslDelete(zskiplist *zsl, double score, robj *obj) &#123; zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; int i; // 遍历跳跃表，查找目标节点，并记录所有沿途及节点 x = zsl-&gt;header; for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123; while (x-&gt;level[i].forward &amp;&amp; (x-&gt;level[i].forward-&gt;score &lt; score || (x-&gt;level[i].forward-&gt;score == score &amp;&amp; compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; 0))) x = x-&gt;level[i].forward; update[i] = x; &#125; // 分值和对象相同时，将其删除 x = x-&gt;level[0].forward; if (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123; zslDeleteNode(zsl, x, update); zslFreeNode(x); return 1; &#125; return 0; /* not found */&#125; 查找给定分值和成员对象的节点在跳跃表中的排位123456789101112131415161718192021222324252627282930313233unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) &#123; zskiplistNode *x; unsigned long rank = 0; int i; // 遍历整个跳跃表 x = zsl-&gt;header; for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123; // 遍历节点并对比元素 while (x-&gt;level[i].forward &amp;&amp; (x-&gt;level[i].forward-&gt;score &lt; score || // 比对分值 (x-&gt;level[i].forward-&gt;score == score &amp;&amp; // 比对成员对象 compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= 0))) &#123; // 累积跨越的节点数量 rank += x-&gt;level[i].span; // 沿着前进指针遍历跳跃表 x = x-&gt;level[i].forward; &#125; // 必须确保不仅分值相等，而且成员对象也要相等 if (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123; return rank; &#125; &#125; // 没找到 return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-字典]]></title>
      <url>%2F%2Fblog%2F2017%2F06%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8.html</url>
      <content type="text"><![CDATA[Redis字典由哈希表实现的保存键值对的抽象数据结构。 实现文件在dict.h\dict.c中。 哈希表Redis字典结构体定义。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef struct dictEntry &#123; void *key;// key 键 union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v;// 值，支持多种类型,使用联合。 struct dictEntry *next;// 下一个点 采用链式来解决索引冲突问题&#125; dictEntry;typedef struct dictType &#123; unsigned int (*hashFunction)(const void *key);// hash函数 void *(*keyDup)(void *privdata, const void *key);// key复制函数 void *(*valDup)(void *privdata, const void *obj);// value复制函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2);// key比较函数 void (*keyDestructor)(void *privdata, void *key);// key释放函数 void (*valDestructor)(void *privdata, void *obj);// value释放函数&#125; dictType;/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */typedef struct dictht &#123; dictEntry **table;// 指针的数组头的指针 unsigned long size;// 大小 unsigned long sizemask;// 大小的掩码 总是等于size-1 unsigned long used;// 被使用的节点数&#125; dictht;// hash表typedef struct dict &#123; dictType *type;// 绑定的函数 void *privdata;// 私有数据 dictht ht[2];// hash表，一般只使用[0]，在rehash的时候使用[1] long rehashidx; // 记录rehash的进度，不进行rehash的时候为-1 int iterators; /* number of iterators currently running */&#125; dict;// 字典/* If safe is set to 1 this is a safe iterator, that means, you can call * dictAdd, dictFind, and other functions against the dictionary even while * iterating. Otherwise it is a non safe iterator, and only dictNext() * should be called while iterating. */typedef struct dictIterator &#123; dict *d; long index; int table, safe; dictEntry *entry, *nextEntry; /* unsafe iterator fingerprint for misuse detection. */ long long fingerprint;&#125; dictIterator;// 迭代器 哈希算法确认一个键值插入到字典的位置是哪，需要调用hash算法 12345//计算key的hash值hash = dict-&gt;type-&gt;hashFunction(key);//按位与确认在hash表中的位置//根据情况，可能是ht[0]或者ht[1]index = hash &amp; dict-&gt;ht[x].sizemask; 字典在redis中使用MurmurHash2算法进行计算键的哈希值。有点在于计算速度非常快，即使输入的键有规律也能够很好的给出一个随机分布。 键的冲突解决在key获取的index相同的情况下，产生了键的冲突。redis采用链式解决冲突，新的键值放在链的头部。 rehash随着hash表不断插入删除数据，hash表的负载因子会不断变化。当负载因子在一个不合理的范围内，则redis的会对hash表进行rehash。 渐进式 rehash渐进式rehash的目的是为了防止一次性rehash的情况下，服务器停止响应。 redis渐进式rehash的步骤: 1）为ht[1]分配空间，让字典同时持有 ht[0]和ht[1]两个哈希表 2）在字典位置一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。 3）在rehash进行期间，每次对字典执行删除、添加、查找或者更新操作时候，程序除了执行指定的操作外，还顺便将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后将rehashidx属性的值增加1 4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehsh至ht[1]，这时程序将rehashidx属性值设为-1，表示rehash操作已完成。 渐进式rehash过程中，字典会同时对ht[0]和ht[1]两个哈希表进行操作，字典在删除、查找、更新等操作会在两个哈希表进行。 在渐进式rehash执行期间，新添加到字典的键值对一律会被保存在ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减少不增加，并随着rehash操作的执行最终变为空。 rehash有两种方式，一种是单步，在字典没有安全迭代器的情况下能够执行。一种是执行一段时间跳出。两种方法均调用int dictRehash(dict *d, int n) 完成。 123static void _dictRehashStep(dict *d) &#123; if (d-&gt;iterators == 0) dictRehash(d,1);&#125; 12345678910111213int dictRehashMilliseconds(dict *d, int ms) &#123; // 开始时间 long long start = timeInMilliseconds(); int rehashes = 0; while(dictRehash(d,100)) &#123; rehashes += 100; // 时间到达，跳出 if (timeInMilliseconds()-start &gt; ms) break; &#125; return rehashes;&#125; int dictRehash(dict *d, int n) 算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 //执行N步渐进式rehash操作，rehash之后如果旧表还存在数据，则返回1，不存在返回0int dictRehash(dict *d, int n) &#123; int empty_visits = n*10; // 最大允许访问的空桶值 if (!dictIsRehashing(d)) return 0; // 判断是否允许rehash while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123; dictEntry *de, *nextde; // rehashidx不能大于哈希表的大小 assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx); // 跳过空节点 while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123; d-&gt;rehashidx++; // 超过空节点最大值，直接跳出 if (--empty_visits == 0) return 1; &#125; // 获取需要rehash的节点 de = d-&gt;ht[0].table[d-&gt;rehashidx]; // 将该桶下所有节点移动到新表 while(de) &#123; unsigned int h; nextde = de-&gt;next; // 获取新表中hash索引 h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask; de-&gt;next = d-&gt;ht[1].table[h]; d-&gt;ht[1].table[h] = de; d-&gt;ht[0].used--; d-&gt;ht[1].used++; de = nextde; &#125; d-&gt;ht[0].table[d-&gt;rehashidx] = NULL; d-&gt;rehashidx++; &#125; // 判断是否都迁移完成，完成返回0 if (d-&gt;ht[0].used == 0) &#123; // 释放旧表,将rehashidx设置为-1 zfree(d-&gt;ht[0].table); d-&gt;ht[0] = d-&gt;ht[1]; _dictReset(&amp;d-&gt;ht[1]); d-&gt;rehashidx = -1; return 0; &#125; // 未完成返回1 return 1;&#125; dict部分API1234567891011121314151617181920dict *dictCreate(dictType *type, void *privDataPtr); // 创建一个新字典int dictExpand(dict *d, unsigned long size); // 在字典中创建一个新hash表int dictAdd(dict *d, void *key, void *val); // 尝试将给定键值添加到字典中dictEntry *dictAddRaw(dict *d, void *key); // 尝试将给定键插入到字典中，键已经存在则返回nullint dictReplace(dict *d, void *key, void *val); // 将给定键值添加到字典中，如果已经存在就替换dictEntry *dictReplaceRaw(dict *d, void *key); // 将给定键值添加到字典中，如果已经存在则不添加，返回已经存在的值int dictDelete(dict *d, const void *key); // 删除字典中给定键的节点int dictDeleteNoFree(dict *d, const void *key);// 删除包含给定键的及诶单，但是不释放void dictRelease(dict *d); // 删除并释放整个字典dictEntry * dictFind(dict *d, const void *key); // 查找节点void *dictFetchValue(dict *d, const void *key); // 获取包含给定键的节点值int dictResize(dict *d); // 缩小字典，使得已用节点和字典大小比率接近1:1dictIterator *dictGetIterator(dict *d); // 创建并返回给定字典的不安全迭代器dictIterator *dictGetSafeIterator(dict *d); // 创建并返回给定节点的安全迭代器dictEntry *dictNext(dictIterator *iter); // 返回当前节点，指向下个节点void dictReleaseIterator(dictIterator *iter); // 释放迭代器dictEntry *dictGetRandomKey(dict *d); // 随机返回字典中一个节点void dictEmpty(dict *d, void(callback)(void*)); // 清空字典中所有哈希表节点，并重置属性void dictEnableResize(void); // 开启自动rehashvoid dictDisableResize(void); // 关闭自动rehash 创建dict使用dictCreate创建字典。 123456789101112131415161718192021222324252627282930313233// 创建字典dict *dictCreate(dictType *type, void *privDataPtr)&#123; // 分配空间 dict *d = zmalloc(sizeof(*d)); // 初始化字典 _dictInit(d,type,privDataPtr); return d;&#125;static void _dictReset(dictht *ht)&#123; ht-&gt;table = NULL; ht-&gt;size = 0; ht-&gt;sizemask = 0; ht-&gt;used = 0;&#125;// 初始化字典int _dictInit(dict *d, dictType *type, void *privDataPtr)&#123; // 重置hash表 _dictReset(&amp;d-&gt;ht[0]); _dictReset(&amp;d-&gt;ht[1]); d-&gt;type = type; // 设置字典类型 d-&gt;privdata = privDataPtr; d-&gt;rehashidx = -1; // 初始为-1，表明没有进行rehash d-&gt;iterators = 0; //正在使用的迭代器数量 return DICT_OK;&#125; 添加键值对使用int dictAdd(dict d, void key, void *val)添加键值对 123456789101112131415161718192021222324252627282930313233343536373839404142// 添加一个键值对到dict中int dictAdd(dict *d, void *key, void *val)&#123; // 往字典中添加一个只有key的键值对 dictEntry *entry = dictAddRaw(d,key); // 添加失败，则返回错误 if (!entry) return DICT_ERR; //使用宏，添加成功则设置key键值对的值 dictSetVal(d, entry, val); return DICT_OK;&#125; // 添加键到字典中 // 键存在则返回null // 不存在则创建节点，与键关联，并返回节点dictEntry *dictAddRaw(dict *d, void *key)&#123; int index; dictEntry *entry; dictht *ht; // 尝试进行单步式rehash if (dictIsRehashing(d)) _dictRehashStep(d); // 尝试获取hash表中的索引值，返回-1表示键已经存在 if ((index = _dictKeyIndex(d, key)) == -1) return NULL; // rehash使用1号哈希表，不在rehash使用0号 ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0]; // 分配空间，将节点添加到链表表头 entry = zmalloc(sizeof(*entry)); entry-&gt;next = ht-&gt;table[index]; ht-&gt;table[index] = entry; ht-&gt;used++; // 使用宏，设置新节点的键 dictSetKey(d, entry, key); return entry;&#125; 替换键值对123456789101112131415161718192021 // 如果键值不存在，返回1 //存在，更新键值，返回0int dictReplace(dict *d, void *key, void *val)&#123; dictEntry *entry, auxentry; // 添加成功返回1 if (dictAdd(d, key, val) == DICT_OK) return 1; // 查找键 entry = dictFind(d, key); // 更新键值 auxentry = *entry; dictSetVal(d, entry, val); // 释放原值 dictFreeVal(d, &amp;auxentry); return 0;&#125; 查找键值对123456789101112131415161718192021222324252627dictEntry *dictFind(dict *d, const void *key)&#123; dictEntry *he; unsigned int h, idx, table; // hash表大小为0，表名无值 if (d-&gt;ht[0].size == 0) return NULL; /* We don't have a table at all */ // 如果在rehash，则单步rehash if (dictIsRehashing(d)) _dictRehashStep(d); // 查找索引 h = dictHashKey(d, key); // 遍历索引下的键 for (table = 0; table &lt;= 1; table++) &#123; idx = h &amp; d-&gt;ht[table].sizemask; he = d-&gt;ht[table].table[idx]; while(he) &#123; if (dictCompareKeys(d, key, he-&gt;key)) return he; he = he-&gt;next; &#125; // 如果没有进行rehash，则不再查找ht[1] if (!dictIsRehashing(d)) return NULL; &#125; return NULL;&#125; 删除键值对123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 删除该键值对，并释放键和值int dictDelete(dict *ht, const void *key) &#123; return dictGenericDelete(ht,key,0);&#125;// 删除该键值对，不释放键和值int dictDeleteNoFree(dict *ht, const void *key) &#123; return dictGenericDelete(ht,key,1);&#125;// 查找并删除对应的键值对static int dictGenericDelete(dict *d, const void *key, int nofree)&#123; unsigned int h, idx; dictEntry *he, *prevHe; int table; // 空则直接返回错误信息 if (d-&gt;ht[0].size == 0) return DICT_ERR; /* d-&gt;ht[0].table is NULL */ // rehash时，进行一次rehash if (dictIsRehashing(d)) _dictRehashStep(d); h = dictHashKey(d, key); // 获取hash索引 for (table = 0; table &lt;= 1; table++) &#123; idx = h &amp; d-&gt;ht[table].sizemask; he = d-&gt;ht[table].table[idx]; prevHe = NULL; // 查找，遍历整个链表 while(he) &#123; if (dictCompareKeys(d, key, he-&gt;key)) &#123; /* Unlink the element from the list */ if (prevHe) prevHe-&gt;next = he-&gt;next; else d-&gt;ht[table].table[idx] = he-&gt;next; if (!nofree) &#123; // 根据传入参数是否释放键值 dictFreeKey(d, he); dictFreeVal(d, he); &#125; zfree(he); d-&gt;ht[table].used--; return DICT_OK; &#125; prevHe = he; he = he-&gt;next; &#125; // 没有进行rehash则不查找ht[1] if (!dictIsRehashing(d)) break; &#125; return DICT_ERR; /* not found */&#125; 字典删除1234567891011121314151617181920212223242526272829303132333435363738394041// 清理释放整个字典void dictRelease(dict *d)&#123; // 释放ht[0] _dictClear(d,&amp;d-&gt;ht[0],NULL); // 释放ht[1] _dictClear(d,&amp;d-&gt;ht[1],NULL); // 释放字典 zfree(d);&#125;int _dictClear(dict *d, dictht *ht, void(callback)(void *)) &#123; unsigned long i; // 释放所有元素 for (i = 0; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; 0; i++) &#123; dictEntry *he, *nextHe; if (callback &amp;&amp; (i &amp; 65535) == 0) callback(d-&gt;privdata); if ((he = ht-&gt;table[i]) == NULL) continue; while(he) &#123; nextHe = he-&gt;next; // 释放键值对 dictFreeKey(d, he); dictFreeVal(d, he); zfree(he); ht-&gt;used--; he = nextHe; &#125; &#125; // 释放hash表 zfree(ht-&gt;table); // 重置hsh表 _dictReset(ht); return DICT_OK; /* never fails */&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读书摘录-编程大师访谈录]]></title>
      <url>%2F%2Fblog%2F2017%2F05%2F%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95.html</url>
      <content type="text"><![CDATA[【美】Susan Lammers 第1篇 查尔斯•西蒙尼2017-04-30采访者：编程是一种技巧或技能吗？ 西蒙尼：什么是编程？人们对此一直各持己见。有人说它是科学，有人说它是艺术，还有人称之为技能或手艺。我认为这三方面兼而有之。我们喜欢说它蕴含大量艺术成分，但是我们都知道它里面更多的是科学。 孩子们在学校里学习数学，高中毕业时，他们会以为数学就是加法和乘法，甚或代数和微积分。其实，算术，即使简单如加法的运算，背后也有令人难以置信的科学理论作支持。 计算机编程背后也有大量科学理论作支持。例如，哥德尔定理的数学证明冗长而复杂，但是如果借用计算机科学的图灵定理，证明起来不费吹灰之力。信息理论和计算机科学其他领域对数学影响巨大，反之亦然。 编程包含有大量科学，同时，它也有点像手艺。实际上，在许多人看来，编程是一项复杂的技能，这跟工具制造很像，需要精雕细琢。我认为，只要将科学、艺术和技能这三者拿捏得恰到好处，你就能取得一些引人瞩目的成绩。2017-04-30别人读几段你的源代码，有没有可能断定“这代码是查尔斯·西蒙尼写的”？ 西蒙尼：噢，是的，毫无疑问。是不是我本人写的可能很难分辨，但有一点是确定无疑的：只要看了代码，你就能知道它是不是我的团队写的，或者是不是受我的影响写的。这是因为我从1972年起写的代码都遵循特定的命名规范，许多人称之为“匈牙利命名法”。你一眼就能分辨出哪些代码是受我的影响写出来的，包括Microsoft Word、Multiplan和Bravo，以及其他许多遵循这些规范写成的程序。註: 原来是他2017-04-30进入公司第一天，程序员就会拿到几本书。其中一本是数学家乔治·波利亚写的《怎样解题》。（西蒙尼边说边从他办公桌旁的书柜里取出那本书，翻到某一页。）这两页很重要。这本书的其余内容就是基于这两页展开的。这就像一张问题求解的检查单。这是起飞前、起飞和着陆检查单。它不会教你如何飞行，但是如果不照做，即使你已经懂得怎么飞行，也有可能会坠机身亡。 求解问题时，我们遵循以下四个步骤：首先理解问题，然后拟定计划，接着执行计划，最后回顾整个过程。这样的书我们大概有四本，我觉得我们能使程序员比刚加入公司时变得更加优秀。 第2篇 巴特勒•兰普森2017-04-30但是我坚持认为，如果你打算在研究生院攻读计算机科学，那么本科学习计算机科学就是犯了大忌。 采访者：为什么？ 兰普森：因为从长远来看，你学的内容大部分都没什么价值。你学不到施展聪明才智的新方法，而这些方法对你来说，要比学习如何编写编译器的细枝末节有 用得多，尽管后者可能是你本科念计算机科学时的学习内容。我认为，要是所有计算机科学研究生院联合起来，一致决定不接受本科念计算机科学的毕业生，世界会变得更好。学校应当要求这些人补习一年，学习数学或历史等科目，才能继续攻读计算机科学的研究生。不过，我还没看到有学校这么做的。2017-04-30举例来说，鲍勃·斯普劳尔（Bob Sproull）和我花了大量时间设计Interpress项目，那是一种印刷标准。我为此投入了很大精力，原本衷心希望施乐公司接受并促使所有人采纳。相反，他们完全把它搞砸了。结果，参与开发的部分人员离职并创办了Adobe系统公司，开发出一种类似的产品PostScript。很显然，后者成了大家现在都会采用的标准。这种事情很恼人，但是研究实验室的主要产品就是创意。註: 这不就和盛大研究院一样2017-04-30：程序员需要具备什么样的素质才能写出成功的程序？ 兰普森：最重要的素质是能够把问题的解决方案组织成容易操控的结构，其中每个组件都可以用简单的方式说明。有时，成功的程序员可以做到这一点，但他们无法解释自己做了什么，因为他们看不到那个结构。有些人之所以成为出色的程序员，是因为他们可以比多数人处理更多的细节。2017-04-30你有没有看到20年后每个指尖上都有一台计算机会出现什么问题？ 兰普森：我不觉得那有什么问题。显然每只手腕上都会有计算机。计算机的存在是予人帮助，我希望它们会给人们带来正面的影响。註: 手机 第3篇 约翰•沃诺克2017-05-01你编程有什么诀窍？ 沃诺克：我不知道能不能归结到几点上。我前面提到过一些。不要早作绑定，尽可能推迟决定时间。眼界放宽一些，设计要比你自认为需要的程度更加灵活，因为从长远看你最终会需要这样。快速让某样东西工作起来，然后还能弃之不用。 从小的开始实验而不是大的入手学习。不要一头扎进周期长达两年且中间不出什么成果的开发当中。最好每两个月就要出点成果，这样你才能进行评估、重组和重新开始。程序员经常在一开始时过度定义他们的方法。他们可能会从一个中心构思着手，从第一天就开始编码。然后他们发现自己陷入重围，每件东西都开始膨胀，因为它们依赖于太多其他因素。应当反其道而行之，如果让过程较为宽松，保持一定的自由度，并在最后阶段加快速度，长远来说，你会做出更好的产品。 第4篇 加里•基尔代尔2017-05-01你说编程对很多人来说也是一种宗教体验，这是什么意思呢？ 基尔代尔：嗯，如果你和一群使用相同编程语言的程序员谈论编程的话，他们几乎可以成为那种编程语言的传教士。他们组成了一个紧密结合的社群，坚持一定的信念，在编程时遵循一定的规则。就像是一个把编程语言当作是圣经的教会。 FORTH是一个很好的例子，它是一种编程语言，对于很多人来说，可能很接近宗教的体验。当FORTH刚出来的时候，其信徒就声称它做任何算法都能快上十倍。这是一个典型的宣言。如果你在这点或其他任何方面有异议，你会发现自己是对牛弹琴，而且你是绝对不会被容许加入“教会”的。我并不想贬低使用这一种语言的人。那是一个非常能给人帮助的团体，所用的也是一种非常有效的语言，但他们没有基于理性去讨论问题，他们是基于信仰的。说过这句话，我可能会收到一千封有关FORTH及人们对其宗教体验的邮件。但是就算我能整天鼓吹LISP的神奇，我也不会把自己归到一个特殊的派别中。註: 哈哈。php 第5篇 比尔•盖茨2017-05-01不，我认为在过了最初的三四年后，就会非常明显地显现出你是否是一个优秀的程序员。刚开始的几年中，你可能会更多地知道怎样去管理大型项目和不同个性的人，但在三四年后，就能很清楚地看出你会成为什么样的程序员了。在微软没有哪个程序员是在平庸了几年之后突然间一鸣惊人的。我和一个人谈谈他的程序，马上就能知道他是否是个好程序员。如果他真的很棒，每个细节他都会脱口而出。 就像下棋的人一样。如果你特别喜欢下棋，会很容易记住10盘棋中的每一步，因为你已置身其中了。其他人看到国际象棋选手或程序员能记住每个细节时，觉得他们像个怪物。其实这很正常。即使到了今天，在我写了微软的BASIC程序10年后，我仍可以在黑板上大段大段写出当时的源代码。2017-05-01编程需要非常大量的精力，所以大多数程序员都比较年轻。这就会带来一个问题，因为编程需要很多的训练。在年轻时，目标不是很持久，可能会被这样那样的事分心。但是年轻的程序员应当坚持下去，他们会变得更出色。作为程序员，我认为自己在1975年到1980年之间的提高是最明显的。在1975年，我会说：“嘿，看看，我什么事情都能做。”我真的认为自己可以，因为我读了大量代码，从来没有发现哪段代码是我无法快速读懂的。今天我仍旧认为检验编程能力的最好方法之一就是给程序员一本30来页的代码，看看他阅读和理解的速度有多快 第6篇 约翰•佩奇2017-05-01从一个计算机程序员转变到运营一个庞大的公司，你觉得困难吗？ 佩奇：这个角色转换是一个非常平缓的过程，因为我已经做了二十多年的管理人员，我可以告诉你真相，最难的是从管理者重新变成程序员。在创办公司前，我 在惠普已经习惯于领导很多人了。再回到编程工作时，我被迫完全依靠自己。真是让人一震。事实上这有点儿可怕——我不知道自己是否还能编程。但是，就像骑自行车一样——你永远都不会忘记的，只要一踏脚蹬，车就奔着夕阳去了。2017-05-01独自一人编程和一个团队合作编程有什么不同？ 佩奇：如果一个产品需要四到五个人开发，那和你自己一个人编程时采取的方法是不同的。我坚信只能由一个人来做产品和高层结构的设计，最多不能超过两个人。所有的设计出于一个头脑，才能够实现和谐与一致。如果试图取悦于所有人，让一个委员会来做设计，你的方向就错了。那绝对是致命的。 所以我在定义阶段会用一个人数非常少的团队来工作，然后如果有必要，再扩大团队来实施编程设计。实施设计方案所需要的队伍越大，就越必须严格地把整个系统划分成可管理的模块，并定义好相互间的接 口。除非一个程序大到必须由两三个人以上来做，否则不必编写很多结构化程序报告，也不用为每个步骤都编写文档。 有些系统，例如设计一个控制航天飞机的程序，需要上百名程序员。那就必须严格地把结构划分成可管理的模块才行。一个小系统的架构可能会过于大，一个大系统的架构可能会过于小——使用的技术必须与问题的规模相匹配。我就是这样做的。2017-05-01有些人觉得完成项目真是太过瘾了，他们做完一个项目就接着又做另一个了。这样会把自己累垮的。如果连续开始新的项目，情况会变得很糟。 另外，当你在复杂的程序上艰苦工作时，锻炼身体是很重要的。大部分程序员都缺乏身体锻炼，这样会失去敏锐的思维。往往在连续完成了第二个或第三个工作后，身体就虚弱了，以至于你会产生幻灭感，你会对着镜子说：“上帝啊，看看我，我为什么要这样做呢？ 第7篇 C.韦恩•莱特莱夫2017-05-01另一方面，非常有意思的是专家系统。我的预测是，在两三年之内，专家系统不必再和人工智能牵扯在一起。这就是人工智能的历史：当某件东西开始变得众所周知时，它就独立出来了。模式识别曾经被当作是人工智能，但现在这是一个独立的领域。这也正是专家系统当下的命运。我认为专家系统在我们产业里将变得非常重要，就像垂直应用一样。註: 和现在一样 第11篇 雷•奥奇2017-05-02我推崇严谨、一致而清晰的结构。另外，我认为软件应该高度模块化和分层，非常灵活地运用大量文件和目录。如果你必须分别构建不同组件，那么接口自然就会更加凸显出来，要求你规范这些接口。当许多人共同开发一个程序时，在项目早期确立全局的错误处理、参数传递和子程序命名规范（虽然不见得所有人都会同意），显得非常重要。不过，对于代码该怎么注释、大括号怎么用或者代码该怎么缩进，我觉得你绝不应该对别人指手画脚。在修改别人的模块时，你最好还是按照他的惯例编写代码。这是学会与他人共事的必修课。交流想法的环境应该是开放的。设计会议上允许非常激烈和紧张的讨论。我发现许多优秀设计师往往固执己见，但只要他们觉得是对的，就会毫不客气地坚持，但他们也知道什么时候应该怎么让步。优秀设计师不会有“非此创造”综合征。2017-05-02我过去常想，个人时间管理程序应该会非常便利。结果现在却得在公文包里装一台计算机随身携带，打开并启动计算机，就只为了查看我的会面安排，远不及我那口袋大小的通讯记事簿来得方便。我想要一本通讯记事簿，让我的秘书和我可以同时写入，这非常有用，因为我们俩都能便捷地安排我的时间。我希望哪个聪明的家伙能发明这种记事簿。註: 手机日程管理软件 第14篇 杰夫•拉斯金2017-05-031979年，苹果公司正致力于开发Lisa。不管你信不信，它最初的目标是开发一款字符界面的机器。我在苹果公司担任高级系统经理，对Lisa很不满。它非常昂贵，我认为苹果公司不够理智，居然以小型机的价格去跟DEC、通用数据公司和IBM比拼。70年代初，我在斯坦福大学人工智能实验室做访问学者期间，在施乐PARC度过了大量时光。在我看来，施乐PARC在位图屏幕、通用键盘和图形方面的研究真是不可思议。因此，我极力游说，说服苹果公司把Lisa改成位图机器。我把施乐和苹果公司撮合到一起。施乐一度持有苹果公司10%的股票。我提议开发一款容易使用并融合文字和图形的电脑，售价在1000美元左右。乔布斯认为这想法太疯狂了，这种机器不会有销路，我们绝不要这种玩意。他试图否决这个项目。因此，我越过乔布斯直接找到当时的董事长迈克·马库拉（Mike Markkula），和他探讨我的想法。幸运的是，马库拉和时任总裁迈克·斯科特（Mike Scott）叮嘱乔布斯别管我。我招揽了早期成员：巴德·特里伯（Bud Tribble）、布里安·霍华德（Brian Howard）和布雷尔·史密斯（Burrell Smith）。我们搬到另一栋大楼，打造Macintosh及其软件的原型，搭建并让它运行起来。后来，乔布斯接手后，他还编了个故事，把Mac项目称为“海盗行动”。我们并未像他后来说的那样，试图让这个项目远离苹果公司。我们跟苹果公司其他部门的联系十分紧密，我们只是尽量不让乔布斯干预这个项目。在头两年，乔布斯总想着要毙掉这个项目，因为他不明白它到底是怎么回事。最初的Macintosh设计得既精心又合理。最后，苹果公司所有人都意识到，这是公司继Apple II后推出新产品的希望所在。随后，乔布斯接管了这个项目。他径直走进来，对我说：“我接手Macintosh硬件，你可以负责软件和出版物。”他抛出软件设计，要求Macintosh软件与Lisa保持兼容，并坚持使用鼠标。机器变得更大、更复杂，也昂贵得多。现在它跑起来黏糊糊的。你有没有用过MacWrite？我们这里把它叫做MacWait。又过了几个月，乔布斯对我说：“我来接手软件，你可以负责出版物。”于是我回答：“你也可以接手出版物。”说完便离开了。那是1982年5月。他和马库拉对我说：“请别走。再过一个月，我们会提供一份你无法拒绝的薪酬。”于是我给了他们一个月时间，他们开了一份薪酬，我没接受。2017-05-03近期《新闻周刊》上的一篇文章把我逗乐了，他说：“我还有几个不错的设计。”他从来没做过什么设计，他一款产品都没设计过。沃兹（Steve Wozniak）设计了Apple II。肯·罗斯穆勒（Ken Rothmuller）等人设计了Lisa。我和我的团队设计了Macintosh。温德尔·桑德斯（Wendell Sanders）设计了Apple III。乔布斯设计了什么？什么也没有。註: 哈哈，乔布斯2017-05-03人工智能教会了我们大量关于我们自身以及知识的内容。非常廉价的机器上用不了靠谱的人工智能程序，至少目前行不通。真正的人工智能有点像宗教。从前人们都说天空上面就是天堂和天使。然后你搭乘火箭飞船到了那里，发现并不是那么回事。于是你知道原来的理解有误。一旦你实现了某样东西，它就不再是人工智能。曾几何时，国际象棋博弈程序一度被认为包含人工智能的成分。当我还在念研究生时，只要学会编写国际象棋博弈程序，你就可以拿到人工智能博士学位。现在你花上29.95美元就能买到国际象棋博弈程序，没有人称之为人工智能。它只是个会下棋的小算法。首先，有个定义的问题。然后，它变得更加复杂。人们认为程序应该理解自然语言，但我们的话语方式对电脑或别人来说太不精确，无法弄清楚要做什么。这正是我们创造编程语言的原因。只要试过以英文写成的规格为基础开展工作，他们就会知道自己无法借此编写程序，因为它不够精确。因此，如果人类都不能做到这一点，基本上就不可能指望还能让机器做到。当你面对所谓的人工智能程序时，电脑必须已经掌握一个词汇表。比方说，你有5个命令，你想让机器理解与之等价的所有可能的英文表述，但是它理解不了所有等价的英文表述。有人可能会说：“拿个工号。”而英国绅士可能会说：“劳烦你给我们的员工派个数字编号。”这正是搞AI的人试图解决的大麻烦。人工智能相关的许多承诺都被误解了。人工智能已经教导我们的有关语言的东西是美好的。那么，我是否认为人工智能值得做？绝对是。我是否认为这会转化出很棒的产品？会有一些。我是否认为这会实现你在大众传媒上了解到的承诺？根本不会。我会投很多钱到人工智能领域吗？没门 第15篇 安迪•赫兹菲尔德2017-05-03有个故事是关于沃兹的。沃兹是公司创始人之一，不用说，他分到了大量股票。有些人一点股票都没有，而有的人却拥有这么多股票，对此他觉得很不公平。于是他拿出自己的股票，宣布只要是在苹果公司工作满一定年限的员工，都可以从他那里买到2500股。沃兹的用意无疑是最好的，但结果这反倒让那些坏心肠的人欢天喜地。事情是这样的，许多不在乎钱财的雇员并没有行使股票购买权，于是那些贪心的家伙就对他们说：“好吧，我给你钱，我来买你的股份。”有些人不再认真工作，反而成了股票买手；他们令人生厌，个性糟糕，是不够格的工程师，毛孔里都滴着贪婪。在一个月内，有个家伙光靠这个捞了几十万美元。这实质上是在窃取沃兹的钱财。但这也是苹果公司上市时发生的故事的一部分。到了1980年年底，在苹果公司工作不再那么有趣。通常你的头儿是从另一家公司挖过来的，对产品一无所知。最后，迈克·斯科特意识到苹果公司聘请的管理人员都是些眼高手低的家伙，1981年2月，他在一天之内把这些人都给解雇了。工程部门一共有90人，他解雇了其中40人。这一天在苹果历史上被称为“黑色星期三”。人们都惊呆了。2017-05-03就在Mac发布之后，Mac团队开始组建管理层的时候，我离开了苹果公司。我跟新来的技术经理有矛盾，他最初是我面试和同意录用的，没想到他是个控制和权力狂。这家伙认为我太傲慢，自以为可以通过考核给我差评打击我。我很震惊。我掏心掏肺地为这家公司卖命，尽我所能做到最好，每天工作15个小时开发这个项目。Macintosh本不该是这样的，但是这家伙却进来把它搞成了这样。因此我不得不选择离开，但是我把自己生命中整整两年献给了Macintosh，它是我最在意的。所以我一直待到Mac发布之后才离开苹果公司，开始自己单干。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读书摘录-调试九法：软硬件错误的排查之道]]></title>
      <url>%2F%2Fblog%2F2017%2F04%2F%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%EF%BC%9A%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B9%8B%E9%81%93.html</url>
      <content type="text"><![CDATA[【美】阿甘斯 第3章 理解系统2017-04-07你必须掌握系统的工作原理以及它是如何设计的。在某些情况下，还要知道为什么这样设计。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方。（这不仅仅是“墨菲定律”的问题，如果你不能理解你所设计的系统，你的工作可能会变得一团糟。） 3.1 阅读手册2017-04-07如果你是一位工程师，正在调试自己公司的产品，那么你需要读一读内部手册。工程师们设计它是用来做什么的？读一下功能说明以及所有的设计规范，研究一下图表、时序图和状态机。分析它们的代码，还要读一下注释。（是的，读一下注释，这非常重要。）一定要检查产品的设计。查明构建它的工程师们打算用它来做什么（除了用它来赚钱买辆宝马车以外）。注意，手册上的信息也不可全信。手册（以及那些只想着赚钱买宝马车的工程师们）可能也是错的，很多难以发现的bug就出现在这里。但你仍需要了解他们的想法，哪怕其中有些信息是很难接受的。 3.2 逐字逐句阅读整个手册2017-04-07参考设计和样本程序给出了产品的一种使用方式，有时这些就是能获得的全部文档了。但是，在使用这些设计时一定要注意，创建它们的人往往只了解他们的产品，而没有遵循好的设计实践，或者不是为真实应用而设计的（最常见的缺点是不能进行错误恢复）。不要照搬这些设计，如果你没有在开始的时候发现bug，那么将来也会发现。此外，即使是最好的参考设计可能也不会完全符合应用程序的特定需求，而不符合的地方可能就是出问题的地方。当我照搬了朋友的微处理器设计时，就发生了问题，因为他的设计无法处理中3.3 知道什么是正常的2017-04-07当你检查系统时，必须知道系统的正常工作状态。如果你不知道低位字节首先由使用了Intel芯片的PC程序来处理，那么你会认为所有长字（longword）都是随意处理的。如果你不知道缓存是干什么的，就会非常奇怪有些数据为什么没有马上写入内存。如果你不了解三态（tri-state）数据总线的工作原理，你将会认为它们可能是主板上的故障信号。如果你从未听说过电锯，你可能会认为那个发出讨厌的嗡嗡声的东西一定是出了什么毛病。知道什么是正常的可以帮助你注意到什么是不正常的。你必须掌握一些你所工作的技术领域的基础知识。如果我不知道时钟选通脉冲和地址线是做什么的，那么即使我读了手册之后也无法理解中断问题。本书中几乎所有的（即使不是全部的话）示例都假定人们已经掌握了系统工具原理的一些基本知识。（如果我在前面使你误认为读完本书就可以调试任何技术领域的bug，那么请恕我无心之过。如果你是一位游戏编程人员，最好不要去管核电厂的调试。如果你不是医生，那么就不要试图诊断你手臂上的灰绿色斑点是什么。如果你是一位政客，那么就不要介入任何有关bug的事情。） 3.7 小结2017-04-07理解系统这是第一条规则，因为它是最重要的。阅读手册。它会告诉你在使用除草机时，要在除草头上涂润滑油，这样除草绳就不会被烧化。仔细阅读每个细节。有关微处理器如何处理中断的详细信息就隐藏在数据手册的第37页。掌握基础知识。电锯本来就会发出很大的噪声。了解工作流程。引擎的转速可能与轮胎的转速不同，这是由传动轴造成的。了解工具。弄清楚体温计的哪一端才是用来测量体温的，弄清楚Glitch-O-Matic逻辑分析器的强大功能是如何使用的。查阅细节。连爱因斯坦都会去查阅细节，而Kneejerk却盲目相信自己的记忆力 第4章 制造失败2017-04-09“当你发现一个故障时该怎么办？”他会回答说：“试着让它再次发生。”（Charlie是一位训练有素的调试人员）。这样做有3个原因。可以观察它。要观察错误（下一节将更详细地讨论这个问题），就必须使它发生。我们必须尽可能有规律地制造失败。在前面讲的电视游戏的例子中，当问题发生时我可以集中注意力观察示波器（虽然当时我已经很疲倦）。可以专心查找原因。准确地知道问题在什么条件下会发生，有助于集中精力查找原因（但是请注意，有时这会产生误导，例如，“烤箱只有在你把面包放进去的时候才会把面包烤焦，因此问题就出在面包上。”这个问题后文也会详细讨论。）可以判断是否已修复问题。当你认为已经修复了问题时，如何才能确信它确实已被修复呢？那就是明确知道问题是如何发生的。当问题没有修复时，如果你执行X操作，失败率为100%；在修复问题后，再执行X操作，如果失败率为0，那么你知道bug确实已被修复。（我这么说并不多余。很多时候，开发人员在修复bug时会修改软件，然后在一个与当初发现bug的不同条件下测试新软件。软件当然能运行，即使他在代码中输入一行打油诗，而他也高兴地回家了。然而，几星期后，在测试过程中，或者更糟，在客户现场，软件再次失败。后文将讨论更多这方面的内容。 4.4 不要模拟失败2017-04-09记住，这并不意味着不能用自动化过程来引发失败，也不意味着在这个过程中不能采用一些起到放大效果的措施。自动测试能够使间歇性的问题更快发生，例如电视游戏的例子。放大效果可以使得细微的问题更明显，例如在修窗户的例子中，我可以用喷水管来找到漏雨的窗户，而不用等待偶尔才有的暴风雨来检查。这两种技术都有助于引发失败，而不是模拟失败的机理。所做的改变应该是一些高层次的改变，只影响错误发生的频率，而不影响错误的发生方式。此外，还要注意不要画蛇添足，引发新的问题。不要因为假设芯片的问题是由于热量引起的，就用热风枪来给芯片加热以模拟错误，这样只会把芯片烧化，然后你会误认为bug完全就是电路板上那堆被烧化的塑料。如果我用消防用的水龙来检查漏雨问题，可能会断定问题显然就是出在被击碎的窗子上。 4.9 小结2017-04-10制造失败虽然看起来很简单，但如果不制造失败的话，调试就会变得很困难。制造失败。目的是为了观察它，找到原因，并检查是否已修复。从头开始。修车工需要知道汽车车窗在被冻结之前你洗过车。引发失败。用喷水管向漏雨的那扇窗子喷水。但不要模拟失败。用喷水管向漏雨的那扇窗子喷水，而不要向另一扇不同的、“类似的”窗子喷水。查找不受你控制的条件（正是它导致了间歇性失败）。改变能够改变的每件事情，振动、摇晃、扭曲，直到再现失败。记录每件事情，并找到间歇性bug的特征。我们的绑定系统总是只在呼叫顺序错乱时才会失败。不要过于相信统计数据。绑定问题看起来与时间段有关，但实际上真正的原因是当地的年轻人占用了电话线路。要认识到“那”是可能会发生的。甚至冰淇淋的口味也会影响汽车的发动。永远不要丢掉一个调试工具。自动击球板可能在某一天就会派上用场。 5.6 猜测只是为了确定搜索的重点目标2017-04-11不要想，而要看”并不意味着不能做任何猜想。事实上猜测是好事，特别是当你理解了系统之后。你的猜测可能很接近事实，但猜测只是为了确定搜索的重点。在尝试修复问题之前，仍需要再次看到失败，以便确认你的猜测是正确的。 5.7 小结2017-04-11不要想，而要看凭空想象，问题可能有几千条原因。而实际的原因只有去看了才能发现。观察失败。高级工程师看到了真实的问题，并且能够找到原因。而初级工程师们认为他们知道错误发生在哪里，结果他们修复的地方根本没有出错。查看细节。听到水泵似乎发出声音时不要停下来。到地下室查明是哪个水泵。植入插装工具。使用源代码调试器、调试日志、状态消息、信号灯和臭鸡蛋的气味。添加外部插装工具。使用分析器、示波器、量表、金属检测仪、心电图仪和肥皂泡。不要害怕深入研究。虽然它是软件成品，但它出问题了，你必须打开并修复它。注意海森堡效应。不要让仪器影响了系统。猜测只是为了确定搜索的重点。大胆地猜测内存时序发生了错误，但在修复之前应该先查看它。 6.4 修复已知bug2017-04-12有时，我们很难相信一个系统中会有多个bug，就像在旅店预订的例子中一样。这使得用“分而治之”原则隔离每个bug变得更加困难。因此，如果同时出现了多个问题，当你确实查明了其中的一个问题时，应该立即修复它，然后再查找其他问题。我总听人们说“那里出问题了，但它不可能影响我们正在查找的问题。”事实上，它确实（而且经常）会产生影响。如果你修复了已知的错误，就可以专心致志地查找其他问题。在旅店预订系统中，技术人员只有在修复了转接盒中的双向电阻阻值过高的问题之后，才能够发现速度最慢的那台终端的接线问题。有时修复了一个问题，另一个问题也解决了，两个问题实际上是同一个bug。此外，如果修复某个问题对其他的问题有影响，一定要首先修复它之后再测试其他的问题。如果修复了一个问题后将会引发新的问题，那么你可以尽早发现，并有更多时间处理新的问题。 6.5 首先消除噪声干扰2017-04-12人们也很容易成为一个“完美主义者”，为了达到全面的高质量把你发现的所有不好的设计都“修复”一遍。你可能只是因为先前的程序员编写的GOTO语句看起来很差劲就删掉它们，但是，如果它们并没有实际引起问题，最好还是保留它们吧。 6.6 小结2017-04-12分而治之当bug的藏身之地不断被缩小一半时，它将很难再隐藏下去。通过逐次逼近缩小搜索范围。猜测1～100内的一个数字，只需7次。确定范围。如果数字是135而你却认为它在1～100内，那么你必须扩大范围。确定你位于bug的哪一侧。如果你所在的位置有排放物，则排放管就在上游。如果没有排放物，则排放管就在下游。使用易于查看的测试模式。从干净、清澈的水开始，以便当排放物进入河流中时很容易看到它。从有问题的一端开始搜索。如果你验证的是正确的部分，那么需要验证的地方太多了。应该从有问题的地方开始，然后向后追查原因。修复已知bug。bug互相保护，互相隐藏。因此一旦找到，立即修复它们。首先消除噪声干扰。注意那些导致系统问题的干扰因素。但对一些无足轻重的问题不要过于极端，也不要为了追求完美而去修改所有地方。 第7章 一次只改一个地方2017-04-12我们的软件工程师为了修复问题而更改了一个地方，但这个修改并没有解决问题，而他认为这不会产生什么影响。这是一个非常错误的假设。它确实有影响，它使得音频数据发生错误，只是两次错误与一次错误也没有什么太大的区别。当原来的错误被修复后，他犯的错误仍然存在，因此声音的质量仍很差。当他的修改没有解决问题时，应该立即把它改回来。註: 经常遇到 7.2 用双手抓住黄铜杆2017-04-23在很多情况下，你可能想改变系统的不同部分，以便看看它们是否对问题有影响。这往往是一个危险的信号，说明你正在猜测，而不是使用插装工具来观察正在发生什么。你正在改变条件，而不是捕捉错误的自然发生。这可能会把最初的错误隐藏起来，而且引起更多错误。 7.5 自从上一次能够正常工作以来你更改了什么2017-04-23有时，正常的系统和错误的系统之间的区别是由于一项更改造成的。做了更改之后，正常的系统开始出现故障。一种非常有效的办法是找出第一个导致系统出错的版本，尽管这可能需要连续测试原来的版本，直到找到没有故障的版本。一旦找到了这个版本，再前进到下一个版本，验证故障是否再次出现。做完这一步之后，至少可以把问题的范围限定到两个版本之间所做的修改。2017-04-23问题已经存在了很长时间，但只是某个地方（例如时序或数据库大小）被改变之后，它才显露出来 7.6 小结2017-04-23一次只改一个地方我们在生活中要有一点先见之明。如果你所做的更改没有起到预期的作用，那么就把它改回来。它们可能会产生无法预料的影响。隔离关键因素。如果你在检查日照时间的影响，就不要改变灌溉方案。用双手抓住黄铜杆。如果你在不知道具体发生了什么问题的情况下就试图去修理核潜艇，可能会引发一次水下的切尔诺贝利爆炸。一次只改一个测试。我之所以知道我的VGA采集相位被破坏了，就是因为其他东西都没有发生改变。与正常情况进行比较。如果所有出错的情况都有一些特征，而这些特征是正常情况所没有的，那么你就找到了问题所在。确定自从上一次正常工作以来你改变了什么地方。我的工友改变了唱机转盘上的唱头，因此这是一个很好的调试起点。 8.6 小结2017-04-23保持审计跟踪不要只是在心里记住“保持审计跟踪”这条规则，而要把它写下来。把你的操作、操作的顺序和结果全部记录下来。你上一次喝咖啡是什么时候？你的头痛是从什么时候开始的？要知道，任何细节都可能是重要的。视频压缩芯片的崩溃是由于格子衬衫造成的。把事件关联到一起。“它发出噪声，从21:04:53开始，持续4秒”比仅仅说“它发出噪声”要好得多。用于设计的审计跟踪在测试中也非常有用。软件配置控制工具可以告诉你哪次修订引入了bug。把事情记录下来！无论那个时刻多么恐怖，都要把它记到备忘录中，这样你才不会忘记。 9.4 小结2017-04-23检查插头一些显而易见的假设往往是错误的。请恕我赘述，假设错误通常是最容易修复的错误。置疑你的假设。是否运行了正确的代码？是不是燃气用完了？插头是否已插好？从头开始。是否正确地对内存进行了初始化？是否按了除草机上的“primer bulb”按钮？开关是否已打开？对工具进行测试。是否运行了正确的编译器？燃料油表是否被粘住了？量表是不是没电了？ 10.5 小结2017-04-23获得全新观点不管怎样，你都需要休息一下，喝杯咖啡。征求别人的意见。甚至一个不说话的人体模特也能帮助你认识到你先前没有注意到的事情。获取专业知识。只有VGA视频采集卡的厂商才能够肯定相位功能发生了错误。听取别人的经验。别人会告诉你车内顶灯的线被挤压出来了。帮助无处不在。同事、供应商、网络，还有书店，都在等待着为你提供帮助。放下面子。bug发生了。以除掉bug为自豪，而不要非得以自己除掉bug才为自豪。报告症状，而不要讲你的理论。不要把别人拖进你的思维定式中。你提出的问题不必十分肯定。甚至连“穿了格子衬衫”这样的事情也可以提出来。 11.6 小结2017-04-23如果你不修复bug，它将依然存在现在你已经掌握了所有的技术，没有理由再让bug存在了。查证问题确实已被修复。不要假设是电路的问题，而仍然让汽车带着脏的滤油嘴上路。查证确实是你的修复措施解决了问题。口中大喊“Wubba!”并不是使计算机打开的窍门。要知道，bug从来不会自己消失。使用最初导致它失败的方法再次制造失败。如果必须交付产品，那么就在产品中设计一个用于捕捉bug的“陷阱”，以便产品在客户现场发生失败时，把它捉住。从根本上解决问题。在烧坏另一台变压器之前，先把无用的8音轨磁带卡座扔掉。对过程进行修复。不要只是擦掉地上的油，而要纠正设计机器的方式。 14.3 小结2017-04-25从帮助台得到的观点是不明确的只能通过远程方式了解问题，眼睛和耳朵接收到的信息并不十分准确，而且关键是时间紧迫。遵循规则。无论用户多么糊涂，都必须找到应用规则的途径。对行动和结果加以确认。用户会误解你的意思，同时会犯错误。通过确认他们所说和所做的一切可以及早发现这些问题。使用自动工具。不要让用户参与系统生成的日志和远程监控与控制工具。即使是最简单的假设也需要确认。是的，有些人就是不知道有电才能使用字处理器。使用可用的故障检修指南。要处理的很可能就是已知的、好的设计。不要忽略历史。帮助完善故障检修指南。如果找到了某个已知系统的一个新问题，将解决问题的所有内容进行归档可以帮助下一位支持人员。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vs2017与vs2005冲突解决]]></title>
      <url>%2F%2Fblog%2F2017%2F04%2Fvs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3.html</url>
      <content type="text"><![CDATA[先安装vs2005，后安装vs2017，vs2017无法运行原因：vs2005注册了Microsoft.VisualStudio.Shell.Interop.8.0.dll，优先于vs2017需要的dll。导致运行错误。 解决方法： 复制C:\ProgramFiles(x86)\Microsoft_Visual Studio\2017\Enterprise\Common7\IDE\PublicAssemblies\Microsoft.VisualStudio.Shell.Interop.8.0.dll到C:\Windows\assembly\GAC\Microsoft.VisualStudio.Shell.Interop.8.0\8.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualStudio.Shell.Interop.8.0.dll]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-链表]]></title>
      <url>%2F%2Fblog%2F2017%2F03%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8.html</url>
      <content type="text"><![CDATA[C语言程序由于没有标准库的存在，各种造轮子。Redis为了满足需求，同样写了一个链表。 实现文件在adlist.h/adlist.c中。 结构体定义和普通的C写的双向链表差不多。没有什么特点。 1234567891011121314151617181920typedef struct listNode &#123; struct listNode *prev; // 前节点 struct listNode *next; // 后节点 void *value; // 值&#125; listNode;// 迭代器typedef struct listIter &#123; listNode *next;// 下一个节点 int direction;// 方向&#125; listIter;typedef struct list &#123; listNode *head; // 头 listNode *tail; // 尾 void *(*dup)(void *ptr); // 自定义节点复制函数 void (*free)(void *ptr); // 自定义节点释放函数 int (*match)(void *ptr, void *key); // 自定义节点匹配函数 unsigned long len; // 链表长度&#125; list; 宏定义了一些快速操作的宏 12345678910111213141516/* Functions implemented as macros */#define listLength(l) ((l)-&gt;len) // 获取list长度#define listFirst(l) ((l)-&gt;head) // 获取list头节点指针#define listLast(l) ((l)-&gt;tail) // 获取list尾节点指针#define listPrevNode(n) ((n)-&gt;prev) // 获取当前节点前一个节点#define listNextNode(n) ((n)-&gt;next) // 获取当前节点后一个节点#define listNodeValue(n) ((n)-&gt;value) // 获取当前节点的值#define listSetDupMethod(l,m) ((l)-&gt;dup = (m)) // 设定节点值复制函数#define listSetFreeMethod(l,m) ((l)-&gt;free = (m)) // 设定节点值释放函数#define listSetMatchMethod(l,m) ((l)-&gt;match = (m)) // 设定节点值匹配函数#define listGetDupMethod(l) ((l)-&gt;dup) // 获取节点值赋值函数#define listGetFree(l) ((l)-&gt;free) // 获取节点值释放函数#define listGetMatchMethod(l) ((l)-&gt;match) // 获取节点值匹配函数 API都是些链表常用的API，比较有特点的是迭代器的C语言实现。12345678910111213141516/* Prototypes */list *listCreate(void);void listRelease(list *list);list *listAddNodeHead(list *list, void *value);list *listAddNodeTail(list *list, void *value);list *listInsertNode(list *list, listNode *old_node, void *value, int after);void listDelNode(list *list, listNode *node);listIter *listGetIterator(list *list, int direction);listNode *listNext(listIter *iter);void listReleaseIterator(listIter *iter);list *listDup(list *orig);listNode *listSearchKey(list *list, void *key);listNode *listIndex(list *list, long index);void listRewind(list *list, listIter *li);void listRewindTail(list *list, listIter *li);void listRotate(list *list);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-动态字符串sds]]></title>
      <url>%2F%2Fblog%2F2017%2F03%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds.html</url>
      <content type="text"><![CDATA[Redis没有使用c语言的字符串结构，自己设计了一个简单的动态字符串。特点是：修改时大小不足则扩容，大小足够直接使用不缩小。末尾使用‘\0’，与c语言字符串兼容。 sds的源代码在sds.h与sds.c中。 sds的定义1234567typedef char *sds;// 兼容Cstruct sdshdr &#123; unsigned int len;// 字符串长度 unsigned int free;// 未分配的空间 char buf[];// 末尾'/0'的C风格字符串&#125;;// SDS的实际结构，兼容char*则返回buf地址 SDS这样设计的优点： 重用部分C字符串库函数的函数。 在常数复杂度的情况下获取字符串长度(以下代码)。 杜绝缓冲区溢出，通过获取空余空间函数，来进行处理(sdscat函数)。 减少字符串内存的重分配。不足则分配更大的空间，足够也不减少空间，而是记录新的len、free值。 二进制兼容。C字符串以空字符结尾，而某些二进制数据中间可能存在空字符。SDS兼容该种数据。 SDS API获取长度123456789101112// 获取字符串长度static inline size_t sdslen(const sds s) &#123; struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); return sh-&gt;len;&#125;// 获取空余空间static inline size_t sdsavail(const sds s) &#123; struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); return sh-&gt;free;&#125; SDS创建有两个函数，一个定长创建，一个是不定长创建。 123456789101112131415161718192021222324252627282930313233343536sds sdsnewlen(const void *init, size_t initlen) &#123; struct sdshdr *sh; if (init) &#123; //为空则使用malloc sh = zmalloc(sizeof(struct sdshdr)+initlen+1); &#125; else &#123; //不为空使用calloc分配 sh = zcalloc(sizeof(struct sdshdr)+initlen+1); &#125; if (sh == NULL) return NULL;// 分配失败处理 //设定sds的参数 sh-&gt;len = initlen; sh-&gt;free = 0; //值的复制 if (initlen &amp;&amp; init) memcpy(sh-&gt;buf, init, initlen); sh-&gt;buf[initlen] = '\0';// 尾部结束符 return (char*)sh-&gt;buf;&#125;// 复制一个char*sds sdsnew(const char *init) &#123; size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);&#125;// 生成一个空sdsds sdsempty(void) &#123; return sdsnewlen("",0);&#125;// 复制一个sdssds sdsdup(const sds s) &#123; return sdsnewlen(s, sdslen(s));&#125; sds释放函数先获取sdshdr的首地址，使用zfree释放。 12345void sdsfree(sds s) &#123; if (s == NULL) return; // 获取真实首地址释放 zfree(s-sizeof(struct sdshdr));&#125; sds动态空间调整123456789101112131415161718192021222324252627282930// 空间增长sds sdsMakeRoomFor(sds s, size_t addlen) &#123; struct sdshdr *sh, *newsh; size_t free = sdsavail(s); size_t len, newlen; if (free &gt;= addlen) return s;// 空间足够直接返回 len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); newlen = (len+addlen);// 新的长度 if (newlen &lt; SDS_MAX_PREALLOC)// 不足1MB直接翻倍分配 newlen *= 2; else// 超过1MB，多分配1MB空余空间 newlen += SDS_MAX_PREALLOC; newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);// 分配空间 if (newsh == NULL) return NULL; // 分配失败 // 设置参数 newsh-&gt;free = newlen - len; return newsh-&gt;buf;&#125;// 空间的重分配sds sdsRemoveFreeSpace(sds s) &#123; struct sdshdr *sh; sh = (void*) (s-(sizeof(struct sdshdr))); sh = zrealloc(sh, sizeof(struct sdshdr)+sh-&gt;len+1); sh-&gt;free = 0; return sh-&gt;buf;&#125; sds连接操作1234567891011121314151617sds sdscatlen(sds s, const void *t, size_t len) &#123; struct sdshdr *sh; size_t curlen = sdslen(s); // 获取字符串长度 s = sdsMakeRoomFor(s,len);// 扩展字符串 if (s == NULL) return NULL; sh = (void*) (s-(sizeof(struct sdshdr))); memcpy(s+curlen, t, len);// 连接字符串到末尾 sh-&gt;len = curlen+len;// 设置长度 sh-&gt;free = sh-&gt;free-len; s[curlen+len] = '\0';// 设置尾部 return s;&#125;sds sdscat(sds s, const char *t) &#123; return sdscatlen(s, t, strlen(t));&#125; sds复制12345678910111213141516171819202122sds sdscpylen(sds s, const char *t, size_t len) &#123; struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); size_t totlen = sh-&gt;free+sh-&gt;len; // 空间不足，分配空间 if (totlen &lt; len) &#123; s = sdsMakeRoomFor(s,len-sh-&gt;len); if (s == NULL) return NULL; sh = (void*) (s-(sizeof(struct sdshdr))); totlen = sh-&gt;free+sh-&gt;len; &#125; // 复制 memcpy(s, t, len); s[len] = '\0'; sh-&gt;len = len; sh-&gt;free = totlen-len; return s;&#125;sds sdscpy(sds s, const char *t) &#123; return sdscpylen(s, t, strlen(t));&#125; 一些其他接口123456789101112131415sds sdscatfmt(sds s, char const *fmt, ...);// 格式化输出sds sdstrim(sds s, const char *cset); // 去除cset中所含字符void sdsrange(sds s, int start, int end);// 获取指定区间字符串void sdsupdatelen(sds s); // 更新字符串长度void sdsclear(sds s); // 清空字符串int sdscmp(const sds s1, const sds s2); // 字符串比较// 依据sep将s分割，返回 一个二维数组sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);// 释放由sdssplitlen函数解析的二维数组 void sdsfreesplitres(sds *tokens, int count);void sdstolower(sds s); // 转小写void sdstoupper(sds s); // 转大写sds sdsfromlonglong(long long value);// ll转sdssds sdsjoin(char **argv, int argc, char *sep); // 以分隔符连接字符串子数组构成新的字符串]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读书摘录-程序员的思维方式]]></title>
      <url>%2F%2Fblog%2F2017%2F03%2F%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F.html</url>
      <content type="text"><![CDATA[2.2 德雷福斯模型的5个阶段 2017-01-24 但是，如果给新手提供与情境无关的规则去参照，他们就会变得能干起来。也就是说，需要这种形式的规则：“当X发生时，执行Y。”换言之，需要一份指令清单。图2-2 玉米饼食谱，不过你知道需要烹饪多长时间吗这就是呼叫中心的工作原理。你可以雇用一大批对当前技术没有很多经验的人，然后让他们按照一个决策树按部就班地执行下去。 3.3 L型和R型的特征 2017-02-06 事实上，综合是一项非常强大的学习技术，以至于麻省理工学院媒体实验室的尼葛洛庞蒂在Don’t Dissect the Frog, Build It [Neg94]中建议，真正想要了解一只青蛙，传统的解剖不是办法，更好的方式是构造一只青蛙。也就是说，要求学生构造一个具有青蛙特征的生物。这是一种伟大的方式，可以真正了解到，什么使青蛙成之为青蛙，以及青蛙如何适应其特定环境。这是一个综合学习的绝佳例子。 4.4 收获R型线索 2017-02-08 这种方法为什么会起作用？我认为这是因为晨写让毫无防备的大脑倾倒想法。早上刚起床时，你还没有像你想的那样清醒。潜意识仍然占主角。你还没有提起所有防备，也还未适应有限的现实世界。你可以直接连通R型，至少一小会儿。 2017-02-08 你需要培养一种非目标驱动的思维方式。正如庞加莱所做，把一切都写在纸上（或者编辑器中，如果你必须得这么做的话），然后不去管它。不要试图思考。记住它，如布朗所说，不要关注它。只要简单地记住它。让事实和问题自由地搅和、浸泡（我们将在8.2节讨论这一话题） 4.5 收获模式 2017-02-08 “在开始练习武术之后，我感觉到我的注意力持续时间和控制能力（比如在糟糕的环境下集中注意力）都有了提高。我一直在向软件开发人员和其他知识工作者推荐我的实践经验。它就是气功，它既有武术的一面，也包含太极、冥想和呼吸的方面。 注 跑步应该也行的。 6.2 瞄准SMART目标 2017-03-05 使用SMART方法实现你的目标。在这里，SMART代表具体的、可度量的、可实现的、相关的和时间可控的（Specific, Measurable, Achievable, Relevant, and Time-boxed）。对于任何目标（减肥、炒老板鱿鱼、征服世界等），你都需要制定一个计划，定出一系列帮助你实现目标的任务（objective）。每一个任务都应该具有SMART特性。 6.3 建立一个务实的投资计划 2017-03-05 就像任何投资一样——无论是金融还是艺术上的——都必须时刻进行管理。很多年来，戴维·托马斯（Dave Thomas）和我一直把实用投资计划作为咨询实践的一部分，在这里我简单地介绍一下这些内容。实用投资计划基于一种非常简单但是有效的理念：像管理你的金融投资一样小心管理你的知识投资。 6.4 使用你的原生学习模式 2017-03-05 很多教育家把学习者分为三大类：视觉型、听觉型和动觉型。视觉型学习者需要看到学习资料和老师。图片和图表对视觉型学习者都很有效，他们对肢体语言和面部表情也很敏感。听觉型学习者必须听到学习材料。讲座、研讨会和播客都很有效。他们对语气、语速和其他细节都很敏感。动觉型学习者通过活动和触摸来学习。他们需要亲身感受学习材料。特别是对运动、艺术和工艺等领域，你都需要通过动手来学习。 6.9 利用文档的真正力量 2017-03-05 创建低层次的设计文档，简单地反映代码的细节（几乎很快就会过时）对任何人都没有意义。但是其他形式的文档可能是有价值的，即使没有明确的读者。 6.10 以教代学 2017-03-05 为了省掉你的同事过来，我们建议你在桌子上摆一只黄色橡皮鸭作替身，当你遇到问题时，先和它聊聊。另一种有用的办法是尝试向一个孩子或者你所在领域之外的人解释你的东西。诀窍就是用他们能理解的话语进行解释。这是一个向你的Edna大婶解释你的工作的好机会，也是一个练习从听众角度观察问题并创建隐喻的好机会，这些隐喻有助于解释、阐明你的工作。你可能会在这个过程中惊奇地发现一些新的收获和领悟。 第7章 积累经验 2017-03-05 我们应该小心翼翼地从实践中获得智慧并适可而止，否则我们就会像不慎坐在热炉子上的猫一样，它再也不会坐在热炉子上——这还好，但是它也再也不会坐在冷炉子上。——马克·吐温 7.3 正确对待实践中的失败 2017-03-05 你可以在公司范围之外尝试，比如在家里做开源项目。这起码会减少产生负面结果的风险。但是仅仅这样不足以为你建立一个积极的学习环境。不论是在公司团队还是在黑夜里偷偷进行的独自实验，你都需要做到以下几点。 7.4 了解内在诀窍 2017-03-05 在采取纠正行动之前完全知道“这是什么”对于调试非常重要。太多程序员（包括我自己）往往在没有完全明白真正的错误是什么之前就着急修正它。匆忙地作出判断或者过早地进行修补。你需要首先完全明白系统的原理，然后再判断哪部分错了，最后提供解决方案。也就说，不要动手做，而是要袖手旁观。琼·金姆介绍下述方法来帮助大家充分了解。 8.2 通过分散注意力来集中注意力 2017-03-05 怎么区分你是在浸泡思想还是在拖延、浪费时间呢？我总是把拖延称为“做纸娃娃”。一个密友（姓名保密）第二天有一门重要的考试，但是前一天晚上，她并不学习，而是坐在沙发上剪纸娃娃。当时这在我看来就是典型的耗费时间：一个无关的非生产性的活动阻碍了你需要做的真正工作。但也许我错了。也许这不是拖延。这是一个高级触觉练习，也许是她浸泡思想的方法。她通过了测验并以优异成绩毕业。如果某个任务你真的不想做，那么任何分散注意力的努力都很可能只是耗费时间。如果你仍然有兴趣，但感觉“困难”，那么思想其实是在继续发酵，这当然没问题。 8.6 保持足够大的情境 2017-03-05 事实上，保持情境中任务相关的东西很有益处。不论你如何衡量生产力，仅仅多使用一台显示器就可以让你的生产力提升20%~30%。这是为什么？适合你的不是桌面隐喻，而是Frederick Brooks在几年前描述的拥挤的飞机座位隐喻。在一个大桌面上，你可以展开你的工作，看到你在做什么——同时看到所有的。在拥挤的飞机座位上，你没有足够的空间同时看两份以上的文档（或者文档的一部分）。你必须来回地切换文档。我敢打赌，让你去Staples或者Office Depot等办公用品店寻找一张17英寸的办公桌，你找不到，因为这个尺寸实在是太小了。然而，大多数显示器都是17到21英寸。这点空间就是我们办公的地方。你不得不在活动窗口和应用程序之间切换，因为你无法在如此小的空间里保持足够的情境。你知道Alt-Tab组合键（Mac上的Command-Tab）称为什么吗?情境切换。正如我们看到的，情景切换扼杀生产力。即使是类似使用Alt-Tab切换不同窗口的小动作也会花费时间、短期记忆力和精力。 2017-03-05 在最先进的操作系统上你可以使用虚拟桌面切换器，允许你拥有很多不同的屏幕，你可以使用特殊键随意切换。每一个屏幕都是独立的，称为工作空间。秘诀在于你如何在工作空间中分配应用。 9.2 明天上午做什么 2017-03-05 现在就开始吧！你选择开始做什么并不特别重要，重要的是主动尝试本书中提到的知识，这是你明天一大早要做的第一件事。下面是对第一步的一些建议。开始承担责任，不要害怕问“为什么”，也不要害怕问“你怎么知道的”或者“我怎么知道的”，同样要大方地回答“我目前还不知道”。挑两件帮助你维持情境、免受干扰的事情，立即实施。创建一个实用投资计划，设定SMART目标。弄清楚你在所属专业领域中所处的位置（从新手到专家）和你期望的位置。保证诚实。你需要更多的诀窍还是更多的情境？更多规则还是更多直觉？实践。某段代码遇到问题了吗？尝试用五种不同的方式编写。允许犯更多错误——错误是许可的，要从中学习教训。携带一个笔记本（最好不带横线）。涂鸦，做思维导图，记笔记。让你的思想自由地流动。打开心扉接收美感和其他的感官输入。不论是你的房间、桌面还是代码，关注它们是多么地赏心悦目。开始在私人wiki上记录你感兴趣的事情。开始写博客。为你读过的书写评论。阅读更多书，你会有更多可写的东西。使用SQ3R和思维导图。让散步成为你每天生活的一部分。启动一个读书小组。再拿一个显示器，开始使用虚拟桌面。回顾每章的“实践单元”，尝试去做。 9.3 超越专家 2017-03-05 达芬奇在600年前抱怨说：“人们看却没有看见，听却没有听见，吃却没有味觉，接触却没有触觉，说话却没有思考。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-内存分配]]></title>
      <url>%2F%2Fblog%2F2017%2F03%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html</url>
      <content type="text"><![CDATA[redis的内存分配主要就是对malloc和free进行了一层简单的封装。具体的实现在zmalloc.h和zmalloc.c中。 内存分配器的选择redis支持多种内存分配器，可以选择的分配器tcmalloc、jemalloc、dlmalloc、malloc/malloc.h(apple)，这几个分配器自带内存大小的记录。如果不进行设置，则默认使用malloc进行分配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// zmalloc.h// 选择使用的内存分配器，分别为tcmalloc、jemalloc、dlmalloc、malloc/malloc.h// 同时设置HAVE_MALLOC_SIZE为真，内存分配器自带大小统计。// 如果不选择内存分配器，则使用默认的malloc，同时同时设置HAVE_MALLOC_SIZE为假。// 指定zmalloc_size#if defined(USE_TCMALLOC)#define ZMALLOC_LIB ("tcmalloc-" __xstr(TC_VERSION_MAJOR) "." __xstr(TC_VERSION_MINOR))#include &lt;google/tcmalloc.h&gt;#if (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6) || (TC_VERSION_MAJOR &gt; 1)#define HAVE_MALLOC_SIZE 1#define zmalloc_size(p) tc_malloc_size(p)#else#error "Newer version of tcmalloc required"#endif#elif defined(USE_JEMALLOC)#define ZMALLOC_LIB ("jemalloc-" __xstr(JEMALLOC_VERSION_MAJOR) "." __xstr(JEMALLOC_VERSION_MINOR) "." __xstr(JEMALLOC_VERSION_BUGFIX))#include &lt;jemalloc/jemalloc.h&gt;#if (JEMALLOC_VERSION_MAJOR == 2 &amp;&amp; JEMALLOC_VERSION_MINOR &gt;= 1) || (JEMALLOC_VERSION_MAJOR &gt; 2)#define HAVE_MALLOC_SIZE 1#define zmalloc_size(p) je_malloc_usable_size(p)#else#error "Newer version of jemalloc required"#endif#elif defined(__APPLE__)#include &lt;malloc/malloc.h&gt;#define HAVE_MALLOC_SIZE 1#define zmalloc_size(p) malloc_size(p)#elif defined(USE_DLMALLOC)#include "Win32_Interop/win32_dlmalloc.h"#define ZMALLOC_LIB ("dlmalloc-" __xstr(2) "." __xstr(8) )#define HAVE_MALLOC_SIZE 1#define zmalloc_size(p) g_msize(p)#endif#ifndef ZMALLOC_LIB#define ZMALLOC_LIB "libc"#endif// zmalloc.c// 依据选择的内存分配器，设定好宏定义，否则使用系统默认分配。#if defined(USE_TCMALLOC)#define malloc(size) tc_malloc(size)#define calloc(count,size) tc_calloc(count,size)#define realloc(ptr,size) tc_realloc(ptr,size)#define free(ptr) tc_free(ptr)#elif defined(USE_JEMALLOC)#define malloc(size) je_malloc(size)#define calloc(count,size) je_calloc(count,size)#define realloc(ptr,size) je_realloc(ptr,size)#define free(ptr) je_free(ptr)#elif defined(USE_DLMALLOC)#define malloc(size) g_malloc(size)#define calloc(count,size) g_calloc(count,size)#define realloc(ptr,size) g_realloc(ptr,size)#define free(ptr) g_free(ptr)#endif 功能函数一栏1234567891011121314void *zmalloc(size_t size);// 调用malloc，分配size大小的空间void *zcalloc(size_t size);// 调用calloc，分配size大小的空间void *zrealloc(void *ptr, size_t size);// 调用realloc，重新分配size大小的空间void zfree(void *ptr);// 释放ptrchar *zstrdup(const char *s);// c风格字符串copysize_t zmalloc_used_memory(void); // 获取当前占用的内存大小void zmalloc_enable_thread_safeness(void); // 设置线程安全void zmalloc_set_oom_handler(void (*oom_handler)(size_t)); // 设置内存分配失败的处理方法float zmalloc_get_fragmentation_ratio(size_t rss);// 获取所给内存和已经使用的内存大小之比size_t zmalloc_get_rss(void); // 获取RSS信息（Resident Set Size）size_t zmalloc_get_private_dirty(void);// 获取实际内存大小size_t zmalloc_get_smap_bytes_by_field(char *field);// 获取/proc/self/smaps字段的字节数void zlibc_free(void *ptr); // 获取物理内存大小WIN32_ONLY(void zmalloc_free_used_memory_mutex(void);) //原始系统free的释放方法 统计使用的内存总数redis每次分配内存、释放内存都会进行记录。用来统计redis使用的总内存。 123456789101112131415161718size_t zmalloc_used_memory(void) &#123;// 获取使用的内存，直接获取used_memory的变量的值。 size_t um; if (zmalloc_thread_safe) &#123;// 线程安全#if defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC) um = update_zmalloc_stat_add(0);#else pthread_mutex_lock(&amp;used_memory_mutex); um = used_memory; pthread_mutex_unlock(&amp;used_memory_mutex);#endif &#125; else &#123;// 非线程安全 um = used_memory; &#125; return um;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static size_t used_memory = 0;// 定义了一个全局变量，用来记录使用的内存数量。static int zmalloc_thread_safe = 0;// 默认不线程安全，调用zmalloc_enable_thread_safeness进行设置为线程安全。#ifdef _WIN32// 根据系统选择多线程锁。pthread_mutex_t used_memory_mutex;#elsepthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;#endif// __ATOMIC_RELAXED提供原子加减操作#if defined(__ATOMIC_RELAXED)#define update_zmalloc_stat_add(__n) __atomic_add_fetch(&amp;used_memory, (__n), __ATOMIC_RELAXED)#define update_zmalloc_stat_sub(__n) __atomic_sub_fetch(&amp;used_memory, (__n), __ATOMIC_RELAXED)#elif defined(HAVE_ATOMIC)// GCC提供的原子加减操作#define update_zmalloc_stat_add(__n) __sync_add_and_fetch(&amp;used_memory, (__n))#define update_zmalloc_stat_sub(__n) __sync_sub_and_fetch(&amp;used_memory, (__n))#else// 使用多线程锁来实现多线程加减操作#define update_zmalloc_stat_add(__n) do &#123; \ pthread_mutex_lock(&amp;used_memory_mutex); \ used_memory += (__n); \ pthread_mutex_unlock(&amp;used_memory_mutex); \&#125; while(0)#define update_zmalloc_stat_sub(__n) do &#123; \ pthread_mutex_lock(&amp;used_memory_mutex); \ used_memory -= (__n); \ pthread_mutex_unlock(&amp;used_memory_mutex); \&#125; while(0)#endif// 增加redis内存计数#define update_zmalloc_stat_alloc(__n) do &#123; \ size_t _n = (__n); \ if (_n&amp;(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&amp;(sizeof(PORT_LONG)-1)); \ // 将n调整为sizeof(PORT_LONG)的整数倍 if (zmalloc_thread_safe) &#123; \ // 开启线程安全 update_zmalloc_stat_add(_n); \ &#125; else &#123; \ used_memory += _n; \ // 不开启线程安全 &#125; \&#125; while(0)// 减少redis内存计数#define update_zmalloc_stat_free(__n) do &#123; \ size_t _n = (__n); \ if (_n&amp;(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&amp;(sizeof(PORT_LONG)-1)); \ // 将n调整为sizeof(PORT_LONG)的整数倍 if (zmalloc_thread_safe) &#123; \ update_zmalloc_stat_sub(_n); \// 开启线程安全 &#125; else &#123; \ used_memory -= _n; \// 不开启线程安全 &#125; \&#125; while(0) 内存管理函数异常处理函数异常处理函数, 在内存分配失败时进行调用。 默认使用zmalloc_default_oom，也可以通过zmalloc_set_oom_handler进行设置异常处理方式。 123456789101112static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) &#123; zmalloc_oom_handler = oom_handler;&#125;static void zmalloc_default_oom(size_t size) &#123; fprintf(stderr, "zmalloc: Out of memory trying to allocate %Iu bytes\n", WIN_PORT_FIX /* %zu -&gt; %Iu */ size);// 打印日志 fflush(stderr); abort();// 中断退出&#125; zmalloczmalloc用来分配指定大小的内存。实际上对malloc进行了一层封装，加入了异常处理和内存统计。 1234567891011121314151617181920void *zmalloc(size_t size) &#123; // 调用malloc进行内存分配 // 多出的PREFIX_SIZE大内存用来记录该段内存大小。 void *ptr = malloc(size+PREFIX_SIZE); // 分配失败的异常处理 if (!ptr) zmalloc_oom_handler(size); // 统计内存使用#ifdef HAVE_MALLOC_SIZE // 内存分配器自带内存大小 update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr;#else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE;#endif&#125; zcalloccalloc是分配内存，并初始化为0。封装的和zmalloc类似。 1234567891011121314151617void *zcalloc(size_t size) &#123; // 分配内存 void *ptr = calloc(1, size+PREFIX_SIZE); // 分配失败的异常处理 if (!ptr) zmalloc_oom_handler(size); // 统计内存使用#ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr;#else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE;#endif&#125; zrealloczrealloc用来重新调整分配的内存大小。 123456789101112131415161718192021222324252627282930void *zrealloc(void *ptr, size_t size) &#123;#ifndef HAVE_MALLOC_SIZE void *realptr;#endif size_t oldsize; void *newptr; // ptr为空，直接使用zmalloc进行分配size大小内存。 if (ptr == NULL) return zmalloc(size);#ifdef HAVE_MALLOC_SIZE oldsize = zmalloc_size(ptr); // 获取ptr指向的内存大小 newptr = realloc(ptr,size); // 重新分配内存 if (!newptr) zmalloc_oom_handler(size); // 异常处理 update_zmalloc_stat_free(oldsize);// 先减 update_zmalloc_stat_alloc(zmalloc_size(newptr));// 后加 return newptr;#else realptr = (char*)ptr-PREFIX_SIZE; oldsize = *((size_t*)realptr);// 获取ptr指向的内存大小 newptr = realloc(realptr,size+PREFIX_SIZE);// 重新分配内存 if (!newptr) zmalloc_oom_handler(size);// 异常处理 *((size_t*)newptr) = size; update_zmalloc_stat_free(oldsize);// 先减 update_zmalloc_stat_alloc(size);// 后加 return (char*)newptr+PREFIX_SIZE;#endif&#125; zfree释放函数 1234567891011121314151617void zfree(void *ptr) &#123;#ifndef HAVE_MALLOC_SIZE void *realptr; size_t oldsize;#endif if (ptr == NULL) return;// 空直接返回#ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_free(zmalloc_size(ptr));// 减少统计数量 free(ptr);// 释放#else realptr = (char*)ptr-PREFIX_SIZE; // 获取真实的指针 oldsize = *((size_t*)realptr);// 获取大小 update_zmalloc_stat_free(oldsize+PREFIX_SIZE);// 减少统计数量 free(realptr);// 释放#endif&#125; zmalloc_size获取指针指向内存大小，在内存分配器不自带该函数时定义。 123456789101112131415// zmalloc.h#ifndef HAVE_MALLOC_SIZEsize_t zmalloc_size(void *ptr);#endif// zmalloc.c#ifndef HAVE_MALLOC_SIZEsize_t zmalloc_size(void *ptr) &#123; void *realptr = (char*)ptr-PREFIX_SIZE; size_t size = *((size_t*)realptr); /* Assume at least that all the allocations are padded at sizeof(PORT_LONG) by * the underlying allocator. */ if (size&amp;(sizeof(PORT_LONG)-1)) size += sizeof(PORT_LONG)-(size&amp;(sizeof(PORT_LONG)-1)); return size+PREFIX_SIZE;&#125;#endif]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis源码阅读-开始]]></title>
      <url>%2F%2Fblog%2F2017%2F03%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B.html</url>
      <content type="text"><![CDATA[自本博客之后的文章大概都是依照《Redis设计与实现》对Redis的源码进行阅读的记录。目的是为了对于Redis有一个了解，同时对之后需要使用Redis的项目上能够有所帮助。 Redis的介绍redis是一个使用C编写的key-value数据库。性能极高且支持丰富的数据类型。它所有的操作都是原子性的。代码精简，只有3w行不到，利于阅读。 阅读顺序如何阅读Redis源码？阅读的顺序主要还是按照黄建宏老师所建议的顺序进行阅读。 阅读数据结构的实现。 阅读内存编码数据结构的实现。 阅读数据类型的实现。 阅读数据库实现相关代码。 阅读客户端和服务端相关代码。 阅读多机功能的实现。 至此将Redis阅读完毕。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gitlab workflow]]></title>
      <url>%2F%2Fblog%2F2017%2F01%2Fgitlab-workflow.html</url>
      <content type="text"><![CDATA[建立一个长期分支，就是master，master分支上的版本都是能够编译运行的版本。整个工作流程如下。第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。第二步：新分支开发完成后，或者需要讨论的时候，先从master合并到分支，解决冲突，然后向master发起一个pull request（简称PR）。第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。） 建立测试项目新建一个项目用于测试工作流。演示项目地址：http://10.10.10.98/MekaYangyi/workflow 设置分支保护新建项目默认master用户才能够push和merge。其余用户只能新建分支，在分支测试完毕后，再发起Merge Requests。发起后，由master进行审核后合并。 设置开发成员项目创建者在项目页面选择Member。 设置开发人员分为两种，一种是直接设置用户，一种是设置一Group都为指定权限。权限分为四类： GuestReporterDeveloperMaster 一般开发人员指定为Developer。具体权限在http://10.10.10.98/help/user/permissions.md查看。设置用户权限设置整个Group的权限 建立本地分支在项目文件夹右键，选择TortoiseGit→Create Branch。填写信息 切换分支在项目文件夹右键，选择TortoiseGit→Switch/Checkout。选择OK。 Commit分出分支后，可以在本地进行Commit，知道一个功能开发完毕后，再上传到服务器。修改本地的文件，Commit。填写上传备注，Commit。 将Master向Test_WorkFlow合并先从服务器pull最新版本，然后将master向Test_WorkFlow合并，防止master在分支分出之后被修改导致的冲突。从服务器pull最新版本。将master向Test_WorkFlow合并。合并解决冲突。 push上传成功后选择push。 确认。成功。 发起Merge Request在项目页面找到分支，选择Merge Request填写相关信息，Submit merge request 检视代码并讨论选择Merge Request。单击测试分支合并功能这一个Merge Request弹出页面。检视代码 Commit，查看修改记录。图中红色区域单击可以Diff与查看源文件。单击任意版本提交记录，增加检视意见，在diff时，任意处可以添加讨论。或者在页面底部对整个修改进行评价。 Changes，查看版本区别。 Discusion，填写建议填写建议后，选择Comment可以互相讨论。或者选择Close merge request关闭请求。 Accept merge request或者Close merge request 合并完成选择Accept Merge Request,同时选择合并时将分支删除。合并结果。 本地pull在本地项目进行pull,同步服务器版本。本地同步结果。 删除本地分支由于远程分支与本地分支没有关系，那么当远程正式Merge之后，需要删除本地分支，防止以后分支一直增加，不减少。在项目文件夹右键，选择TortoiseGit→Switch/Checkout，先把分支切换到本地master。切换完成后，再次进入该界面选择….删除分支 IssueIssue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。 新建Issue选择New Issue填写相关信息。功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如”1-测试Issue”。 新建完成,每一个Issue都有一个编号，本Issue的编号为#1。在分支开发完成后，在commit message里面，可以写上”fixes #14”或者”closes #67”。Github规定，只要commit message里面有下面这些动词 + 编号，就会关闭对应的issue。 closeclosesclosedfixfixesfixedresolveresolvesresolved 这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是username/repository#issue_number。Pull Request被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。 查看结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一次使用gitlab]]></title>
      <url>%2F%2Fblog%2F2017%2F01%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab.html</url>
      <content type="text"><![CDATA[安装git版本差别不大，目前使用的版本git2.11.0.3。一路下一步,不修改安装位置，直接使用默认设置。 安装TortoiseGit一路下一步，不修改安装位置，直接使用默认设置。 登录账户管理员创建账户Admin→New User。新建账户、并设置密码。同时设置该用户所属Group。 name：上传显示的名字，可以经常更改，使用中文名好。 username：登陆的用户名，不可修改，用于账户登陆。 email：账户email，内网联系email。 password：密码，牢记，root用户可修改。 登录登陆内网gitlab，目前网址：10.10.10.98。 修改密码登录后会要求修改密码，自己输入即可。 设置TortoiseGit将注册的用户填入TortoiseGit中,设置为全局账号。 添加ssh如果不添加shh，每次修改都会要求输入账号密码，比较麻烦。添加后与设备绑定，修改不再需要填写账号密码。如果不再使用一个设备，请删除ssh。 生成ssh任意空白处，选择git bash。窗口中输入，一路按回车。1ssh-keygen -t rsa -C "你注册的email地址" 生成后的公钥会存放在 C:/Users/You_User_Name/.ssh/id_rsa.pub。用记事本打开，复制。 将ssh加入gitlab浏览器转到http://10.10.10.98/profile/keys。将复制的Key粘贴，Add key。 新建一个项目新建一个私有项目新建一个私有项目进行实验，gitlab是否能够正常上传。选择new project。 填写基本信息 Project name：项目名称。Project description：项目描述。Visibility Level：项目级别，内网使用只选择public与private。private除了项目成员不可见，public在内网均可见。 选择Create project创建项目。 Clone项目项目创建完成，复制项目地址。复制浏览器的项目地址：http://10.10.10.98/test/test_project。选择计算机一个文件夹，右键，选择git clone。clone之前复制地址项目，确认，输入用户名与密码，clone成功，会新建一个文件夹。 第一次push在该文件夹中建立一个README.md文件。 add右键add，确认，ok。 commitcommit将修改更新到本地。在项目文件夹空白处右键，选择git commit。填写上传理由，commit。 push选择push，push能够将修改push到服务器。确认。成功界面。 查看结果成功在网页端看到修改记录(之前误上传为.md.txt文件，修改为.md文件网页端会显示文字)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] stl源码剖析 总结]]></title>
      <url>%2F%2Fblog%2F2016%2F11%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.html</url>
      <content type="text"><![CDATA[大致上是将STL源码剖析看过了一篇。前三章看到比较认真，后面几章就看到比较粗略了。我想STL的精髓正是在内存配置、迭代器、容器中。至于后面的一些关联式容器，用的红黑树稍复杂，不过在之前的数据结构的基础上和前几章对stl的一些常用方法是熟悉下，其实也就简单了。算法，利用迭代器，同时特化不同的版本。仿函数则是模仿函数效果的对象。整体上都算简单了。我的计划是在未来的一小段日子里实现一个小型的stl，所谓实现，可能也不过是重新将sgi的代码打一遍罢了。不过对于整个stl的理解，我相信会更好一些。之后我应该会更新一些写小型stl遇到的问题和解决方案。项目的地址：https://github.com/MekaYangyi/STL/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] stl源码剖析 第四章 序列式容器]]></title>
      <url>%2F%2Fblog%2F2016%2F11%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8.html</url>
      <content type="text"><![CDATA[容器分类 vectorvector还是比较简单，也就是一个动态数组，提供了些操作，带三个指针，start/finish/end核心就是动态调整内存的方法，也就是满了开大一倍空间，拷贝过去。push_back等操作都是值语义的，拷贝传进来的内容放入到vector中。因为是连续的空间，所有元素连续存储在一整块内存上，迭代器直接用的原始指针。 listlist复杂些.模型和常见的list是一致的，动态创建节点，插入。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct _List_node_base &#123; _List_node_base* _M_next; _List_node_base* _M_prev;&#125;;template &lt;class _Tp&gt;struct _List_node : public _List_node_base &#123; _Tp _M_data;&#125;;//迭代器basestruct _List_iterator_base &#123; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef bidirectional_iterator_tag iterator_category; _List_node_base* _M_node;//节点指针 _List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125; _List_iterator_base() &#123;&#125; void _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125; void _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125; bool operator==(const _List_iterator_base&amp; __x) const &#123; return _M_node == __x._M_node; &#125; bool operator!=(const _List_iterator_base&amp; __x) const &#123; return _M_node != __x._M_node; &#125;&#125;; //迭代器,重载了++ -- == * -&gt;等操作template&lt;class _Tp, class _Ref, class _Ptr&gt;struct _List_iterator : public _List_iterator_base &#123; typedef _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt; iterator; typedef _List_iterator&lt;_Tp,const _Tp&amp;,const _Tp*&gt; const_iterator; typedef _List_iterator&lt;_Tp,_Ref,_Ptr&gt; _Self; typedef _Tp value_type; typedef _Ptr pointer; typedef _Ref reference; typedef _List_node&lt;_Tp&gt; _Node; _List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125; _List_iterator() &#123;&#125; _List_iterator(const iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125; reference operator*() const &#123; return ((_Node*) _M_node)-&gt;_M_data; &#125;#ifndef __SGI_STL_NO_ARROW_OPERATOR pointer operator-&gt;() const &#123; return &amp;(operator*()); &#125;#endif /* __SGI_STL_NO_ARROW_OPERATOR */ _Self&amp; operator++() &#123; this-&gt;_M_incr(); return *this; &#125; _Self operator++(int) &#123; _Self __tmp = *this; this-&gt;_M_incr(); return __tmp; &#125; _Self&amp; operator--() &#123; this-&gt;_M_decr(); return *this; &#125; _Self operator--(int) &#123; _Self __tmp = *this; this-&gt;_M_decr(); return __tmp; &#125;&#125;; deque双向开头的连续空间 比较特别的地方是用一个双指针维护了一个多个连续的空间 迭代器保持连续的方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253inline size_t __deque_buf_size(size_t __size) &#123; return __size &lt; 512 ? size_t(512 / __size) : size_t(1);&#125;template &lt;class _Tp, class _Ref, class _Ptr&gt;struct _Deque_iterator &#123; typedef _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt; iterator; typedef _Deque_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator; static size_t _S_buffer_size() &#123; return __deque_buf_size(sizeof(_Tp)); &#125;..... _Tp* _M_cur; _Tp* _M_first; _Tp* _M_last; _Map_pointer _M_node; _Deque_iterator(_Tp* __x, _Map_pointer __y) : _M_cur(__x), _M_first(*__y), _M_last(*__y + _S_buffer_size()), _M_node(__y) &#123;&#125; _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) &#123;&#125; _Deque_iterator(const iterator&amp; __x) : _M_cur(__x._M_cur), _M_first(__x._M_first), _M_last(__x._M_last), _M_node(__x._M_node) &#123;&#125; reference operator*() const &#123; return *_M_cur; &#125;#ifndef __SGI_STL_NO_ARROW_OPERATOR pointer operator-&gt;() const &#123; return _M_cur; &#125;#endif /* __SGI_STL_NO_ARROW_OPERATOR */ difference_type operator-(const _Self&amp; __x) const &#123; return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - 1) + (_M_cur - _M_first) + (__x._M_last - __x._M_cur); &#125;//++ _Self&amp; operator++() &#123; ++_M_cur; if (_M_cur == _M_last) &#123; //到尾部了就进入下一个区域 _M_set_node(_M_node + 1);//_M_node + 1就是下一个区域 _M_cur = _M_first; &#125; return *this; &#125;......//重置first等指针 void _M_set_node(_Map_pointer __new_node) &#123; _M_node = __new_node; _M_first = *__new_node; _M_last = _M_first + difference_type(_S_buffer_size()); &#125;&#125;; 如果map不足，分配空间12345678910template &lt;class _Tp, class _Alloc&gt;class _Deque_base &#123;....protected: _Tp** _M_map; size_t _M_map_size; //记录的map的大小 iterator _M_start; iterator _M_finish; ....&#125;; 空间不足分配空间12345678910111213141516171819202122 void push_back(const value_type&amp; __t) &#123; if (_M_finish._M_cur != _M_finish._M_last - 1) &#123; construct(_M_finish._M_cur, __t); ++_M_finish._M_cur; &#125; else _M_push_back_aux(__t); &#125; ... template &lt;class _Tp, class _Alloc&gt;void deque&lt;_Tp,_Alloc&gt;::_M_push_back_aux(const value_type&amp; __t)&#123; value_type __t_copy = __t; _M_reserve_map_at_back(); *(_M_finish._M_node + 1) = _M_allocate_node(); __STL_TRY &#123; construct(_M_finish._M_cur, __t_copy); _M_finish._M_set_node(_M_finish._M_node + 1); _M_finish._M_cur = _M_finish._M_first; &#125; __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + 1)));&#125; stack以deuqe为底部结构，封闭头端开口，就是stack。没有迭代器。12345678910111213141516171819202122232425262728293031323334353637383940414243444546//这里设定了了 以deque为基础template &lt;class _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;class stack;template &lt;class _Tp, class _Seq&gt;bool operator==(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);template &lt;class _Tp, class _Seq&gt;bool operator&lt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);template &lt;class _Tp, class _Sequence&gt;class stack &#123;.....#ifdef __STL_MEMBER_TEMPLATES template &lt;class _Tp1, class _Seq1&gt; friend bool operator== (const stack&lt;_Tp1, _Seq1&gt;&amp;, const stack&lt;_Tp1, _Seq1&gt;&amp;); template &lt;class _Tp1, class _Seq1&gt; friend bool operator&lt; (const stack&lt;_Tp1, _Seq1&gt;&amp;, const stack&lt;_Tp1, _Seq1&gt;&amp;);#else /* __STL_MEMBER_TEMPLATES */ friend bool __STD_QUALIFIER operator== __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;); friend bool __STD_QUALIFIER operator&lt; __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);#endif /* __STL_MEMBER_TEMPLATES */.....protected: _Sequence c;public: stack() : c() &#123;&#125; explicit stack(const _Sequence&amp; __s) : c(__s) &#123;&#125; bool empty() const &#123; return c.empty(); &#125; size_type size() const &#123; return c.size(); &#125; reference top() &#123; return c.back(); &#125; const_reference top() const &#123; return c.back(); &#125; void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125; void pop() &#123; c.pop_back(); &#125;&#125;; queue同样以deque为基础1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;class _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;class queue;template &lt;class _Tp, class _Seq&gt;inline bool operator==(const queue&lt;_Tp, _Seq&gt;&amp;, const queue&lt;_Tp, _Seq&gt;&amp;);template &lt;class _Tp, class _Seq&gt;inline bool operator&lt;(const queue&lt;_Tp, _Seq&gt;&amp;, const queue&lt;_Tp, _Seq&gt;&amp;);template &lt;class _Tp, class _Sequence&gt;class queue &#123;.....#ifdef __STL_MEMBER_TEMPLATES template &lt;class _Tp1, class _Seq1&gt; friend bool operator== (const queue&lt;_Tp1, _Seq1&gt;&amp;, const queue&lt;_Tp1, _Seq1&gt;&amp;); template &lt;class _Tp1, class _Seq1&gt; friend bool operator&lt; (const queue&lt;_Tp1, _Seq1&gt;&amp;, const queue&lt;_Tp1, _Seq1&gt;&amp;);#else /* __STL_MEMBER_TEMPLATES */ friend bool __STD_QUALIFIER operator== __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;); friend bool __STD_QUALIFIER operator&lt; __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);#endif /* __STL_MEMBER_TEMPLATES */.....protected: _Sequence c;public: queue() : c() &#123;&#125; explicit queue(const _Sequence&amp; __c) : c(__c) &#123;&#125; bool empty() const &#123; return c.empty(); &#125; size_type size() const &#123; return c.size(); &#125; reference front() &#123; return c.front(); &#125; const_reference front() const &#123; return c.front(); &#125; reference back() &#123; return c.back(); &#125; const_reference back() const &#123; return c.back(); &#125; void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125; void pop() &#123; c.pop_front(); &#125;&#125;; heap堆也就是个完全二叉树。用个数组或者vector就能实现stl中的heap是保证每个父节点大于等于子节点，每次插入删除节点需要重新调整树 push_heappush操作,后调整树，查看父节点是不是符合要求123456789101112131415161718192021222324252627282930313233__push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value)&#123; _Distance __parent = (__holeIndex - 1) / 2;//父节点 while (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123; //调整节点 *(__first + __holeIndex) = *(__first + __parent); __holeIndex = __parent; __parent = (__holeIndex - 1) / 2;//再判断父节点 &#125; *(__first + __holeIndex) = __value;//把新值移动到新位置&#125;template &lt;class _RandomAccessIterator, class _Distance, class _Tp&gt;inline void __push_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance*, _Tp*)&#123; __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), _Tp(*(__last - 1)));&#125;//push_heap算法，这个时候值已经插入heap的最尾端，调用此函数调整heaptemplate &lt;class _RandomAccessIterator&gt;inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)&#123; __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator); __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type, _LessThanComparable); __push_heap_aux(__first, __last, __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));&#125; pop_heap调整相关节点，使得上部全部填满，最底层空出区域。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253template &lt;class _RandomAccessIterator, class _Distance, class _Tp&gt;void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value)&#123; _Distance __topIndex = __holeIndex; _Distance __secondChild = 2 * __holeIndex + 2; while (__secondChild &lt; __len) &#123; if (*(__first + __secondChild) &lt; *(__first + (__secondChild - 1))) __secondChild--; *(__first + __holeIndex) = *(__first + __secondChild); __holeIndex = __secondChild; __secondChild = 2 * (__secondChild + 1); &#125; if (__secondChild == __len) &#123; *(__first + __holeIndex) = *(__first + (__secondChild - 1)); __holeIndex = __secondChild - 1; &#125; __push_heap(__first, __holeIndex, __topIndex, __value);&#125;template &lt;class _RandomAccessIterator, class _Tp, class _Distance&gt;inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Tp __value, _Distance*)&#123; //把first放到last-1 *__result = *__first; //重新整理first到last-1之间重新成为heap __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);&#125;template &lt;class _RandomAccessIterator, class _Tp&gt;inline void __pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*)&#123; //pop出的是最大值，也就是删除掉first，把first放到last-1，然后重新整理first到last-1之间重新成为heap //这样之后只要去取last-1的值，就是弹出的值了。 __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __DISTANCE_TYPE(__first));&#125;//poptemplate &lt;class _RandomAccessIterator&gt;inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)&#123; __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator); __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type, _LessThanComparable); __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));&#125; make_heap不断调用__adjust_heap调整heap的话，最终会是一个heap1234567891011121314151617181920212223242526template &lt;class _RandomAccessIterator, class _Tp, class _Distance&gt;void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*, _Distance*)&#123; if (__last - __first &lt; 2) return; _Distance __len = __last - __first; _Distance __parent = (__len - 2)/2; while (true) &#123; __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent))); if (__parent == 0) return; __parent--; &#125;&#125;template &lt;class _RandomAccessIterator&gt;inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)&#123; __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator); __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type, _LessThanComparable); __make_heap(__first, __last, __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));&#125; sort_heap对一个heap一直pop，最大值移到末尾，那么就是增序序列 了。123456789template &lt;class _RandomAccessIterator&gt;void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)&#123; __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator); __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type, _LessThanComparable); while (__last - __first &gt; 1) pop_heap(__first, __last--);&#125; priority_queue优先弹出权值高的项目，用上面的max_heap就能够实现。操作不多。12345678910111213141516171819202122232425262728293031323334template &lt;class _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector&lt;_Tp&gt;), class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less&lt;typename _Sequence::value_type&gt;) &gt;class priority_queue &#123;......protected: _Sequence c; _Compare comp;public: priority_queue() : c() &#123;&#125; explicit priority_queue(const _Compare&amp; __x) : c(), comp(__x) &#123;&#125; priority_queue(const _Compare&amp; __x, const _Sequence&amp; __s) : c(__s), comp(__x) &#123; make_heap(c.begin(), c.end(), comp); &#125;..... bool empty() const &#123; return c.empty(); &#125; size_type size() const &#123; return c.size(); &#125; const_reference top() const &#123; return c.front(); &#125; void push(const value_type&amp; __x) &#123; __STL_TRY &#123; c.push_back(__x); push_heap(c.begin(), c.end(), comp); &#125; __STL_UNWIND(c.clear()); &#125; void pop() &#123; __STL_TRY &#123; pop_heap(c.begin(), c.end(), comp); c.pop_back(); &#125; __STL_UNWIND(c.clear()); &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] stl源码剖析 第三章 迭代器]]></title>
      <url>%2F%2Fblog%2F2016%2F11%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8.html</url>
      <content type="text"><![CDATA[迭代器是一种抽象的设计概念。iterator模式：提供一种方法，使能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表述方式。 迭代器的设计思维-stl关键所在STL的中心思想在于：将数据容器和算法分开，彼此独立设计。容器和算法的泛型化。迭代器就是扮演着粘胶角色。 迭代器是一种smart pointerlist迭代器stl的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//listnode的基础类struct _List_node_base &#123; _List_node_base* _M_next; _List_node_base* _M_prev;&#125;;//listnodetemplate &lt;class _Tp&gt;struct _List_node : public _List_node_base &#123; _Tp _M_data;&#125;;//迭代器基础类struct _List_iterator_base &#123; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef bidirectional_iterator_tag iterator_category; _List_node_base* _M_node;//包含一个node _List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125; _List_iterator_base() &#123;&#125; void _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125; void _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125; bool operator==(const _List_iterator_base&amp; __x) const &#123; return _M_node == __x._M_node; &#125; bool operator!=(const _List_iterator_base&amp; __x) const &#123; return _M_node != __x._M_node; &#125;&#125;; //迭代器template&lt;class _Tp, class _Ref, class _Ptr&gt;struct _List_iterator : public _List_iterator_base &#123; typedef _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt; iterator; typedef _List_iterator&lt;_Tp,const _Tp&amp;,const _Tp*&gt; const_iterator; typedef _List_iterator&lt;_Tp,_Ref,_Ptr&gt; _Self; typedef _Tp value_type; typedef _Ptr pointer; typedef _Ref reference; typedef _List_node&lt;_Tp&gt; _Node; _List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125; _List_iterator() &#123;&#125; _List_iterator(const iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125; reference operator*() const &#123; return ((_Node*) _M_node)-&gt;_M_data; &#125;#ifndef __SGI_STL_NO_ARROW_OPERATOR pointer operator-&gt;() const &#123; return &amp;(operator*()); &#125;#endif /* __SGI_STL_NO_ARROW_OPERATOR */ //重载了几个操作实现了迭代器，不是很复杂 //++i _Self&amp; operator++() &#123; this-&gt;_M_incr(); return *this; &#125; //i++ _Self operator++(int) &#123; _Self __tmp = *this; this-&gt;_M_incr(); return __tmp; &#125; _Self&amp; operator--() &#123; this-&gt;_M_decr(); return *this; &#125; _Self operator--(int) &#123; _Self __tmp = *this; this-&gt;_M_decr(); return __tmp; &#125;&#125;; Traits编程技法之前就见到用过，通过类型获取，其余的类型。12345678910111213141516171819202122232425262728293031323334353637template &lt;class _Category, class _Tp, class _Distance = ptrdiff_t, class _Pointer = _Tp*, class _Reference = _Tp&amp;&gt;struct iterator &#123; typedef _Category iterator_category; typedef _Tp value_type; typedef _Distance difference_type; typedef _Pointer pointer; typedef _Reference reference;&#125;;template &lt;class _Iterator&gt;struct iterator_traits &#123; typedef typename _Iterator::iterator_category iterator_category; typedef typename _Iterator::value_type value_type; typedef typename _Iterator::difference_type difference_type; typedef typename _Iterator::pointer pointer; typedef typename _Iterator::reference reference;&#125;;//对原生指针特化template &lt;class _Tp&gt;struct iterator_traits&lt;_Tp*&gt; &#123; typedef random_access_iterator_tag iterator_category; typedef _Tp value_type; //ptrdiff_t是C/C++标准库中定义的一个与机器相关的数据类型。ptrdiff_t类型变量通常用来保存两个指针减法操作的结果。ptrdiff_t定义在stddef.h（cstddef）这个文件内。ptrdiff_t通常被定义为long int类型。 typedef ptrdiff_t difference_type; typedef _Tp* pointer; typedef _Tp&amp; reference;&#125;;template &lt;class _Tp&gt;struct iterator_traits&lt;const _Tp*&gt; &#123; typedef random_access_iterator_tag iterator_category; typedef _Tp value_type; typedef ptrdiff_t difference_type; typedef const _Tp* pointer; typedef const _Tp&amp; reference;&#125;; 迭代器的分类：input iter：只读iteroutput iter:只写iterforward iter:允许写入型算法在这种迭代器所形成的区间操作，前向迭代器bidirectional iterator：双向移动iter。random access iter：前三种支持++,第四种支持++ –。这种支持所有指针的算术能力。 typedef typename _Iterator::iterator_category iterator_category;的作用就是能够在编译器发现迭代器的类型，选用最合适的函数版本。12345struct input_iterator_tag &#123;&#125;;struct output_iterator_tag &#123;&#125;;struct forward_iterator_tag : public input_iterator_tag &#123;&#125;;struct bidirectional_iterator_tag : public forward_iterator_tag &#123;&#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag &#123;&#125;; 例子1234567891011121314151617181920212223242526272829template &lt;class _InputIter, class _Distance&gt;inline void __advance(_InputIter&amp; __i, _Distance __n, input_iterator_tag) &#123; while (__n--) ++__i;&#125;template &lt;class _BidirectionalIterator, class _Distance&gt;inline void __advance(_BidirectionalIterator&amp; __i, _Distance __n, bidirectional_iterator_tag) &#123; __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator); if (__n &gt;= 0) while (__n--) ++__i; else while (__n++) --__i;&#125;template &lt;class _RandomAccessIterator, class _Distance&gt;inline void __advance(_RandomAccessIterator&amp; __i, _Distance __n, random_access_iterator_tag) &#123; __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator); __i += __n;&#125;template &lt;class _InputIterator, class _Distance&gt;inline void advance(_InputIterator&amp; __i, _Distance __n) &#123; __STL_REQUIRES(_InputIterator, _InputIterator); //通过下面的函数，选用合适的版本 //不需要传递参数，能够在编译器选定版本 __advance(__i, __n, iterator_category(__i));&#125; __type_traits提供一种机制，允许针对不同的型别熟悉，完成函数派送。在内存配置器中就用到了，比如有没有拷贝构造函数等 1234567891011121314151617181920212223242526272829303132struct __true_type &#123;&#125;;struct __false_type &#123;&#125;;//选择使用__false_type为struct的目的是为了类型推倒，而不是使用bool值作为参数的话只是运行时的选择。template &lt;class _Tp&gt;struct __type_traits &#123; typedef __true_type this_dummy_member_must_be_first; /* Do not remove this member. It informs a compiler which automatically specializes __type_traits that this __type_traits template is special. It just makes sure that things work if an implementation is using a template called __type_traits for something unrelated. */ /* The following restrictions should be observed for the sake of compilers which automatically produce type specific specializations of this class: - You may reorder the members below if you wish - You may remove any of the members below if you wish - You must not rename members without making the corresponding name change in the compiler - Members you add will be treated like regular members unless you add the appropriate support in the compiler. */ typedef __false_type has_trivial_default_constructor; typedef __false_type has_trivial_copy_constructor; typedef __false_type has_trivial_assignment_operator; typedef __false_type has_trivial_destructor; typedef __false_type is_POD_type;&#125;; 然后在这个文件里定义了大量的特化，主要是特化C++标准类型。12345678__STL_TEMPLATE_NULL struct __type_traits&lt;bool&gt; &#123; typedef __true_type has_trivial_default_constructor; typedef __true_type has_trivial_copy_constructor; typedef __true_type has_trivial_assignment_operator; typedef __true_type has_trivial_destructor; typedef __true_type is_POD_type;&#125;;//等。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] stl源码剖析 第一章、第二章 概论、内存配置器]]></title>
      <url>%2F%2Fblog%2F2016%2F11%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E3%80%81%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8.html</url>
      <content type="text"><![CDATA[概论第一章基本都是C++基础的知识，读了《C++ Primer》的话都懂。关于各种C++的特性、STL特性都有。 STL六大组件 功能与运用STL提供六大组件，彼此可以组合套用 容器：各种数据结构。Vector,list,deque,set,map 算法：各种常用算法如sort,search,copy,erase 迭代器：扮演容器与算法之间的粘合剂，所谓的泛型指针。五种类型 仿函数：行为类似函数，可以作为算法的某种策略。仿函数是重载了()的class或者class template，一般函数指针可视为狭义的仿函数 配接器：一种用来修饰容器或者仿函数或迭代器接口的东西。 配置器：负责控件的配置与管理。 空间配置器SGI STL时间了一个专属的，拥有次层配置能力的、效率优越的特殊配置器。SGI STL的缺省分配器都是其自己的分配器。 SGI特殊的空间配置器 std::alloc使用::construct() ::destroy()构造和析构使用alloc::allocate() alloc::deallocate()分配 释放123456789//直接利用这个类能够用指定类型指针，转换为其他引用等template &lt;class _Tp&gt;struct iterator_traits&lt;const _Tp*&gt; &#123; typedef random_access_iterator_tag iterator_category; typedef _Tp value_type; typedef ptrdiff_t difference_type; typedef const _Tp* pointer; typedef const _Tp&amp; reference;&#125;; 123456789101112131415161718192021222324252627//如果有non-trivial 析构函数template &lt;class _ForwardIterator&gt;void__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)&#123; for ( ; __first != __last; ++__first) destroy(&amp;*__first);&#125;//如果没有non-trivial 析构函数template &lt;class _ForwardIterator&gt; inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) &#123;&#125;template &lt;class _ForwardIterator, class _Tp&gt;inline void __destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)&#123; typedef typename __type_traits&lt;_Tp&gt;::has_trivial_destructor _Trivial_destructor; __destroy_aux(__first, __last, _Trivial_destructor());//_Trivial_destructor()将会是_true_type 或者_false_type //利用模板和特化&#125;template &lt;class _ForwardIterator&gt;inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) &#123; __destroy(__first, __last, __VALUE_TYPE(__first));//__VALUE_TYPE(__first)获取到了类型的指针，然后调用上面函数 //利用模板和特化&#125; 空间的配置与释放 std::allocsgi设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略。当分配大于128bytes时候调用第一级，小于128时候，为了降低额外负担，使用负责的memory pool整理方式。 第一级配置器 __malloc_alloc_template剖析以malloc free realloc实现。然后自己实现了一个new handler机制。123456789101112131415template &lt;int __inst&gt;void*__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(size_t __n)&#123; void (* __my_malloc_handler)(); void* __result; for (;;) &#123; __my_malloc_handler = __malloc_alloc_oom_handler; if (0 == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; (*__my_malloc_handler)(); __result = malloc(__n); if (__result) return(__result); &#125;&#125; 第二级配置器SIG第二级配置器的做法，如果区块够大，超过128bytes时候，就移交第一级配置器处理。当区块小鱼128bytes时候，则以内存池管理。每次配置一大块内存，并维护对应之自由链表，下次若再有相同大小的内存需求从free-lists中拨出。如果客端释放小额区块，就由配置器回收到fres-lists中。分配区块时候，自动上调到8的倍数，并维护16个fres-lists,分别管理大小为8/16/24/32/40/48/56/64/72/80/88/96/104/112/120/128的小额区块。 其实这里和公司用的NG_malloc是一样的策略。ng_malloc之前对于大小的区分是256k的样子，更大。后来又改写了，支持更大的内存块了。 节点如下12345__PRIVATE: union _Obj &#123; union _Obj* _M_free_list_link; char _M_client_data[1]; /* The client sees this. */ &#125;; 使用union的话，可以不用每次都去转换。char _M_client_data的存在是，方便去取首地址。实际上下面用到的就是_M_free_list_link，用来作为链表。这样的话，就可以用一个4字节的空间(32位机器指针大小)，实现两个功能。而不是使用struct，因为那样就会浪费空间。 空间配置函数allocate()功能：判断大小，大于128用第一级分配，小于128就查找free list。如果free list中有可用的区块，就直接拿来用，如果没有就将区块大小上调至8的倍数边界，然后调用refill()，准备为free list重新填充空间。123456789101112131415161718192021222324252627282930313233 static void* allocate(size_t __n) &#123; void* __ret = 0; //超过设定的最大值就调用第一级配置器，STL设置为128 if (__n &gt; (size_t) _MAX_BYTES) &#123; __ret = malloc_alloc::allocate(__n); &#125; else &#123; //寻找合适的free lists中适当的一个 _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); // Acquire the lock here with a constructor call. // This ensures that it is released in exit or during stack // unwinding.# ifndef _NOTHREADS /*REFERENCED*/ //多线程锁 _Lock __lock_instance;# endif _Obj* __RESTRICT __result = *__my_free_list; if (__result == 0) //没找到的话，就重新填充free list __ret = _S_refill(_S_round_up(__n)); else &#123; //指向后一个成员 *__my_free_list = __result -&gt; _M_free_list_link; __ret = __result; &#125; &#125; return __ret; &#125;; 空间释放函数 deallocate()先判断大小，大于128调用第一级，小于128找出对应的free list，将区块回收。1234567891011121314151617181920/* __p may not be 0 */ static void deallocate(void* __p, size_t __n) &#123; if (__n &gt; (size_t) _MAX_BYTES) malloc_alloc::deallocate(__p, __n); else &#123; _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __q = (_Obj*)__p; // acquire lock# ifndef _NOTHREADS /*REFERENCED*/ _Lock __lock_instance;# endif /* _NOTHREADS */ __q -&gt; _M_free_list_link = *__my_free_list; *__my_free_list = __q; // lock is released here &#125; &#125; 重新填充free lists123456789101112131415161718192021222324252627282930313233template &lt;bool __threads, int __inst&gt;void*__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(size_t __n)&#123; int __nobjs = 20; //尝试分配空间 __nobjs是引用传递，作为返回值 char* __chunk = _S_chunk_alloc(__n, __nobjs); _Obj* __STL_VOLATILE* __my_free_list; _Obj* __result; _Obj* __current_obj; _Obj* __next_obj; int __i; //对只分配出一个的时候的优化 if (1 == __nobjs) return(__chunk); __my_free_list = _S_free_list + _S_freelist_index(__n); //形成链表 /* Build free list in chunk */ __result = (_Obj*)__chunk; *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); for (__i = 1; ; __i++) &#123; __current_obj = __next_obj; __next_obj = (_Obj*)((char*)__next_obj + __n); if (__nobjs - 1 == __i) &#123; __current_obj -&gt; _M_free_list_link = 0; break; &#125; else &#123; __current_obj -&gt; _M_free_list_link = __next_obj; &#125; &#125; return(__result);&#125; 内存池从内存池中取空间给free list 使用，是chunk_alloc的工作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667template &lt;bool __threads, int __inst&gt;char*__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(size_t __size, int&amp; __nobjs)&#123; char* __result;//返回值 size_t __total_bytes = __size * __nobjs;//需要分配的空间大小 size_t __bytes_left = _S_end_free - _S_start_free;//内存池剩余空间 if (__bytes_left &gt;= __total_bytes) &#123; __result = _S_start_free;//返回 _S_start_free += __total_bytes;//内存池可用空间起始处后移 return(__result); &#125; else if (__bytes_left &gt;= __size) &#123;//能够分配一部分空间 __nobjs = (int)(__bytes_left/__size);//判断能够分配的块数 __total_bytes = __size * __nobjs; __result = _S_start_free; _S_start_free += __total_bytes;//与上同 return(__result); &#125; else &#123;//不能够分配一块的大小 size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4); // Try to make use of the left-over piece. if (__bytes_left &gt; 0) &#123;//把剩余空间，分配到合适的free list _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left); ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list; *__my_free_list = (_Obj*)_S_start_free; &#125; //从堆上重新分配出部分空间 _S_start_free = (char*)malloc(__bytes_to_get); if (0 == _S_start_free) &#123; size_t __i; _Obj* __STL_VOLATILE* __my_free_list; _Obj* __p; // Try to make do with what we have. That can't // hurt. We do not try smaller requests, since that tends // to result in disaster on multi-process machines. for (__i = __size; __i &lt;= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN) &#123; __my_free_list = _S_free_list + _S_freelist_index(__i); __p = *__my_free_list; //malloc失败的话，在现有的free list中找未用的、足够大的fee list分配 if (0 != __p) &#123; *__my_free_list = __p -&gt; _M_free_list_link; _S_start_free = (char*)__p; _S_end_free = _S_start_free + __i; return(_S_chunk_alloc(__size, __nobjs)); // Any leftover piece will eventually make it to the // right free list. &#125; &#125; _S_end_free = 0; // In case of exception. _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get); // This should either throw an // exception or remedy the situation. Thus we assume it // succeeded. &#125; //拿到新空间 _S_heap_size += __bytes_to_get; _S_end_free = _S_start_free + __bytes_to_get; return(_S_chunk_alloc(__size, __nobjs)); &#125;&#125; 内存基本处理工具uninitialized_copy、uninitialized_fill、uninitialized_fill_n用来处理一些特殊的复制构造的情况。 uninitialized_fill_n实现1234567template &lt;class _ForwardIter, class _Size, class _Tp&gt;inline _ForwardIter uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp&amp; __x)&#123; return __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));&#125; 1234567template &lt;class _ForwardIter, class _Size, class _Tp, class _Tp1&gt;inline _ForwardIter __uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp&amp; __x, _Tp1*)&#123; typedef typename __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD; return __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());//判断有没有复制构造函数，调用不同的函数处理&#125; 12345678910111213141516171819202122//没有复制构造函数的版本template &lt;class _ForwardIter, class _Size, class _Tp&gt;inline _ForwardIter__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n, const _Tp&amp; __x, __true_type)&#123; return fill_n(__first, __n, __x);&#125;//有复制构造函数的版本template &lt;class _ForwardIter, class _Size, class _Tp&gt;_ForwardIter__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n, const _Tp&amp; __x, __false_type)&#123; _ForwardIter __cur = __first; __STL_TRY &#123; for ( ; __n &gt; 0; --__n, ++__cur) _Construct(&amp;*__cur, __x); return __cur; &#125; __STL_UNWIND(_Destroy(__first, __cur));&#125; uninitialized_copy、uninitialized_fill的实现类似]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读谷歌编程规范]]></title>
      <url>%2F%2Fblog%2F2016%2F11%2F%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83.html</url>
      <content type="text"><![CDATA[事情的起因好的东西就是这样，你每次看都能够有新的收获。这次也一样，读了一遍谷歌编程规范，又有些新的理解，也有一些需要重新让自己记住的点。遂记录下来，成此博文。 头文件#define保护谷歌的格式是当是： H为保证唯一性，头文件的命名应基于其所在项目源代码树的全路径。例如，项目 foo 中的头文件 foo/src/bar/baz.h 按如下方式保护：1234#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif // FOO_BAR_BAZ_H_ 比较起来我们的格式是使用项目前缀来防止重复，考虑到我们项目的规模一般是不会重复的，因为文件命名上就不一致。 头文件依赖尽量使用前置声明减少头文件的依赖。因为引入一个新的头文件，头文件改变时，包含这个头文件的其他头文件也会被重新编译。1.强数据成员声明为Foo* Foo&amp;2.参数、返回值类型为Foo的函数，只是声明3.今天数据成员的类型可以被声明为Foo，因为静态数据成员定义在类定义之外至于使用指针成员替代成员对象，则会降低可读性，执行效率，不要这样做。 内联函数少于十行的函数定义为内联函数。小巧的代码更好的利用指令缓存。短小的内联函数直接放在.h文件中，对于比较复杂的内联应该放在-inl.h文件中 函数参数的顺序输入参数在前，输出在后。 包含文件顺序C库 C++库 其他库 项目内的头文件应该有带有目录信息,不要使用当前目录和父目录123456789举例来说， google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下 ：#include "foo/public/fooserver.h" // 优先位置#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;hash_map&gt;#include &lt;vector&gt;#include "base/basictypes.h"#include "base/commandlineflags.h"#include "foo/public/bar.h" 作用域命名空间在.CC文件中，允许甚至提倡使用不具名命名空间，以避免运行时候的命名冲突。最好不要使用using，不要声明命名空间std下的恩和内容。 嵌套类公开嵌套类作为接口的一部分时候，虽然可以直接放在全局作用域中，但是最好还是放在命名空间里。使用起来的话， 非成员函数、静态成员函数和全局函数尽量放在命名空间里。 局部变量将函数变量尽可能置于最小作用域内，在声明变量时候将其初始化。靠近第一次使用，利于阅读。 全局变量全局变量的构造函数、西沟函数以及初始化操作的调用顺序只是被部分规定，每次生产可能会有变化。很多可以用单例模式替代。 类构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。构造函数的问题是，没有异常处理。 明确的构造函数使用explicit，防止自动转换。 拷贝构造函数大量类并不要拷贝构造函数，所以应该使用DISALLOW_COPY_AND_ASSIGN来防止拷贝构造函数的自动生成123456789101112// 禁止使用拷贝构造函数和赋值操作的宏// 应在类的 private:中使用#define DISALLOW_COPY_AND_ASSIGN(TypeName) \TypeName(const TypeName&amp;); \void operator=(const TypeName&amp;)class Foo &#123;public:Foo(int f);~Foo();private:DISALLOW_COPY_AND_ASSIGN(Foo);&#125;; 继承使用组合一般都比使用继承合适，继承只使用public继承虚析构函数只在有继承同时有虚函数的时候使用。 接口接口是指满足特定条件的类，这些类以Interface为后缀定义：纯接口 只有纯虚函数和静态函数没有非静态数据成员没有定义任何构造函数，如果有，也不含参数，并且为protected如果是子类，也只能继承满足上述条件并以Interface为后缀的类 操作符重载除了少数特定环境外，不要重载操作符。缺点 混淆你的直觉，让你误以为费时的操作和内建操作一样轻巧查找重载操作符的调用处困难有的操作符可以对指针进行操作重载的副作用，重载操作符&amp;的类不能被前置声明 声明次序在类中使用特定的声明次序：public:在 private:之前，成员函数在数据成员（变量）前。定义次序如下：public:、protected:、private:，如果那一块没有，直接忽略即可。每一块中，声明次序一般如下：1) typedefs 和 enums；2) 常量；3) 构造函数；4) 析构函数；5) 成员函数，含静态成员函数；6) 数据成员，含静态数据成员。宏 DISALLOW_COPY_AND_ASSIGN 置于 private:块之后，作为类的最后部分。参考 拷贝构造函数。.cc 文件中函数的定义应尽可能和声明次序一致。不要将大型函数内联到类的定义中，通常，只有那些没有特别意义的或者性能要求高的，并且是比较短小的函数才被定义为内联函数。更多细节参考译文第一篇的 内联函数。 编写短小函数超过40行，考虑分割。 Google特有的风情智能指针需要使用智能指针的话scoped_ptr完全可以胜任。特殊情况下使用share_ptr。不要使用auto_ptr。倾向于设计对象隶属明确的代码。最明确的对象隶属是根本不使用指针，直接将对象作为一个域或者局部变量使用。 其他C++特征引用参数所有按引用传递的参数必须加上const 缺省参数禁止使用缺省函数参数，所有参数必须明确指定的话，避免程序员不知道存在的缺省参数。 编程数组和alloca禁止使用变长数组。使用安全的分配器。 友元将一个单元测试用类声明为待测类的友元，很方便。 不使用C++异常不使用RTTI直接利用虚函数处理不同类型就好了。 类型转换使用 static_cast比较好处理，直接查找static_cast，就能找到哪里用了转换。C语言转换语义模糊。1) static_cast：和 C 风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上转换；2) const_cast：移除 const 属性；3) reinterpret_cast：指针类型和整型或其他指针间不安全的相互转换，仅在你对所做一切了然于心时使用；4) dynamic_cast：除测试外不要使用，除单元测试外，如果你需要在运行时确定类型信息，说明设计有缺陷（参考 RTTI）。 流 streams只在记录日志的时候使用。其他时候使用printf替代。估计是stream的构造使用成本高，printf简单直接。然后steam重载&lt;&lt;会产生很多意想不到的错误，在深入理解C++面向对象的书里面也有提到。 前置自增和自减效率更高。对于简单数值来说无所谓，但是对于迭代器这种，前置更好。 const的使用在能够使用const的时候使用const. 整型C++中使用 stdint.h中的确定大小整型不要使用无符号，使用断言声明变量非负数。也就是在传参的时候，在执行前断言判断。 预处理宏宏尽量被内联函数、枚举和常量替代下面给出的用法模式可以避免一些使用宏的问题，供使用宏时参考：1) 不要在.h 文件中定义宏；2) 使用前正确#define，使用后正确#undef；3) 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；4) 不使用会导致不稳定的 C++构造（unbalanced C++ constructs，译者注） 的宏，至少文档说明其行为。像我们项目里的宏，完全应该被替代，起码使用一个命名空间，防止污染全局空间事情的发生。 命名约定通用命名规则不缩写易于理解第一 注释TODO注释12// TODO(kl@gmail.com): Use a "*" here for concatenation operator.// TODO(Zeke) change this to use relations. 格式swich如果 default 永不会执行，可以简单的使用 assert：12345678910111213switch (var) &#123;case 0: &#123; // 2 space indent... // 4 space indentbreak;&#125;case 1: &#123;...break;&#125;default: &#123;assert(false);&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows下Pyqt + guiqwt环境的搭建]]></title>
      <url>%2F%2Fblog%2F2016%2F10%2Fwindows%E4%B8%8BPyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA.html</url>
      <content type="text"><![CDATA[事情的起因这几天为了搭一个PyQt的生产环境遇到了好一些坑。本身搭建PyQt的目的是为了进行试验，使用PyQt开发曾经开发过的项目的难度。原项目是使用MFC开发，利用自己开发的折线绘制控件，进行高速的工控数据采集后，显示到界面上。难点主要在，高速采集之后，绘图的效率问题。最终通过自己开发了一套平移显示绘图控件，在新增数据的时候，每一次只绘制一部分数据，然后通过平移之前的图像与之后的链接在一起，这样达到比较高的绘图效率，才解决了问题。但是MFC界面开发复杂，在MFC界面上花费过多的时间。同时本身绘图控件的开发，可能可以利用现有开源控件进行开发来避免重复造轮子。于是利用PyQt+guiqwt绘图库来开发的方案构建起来。guiqwt本身是QT下常用的绘图控件，效率足够高，经过一些优化是能够使用的。相对Python经常使用的matplotlib来说不够漂亮，但是进行实时数据的平移绘图，效率高出很多。PyQt是模仿QT写的图形库，可以利用QTCreate进行快速的界面构建，而Python相对C++来说，需要处理的坑更少，出现各类崩溃的异常的情况会更少一些。本文主要讲的是PyQt+guiqwt在windows上的搭建。目的是在之后能够通过本文进行快速的开发环境的搭建。 开始搭建安装PythonPython官网通过Python官网下载相应版本的Python,我这里下载的是：python-3.5.2-amd64。64位版本，记住版本号，用于之后的库的选择。 安装PyQtPyQt有完整的安装包，过程中会自动安装PyQt+Qt等完整的依赖库。PyQt下载站点浏览所有文件找到对应的PyQt完整安装包。我下的是下面网址中的64位版本。PyQt5-5.6-gpl-Py3.5-Qt5.6.0-x64-2PyQt完整安装包下载安装一路下一步完成。 安装NumPy为了能够使用guiqwt必须安装依赖的库。首先安装numpy，注意的是需要安装+mk1的numpy库，否则scipy无法正常安装后使用。下载地址搜索Numpy找到相应的位置。我选择下载的是，与Python版本对应：numpy-1.11.2+mkl-cp35-cp35m-win_amd64.whl使用pip3.5安装 安装scipy同上，在上面的网站找到scipy。版本我选择的是：scipy-0.18.1-cp35-cp35m-win_amd64使用pip3.5在numpy之后安装 安装guiqwt安装guiqwt上面网站搜索guiqwt选择guiqwt-3.0.3-cp35-cp35m-win_amd64。在sicpy之后使用pip3.5安装 安装eric6下载地址我选择的是：eric6-6.1.10和eric6-i18n-zh_CN-6.1.10解压，放到python的安装目录下：python35/eric6运行python35/eric6、install.py进行安装。运行Python35\Scripts\eric6.bat 就打开了eric6 至此开发环境搭建完成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第三章 模块化 对象和状态]]></title>
      <url>%2F%2Fblog%2F2016%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81.html</url>
      <content type="text"><![CDATA[有效的程序综合还需要一些组织原则，它们能够指导我们系统化地完成系统的整体设计。特别的需要一些能够帮助我们构造起模块化的大型系统策略，也就是说，使这些系统能够“自然地”划分为一些具有内聚力的部分，使这些部分可以分别进行开发和维护。有一种非常强有力的设计策略，特别适合用于构造那类模拟真实物理系统的程序，那就是基于被模拟程序的结构去设计程序的结构。那么有关的物理系统里的每一个对象，我们构造起一个与之对象的计算对象；对该系统里的每种活动，我们在自己的计算系统里顶一种符号操作。采用这一策略时的希望是，在需要针对系统中的新对象或者新活动扩充对应的计算模型时候，我们能够不必对程序的组织方面做得很成功，那么在需要添加新特城或者排除旧东西里的错误时候，就只需要在系统里的一些小局部中工作。本章研究两种特点鲜明的策略。第一种策略将注意力集中在对象上，将大型系统看成一大批对象，它们的行为可能随着时间的进展而不断的变化。另一种组织策略将注意力集中在流过的系统的信息流上，非常像电子工程师观察一个信号处理系统。对于对象途径而言，我们必须关注计算对象可以怎样变化而又同时保持其标识。这将迫使我们抛弃老的计算的代换模型，转向更机械式的，理论上也更不同意把握的计算的环境模型。在处理对象、变化和标识时，各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗。如果允许程序并发指向的可能性，事情会变得更困难许多。流方式特别能用于松解在我们模型中对时间的模拟与计算机求值过程中的各种时间发生的顺序。我们将通过一种称为延时求值的技术做到这一点。 赋值和局部状态一个由许多对象组成的系统里，其中的这些对象极少会是完全独立的。每个对象都可能通过交互作用，影响其他对象的状态，所谓交互就是建立起一个对象的状态变量与其他对象的状态变量之间的联系。确实如果一个系统中的状态变量可以分组，形成一些内部紧密结合的子系统，每个子系统与其他子系统之间只存在松散的练习，此时将这个系统看作是由一些独立对象组成的观点就会特别有用。对于一个系统的这种观点，有可能成为组织这一系统的计算模型的有力框架。要使这样的一个模型成为模块化的，就要求它能够分解为一批计算对象，使它们能够模拟系统里的实际对象。每个计算对象必须有它自己的一些局部状态变量，用于描述实际对象的状态。对于被模拟系统里的对象的状态是随着时间的变化的，与它们对象的计算对象的状态也必须变化。 局部状态变量12345678910(set! &lt;name&gt; &lt;new-value&gt;);设置值(begin &lt;exp1&gt; &lt;exp2&gt;);顺序求值(define balance 100)(define (withdraw amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) "Insufficient funds")) 上面使用了全局变量下面使用局部变量 1234567(define new-withdraw (let ((balance 100)) (lambda (amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) "Insufficient funds")))) 构建一个提款机123456(define (make-withdraw balance) (lambda (amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) "Insufficient funds"))) 创建一个账户123456789101112131415(define (make-withdraw balance) (define (withdraw amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) "Insufficient funds")) (define (deposit amount) (set! balance (+ balance amount)) balance) (define (dispatch m) (cond ((eq? m 'withdraw) withdraw) ((eq? m 'deposit) deposit) (else (error "Unknoew request --MAKE-ACCOUNT" m)))) dispatch) 引进赋值带来的收益能够简化一部分需要变量状态的过程。 引进赋值的代价相比函数是编程，输入什么结果就是什么。显然引进赋值让程序变得更复杂。需要存在一个位置存储变量。 命令式程序设计的缺陷与函数式程序设计相对，广泛采用的赋值程序设计被称为命令是程序设计。求值顺序需要保证。 求值的环境模型类似于C++的区域。过程也是对象。调用过程就会产生新的上下文环境，过程内的是过程内的环境。过程外全局环境等。 过程应用的环境模型两条规则： 将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在构造起的这一新环境的上下文中求 相对于一个给定的环境求值一个lambda表达式，将创建其一个过程对象，这个过程对象是一个序对，由该lambda表达式的征文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时候的环境。 简单过程的应用将框架看做局部状态的展台内部定义 局部过程的名字不会与包容它们的过程之外的名字互相干扰，这是因为这些局部过程名 都是该过程运行时创建的框架里约束的，而不是在全局环境里约束的。 局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数，这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属。 用变动的数据做模拟12345678(define (append! x y) (set-cdr! (last-pair x) y) x)(define (last-pair x) (if (null? (cdr x)) x (last-pair (cdr x)))) 共享与相等共享会导致多个对象都拥有同一个对象，修改一个会导致另外的也跟着被修改。1(eq? x y);检查是不是一个对象 改变也就是赋值主要是构建了一前一后两个指针。12345678910111213141516171819(define (cons x y) (define (set-x! v) (set! x v)) (define (set-y! v) (set! y v)) (define (dispatch m) (cond ((eq? m 'car) x) ((eq? m 'cdr) y) ((eq? m 'set-car!) set-x!) ((eq? m 'set-cdr!) set-y!) (else (error "Undefined operation -- CONS" m)))) dispatch)(define (car z) (z 'car))(define (cdr z) (z 'cdr))(define (set-car! z new-value) ((z 'set-car!) new-value) z)(define (set-cdr! z new-value) ((z 'set-cdr!) new-value) z) 队列的表示1234567891011121314151617181920212223242526272829303132;构造函数(define (make-queue) (cons '() '()));选择函数(define (front-queue queue) (if (empty-queue? queue) (error "FRONT called with an empty queue" queue) (car (front-ptr queue))));检测队列是否为空(define (empty-queue? queue) (null? (front-ptr queue)));改变函数(define (insert-queue! queue item) (let ((new-pair (cons item '()))) (cond ((empty-queue? queue) (set-front-ptr! queue new-pair) (set-rear-ptr! queue new-pair) queue) (else (set-cdr! (rear-ptr queue) new-pair) (set-rear-ptr! queue new-pair) queue))))(define (delete-queue! queue) (cond ((empty-queue? queue) (error "DELETE! called with an empty queue" queue)) (else (set-front-ptr! queue (cdr (front-ptr queue))) queue)))(define (front-ptr queue) (car queue))(define (rear-ptr queue) (cdr queue))(define (set-front-ptr! queue item) (set-car! queue item))(define (set-rear-ptr! queue item) (set-car! queue item)) 表格的表示12345678910111213141516171819(define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false)))(define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records)))))(define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))))(define (make-table) (list '*table*)) 数字电路的模拟器并发：时间本质是个问题和普通的并发问题是一致的。串行化共享部分。123456789101112131415161718(define s make-serializer)(define (make-account balance) (define (withdraw amount) (if (&gt;= balance amount) (begin (set! balance (= balance amount)) balance) "Insufficient funds")) (define (deposit amount) (set! balance (+ balance amount)) balance) (let ((protected (make-serializer))) (define (dispatch m) (cond ((eq? m 'withdraw) (protected withdraw)) ((eq? m 'deposit) (protected deposit)) ((eq? m 'balance) balance) (else (error "Unknown request --MAKE-ACCOUNT" m)))) dispatch)) 串行化的实现互斥元同步机制。12345678910111213141516171819202122232425(define (make-serializer) (let ((mutex (make-mutex))) (lambda (p) (define (serialized-p . args) (mutex 'acquire) (let ((val (apply p args))) (mutex 'release) val)) serialized-p)))(define (make-mutex) (let ((cell (list false))) (define (the-mutex m) (cond ((eq? m 'acquire) (if (test-and-set! cell) (the-mutex 'acquire))) ((eq? m 'release) (clea! cell)))) the-mutex))(define (test-and-set! cell) (if (car cell) true (begin (set-car! cell true) false)))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第二章 带有通用型操作的系统]]></title>
      <url>%2F%2Fblog%2F2016%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E6%9C%89%E9%80%9A%E7%94%A8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F.html</url>
      <content type="text"><![CDATA[通用型算术运算12345678910111213141516171819202122(define (add x y) (apply-generic 'add x y))(define (sub x y) (apply-generic 'sub x y))(define (mul x y) (apply-generic 'mul x y))(define (div x y) (apply-generic 'div x y))(define (install-scheme-number-package) (define (tag x) (attach-tag 'scheme-number x)) (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y)))) (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y)))) (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y)))) (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y)))) (put 'make '(scheme-number scheme-number) (lambda (x) (tag x))) 'done) (define (make-scheme-number n) ((get 'make 'scheme-number) n)) 利用同样的方法可以加入有理数/复数等操作 不同类型数据的组合处理跨类型的操作。为每一种跨类型操作提供专门的过程处理，是可以，但是太麻烦。每添加一种类型，要增加太多过程。 强制类型转换处理能够解决一部分问题。123;实数转虚数(define (scheme-number-&gt;complex n) (make-complex-from-real-imag (contents n) 0)) 将这些强制过程安装到一个特护的表格里，用两个类型的名字作为索引。1(put-coercion 'scheme-number 'complex scheme-number-&gt;complex) 123456789101112131415161718192021(define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (if (= (length args) 2) (let ((type1 (car type-tags)) (type2 (cadr type-tags)) (a1 (car args)) (a2 (cadr args))) (let ((t1-&gt;t2 (get-coercion type1 type2)) (t2-&gt;t1 (get-coercion type2 type1))) (cond (t1-&gt;t2 (apply-generic op (t1-&gt;t2 a1) a2)) (t2-&gt;t1 (apply-generic op a1 (t2-&gt;t1 a2))) (else (error "No method for these types" (list op type-tags)))))) (error "No method for these types" (list op type-tags))))))) 类型的层次结构就是继承嘛。子类型有父类型的所有操作。 #层次结构的不足可能产生菱形的层次结构。 在设计大型系统时，处理好一大批相互有关的类型而同时又能保持模块性，这是一个困难的问题，也是当前正在继续研究的领域。编者注：这句话出现在书的第一版本。它的现在就像20年前写出时候正确。开发出一种有用的，具有一般意义的框架，以描述不同类型对象之间的关系(哲学中本体论)，看来是一件极其困难的工作。在10年前存在的混乱和今天存在的混乱之间的主要差异在于，今天已经有了一批各式各样的并不合适的本体理论，它们已经嵌入数量过多而又先天不足的各种程序设计语言里。举例来说，面向对象语言的大部分复杂性-以及当前各种面向对象语言之间细微的而且诗人迷惑的差异-的核心，就是类型之间通用型操作的处理。我们在第三章有关计算性对象的讨论中完全避免了这些问题。熟悉面向对象程序涉及到读者将会注意到，在第三章里关于局部状态说了许多东西，但是却根本没有提到“类”或者“继承”。事实上，我们的猜想是，如果没有知识表示和自动推理工作的帮助，这些问题是无法仅仅通过计算机语言设计的方式合理处理的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第二章 抽象数据的多重表示]]></title>
      <url>%2F%2Fblog%2F2016%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA.html</url>
      <content type="text"><![CDATA[对于一个数据对象可以能存在多种有用的表示形式，而且我们也希望所涉及的系统能够处理多种表示形式。例子：复数的极坐标形式和直角坐标的形式构造通用型过程：可以在不止一种数据表示上操作的过程。采用的技术：让它们在带有类型标志的数据对象上工作。也就是说，让数据对象包含着它们应该如何处理的明确信息。 复数的表示为一个数据提供了多种操作，存在多种形式123456789101112131415161718192021222324252627282930(define (real-part z) (car z))(define (imag-part z) (cdr z))(define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z)))))(define (angle z) (atan (imag-part z) (real-part z)))(define (make-from-real-imag x y) (cons x y))(define (make-from-mag-ang r a) (cons (* r (cos a)) (* r (sin a))))(define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))(define (sub-complex z1 z2) (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))(define (mul-complex z1 z2) (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))(define (div-complex z1 z2) (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2)))) 带标志数据认识数据抽象的一种方式是将其看做”最小允诺原则“的一个应用。在实现上面的复数系统的时候，采用两种形式，由选择函数和构造函数形成的抽象屏障，使我们可以把为自己所用的数据对象选择具体表现形式的事情尽量往后推，而且还能够保持系统设计的最大灵活性。方式，利用类型标志，来确定什么类型，选择什么函数。增加类型标示123456789101112131415161718(define (attach-tag type-tag contents) (cons type-tag contents))(define (type-tag datum) (if (pair? datum) (car datum) (error "Bad tagged datum -- TYPE-TAG" datum)))(define (contents datum) (if (pair? datum) (cdr datum) (error "Bad tagged datum -- CONTENTS" datum)))(define (rectangular? z) (eq? (type-tag z) 'rectangular))(define (polar? z) (eq? (type-tag z) 'polar)) 修改新的直角坐标表示1234567891011121314(define (real-part-rectangular z) (car z))(define (imag-part-rectangular z) (cdr z))(define (magnitude-rectangular z) (sqrt (+ (square (real-part-rectangular z)) (square (imag-part-rectangular z)))))(define (angle-rectangular z) (atan (imag-part-rectangular z) (real-part-rectangular z)))(define (make-from-real-imag-rectangular x y) (attach-tag 'rectangular (cons x y)))(define (make-from-mag-ang-rectangular r a) (attach-tag 'rectangular (cons (* r (cos a)) (* r (sin a))))) 修改极坐标的表现形式12345678910111213141516171819(define (real-part-polat z) (* (magnitude-polat z) (cos (angle-polat z))))(define (imag-part-polat z) (* (magnitude-polat z) (sin (angle-polat z))))(define (magnitude-polat z) (car z))(define (angle-polat z) (cdr z))(define (make-from-real-imag-polatr x y) (attach-tag 'polar (cons (sqrt (+ (square x) (square y))) (atan y x))))(define (make-from-mag-ang-polat r a) (attach-tag 'polar (cons r a))) 在通用选择函数都添加检查类型的标志，调用合适的函数。123456789101112131415161718192021222324252627(define (real-patr z) (cond ((rectangular? z) (real-part-rectangular (contents z))) ((polar? z) (real-part-polat (contents z))) (else (error "Unknown type -- REAL-PART" z))))(define (imag-patr z) (cond ((rectangular? z) (imag-part-rectangular (contents z))) ((polar? z) (imag-part-polat (contents z))) (else (error "Unknown type -- IMAG-PART" z))))(define (magnitude z) (cond ((rectangular? z) (magnitude-rectangular (contents z))) ((polar? z) (magnitude-polat (contents z))) (else (error "Unknown type -- MAGNITUDE" z))))(define (angle z) (cond ((rectangular? z) (angle-rectangular (contents z))) ((polar? z) (angle-polat (contents z))) (else (error "Unknown type -- ANGLE" z)))) 实现算数操作的时候不需要改变。还是原来的形式就可以。123(define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2)))) 需要修改下构造函数12345(define (make-from-real-imag x y) (make-from-real-imag-rectangular x y))(define (make-from-mag-ang r a) (make-from-mag-ang-polat r a)) 数据导向的程序设计和可加性检查一个数据项的类型，并据此去调用某个适当的过程称为基于类型的分派。在系统设计中，这是一种获得模块性的强有力策略（可能oo是更好的方式，检测类型还是比较麻烦的）。存在两个弱点： 其中的通用型接口过程，必须知道素有的不同表示。需要检测类型，选择适当函数 独立的表现形式分别设计，需要拥有不同的名字。那么这就导致，这种实现不具有可加性。在每一次增加一种新形式的时候，需要去修改原过程，修改类型判断，增加代码，修改过程名字。 现在我们需要的是一种能够将系统设计进一步模块化的方法。一种称为数据导向的程序设计都编程技术提供了这种能力（其实在数据中保存能够处理数据的过程，就能够不用选择函数直接处理了嘛）。（实际上这里讲的是一种注册机制）假定存在put get来制造表格12345678910111213141516171819202122(define (install-rectangular-package) ;internal procedures (define (real-part z) (car z)) (define (imag-part z) (cdr z)) (define (make-from-real-imag x y) (cons x y)) (define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z))))) (define (angle z) (atan (imag-part z) (real-part z))) (define (make-from-mag-ang r a) (cons (* r (cos a)) (* r (sin a)))) ;interface the rest of the system (define (tag x) (attach-tag 'rectangular x)) (put 'real-part '('rectangular) real-part) (put 'imag-part '('rectangular) imag-part) (put 'magnitude '('rectangular) magnitude) (put 'angle '('rectangular) angle) (put 'make-from-real-imag '('rectangular) (lambda (x y) (tag (make-from-real-imag x y)))) (put 'make-from-mag-ang '('rectangular) (lambda (r a) (tag (make-from-mag-ang r a)))) 'done) 1234567891011121314151617181920212223(define (install-polar-package) ;internal procedures (define (magnitude z) (car z)) (define (angle z) (cdr z)) (define (make-from-mag-ang r a) (cons r a)) (define (real-part z) (* (magnitude z) (cos (angle z)))) (define (imag-part z) (* (magnitude z) (sin (angle z)))) (define (make-from-real-imag x y) (cons (sqrt (+ (square x) (square y))) (atan y x))) ;interface the rest of the system (define (tag x) (attach-tag 'polar x)) (put 'real-part '('polar) real-part) (put 'imag-part '('polar) imag-part) (put 'magnitude '('polar) magnitude) (put 'angle '('polar) angle) (put 'make-from-real-imag '('polar) (lambda (x y) (tag (make-from-real-imag x y)))) (put 'make-from-mag-ang '('polar) (lambda (r a) (tag (make-from-mag-ang r a)))) 'done) 下面操作用于访问表格12345678(define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (error "No method for these types -- APPLY-GENERIC" (list op type-tags)))))) 那么通用操作。1234(define (real-part z) (apply-generic 'real-part z))(define (imag-part z) (apply-generic 'imag-part z))(define (magnitude z) (apply-generic 'magnitude z))(define (angle z) (apply-generic 'angle z)) 12345(define (make-from-real-imag x y) ((get 'make-from-real-imag 'rectangular) x y))(define (make-from-mag-ang r a) ((get 'make-from-mag-ang 'polat) r a)) 消息传递数据导向的程序设计，最关键的思想是通过显式的操作-类型表格的方式，管理程序中的各种通用性操作。上面使用的程序设计风格是一种基于类型进行分派的组织方式，其中让每个操作管理自己的分派。从效果上看，这种方式就是将操作-类型表哥格分解位一行一行，每个通用型过程表示表格中的一行。另一种实现策略是将这一表格按列进行分解，不是采用一批“只能”操作区基于数据类型进行分派，而是采用“只能数据对象”，让它们基于操作名完成所需要的分派工作。需要做的，将每一个数据对象表示为一个过程。（实际上类似于数据封装，每个数据对象保存专有的函数，利用虚函数就行了。思想是一致的。stl） 12345678910111213(define (make-from-real-imag x y) (define (dispatch op) (cond ((eq? op 'real-part) x) ((eq? op 'iamg-part) y) ((eq? op 'magnitude) (sqrt (+ (square x) (square y)))) ((eq? op 'angle) (atan y x)) (else (error "Unkonown op -- MAKE-FROM-REAL-IMAG" op))))dispatch);查找函数(define (apply-generic op arg) (arg op)) 这种风格的程序设计称为消息传递，将数据对象设想位一个实体，它以消息的方式接受所需要操作的名字。（设计模式里面有一种这种模式）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第二章 符号数据]]></title>
      <url>%2F%2Fblog%2F2016%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE.html</url>
      <content type="text"><![CDATA[12(list 'a 'b)(eq? a b) 符号求导123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960;e是变量吗(define (variable? x) (symbol? x));symbol?判断变量是不是符号;v1和v2是同一个变量吗(define (same-variable? v1 v2) (and (variable? v1) (variable? v2) (eq? v1 v2)));e是和式吗(define (sum? x) (and (pair? x) (eq? (car x) '+)));e的被加数(define (addend s) (cadr s));e的加数(define (augend s) (caddr s));构造起a1和a2的和式(define (make-sum a1 a2) (list '+ a1 a2));e是乘式吗(define (product? x) (and (pair? x) (eq? (car x) '*)));e的被乘数(define (multiplier p) (cadr p));e的乘数(define (multiplicand p) (caddr p));构造起来m1与m2的乘式(define (make-product m1 m2) (list '* m1 m2));求导(define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) ((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))) ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp)))) (else (error "unknown expression type -- DERIV" exp))))(deriv '(+ x 3) 'x)(deriv '(* x y) 'x)(deriv '(* (* x y) (+ x 3)) 'x)'(+ 1 0)'(+ (* x 0) (* 1 y))'(+ (* (* x y) (+ 1 0)) (* (+ (* x 0) (* 1 y)) (+ x 3))) 集合的表示集合作为未排序的表1234567891011121314151617;判断是不是表成员(define (element-of-set? x set) (cond ((null? set) false) ((equal? x (car set)) true) (else (element-of-set? x (cdr set)))));向表增加一项(define (adjoin-set x set) (if (element-of-set? x set) set (cons x set)));合并(define (intersection-set set1 set2) (cond ((or (null? set1) (null? set2)) '()) ((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))) (else (intersection-set (cdr set1) set2)))) 集合作为排序的表排序的存在的好处就是减少复杂度123456789101112131415161718(define (element-of-set? x set) (cond ((null? set) false) ((= x (car set)) true) ((&lt; x (car set)) false) (else (element-of-set? x (cdr set))))) (define (intersection-set set1 set2) (if (or (null? set1) (null? set2)) '() (let ((x1 (car set1)) (x2 (car set2))) (cond ((= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2)))) ((&lt; x1 x2) (intersection-set (cdr set1) set2)) ((&lt; x2 x1) (intersection-set set (cdr set2))))))) 集合作为二叉树有序二叉树12345678910111213141516171819202122232425262728(define (entry tree) (car tree))(define (left-branch tree) (cadr tree))(define (right-branch tree) (caddr tree))(define (make-tree entry left right) (list entry left right)) (define (element-of-set? x set) (cond ((null? set) false) ((= x (entry set)) true) ((&lt; x (entry set)) (element-of-set? x (left-branch set))) ((&gt; x (entry set)) (element-of-set? x (right-branch set)))));插入要找到正确位置(define (adjoin-set x set) (cond ((null? set) (make-tree x '() '())) ((= x (entry set)) set) ((&lt; x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))) ((&gt; x (entry set)) (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))))) huffman编码树123456789101112131415161718192021222324252627282930;树的表示;leaf 符号 权重(define (make-leaf symbol weight) (list 'leaf symbol weight)) (define (leaf? object) (eq? (car object) 'leaf)) (define (symbol-leaf x) (cadr x))(define (weight-leaf x) (caddr x))(define (make-code-tree left right) (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right)))) (define (left-branch tree) (car tree))(define (right-branch tree) (cadr tree))(define (symbols tree) (if (leaf? tree) (list (symbol-leaf tree)) (caddr tree)))(define (weight tree) (if (leaf? tree) (weight-leaf tree) (caddr tree))) 解码过程12345678910111213141516(define (decode bits tree) (define (decode-1 bits current-branch) (if (null? bits) '() (let ((next-branch (choose-branch (car bits) current-branch))) (if (leaf? next-branch) (cons (symbol-leaf next-branch) (decode-1 (cdr bits) tree)) (decode-1 (cdr bits) next-branch))))) (decode-1 bits tree))(define (choose-branch bit branch) (cond ((= bit 0) (left-branch branch)) ((= bit 1) (right-branch branch)) (else (error "bad bit -- CHOOSE-BRANCH" bit)))) 带权重的集合12345678910111213(define (adjoin-set x set) (cond ((null? set) (list x)) ((&lt; (weight x) (weight (car set))) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set))))))(define (make-leaf-set pairs) (if (null? pairs) '() (let ((pair (car pairs))) (adjoin-set (make-leaf (car pair) (cadr pair)) (make-leaf-set (cdr pairs))))))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第二章 构造数据抽象]]></title>
      <url>%2F%2Fblog%2F2016%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1.html</url>
      <content type="text"><![CDATA[第一章关注的是计算过程，以及过程在程序中所扮演的角色。本章，讲将数据对象组合起来，形成复合数据的方式。复合数据：能够提升我们在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。将程序中处理数据对象的表示的部分与处理数据对象的使用部分相互 隔离的技术，称为数据抽象。复合数据中的一个关键性思想是闭包的概念，也就是说，用于组合数据对象的粘合剂不但能用于组合基本的数据对象，也能组合复合数据对象。复合数据对象能够称为以混合与匹配的方式组合程序模块的方便接口。 数据抽象引导数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在抽象数据上操作一样。 有理数的算数运算假定存在构造函数与选择函数123(make-rat n d);返回一个有理数，分子是整数n，分母是整数d(numer x);返回有理数x的分子(denom x));返回有理数x的分母 那么可以定义以下的规则12345678910111213141516171819202122;加法(define (add-rat x y) (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))));减法(define (sub-rat x y) (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))));乘法(define (mul-rat x y) (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))));除法(define (div-rat x y) (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))));等于？(define (equal-rat? x y) (= (* (numer x) (denom y)) (* (numer y) (denom x)))) 序对lisp存在基本过程cons，car,cdr。存在下列关系1234567(define x (cons 1 2))(car x)1(cdr x)2 有理数的表示利用序对完成有理数的实现12345678(define (make-rat n d) (cons n d))(define (numer x) (car x))(define (denom x) (cdr x)) 打印有理数12345(define (print-rat x) (newline) (display (numer x)) (display "/") (display (denom x))) 化简有理数123(define (make-rat n d) (let ((g (gcd n d))) (cons (/ n g) (/ d g)))) 抽象屏障每一个层次中国策构成了所定义的抽象 屏障的接口，联系起系统中的不同层次。使得系统简单，修改容易。 数据意味着什么一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及使这些过程成为一套合法的表示，它们必须满足一组特定的条件。使用过程实现cons car cdr12345678910(define (cons x y) (define (dispatch m) (cond ((= m 0) x) ((= n 1) y) (else (error "Argument not 0 or 1 -- CONS" m)))) dispatch)(define (car z) (z 0))(define (cdr z) (z 1)) 尽管实际语言的实现不是上面的形式，但是我们定义的函数已经能够正常完成工作了。过程和数据的界限被模糊，满足关于序对的描述。 层次性数据和闭包性质某种组合数据对象的操作满足闭包性质，那就是说，通过它组合起数据对象得到的结果本身可以通过同样的操作再进行组合。闭包性质是任何一种组合功能的威力的关键要素，因为它使我们能够建立起层次性的结构，这种结构由一些部分构成，而其中的各个部分又是由它们的部分构成，并且可以继续下去。 序列的表示123(list &lt;a1&gt; &lt;a2&gt;...&lt;an&gt;);等于(cons &lt;a1&gt; (cons &lt;a2&gt; (cons ... (cons &lt;an&gt; nil)...))) nil是拉丁词汇nihil的缩写，拉丁语表示什么也没有，表示序对的链结束，代表一个不包含任何元素的序对，空表。 表操作1234567891011121314151617181920212223242526272829303132333435363738;第n个元素(define (list-ref items n) (if (= n 0) (car items) (list-ref (cdr items) (- n 1))))(define squares (list 1 4 9 16 25))(list-ref squares 3)16;表长 递归(define (length items) (if (null? items) 0 (+ 1 (length (cdr items))))) ;表长 迭代(define (length items) (define (length-iter a count) (if (null? a) count (length-iter (cdr a) (+ 1 count)))) (length-iter items 0)) (length squares)5(define odds (list 1 3 5 7));组合两个表(define (append list1 list2) (if (null? list1) list2 (cons (car list1) (append (cdr list1) list2))))(append odds squares)'(1 3 5 7 1 4 9 16 25) 对表的映射1234567891011121314151617181920212223;DrRacket中未定义nil，若要使用nil(define nil '());缩放(define (scale-list items factor) (if (null? items) nil (cons (* (car items) factor) (scale-list (cdr items) factor)))) (scale-list (list 1 2 3 4 5) 10)'(10 20 30 40 50);更一般的过程(define (map proc items) (if (null? items) nil (cons (proc (car items)) (map proc (cdr items))))) (define (scale-list items factor) (map (lambda (x) (* x factor)) items)) map构建一层抽象屏障，将实现表变换的过程的实现，与如何提取表中元素以及组合结果的细节隔离开。 层次性结构树的分支，而那些本身也是序列的元素就形成了树中的子树。实现count-leaver12345(define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) 对树的映射123456789101112(define (sacle-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (sacle-tree (car tree) factor) (sacle-tree (cdr tree) factor)))))(define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) 序列作为一种约定的接口强有力的设计原理-使用约定的接口。考虑下面的过程，它以一棵树为参数，计算出那些值为奇数的叶子的平方和。123456(define (sum-odd-squares tree) (cond ((null? tree) 0) ((not (pair? tree)) (if (odd? tree) (square tree) 0)) (else (+ (sum-odd-squares (car tree)) (sum-odd-squares (cdr tree)))))) 偶数的斐波那契数列的表。123456789(define (even-fibs n) (define (next k) (if (&gt; k n) nil (let ((f (fib k))) (if (even? f) (cons f (next (+ k l))) (next (+ k 1)))))) (next 0)) 虽然表面上结构差异大，但是计算的抽象描述存在极大的相似性。都是从枚举器开始，产生给定的树的树叶组成的信号。信号流过过滤器，过滤掉不符合规则的信号。通过一个映射，转换每一个元素。积累器把所有的元素组合起来。但是上面的程序是将以上的操作混合在一起。 序列操作修改map过程 12(map square (list 1 2 3 4 5))(1 4 9 16 25) 过滤器123456(define (filter predicate sequence) (cond ((null? sequence) nil) ((predicate (car sequence)) (cond (car sequence);真就保留 (filter predicate (cdr sequence)))) (else (filter predicate (cdr sequence))))) 积累器12345(define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) fib枚举器1234(define (enumerate-interval low high) (if (&gt; low high) nil (cons low (enumerate-interval (+ low 1) high)))) 树叶枚举器12345(define (enumerate-tree tree) (cond ((null? tree) nil) ((not (pair? tree)) (list tree)) (else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree)))))) 重构123456(define (sum-odd-squares tree) (accumulate + 0 (map square (filter odd? (enumerate-tree tree))))) 123456(define (even-fibs n) (accumulate cons nil (filter even? (map fib (enumerate-interval 0 n))))) 通过提供一个标准不见的库，并使这些不见都有着一些能以灵活方式互相连接的约定接口，将能够进一步推动模块化设计。在工程设计中，模块化结构是控制复杂性的一种威力巨大的策略。（类似西门子的自动化软件 plc等）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第一章 构造过程抽象]]></title>
      <url>%2F%2Fblog%2F2016%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1.html</url>
      <content type="text"><![CDATA[关于读书的目的很多时候对于一本比较复杂的书，你在到达一定阶段的时候是难以读进去的。Sicp我曾经在几个月前尝试的去读了第一章。很快就读完的，但是对于其的理解实在浅薄。我希望在这一次的阅读的过程中能够顺利的过一次不本书有所收获。在接下来的日子里，我会记录下读书笔记以及习题的解答。这是一个开始。 构造过程抽象每一种强有力的语言为此提供了三种机制 基本的表达形式， 用于表示语言所关心的最简单的个体。 组合的方法，通过它们可以从简单的东西出发构建出复合的元素。 抽象的方法，通过它们可以为 复合对象命名，并将它们作为单元去操作。 在程序设计中，我们需要处理两类元素：过程和数据。非形式的说，数据是一种我们希望去操作的”东西“，而过程是有关操作这些数据的规则的描述。 1234567(* ( + 2 ( * 5 6 )) ( + 3 5 7))(define (square x) (* x x))(square 21)441 过程应用的带换模型对于符合过程，过程的应用的计算过程是： 将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程求值。 1234567891011(f 5)(sum-of-squares(+ 5 1) (* 5 2))(+ (square 6) (square 10))(+ (* 6 6) (* 10 10))(+ 36 100)136 这种计算过程称为过程应用的代换模型。 应用系和正则序完全展开而后归约的求值模型是正则序求值。先求值参数而后应用的方式为应用序求值。 条件语法1234567891011121314151617(define (abs x) (cond ((&gt; x 0) x) (( = x 0) 0) (( &lt; x 0) (- x))))(define (abs x) (cond (( &lt; x 0) (- x)) (else x)))(define (abs x) (if ( &lt; x 0) (- x) x)) 过程与它们所产生的计算一个过程也就是一种模式，它描述了一个计算过程的局部演化方法。 两种描述阶乘的方式。（lisp的迭代不是说形式上的迭代，实际上如果说调用本身的层面上还是递归，但是思想是迭代的思想，应用序来看的话。）12345678910111213141516(define (factorial n) (if (= n 1) 1 (* n (factorial (- n 1)))));迭代的形式(define (factorial n) (fact-iter 1 1 n));应用序的话会优先求值，那么就不会有上面的方式那么深的层次，尝试求值都能够求出来。(define (fact-iter product counter max-count) (if (&gt; counter max-count) product (fact-iter (* counter product) (+ counter 1) max-count))) 迭代计算过程就是那种其状态可以用固定数据的状态变量描述的计算过程，而与此同时，又存在着一套固定的规则，描述了计算过程从一个状态到下一个状态的转换时候，这些变量的更新方式。还有一个结束检测，它描述着一计算过程应该终止的条件。在计算n!时候，所需要的计算不走随着n线性增长，这种过程称为线性迭代过程。在迭代的情况下，在计算过程中的任何一点，那几个程序变量都提供了有关计算状态的一个完整描述。而递归计算过程而言，这里存在着另外的一些隐含信息，它们并未保存在程序变量里面，而是由解释器维持着，指明了在所推迟的运算所形成的链条里的漫游中，这以计算过程处在合出。链条越长，需要保存的信息越多。 换零钱的实现采用递归过程：将总数为a的现金换成n中硬币的不同方式的数目等于 将现金数a换成除第一种硬币之外的所有其他硬币的不同方式数目，加上 将现金数a-d换成所有种类的硬币的不同数目，其中d是第一种硬币的币值12345678910111213141516171819(define (first-denomination kinds-of-coins) (cond ((= kinds-of-coins 1) 1) ((= kinds-of-coins 2) 5) ((= kinds-of-coins 3) 10) ((= kinds-of-coins 4) 25) ((= kinds-of-coins 5) 50))) (define (cc amount kinds-of-coins) (cond ((= amount 0) 1) ((or (&lt; amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins)))))(define (count-change amount) (cc amount 5))(count-change 100) 增长的阶空间与时间的消耗。大O记号 一个例子求幂 1234567(define (square n) (* n n))(define (fast-expt b n) (cond ((= n 0) 1) ((even? n) (square (fast-expt b (/ n 2)))) (else (* b (fast-expt b (- n 1))))))(fast-expt 2 2) 最大公约数1234(define (gcd a b) (if ( = b 0) a (gcd b (remainder a b)))) 素数检测两种计算方法123456789101112131415161718(define (square n) (* n n))(define (smallest-divisor n) (find-divisor n 2)) ;寻找最小因子(define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n);根号n为检测上限 ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1)))));查找下一个(define (divides? a b) (= (remainder b a) 0)) ;最小因子等于本身的时候为素数(define (prime n) (= n (smallest-divisor n))) 费马检测1234567891011121314151617181920212223(define (square n) (* n n))(define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m))))(define (try-it a n) (= (expmod a n n) a));使用随机数来测试(define (fermat-test n) (try-it (+ 1 (random (- n 1))) n));通过多次的费马测试来概率的推断是不是位素数(define (fast-prime? n times) (cond ((= times 0) true) ((fermat-test n) (fast-prime? n (- times 1))) (else false))) 高阶函数抽象以过程作为参数。以过程作为返回值。这类操作过程的过程称为高阶过程。 12345678910111213141516171819202122#lang racket(define (cube n) (* n n n))(define (sum term a next b) (if (&gt; a b) 0 (+ (term a) (sum term (next a) next b))))(define (inc n) (+ n 1))(define (sum-cubes a b) (sum cube a inc b))(sum-cubes 1 10)(define (integral f a b dx) (define (add-dx x) (+ x dx)) (* (sum f (+ a (/ dx 2.0)) add-dx b)))(integral cube 0 1 0.01) 用lambda构造过程1((lambda (x) (+ 4 x))) 匿名的过程，对于一些简单的过程构造适合 用let创建局部变了一种方法是利用辅助过程去约束局部变量12345(define (f x y) (let ((a (+ 1 x)) (b (+ 2 y))) (+ a b)))(f 1 2) 过程作为一般性的方法通过区间折半寻找方程的根12345678910111213141516171819202122232425262728(define(close-enough? x y) (&lt; (abs (- x y)) 0.001))(define (average x y) (/ (+ x y) 2))(define (search f neg-point pos-point) (let ((midpoint (average neg-point pos-point))) (if (close-enough? neg-point pos-point) midpoint (let ((test-value (f midpoint))) (cond ((positive? test-value) (search f neg-point midpoint)) ((negative? test-value) (search f midpoint pos-point)) (else midpoint))))))(define (half-interval-method f a b) (let ((a-value (f a)) (b-value (f b))) (cond ((and (negative? a-value) (positive? b-value)) (search f a )) ((and (negative? b-value) (positive? a-value)) (search f b a)) (else (error "Values are not of opposite sign" a b)))))(half-interval-method sin 2.0 4.0) 寻找函数不动点123456789101112131415161718192021222324(define tolerance 0.00001)(define (average x y) (/ (+ x y) 2))(define (fixed-point f first-guess) (define (close-enought? v1 v2) (&lt; (abs (- v1 v2)) tolerance)) (define (try guess) (let ((next (f guess))) (if (close-enought? guess next) next (try next)))) (try first-guess))(fixed-point cos 1.0);不收敛(define (sqrt x) (fixed-point (lambda (y) (/ x y)) 1.0));引入阻尼(define (sqrt x) (fixed-point (lambda (y) (average y (/ x y))) 1.0)) 过程作为返回值新的开方方法12345(define (average-damp f) (lambda (x) (average x (f x))))(define (sqrt x) (fixed-point (average-damp (lambda(y) (/ x y))))) 新的牛顿法 12345678(define (deriv g) (lambda (x) (/ (- (+ x dx) (g x)) dx)))(define (newton-transform g) (lambda (x) (- x (/ (g x) ((deriv g) x))))) 抽象和第一级过程复合过程是一种至关重要的抽象机制，因为它使得我们能将一般性的计算方法，用这一程序设计语言里的元素明确描述。现在我们又看到，高阶函数能如何去操作这一些一般性的方法，以便建立起进一步的抽象。作为编程者，我们应该对这类可能性保持高度敏感，设法从中识别出程序里的基本抽象，基于它们去进一步构造，程序设计专家指导的如何根据工作中的情况，去选择合适的抽象层次。但是，能够基于这种抽象去思考确实是最重要的，只有这样才可能在新的上下文中去应用它们。高阶的过程的重要性，就在于使我们能够显式的用程序设计语言的要素去描述这些抽象，使我们能够像操作其他计算元素一样去操作它们。一般而言，程序设计语言总会对计算元素的可能使用方式强加上某些显式。带有最少限制的元素被称为具有第一级状态。第一级元素的某些权利与特权包括: 可以用变量命名 可以提供给过程作为参数 可以由过程作为结果返回 可以包含在数据结构中lisp给了过程完全的第一级的状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书摘录] 黑客与画家]]></title>
      <url>%2F%2Fblog%2F2016%2F09%2F%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6.html</url>
      <content type="text"><![CDATA[2016-08-31 08:09:42 为什么小孩子会这样做呢？ 一部分原因是，青少年在心理上还没有摆脱儿童状态，许多人都会残忍地对待他人。他们折磨书呆子的原因就像拔掉一条蜘蛛腿一样，觉得很好玩。在一个人产生良知之前，折磨就是一种娱乐。 孩子们欺负书呆子的另一个原因是为了让自己感到好受一些。当你踩水的时候，你把水踩下去，你的身体就会被托起来。同样，在任何社会等级制度中，那些对自己没自信的人就会通过虐待他们眼中的下等人来突显自己的身份。我已经意识到，正是因为这个原因，在美国社会中底层白人是对待黑人最残酷的群体。 2016-08-31 08:12:26 我认为，真实世界的关键并非在于它是由成年人组成的，而在于它的庞大规模使得你做的每件事都能产生真正意义上的效果。学校、监狱、上流社会的女士午餐会，都做不到这一点。这些场合的成员都好像关在封闭的泡沫之中，所作所为只对泡沫内部有影响，对外部没有影响。那么很自然地，这些场合就会产生野蛮的做法。因为它们不具备实际功能，所以也就无所谓采用的形式^。 2016-08-31 08:13:16 真实世界的特点是，它极其庞大。如果总体足够大，即使是人数最少的少数派，只要聚集在一起，也能产生可观的力量。在真实世界中，书呆子在某些地方聚集起来，形成自己的社区，智力因素成为那里最被看重的东西。有时，这种因素甚至会以相反的形式表现出来，特别是在大学的数理学系，书呆子甚至会夸大笨拙，以显示自己的聪明。约翰·纳什^非常钦佩诺伯特·维纳^^就学维纳的样子，经过走廊的时候都用手扶着墙走路。 2016-08-31 08:14:01 书呆子感到不适应的真正原因是其他人都是疯子。我记得读髙中的时候，有一次在体育馆观看校运动队的出征大会，啦啦队把对手的模拟像扔到看台上，观众一哄而起，把它撕成碎片。我感到自己仿佛是一个探险家，正在目睹某种奇特的部落仪式。 2016-08-31 08:15:36 为什么人们要搬到郊区去住？为了养育下一代！难怪郊区生活是如此地乏味和贫瘠。整个镇子就像一个巨大的幼儿园，所有一切都是为了教育下一代而有意识地造出来的。 在我生长的这个地方，感觉整个世界就是这么大，你根本没有别的地方可去，没有别的事情可做。这一点都不令人意外。郊区就是故意这样设计的，与外部世界隔离，不让儿童沾染到外界有害的东西。 至于学校，不过是这个虚假环境中关住牲口的围栏。表面上，学校的使命是教育儿童。事实上，学校的真正目的是把儿童都关在同一个地方，以便大人们白天可以腾出手来把事情做完。我对这一点没有意见，在一个高度工业化的社会，对孩子不加管束，让他们四处乱跑，无疑是一场灾难。 让我困扰的，不是把孩子关在监狱里，而是（a）不告诉他们这一点，（b）把这监狱的大部分交给犯人来管理。孩子们被送进来，花6年时间，记住一些毫无意义的事实，还要身处在一个由四肢发达的小巨人管理的世界，那些巨人们只知道追逐一个椭圆形的、棕色的球^，好像这是全世界最天经地义的事情。这简直就像一场超现实的鸡尾酒化妆晚会，如果孩子畏缩不前、瑟瑟发抖，他们就会被视为怪人。 2016-09-01 08:17:47 但是，流行的道德观念不是这样，它们往往不是偶然产生的，而是被刻意创造出来的。如果有些观点我们不能说出口，原因很可能是某些团体不允许我们说。 那些团体神经越紧张，它们所产生的禁止力量就越大。伽利略因为宣传日心说而遭到教廷的审判，这件事讽刺的地方在于，他只是在宣传哥白尼的观点，而后者却安然无恙。事实上，哥白尼不仅不反对教廷，还是一个虔诚的天主教教士，他把自己的著作献给教皇。不幸的是，伽利略正赶上教廷内部反对派上台，宗教改革被压制，任何非正统的思想遭受到前所未有的严厉控制和禁止。 为了在全社会制造出一个禁忌，负责实施的团体必定既不是特别强大也不是特别弱小。如果一个团体强大到无比自信，它根本不会在乎别人的抨击。美国人或者英国人对外国媒体的诋毁就毫不在意。但是，如果一个团体太弱小，就会无力推行禁忌。有一种行为怪癖叫做“嗜粪症”（coprophila），它的患者人数以及影响势力眼下似乎就不太强大，无法把自己的观点推广给其他人。 注: 穆斯林 女权 2016-09-01 08:28:17 各种各样的标签可能是外部线索的最大来源，帮助你发现这个时代流行的是什么。如果一个命题是错的，这就是它所能得到的最坏评价，足够批判它了，根本不用再加上任何其他标签。伹是，如果一个命题不是错的，却被加上各种标签，进行压制和批判，那就有问题。因为只要不是错的观点，就不应该被压制讨论。所以每当你看到有些话被攻击为出自XX分子或XX主义，这就是一个明确的信号，表明背后有问题。不管在1630年还是在2030年，都是如此。当你听到有人在用这样的标签，就要问为什么。 2016-09-01 19:31:06 《人月神话》（The Mythical Man-Month）是布鲁克斯（Frederick Brooks）所写的一本软件项目管理名著。所谓“人月”就是一个人在一个月内所能完成的工作量。假如某个项目预估需要12个人月，那么派4个人处理这个项目，理论上需要3个月，派6个人则只需要2个月。但是，布鲁克斯认为这种换算机制在软件业行不通，是一个神话，因为软件项目是交互关系复杂的工作，需要大量的沟通成本，人力的增加会使沟通成本急剧上升，反而无法达到缩短工期的目的。在本质上，软件项目的人力与工期是无法互换的，当项目进度落后时，光靠增加人力到该项目中，并不会加快进度，反而有可能使进度更加延后。 2016-09-01 19:35:16 没有盗版是一种“优势”，但也是一个问题。一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。 2016-09-01 19:42:05 你可能会问，如果Mac电脑真那么出色，为什么后来它的市场表现不佳？还是那个老生常谈的原因：成本太高。微软公司把所有精力都集中在软件上面，所以很多厂商只要专攻硬件就可以了，把硬件成本降了下来。单单是微软的软件或者第三方厂商的硬件都不足以赢得市场优势，但是它们结合起来，就在个人电脑出现后一段关键时期中主导了市场。苹果公司同时做软件和硬件，所以成本上没有优势。（但是，苹果公司还没有失败，如果它能把iPod升级成手机，并且将网络浏览器包括在其中，那么微软公司就有大麻烦了。）（译者注：这段话写于2001年9月，苹果公司的iPhone手机已于2007年6月上市。 2016-09-02 19:23:17 高级语言比汇编语言更接近人类语言，而某些高级语言又比其他语言更进一步。举例来说，C语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言，而Lisp语言的层次则是相当高。 如果高层级语言比汇编语言更有利于编程，你也许会认为语言的层次越高越好。一般情况下确实如此，但不是绝对的。编程语言可以变得很抽象，完全脱离硬件，但也有可能走错了方向。比如，我觉得Prolog语言就有这个问题。它的抽象能力强得不可思议，但是只能用来解决2%的问题，其余时间你苦思冥想、运用这些抽象能力写出来的程序实际上就是Pascal语言的程序。 另一个你会用到低层次语言的原因就是效率问题。如果你非常关注运行速度，那么最好使用接近机器的语言。大多数操作系统都是用C语言写的，这并非偶然。不过，硬件的运行速度越来越快了，所以使用C这样的低层次语言开发应用程序的必要性正在不断减少，但是大家似乎还是要求操作系统越快越好。（另一种可能是，人们还是希望“缓存区溢出攻击”继续存在下去，以便让大家时时保持警惕）^。 2016-09-02 19:29:39 不仅编程语言有这种现象，这实际上是一种普遍的历史趋势。随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。30年前的人要是看到我们今天如此随意地使用长途电话，一定会感到震惊。100年前的人要是看到一个普通的包裹竟然也能享受一天内从波士顿发件、途经孟菲斯、抵达纽约的待遇，恐怕就要更震惊了。 2016-09-03 08:03:35 Lisp比图灵机表达起来更简洁。证明这一点的一种方法就是写一个Lisp通用函数，证明它比图灵机的一般性描述更短、更易僅。这个Lisp函数就是eval……它用来计算Lisp表达式的值……。编写eval函数需要发明一种表示法，能够把Lisp函数表示成Lisp数据。设计这种书写法完全是为了满足论文写作的需要。（我）根本没有想过用它来编写Lisp程序并在计算机上运行。 2016-09-03 08:07:56 Lisp语言诞生的时候就包含了9种新思想。其中一些我们今天已经习以为常，另一些则刚刚在其他高级语言中出现，至今还有2种是Lisp独有的。按照被大众接受的程度，这9种思想依次如下排列。 条件结构（即if-then-else结构）。现在大家都觉得这是理所当然的，但是Fortran I就没有这个结构，它只有基于底层机器指令的goto结构。 函数也是一种数据类型。在Lisp语言中，函数与整数或字符串一样，也属于数据类型的一种。它有自己的字面表示形式（literal representation），能够存储在变量中，也能当作参数传递。一种数据类型应该有的功能，它都有。 递归。Lisp是第一种支持递归函数的高级语言^。^「Lisp语言的许多特性（比如，把程序写成列表形式以及实现某种形式的递归）都在20世纪50年代的IPL-V语言中出现过。但是，IPL-V更像是汇编语言，它的程序中充满了操作码/地址对。参见Alien Newell等人编著的《IPL-V语言操作手册》（Information Processing Language-V Manual），Prentice-Hail，1961年出版。」 变量的动态类型。在Lisp语言中，所有变量实际上都是指针，所指向的值有类型之分，而变量本身没有。复制变量就相当于复制指针，而不是复制它们指向的数据。 垃圾回收机制。 程序由表达式组成。Lisp程序是一些表达式树的集合，每个表达式都返回一个值。这与Fortran和大多数后来的语言都截然不同，它们的程序由表达式和语句组成。 区分表达式和语句在Fortran I中是很自然的，因为它不支持语句嵌套。所以，如果你需要用数学式子计算一个值，那就只有用表达式返回这个值，没有其他语法结构可用，否则就无法处理这个值。2016-09-03 08:08:15后来，新的编程语言支持块结构，这种限制当然也就不存在了。但是为时已晚，表达式和语句的区分已经根深蒂固。它从Fortran扩散到Algol语言，接着又扩散到它们两者的后继语言。 符号类型。符号实际上是一种指针，指向存储在散列表中的字符串。所以，比较两个符号是否相等，只要看它们的指针是否一样就行了，不用逐个字符地比较。 代码使用符号和常量组成的树形表示法。 无论什么时候，整个语言都是可用的。Lisp并不真正区分读取期、编译期和运行期。你可以在读取期编译或运行代码，也可以在编译期读取或运行代码，还可以在运行期读取或者编译代码。 在读取期运行代码，使得用户可以重新调整（reprogram）Lisp的语法；在编译期运行代码，则是Lisp宏的工作基础；在运行期编译代码，使得Lisp可以在Emacs这样的程序中充当扩展语言（extension language）；在运行期读取代码，使得程序之间可以用S表达式（S-expression）通信，近来XML格式的出现使得这个概念被重新“发明”出来了^。「如果你不想让经理发现你正在使用Lisp编程，你可以告诉他你用的是XML。」 2016-09-03 08:20:26 这种实践不仅很普遍，而且已经制度化了。举例来说，在面向对象编程的世界中，我们大量听到“模式”（pattern）这个词，我觉得那些“模式”就是现实中的因素（c），也就是人肉编译器^。当我在自己的程序中发现用到了模式，我觉得这就表明某个地方出错了。程序的形式应该仅仅反映它所要解决的问题。代码中其他任何外加的形式都是一个信号，（至少对我来说）表明我对问题的抽象还不够深，也经常提醒我，自己正在手工完成的事情，本应该写代码通过宏的扩展自动实现。 「皮特·诺维格发现，总共23种设计模式之中，有16种在Lisp语言中“本身就提供，或者被大大简化”。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] 深入探索C++对象模型 第六章 执行期语意学]]></title>
      <url>%2F%2Fblog%2F2016%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6.html</url>
      <content type="text"><![CDATA[执行期语意学以下一个简单的式子1if (yy == xx.getValue) xx yy定义如下1234567891011121314151617X xx;Y yy;class Y&#123;public: Y(); ~Y(); bool operator==(const&amp; Y) const;&#125;;class X&#123;public: X(); ~X(); operator Y() const; X getValue();&#125;; 那么编译器在我们之后做了什么呢12345678910111213141516if(yy == xx.getValue())//转换为if(yy.operator==(xx.getValue())//接着转换if(yy.operator==(xx.getValue().operator Y()))//接着转换X temp1 = xx.getValue();Y temp2 = temp1.operator Y();int temp3 = (yy.operator==(temp2));if(temp3)temp2.y::~Y();temp1.x::~X(); 对象的构造与析构局部对象123456&#123; Point p; // p.Point::Point(); ... //p.Point::~Point(); &#125; 如果一个函数拥有多个离开点，那么会在每一个离开点之前对对象进行析构。 全局对象1234567Matrix identity;main()&#123; Matrix ml = identity; ... return 0;&#125; C++ 保证一定会在main()中第一次用到identity之前把 didentity构造出来，在main()函数结束之前销毁。C++程序中所有全局对象都被防止在程序的data segment中，如果明确指定给它一个值,object将以该值为初值。否咋object所配置到的内存内容为0。 class object在编译器可以被放置与data sement中并且为0,但是它的构造函数需要在程序激活的时候才会被实施。(也就是说全局对象的初始化的问题，对于类对象的有些门道。) ￼（还是不是很清楚全局对象是如何初始化的） 局部静态对象1234567const Matrix&amp;identity()&#123; static Matrix mat_identity; ... return mat_identity;&#125; 对于局部静态的变量，他们的构造和析构必须只施行一次。编译器的策略是，导入一个临时性的对象以保护mat_identity的初始化操作。第一次处理identity()时候，这临时对象被评估为false，于是构造函数被调用，然后临时对象改为true。同理析构也是如此。（但是具体现代编译器怎么操作的我还是不清楚。）。 对象数组1Point knots[10]; 需要做什么。如果是一个没有构造函数的，也没有析构函数的。那么工作不会比建立一个内建类型所组成的数组更多。如果有的话，那么整齐的操作必须施行与每一个元素上。在cfront中，使用一个命名为vec_new()的函数，产生以class objects构造而成的数组。12345678void* ver_new( void *array, //数组的起始位置 size_t elem_size, //一个对象的大小 int elem_count, //数组的元素个数 void (*constructor)( void*), void (*destructor)(void*, char)) 调用操作 12Point knots[10];ver_new(&amp;knots, sizeof(Point), 10, &amp;Point::Point, 0); 同样如果Point有一个析构函数会有一个类似ver_delete()的函数1234567void* ver_delete( void *array, //数组的起始位置 size_t elem_size, //一个对象的大小 int elem_count, //数组的元素个数 void (*destructor)(void*, char)) 不同的编译器会有不同的实现。如果数组部分被赋予了初值的，那么会产生什么转换12345Point knots[10] = &#123; Point(), Point(1.0, 1.0, 0.5), -1.0&#125;; 对于有了初值的元素ver_new不必要，但是未被初始化的部分会调用vec_new。1234567891011Point knots[10] = &#123; Point(), Point(1.0, 1.0, 0.5), -1.0&#125;;//明确的初始化前三个Point::Point(&amp;knots[0]);Point::Point(&amp;knots[1], 1.0, 1.0, 0.5);Point::Point(&amp;knots[2], -1.0, 0.0, 0.0);ver_new(&amp;knots + 3, sizeof(Point), 7, &amp;Point::Point, 0); default Constructors和数组为了支持1234567891011complex:: complex(double = 0.0, double = 0.0);complext c_array[10];//编译器最终调用vec_new(&amp;c_array, sizeof(complex), 10, &amp;complex::complex, 0);//cfront采用如下方法支持//产生一个默认构造函数 调用带默认参数的构造函数complex::complex()&#123; complex(0.0,0.0);&#125;//来完成调用 （有一个问题，那么这个不就是产生了两个不带参数的构造函数吗，虽然一个有参数，但是都用默认的。怎么解决的。不过大部分构造过程都是在编译期间，那么都是静态指定调用的话，还是解决掉了的。不是很清楚这个问题。） new delete运算符运算符new的使用，之前的几章一直都有。会转换成两步，一步是使用适当的函数，分配内存。后一步是给对象设置初值，类对象的话，调用的对应的构造函数等等1234567891011121314151617181920extern void* operator new( size_t size ) &#123; if( size == 0 ) size = 1; // 这里保证像 new T[0] 这样得语句也是可行的 void *last_alloc; while( !(last_alloc = malloc( size )) ) &#123; if( _new_handler ) ( *_new_handler )(); //调用handler函数 else return 0; &#125; return last_alloc; &#125; extern void operator delete( void *ptr ) &#123; if(ptr) // 从这里可以看出，删除一个空指针是安全的 free( (char*)ptr ); &#125; 针对数组的new语意内建的或者没有默认构造函数的，直接默认的new就能完成任务。对于有默认构造函数的，某些版本的vec_new()就会被调用。 临时性对象很多简短的代码实际上都会产生一些临时对象。是不是真的产生，需要看编译器的具体实现了。 临时性对象的迷思]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学]]></title>
      <url>%2F%2Fblog%2F2016%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6.html</url>
      <content type="text"><![CDATA[构造、解构、拷贝语意学纯虚函数的存在纯虚函数能够被静态的调用，不能经过虚拟机制调用。虚析构函数不能定义为纯虚的，一定要有定义，否则即使可以编译，但是链接的时候会有错误。因为其子类会静态调用上一层的析构函数。如果说上一层的析构函数是一个纯虚函数的话，那么链接的时候会失败。 虚拟规格的存在不应该把所有的函数都声明为虚函数，然后靠编译器去优化操作吧virtual invocation去除。 虚拟规格中的const的存在实际上你很难知道一个类的子类对于这个函数是不是应该定义为const，因为即使现在你不需要修改类的内容，但子类可能需要修改，你没法预料到。那么最好不要定义一个有const函数的基类了。 “无继承”情况下的对象构造1234typedef struct&#123; float x,y,z;&#125; Point; 编译器会分析声明，贴上Plaint OI’ Data的卷标，被贴上该卷标的类，不会有构造函数或者析构函数的调用了。直接使用C的方式。 继承体系下的对象构造1T object; 定义一个object如上时候，实际会发生什么。如果T有一个construct，它会被调用。Constructor可能带有大量 隐藏码，因为编译器会扩充每一个constructor，扩充程度视class T的继承体系而定，一般而言编译器所做的扩充操作大约如下： 记录在member initialization list中的data members初始化操作会被放进constructor函数本身，并以members的声明顺序为顺序。 如果有一个member没有出现在member initialization list中，但是它有一个default constructor, 那么该default construtor必须被调用。 在那之前，如果class object有virtual table pointer(s)，它们必须被设定初值。指向适合的virtual table(s) 在那之前，所有上一层的base class constructirs必须被调用，以base class的声明顺序为顺序 如果base class被列于初始化列表中，那么任何明确的指定参数都应该传递过去 如果base class 没有被列于初始化列表中，而它有默认构造函数，那么调用之 如果base class 是多重继承下的第二或者后继的base class那么this指针必须被调整 在那之前，所有的virtual base class constructor必须被调用，从左到右，从最深到最浅 如果class被列于初始化列表中，那么如果有任何明确指定的参数，都应该传递过去。若没有在list中，而class有默认构造函数，也应该调用 此外，class中的每一个virtual base class subobject的偏移量必须在执行期间可被存取 如果class object是最底层的class，其构造函数可能被调用。某些用以支持这个行为的机制被加入 虚函数不见得一定有运行期绑定，如果能够编译期确定的，编译期乐于去进行静态的调用。 虚拟继承￼有如上图的继承结构。Vertex的构造函数必须调用Point的构造函数。但是Vertex和P哦Point3d同为Vertex3d的 subobjects的时候，它们对Point的构造函数的调用操作一定不可以发生，取而代之的是，作为底层的class，Vertex3d有责任将Point初始化，而更往后的继承，则由PVertex,而不是Vertex3d来负责完成共享的Point subobject的构造.1234567891011Point3d*Point3d::Point3d(Point3d *this, bool __most__derived, float x, float y, float z)&#123; if(__most_derived != false) this-&gt;Point::Point(x,y); this-&gt;__vptr_Point3d = __vtbl_Pint3d; this-&gt;__vptr_Point3d__Point = __vtbl_Point3d__Point; this-&gt;_z = rhs._z; return this;&#125; 123456789101112Vertex3d*Vertex3d::Vertex3d( Vertex3d *this, bool __most_deriver, float x, float y, float z)&#123; if(__most_derived != false) this-&gt;Point::Point(x,y); this-&gt;Point3d::Point3d(false, x, y, z); this-&gt;Vertex::Vertex (false, x, y); //设定vptrs //安插USER CODE return this;&#125; ##vptr 初始化语意学当我们定义一个PVertex object的时候，构造函数的调用顺序是 Point() Point3d() Vertex() Vertex3d() PVertex() 构造函数调用成员函数会决议为静态的，不会使用多态机制。主要是考虑到构造函数中对象可能是不完整的，编译器需要找到合适的函数对象来调用，只能调用到此时能够起作用的函数。 在派生类的构造函数中，所有的Virtual base classes以及上一层base class的constructors会被调用 上述完成之后，对象的vptr(s)被初始化，指向相关的虚表 如果有初始化列表的话，将在构造函数内扩展开来，这必须在vptr设定之后进行，以免一个virtual member function调用 最后执行程序员所提供的的代码 构造函数：1234PVertex::PVertex(float x, float y, float z) : _next(0), Vertex3d(x, y, z), Point(x, y) &#123; if (spyOn) cerr &lt;&lt; "within Point3d::Point3d()" &lt;&lt; " size: " &lt;&lt; size() &lt;&lt; endl;&#125; 会被编译器扩展为：1234567891011121314151617PVertex* PVertex::PVertex( Pvertex* this, bool __most_derived, float x, float y, float z ) &#123; //有条件地调用virtual base class的ctor if ( __most_derived != false ) this-&gt;Point::Point( x, y ); //无条件地调用上一层的base class的ctor this-&gt;Vertex3d::Vertex3d( x, y, z ); //初始化vptr this-&gt;__vptr__PVertex = __vtbl__PVertex; this-&gt;__vptr__Point__PVertex = __vtbl__Point__PVertex; //显式的用户代码 if ( spyOn ) // 虚拟机制调用size()函数 cerr &lt;&lt; "within Point3d::Point3d()"&lt;&lt; " size: " &lt;&lt; (*this-&gt;__vptr__PVertex[ 3 ].faddr)(this) &lt;&lt; endl; return *this;&#125; 对象复制语意学bitwise copy不够的情况和之前几章记录的一致。12345678910111213141516171819202122inline Point&amp; Point::operator= (const Point &amp;p)&#123; _x = p._x; _y = p._y;&#125;//派生一个类classPoint3d : virtual public Point &#123; public: Point3d( float x = 0.0, y = 0.0, float z = 0.0 ); ... protected: float _z;&#125;;//编译器会合成一个inline Point3d&amp; Point3d::operator=( Point3d *constthis, const Point3d &amp;p ) &#123; //调用base class的operator= this-&gt;Point::operator=( p ); // memberwise copy the derived class members _z = p._z; return *this;&#125; 但是考虑到上面那个虚拟继承层次的结构的话。怎么在虚拟继承中去处理复制这个问题。事实上，copy assignment operator在虚拟继承的情况下行为不佳，需要小心的设计和说明，许多编译器甚至不尝试取得正取的语意，造成多次调用虚拟基类的copy assignment operator的多个实体被调用。（我的话，好像多次调用并不会产生大的问题，只是重复复制罢了，实际上没产生什么错误，效率貌似有下降。） 析构语意学如果class没有定义析构函数，那么只有在class内带的成员对象有析构函数的情况下，编译器才会自动合成析构函数，否则析构函数视为不需要的。即使它拥有一个虚函数等。也就是构造函数和析构函数并不是一定要成对的出现，没必要定义了构造函数，就定义出析构函数。 析构函数的扩展 析构函数的本身被执行，user code 如果class拥有成员类对象，而后者拥有析构函数，声明顺序的相反顺序调用其析构函数 如果对象有vptr需要重新被设定，指向合适的base class的vtbl 如果任何一个直接的nonvirtual base classes拥有析构函数，它们会以声明次序的相反顺序被调用 如果任何virtual base classes拥有析构 函数，而当前讨论的这个class是最尾端的class,那么会以其原来的构造函数相反的顺序被调用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记]深入探索C++对象模型 第四章 Function语意学]]></title>
      <url>%2F%2Fblog%2F2016%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-Function%E8%AF%AD%E6%84%8F%E5%AD%A6.html</url>
      <content type="text"><![CDATA[第三章：Function语意学Member的各种调用方式Nonstatic Member FunctionsC++的设计准则之一就是:nonstatic member function 至少必须和一般的nonmember function有相同的效率。nonstatic member function会转换为nonmember形式。 改写函数原型，安插一个额外的参数，也就是this指针。 将每一个对“nonstatic data member的存取操作”改为经由this指针来存取。 将member function重写成一个外部函数，对函数名称进行“mangling”处理，使它在程序中成为一个独一无二的词汇。 12345678void normalize__7Point3dFv(register const Point3d *const this, Point3d &amp;__result)&#123; register float mag = this-&gt;magnitude(); __result.Point3d::Point3d(); __result._x = this-&gt;_x/mag;&#125; 名称的特殊处理一般而言，member的名称前面会加上class名称，形成独一无二的命名。123class Bar&#123; public: int ival; ...&#125;;//其中ival有可能变成这样ival__3Bar 主要考虑是存在继承的问题。123456789//防止函数的重名//加入类名//加入参数链，使得支持重载//cfront采用的编码方式class Point&#123;public: void x__5PointFf(float newX); float x__5PointFv();&#125; Virtual Member Functions如果normalize()是virtual member function123//函数会变成ptr-&gt; normalize()(*ptr-&gt;vptr[1])(ptr); //1为vtbl slot的索引值，关联到normalize Static Member Function你可能会看到形如以下的调用1((Point3d*)0)-&gt;test(); 这种调用在test中没有对类对象的数据成员存储时候是不会出错的。因为根据之前的转化形式看，没有是还用this指针进行操作。这个式子的功能实际上就是实现static 成员函数的功能。在static member function成为c++的标准之前。函数的转化12345678void Point3d::object_cout()&#123;&#125;//转化为void object_cout__5Point3dSFv()&#123;&#125; Virtual Member Functions对于多态的class object身上增加两个members 一个字符串或者数字，表示class的类型 一个指针，指向某表格，表格中带有程序的virtual functions的执行地址 一个class只会有一个virtual table，每个table内含其对应的class object中所有active virtual functions函数实体地址。这些active virtual functions包括： 这个class所定义的函数实体。它会改写一个可能存在的Base class virtual function函数实体 继承自base class的函数实体。这是派生类不改写的部分 一个Pure_virtual_called()函数实体，它既扮演pure virtual function的空间保卫者角色，也可以作为执行期异常处理函数（有时候会用到） ￼ 多重继承下的Virtual Functions在多重继承中支持virtual functions，其复杂度围绕在第二个以及后继的base classes中，以及必须在执行期间调整的this指针这一点。123456789101112class C : public A,B...A* pA = new C;B* pB = new C;//C* pC = new C;B* pB = pC;//转化B* pB = pB ? pB + sizeof(A) : 0;//delete pB; delete 操作会要求调用合适的虚析构函数，那么就要求指针再一次被调整。使得指针再次指向C对象的头。 thunk是小段assembly代码，来完成这个工作。123pbase2_dtor_thunk: this += sizeof(base1); Derived::~Derived(this); 多重继承下的Virtual Functions没讲明白 函数的效能指向Member Function的指针12345678910//指向成员函数的指针声明double (Point :: *coord) () = &amp;Point :: x;coord = &amp;Point::y;//要想要调用，需要(origin.*coord)();(ptr-&gt;*coord)();//操作会自动被编译器转化(coord) (&amp;origin);(coord)(ptr); 指向member function的指针的声明语法，以及指向member selection运算符的指针，其作用是作为this指针的空间保留者。这就是为什么static member functions的类型是函数指针，而不是指向member function指针的原因。利用上述方式去获取一个虚函数的指针，一样能够支持多态。因为实际上获取的是一个索引值，指向虚表的内容。 在多重继承下，指向member funcitons的指针为了让指向member funcitons的指针能够支持多重继承和虚拟继承，Stroustrup设计了下面一个机构体 index faddr分别带有virtual table和nonvirtual member function地址（为了方便，index不指向virtual table时候会被设为-1）。12345678910111213141516struct __mpter&#123; int delta; int index; union &#123; ptrtofunc faddr; int v_offset; &#125;&#125;//在该模型之下，像这样的操作(ptr-&gt;*pmf)();//转变为(pmf.index &lt; 0) ? (*pmf.faddr)(ptr)// nonvirtual invocation : (*ptr-&gt;vptr[pmf.index](ptr));//virtual invocation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] 深入探索C++对象模型 第三章 Data语意学]]></title>
      <url>%2F%2Fblog%2F2016%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-Data%E8%AF%AD%E6%84%8F%E5%AD%A6.html</url>
      <content type="text"><![CDATA[第三章：Data语意学class的大小：内存对齐空Class需要1byte来占位，说明是独一无二的存在有虚函数时候会有虚表指针static 成员不属于类对象，不占空间 Data Member的绑定早期的编译器可能看不到Class后面的内容，导致数据成员的用了外层的同名的。现在已经没有这种情况了。12345678typedef long long length;class Point3d&#123;public: length x;//是long long typedef int length; length y;//是 int&#125;; Data Member的布局Nonstatic data members在class object中的排列顺序是和声明顺序一致的。但是没有规定多个access sections中的数据成员的排列，可以自由排列。实际上的编译器处理来看，还是按照顺序来的。这些顺序成员依靠声明次序在一个连续的区域里。虚表也有强制的规定放在尾部还是头部等位置。 Data Member的存取下面的一段代码中的x的存取成本12Point3d origin;origin.x = 0.0; 需要视x和Point3d如何声明而定。 Static Data Member的存取Static Data Member实际上是一种全局变量，放在类对象之外。每一个Static Data Member对象的存取操作都会转化为：1Point3d::x == 250;//不论是. 或者-&gt;来存取 不论该class是单一的类还是继承有虚函数的类或者多重继承，Static Data Member的路径仍然是这么直接。 编译器会给每一个Static Data Member暗中编码指定独一无二的名字。 NonStatic Data Member的存取NonStatic Data Member是存放在每一个类对象中的，除非经由明确的或者暗喻的类对象，否则么有办法直接存取它们。 123456void Point3d::translate()&#123; x = 1; y = 2; z = 3;&#125; 实际上都会转化为123456void Point3d::translate(Point3d *const this)&#123; this-&gt; x = 1; this-&gt;y = 2; this-&gt;z = 3;&#125; 欲对一个NonStatic Data Member访问必须在类对象的起始地址加上一个数据成员的偏移值。 123origin._y = 0.0;//origin._y的地址实际上等于&amp;origin + (&amp;Point3d::_y - 1); 存取这种数据成员和一个struct的成员是一致的。除了虚拟继承，此种情况下会引入一层间接性。 继承与Data Member在C++中的继承模型中，一个derived class object所表现出来的东西，是其自己的members加上其base lass members的总和。 只要继承不要多态base class的padding也会随之而来。这种设计是为了防止把派生类赋值给基类对象的时候导致基类对象的后面部位有数据而不是0（如果不保留padding的话，而是直接接上去） 加上多态加上多态的额外负担： 导入一个相关的virtual table,用来存放它所声明的每一个虚函数的地址。这个table元素的数目一般而言是被声明的虚函数的数目，再加上一个或者两个slots（用来支持runtime type idetification）。 在每一个类对象中导入一个vptr，提供执行器的连接，使每一个对象能够找到对应的vittual table。 加强构造函数 加强虚构函数 vptr的放置没有强制规定。 多重继承多重继承实际上对于第一继承没什么影响，主要是对于第二或者后继的base class12345678910111213141516Vertex3d v3d;Vertex *pv;Point2d *p2d;Point3d *p3d;pv = &amp;v3d;//需要这样的内部转化pv = (Vertex*)(((char*)&amp;v3d + sizeof(Point3d));//下面的只要简单的拷贝地址就行p2d = &amp;v3d;pv = pv3d;//要考虑pv3d位0的情况pv = pv3d ? (Vertex*)(((char*)&amp;v3d + sizeof(Point3d : 0; 多重继承的存储模型，没有规定怎么存储，但是大部分编译器都是采用下面的方式存储的。 虚拟继承一般的实现方法：class如果含有一个或者多个virtual base class，分割为亮哥部分:一个是不变的局部，一个是共享的局部。不变的局部中的数据，不管后继如何衍化，总有固定的offset，所以这一部分数据可以被直接存取。至于共享局部，所表现的是virtual base class suboject.这一部分的数据，其位置会因为每次的派生操作而变化，所以它们只可以被间接存取。 例子继承体系微软的解决方案：引入所谓的virtual base class table.每一个类对象如果有一个或者多个virtual base classes就会由编译器安插一个指针，指向virtual base class table。至于真正的virtual base class指针，被安放在这个表格中。第二种解决方案 在virtula function table中放置 virtula base class的offset。如同虚函数的指针，虚函数指针的在虚表中是正的offset，负的部分就给了虚基类。1(this +__vptr__Point3d[-3]-&gt;_x += (&amp;rhs + +__vptr__Point3d[-3]-&gt;_x) 123Point3d *p2d = pv3d;//转换为Point3d *p2d = pv3d ? pv3d +__vptr__Point3d[-3] : 0; 一般而言，virtual base class 最有效的一种运行形势是：一个抽象的virtual base class，没有任何data members。 对象成员的效率指向Data Members的指针&amp; Point3d::z;的值为z在class object中的偏移量。 书上的代码试了在VS2015，并没有偏移量增加1的出现123printf("%d", (&amp;Point3d::x));//4printf("%d", (&amp;Point3d::y));//8printf("%d", (&amp;Point3d::z));//c]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学]]></title>
      <url>%2F%2Fblog%2F2016%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6.html</url>
      <content type="text"><![CDATA[第二章：构造函数语意学由于C++的编译器在程序员之外做了太多事情，导致会产生很多意料之外的错误。例子 Conversion运算符。123456789//为了支持if(cin);//定义了一个perator int()//但是导致了以下错误的代码能够正常运行int inVal;cin &lt;&lt; inVal;//此处&lt;&lt;被解释为左移操作符int temp = cin.operator int();temp &lt;&lt; intVal; Default Constructor的构建操作默认构造函数只在编译器认为需要的时候才创建。123456class Foo&#123;public: int val; Foo *pnext&#125;;int main()&#123; Foo test; return 0;] 这种情况实际没有默认构造函数，编译器什么都没做。 带有Default Constructor的 Member class Object如果一个Class没有任何构造函数，但是包含一个member object，而后者又有default constructor，那么会在constructor真正被调用时合成出一个默认构造函数。123456classFoo &#123;public: Foo(),Foo(int);...&#125;;classBar &#123;public: Foofoo; char *str;&#125;;void foo_bar()&#123; Bar bar; //Bar::foo应在此处被初始化 if(str)&#123;...&#125;&#125; 此时的Bar合成默认构造函数会调用Foo的默认构造函数。12345Bar::Bar()&#123; foo.Foo::Foo(); //合成出的 //但是str等成员是不会管的&#125; 如果已经写了一个默认构造函数，那么就会扩张该函数。12345Bar::Bar()&#123; foo.Foo::Foo(); //扩展的 str=0;//程序员代码&#125; C++会以member objects在class中声明的次序来调用各个构造函数，由编译器完成。如果成员没有默认构造函数的话，就不会有扩张。 带有Default Constructor的 Base Class一个没有任何构造函数的类派生子一个带有默认构造函数的基类，那么会合成出一个一个默认构造函数，调用上一层的默认构造函数（根据声明次序）。如果是一个有多个构造函数的类，但是没有默认构造函数，则会扩张每一个构造函数，加入有必要的基类部分的默认构造。但是不会合成默认构造函数，因为已经存在了程序员编写的构造函数。如果也存在带有构造函数的成员，那么会在基类的部分构造之后，调用这些成员的构造函数。 带有一个Virtual Function的 Class另有两种情况，也需要合成出default constructor class声明（或者继承）一个virtual function class派生自一个继承串链，其中有一个或者更多的virtual base classes 如果程序员没有声明自己的构造函数，编译器就会详细记录合成一个default constructor的必要信息。编译器需要做以下的几个功能： 一个virtual function table会被编译器产生出来，内放class的virtual function地址。 在每一个class object中，一个额外的pointer member会被编译器合成，内含相关的classs vtbl的地址。 此外如果必要，虚函数表的部分会被重写，以改变为需要的情况。为了支持这种功能，编译器必须为每个w对象设置它的vptr（这是成员变量，此时需要指向合适的vtbl），因此编译器需要在default ctor中安插一些代码来完成这种工作。 带有一个Virtual Base Class 的Class12345678910111213141516classX &#123; public: inti; &#125;;classA : publicvirtualX &#123; public: intj; &#125;;classB : publicvirtualX &#123; public: doubled; &#125;;classC : publicA, publicB &#123; public: intk; &#125;;//无法在编译期间解析出 pa-&gt;i 的位置（给一个pa无法确定i的地址）。void foo( constA* pa ) &#123; pa-&gt;i = 1024; &#125;main() &#123; foo( new A ); foo( new C ); // ...&#125;//由于pa的真正类型不确定，所以某些编译器会记录一个指针例（如 __vbcX）来记录X，然后通过这个指针来定位pa指向的i。//上述void foo( constA* pa ) &#123; pa-&gt;i = 1024; &#125;//变成了：void foo( constA* pa ) &#123; pa-&gt; __vbcX -&gt;i = 1024; &#125; 其中vbcX标示编译器产生的指针，指向 virtual base class X。 vbcX需要在每一个构造函数按错那么“允许每一个 virtual base class的执行期间存取操作“的码。如果class没有声明任何构造函数，就需要合成一个默认构造函数。 Copy Constructor的构建操作有三种情况会执行拷贝构造函数： 显式的使用 = 传参 返回 Default Memberwise Initialization一个class没有提供显式的拷贝构造函数的话，那么利用Memberwise Initialization(对每一个成员将源对象所有的member复制给目标对象) 非逐位拷贝 这个类的某个member object有拷贝构造函数。（不管成员的拷贝构造函数是合成的还是显式的定义的，都需要合成一个拷贝构造函数）。 这个类继承自某个有copy ctor的base class。（同上）。 这个类声明了若干个virtual function。（如果继承的基类有virtual function那么一定有拷贝构造函数，符合第二条。） 这个类派生自的继承链中有virtual base class。 第三四种情况需要合成的复制构造函数构建正确的虚表指针给每一个对象。因为复制构造函数可以 派生类赋值给基类。那么派生类的虚表指针是没法用逐位拷贝来赋值，需要一个合成的复制构造函数正确的设定虚表指针。 程序转化语意学12345X foo()&#123; X xx; return xx;&#125; 一个人可能会做出以下假设： 每次foo()调用，就会传回xx的值. 如果class X定义了一个拷贝构造函数，那么每次调用foo()，保证该拷贝构造函数也会被调用。 均不一定。move语意和外面没有接收的可能导致以上假设不一定。 明确的初始化操作123456X x0;void foo_bar()&#123; X x1(x0); //定义了x1 X x2 = x0; //定义了x2 X x3 = X(x0); //定义了x3&#125; //转化的两个动作//即变成了12345678910void foo_bar()&#123; X x1; //定义被重写，初始化操作被剥除 X x2; //定义被重写，初始化操作被剥除 X x3; //定义被重写，初始化操作被剥除 //编译器安插X copy ctor。 x1.X::X( x0 ); x2.X::X( x0 ); x3.X::X( x0 );&#125; 其中:x1.X::X( x0 );会表现为对拷贝构造函数的调用： X::X( constX&amp; xx);） 参数的初始化 如下代码的变化1234void foo(X x0);//...X xx;foo(xx) 这种方式把函数的参数变成了引用，然后将拷贝构造函数构造的参数传入。变成了12345void foo(X&amp; x0);//...X __tmp;__tmp.X::X( XX );foo(__tmp); 其中X声明了destructor，它在foo调用完成后销毁暂时性的对象。 返回初始值 12345 X bar()&#123; X xx; //... return xx;&#125; 先添加一个额外的引用参数，然后在返回之前调用一个复制构造函数构造这个返回对象。于是变成了123456void bar(X&amp; _result)&#123; X xx; //... _result.X::X(xx); return;&#125; 1234X xx = bar();//转换为X xx;bar(xx); 1234bar().memfunc();//可能转换为X _temp0;(bar(_temp0), _temp0).memfunc(); 在使用者层面的优化 123456X bar(const T &amp;y, const T &amp;z)&#123; X xx; //... return xx;&#125; 而是定义一个新的构造函数，这样在转换之后效率更高 1234X bar(const T &amp;y, const T &amp;z)&#123; return X(y , z);&#125; 转换后 12345void bar(X &amp;_result, const T &amp;y, const T &amp;z)&#123; _result X::X(y, z); return;&#125; 在编译器层面优化 就是上面那个转换代码 理论上合成的拷贝构造函数就能够正常的工作了。某些情况不会有合成的拷贝构造函数，而是直接逐位拷贝。这样的情况下，就没法实施，上面的编译器层面的优化。那么我们应该预见这个类是不是有很多传值的操作，比如上面的函数的参数，返回值。如果有，那么提供一个，编译器才能够实施优化。 成员们的初始化队伍构造函数初始化列表 初始化一个引用成员（不这样做出错） 初始化一个const成员（不这样做出错） 调用一个base class的构造函数，而它拥有一组参数时（不这样做出错） 调用一个member class的构造函数，而它拥有一组参数时（比赋值更有效率） 编译器会一一操作初始化列表，以适当次序（成员的声明次序）在构造函数之内安插初始化操作，并且在任何显式写的代码之前完成操作。初始化列表能够使用成员函数来初始化一个成员。（这里如果比较复杂的初始化能够使用这种方式提高初始化的效率，但是要注意该函数使用的变量是不是在调用前都被初始化了。合法的原因是此时this指针已经创建好了。）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记]深入探索C++ 对象模型 第一章 关于对象]]></title>
      <url>%2F%2Fblog%2F2016%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1.html</url>
      <content type="text"><![CDATA[阅读的目的在阅读《C++ primer》的时候，书里面写了各种各样的情况下，C++的处理方式。囫囵吞枣的记下后，也就不求甚解了。而C++在工作中的使用已经有了那么一段时间。但是对于C++的很多现象，却依旧是只知道是这样，却不知道为什么是这样。那么阅读这本同样是 Lippman的书籍，就是为了解惑，为什么C++会导致我们看到的现象，而不是其他情况。我希望，通过这么本书，能够解答我的一部分疑问。 序工作里常听到的对于C++的抱怨是C++的编译器为程序员做了太多的服务，导致很多情况不受控制。不像C,大部分都需要手动去执行，可以明确的知道，什么时候做了什么。我想这部分抱怨一方面来源于对于C++的不熟悉，一方面又来源于C++的特性。那么当对C++怎么实现各种特性了解后，对于编译器的行为有了概念后，我相信我应该能够解答很多疑问了。就像Lippman在本书贴出的一封信件一般 他希望这本书是这些问题的解答。 第一章：关于对象本章主要是对于对象模型的一个大概浏览，但是对多重继承和虚拟继承等情况没有太多的观察C语言，数据和处理数据操作是分开声明的，语言本身没有支持数据和函数的关联性。由一组分布在各个以功能为导向的函数中的算法所驱动，它们的处理的是共同的外部数据。C++的实现使用的是ADT123456classPoint &#123;public: Point(float x);private: float _x;&#125;; 这种形式将数据和函数相关联，数据封装。那么这样的数据封装有成本吗？没有所有的Class只会生成出一个函数实体。data members则是直接包含在class object中与C的struct一致。C++的布局和存储时间的额外负担是由virtual引起的： virtual function机制 用来支持一个有效率的“执行期绑定”。 virtual base class 用来实现“多次出现在继承体系中的base class,有一个单一而被共享的实体”。 此外，还有一些多重继承下的额外负担。 C++的对象模型C++中存在两种数据成员 static、nostatic，三种成员函数 static、nostatic、virtual。123456789101112classPoint &#123;public: Point(float xval); virtual ~Point(); float x() const; staticint PointCount();protected: virtual ostream&amp; print(ostream &amp;os) const; float_x; staticint_point_count;&#125;; 上图为C++的对象模型： nostatic data members 被配置在每一个class object之内。 static data members 被存放在所有的class object之外。 staitic 和 nostatic function members存放在class object之外。 virtual functions以两个步骤支持： ①每一个class产生出一堆指向virtual functions 的指针，放在表格之中。也就是虚表。 ②每一个class object被添加了一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设和重置由每一个classd constructor destructor 和 copy assignmemt运算符自动完成。每一个class所关联的type_info object用意支持runtiome tyoe identification，rtti也经由virtual table被指出来，通常是放在第一个slot处。 加上继承c++支持单一继承、多重继承、虚拟继承。 具体的讨论需要3.4中见到。 对象模型如何影响程序class X定义了一个拷贝构造函数，一个虚析构函数，一个虚函数foo();123456789X foobar()&#123; X xx; X *px = new X; xx.foo(); px-&gt;foo(); delete px; return x;&#125; 这个函数可能在内部转换为1234567891011121314151617181920212223242526272829303132//可能的内部转换结果//虚拟C++码void foobar(X&amp; _result)&#123; //使用引用返回，属于编译器的优化了。 //构造 _result.X::X(); //申请内存 px = _new(sizeof(X)); //调用构造函数 if( px != 0) px-&gt;X::X(); //成员函数的形式的转换，成员函数就是普通函数不过有一个this指针 foo(&amp;_result); //虚函数的基本调用方式，通过vptr来调用 (*px-&gt;vtbl[2])(px); //调用虚析构函数 if( px != 0) &#123; (*px-&gt;vtbl[1])(px); _delete(px); &#125; //不需要使用named return statement //不需要摧毁Local object xx //而是使用了传入参数_result return;&#125; 关键词所带来的差异策略性正确的struct把单一元素的数组放在一个struct的尾端，于是每个 struct objects 可以拥有可变大小的数组：12345678struct mumble &#123; char pc[1];&#125;;//获取一个字符串，然后为struct本身和该字符串配置足够的内存struct mumble *pmumbl = (struct mumble*)malloc(sizeof(structmumble) + strlen(string) + 1);strcpy(pmumbl-&gt;pc, string); 这在C++中是很有问题的。不一定在pc后面就没有存放数据。 对象的差异C++支持多种程序设计典范：程序模型、抽象数据类型模型、面向对象模型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记] 《如何阅读一本书》]]></title>
      <url>%2F%2Fblog%2F2016%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B.html</url>
      <content type="text"><![CDATA[阅读的活力与艺术阅读存在很多个层次：娱乐、获取资讯、加深理解力。本书更多的是为了读者能够加深理解力而写的书籍，教导人们如何通过各种手段，来阅读一本值得阅读的书籍。阅读是一种主动的学习方式。而教师的教导等方式更多的是被动的接受。阅读作为主动的学习方式。这里的主动是你主动去获取知识，比如编程的书籍，看了不代表主动，需要更多的实践，这就是主动。不断的去实践、检测书籍中的内容，这样才能够对于艰深的书籍有更多的理解。 作者的观点里存在四个阅读的层次：(这里的层次更多的是阅读方法上的分类) 基础阅读基础阅读：认识字,能够读大部分读物，能够大概的描述阅读的内容说的是什么。 检视阅读这一个层次要求能够快速的、准确的通过各种方式抓住一本书的重点。分为两类有系统的略读：1、看书名、序言。了解整个书讲的什么。2、研究目录，对书的骨架有了了解。3、看索引，能够快速的知道本书内容的范围。4、阅读其他人写的介绍。5、抽取部分篇章阅读。6、不要忽略最后几页粗浅的阅读：1、快速的阅读，即使对很多内容不理解也要将书籍读完。这样才不会停滞不前。2、提高阅读速度的方式，不断移动眼球，不要后退暂停。大脑要跟上阅读的速度。3、需要判断不同的书籍类型，不同的种类使用不同的阅读速度。 如何做一个自我要求的读者主动阅读需要提出的四个问题，在整个阅读的过程中需要不断的去尝试的回答这些问题：1、整体而言，这本书到底谈些什么？2、作者细部说了什么，怎么说的？3、这本书说都有道理吗？是全部由道理，还是部分有道理？4、这本书跟你有什么关系？ 如何让一本书真正属于你自己想要真正拥有一本书，不是花钱买了它。而是阅读它，做好笔记，实践书中的内容。笔记是一个能够提升阅读主动性的存在，有与有笔记的存在，阅读者能够不断提醒自己，不至于打瞌睡，同时对内容的输出也是加深对书籍理解的方式，它迫使你不断的去思考，组织语言回应一个又一个事实。 存在三种笔记：结构笔记：这种笔记的目的是记录下全书的架构，而不是内容。概念笔记：书中一般会有很多新的概念或者其他你了解过的概念。这里记录的是作者的想法，与结构无关。辩证笔记：对于更高层次的读者，已经不是全部接受作者观点了，他们需要的是对于本书已有的观点事实进行讨论，那么记录的笔记更多的是辩证的性质。 分析阅读分析阅读的三个阶段第一个阶段：找出一本书在谈些什么1、依照书的种类与主题分类。2、使用最简短的问题说明一本书谈什么。3、将主要部分按照顺序与关联性列举出来。将全书的大纲列举出来，并将各个部分的大纲也列出来。4、确定作者想要解决的问题。第二个阶段：诠释一本书的内容1、诠释作者使用的关键字，与作者达成共识。2、从最重要的句子中抓住作者的重要主旨3、找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。4、确定作者已经解决了哪些问题，还有哪些是未解决的。未解决的问题中，确定哪些是作者认为自己无法解决的问题。第三个阶段：像是沟通知识一样地评论一本书的规则A．智慧礼节的一般规则（9）除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。（在你说出：“我读懂了！”之前，不要说你同意、不同意或暂缓评论。）（10）不要争强好胜，非辩到底不可。（11）在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。B．批评观点的特别标准（12）证明作者的知识不足。（13）证明作者的知识错误。（14）证明作者不合逻辑。（15）证明作者的分析与理由是不完整的。 批评式阅读条件本章的三个规则说明的是批评式阅读的条件，而在这样的阅读中，读者应该能够与作者“辩论”。第一，要求读者先完整地了解一本书，不要急着开始批评。第二，恳请读者不要争强好辩或盲目反对。第三，将知识上的不同意见看作是大体上可以解决的问题。这个规则再进一步的话，就是要求读者要为自己不同的意见找到理论基础，这样这个议题才不只是被说出来，而且会解释清楚。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[读书笔记]多任务下的数据结构与算法 序章]]></title>
      <url>%2F%2Fblog%2F2016%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html</url>
      <content type="text"><![CDATA[序章部分都是周先生之前的一些经验之谈，感觉在实际编程过程中还是比较有用的，程序里经常遇到这么些问题。 1、参数校验参数校验，大部分函数开始和使用传进来的参数的都是都是需要参数校验的。有时候不知道该不该校验，怎么样才能划分这部分工作是函数使用者的工作，还是函数设计者的工作呢。一直比较迷糊吧。 对于在大循环里调用的函数，不需要再函数内校验。比如链表的遍历，如果校验的话，每一个链表的节点都需要校验，那么函数的效率就要大幅度下降了。 底层的函数调用频度都比较高，一般不校验？这个为什么不校验了，是因为调用频度高？如果在一个函数中多次使用这个底层函数，实际上只要在调用函数之前，一次性校验一次就行了。而不需要在底层函数中进行校验，否则多次校验，影响效率。 调用频率低的校验，和上面一条类似，调用频率低了，自然自带校验好。执行时间开销很大，参数校验对于函数运行时间来说忽略不计。 可以大幅度提高软件的稳定性的。 2、return语句的使用函数对于return语句的使用，多次使用该语句的话，要对资源进行回收完全，但实际情况中，经常会忘记写一些，这样就造成内存泄露比较容易发生。但是你不用return语句的话，一般写程序条件过多，分支过多，读程序的困难就比较大的提升了。 参数校验失败后直接return，并对资源回收 函数内不同的出错，要使用不同的return来表示不同的出错原因*函数内部同类出错，尽量使用同一个return语句，尽量不要让两个return返回同一个返回值 3、while循环和for循环的问题死循环时，在pc-lint中会检测成错误？ 普通时候，循环变量在循环中改变的话，用while，在循环后改变用for 4、if语句多个判断的问题需要校验多个参数时候，把条件放在一个if中，这要就少了return。当然，这些条件要产生不容的return结果的时候，就需要分开了。 5、goto语句的使用我看周先生在一些代码中还是使用的一些goto语句的，根据之前的描述看，就是运用在出错的时候，跳转到资源回收时，比较方便使用。 但是goto的语句使用有一些原则goto语句只能goto到同一函数内，而不能从一个函数里goto到另一个函数里使用goto语句在同一个函数内goto时候，goto的起点应该是函数内一小段功能结束处，目的地是一小段功能开始处，而不是乱跳不能从一段复杂的执行状态中的位置goto，这样很容易遗漏东西。 6、swich…case if else if区别一般swich效率更高些，但是实际情况是，每一个条件存在不同概率时候，把概率大的放最前的话，效率最高。 7、任意数据类型的处理方式 C数据类型几乎存在无限种组合了，c++使用模板，而在c语言中使用void指针是很不错的方法。其实在C++中也经常用到void指针，因为可以指向任意类型的数据。C使用void*时候不知道适合该数据结构的一些操作，所以需要使用回调函数，来传进这些操作。 数据的比较 数据的资源释放数据的访问 数据的拷贝*数据的一些其他计算操作 例子 typedef void (DESTROYFUNC)( void *pArgs);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《The Last Of Us》]]></title>
      <url>%2F%2Fblog%2F2016%2F07%2F%E3%80%8AThe-Last-Of-Us%E3%80%8B.html</url>
      <content type="text"><![CDATA[关于结局1、我不信任马琳。可以确定的是他们确实是想要找到疫苗，即使马琳在爱丽出身开始就在她的旁边，也要杀死爱丽。马琳是抛弃了爱丽的，从最初的国会大厦，到玛利亚医院，她存活下来之后，才开始在其记录的本子录音中关心起爱丽来，当然更多的是关心有免疫体的爱丽。其实作为爱丽没有必要跟着马琳走的，完全可以在波士顿生活下去，爱丽是重情，而马琳就不是了。 2、火萤是一个怎么样的组织呢？从剧情看乔尔的弟弟在离开乔尔之后，加入了火萤，然后从火萤离开，到达森林之中构筑起他的小村落。火萤能不能给人类带来新的希望呢，我觉得是不能的，在长期的对抗之下，火萤显然是从最初的想要找回原来国家秩序的组织退化了，也是由于这个原因让汤米出走，寻找自己的出路，最后汤米接近于实现他的想法。 3、汤米的村落才是人类的希望。汤米的村落才是真正的人类希望。不论是军事管理区、猎人、还是火萤，都让这个国家的秩序不再存在了。从整个游戏的不断对抗之中我们能够发现的是，往往人类比感染者更加难缠，乔尔与爱丽最惊险的时刻还是在与猎人、军政府、火萤的对抗的时候。实际上感染者，可能并没有那么可怕。汤米的小村落，在回归秩序之后，需要担心的更多是猎人，而不是感染者能够说明，如果社会重新回归秩序，那么感染者并没有那么可怕，可怕的更多的是人心。 关于细节1、汤米和乔尔的分裂是必然的。在游戏开场的时候，汤米开车载着乔尔和萨拉，路上有人求救，汤米想要停下来载人，乔尔是强烈反对的。乔尔要求开车冲过人群，不管前面不断涌来的人流，汤米是不愿意的。就如后面剧情所描述的那般，乔尔成为了走私客，当过猎人。帮助他与汤米活了下来。而对于汤米来说，这对他是一场噩梦。两个人的处事原则不一致，导致了他们最终的分裂。而从这一点来看，乔尔为了救爱丽，杀医生与马琳这么些中性的人物也就不奇怪了。 2、关于火萤的疫苗研究。当乔尔一行躲过军队的追击时，问爱丽火萤的安排的时候，爱丽说火萤有着自己的隔离区正在研究疫苗，乔尔与泰丝不屑一顾。说明火萤研究疫苗人尽皆知，但从来不知道真假。 3、泰丝无声的死亡当军队追击到来，泰丝希望能够阻止一会。乔尔与爱丽刚到达二楼，就是一声参加。当我们终于在二楼解决掉敌人的时候，回过头来，泰丝的尸体就躺在了那里。没有太多反抗能力的，无声的死去了。所有关于她的故事，精彩的一生，就这样消失了。带给我的是孤寂。 4、山姆与亨利当终于躲过了猎人与感染者的追击，乔尔爱丽与黑人兄弟建立起来友谊。夜晚来临，亨利对于未来充满想象，愉快的吃着东西讨论着哈雷机车，让我没想到的是，这会是最后一个夜晚了。亨利饮弹自尽，十多秒的黑屏，让我思考很久。 5、爱丽梦到飞机当快要到达旅途的终点，爱丽在一个飞机的海报之前停了下来。描述着之前她做的梦。失去控制的飞机，没有机长的机长室，只能由她来拯救这一飞机上的人，她试图驾驶，但飞机却要坠落了。失控的飞机代表着这个失控的世界，而爱丽就是拯救世界的关键人物，没人可以给与她指引，只能她自己去摸索，但是终究可能会坠落，她害怕失去朋友，害怕完成不了自己的使命。 6、两人关系进展的一些点乔尔在电梯处，掉了下去之后，他问爱丽是不是OK，爱丽回答“NO,你吓到我了”爱丽在乔尔差点被猎人溺死的情况下拯救了乔尔，但是乔尔嘴硬的不愿意承认，爱丽直说乔尔怎么就不知道感谢。游戏设计上立马设计一个乔尔一个人推不动的钢琴，需要爱丽与他一起。同时接着就是乔尔需要爱丽进行掩护攻击猎人。躲避机车的关卡，乔尔没有爬山去的情况下，爱丽直接跳下来与乔尔一起面对难关。在关键时刻需要跳桥的情况下，乔尔关心的是爱丽不会游泳，而爱丽信任他，一句不要让我沉下去，就果断跳了。乔尔寻找会出走的爱丽，爱丽直言，她害怕失去，所有她关心的人都离她而去，除了乔尔。她不需要什么更懂行的汤米，只需要乔尔，只有这样她才能够心安。 爱丽打败大卫，疯狂的痛砍大卫的尸体的时候，乔尔及时的出现，像安慰女儿一样安慰着爱丽（神态语气如同萨拉死去的时候一般），同时抚平了自己的内心。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F%2Fblog%2F2016%2F07%2Fhello-world.html</url>
      <content type="text"><![CDATA[新的博客 Hello World]]></content>
    </entry>

    
  
  
</search>
