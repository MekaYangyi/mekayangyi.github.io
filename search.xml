<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[clean code读书笔记]]></title>
      <url>/2018/07/23/clean-code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>​    命名，很多人戏称为编程中最难的事情。从实践经验出发来看，一个好的命名能够让代码阅读者迅速的知道代码的实际用途，而坏的命名不仅仅是让人摸不着头脑，而且可能误导他人。    </p>
<p>​    本文主要是clean code第二章有意义的命名的笔记，该章节系统的讲述了什么才是一个好的名字。</p>
<ol>
<li><p>名副其实</p>
<blockquote>
<p>如果命名需要注释，则不是一个好的命名。</p>
<p>命名需要表达出准确的含义，不应该使用magic num或者i、j、k这类无意义的变量名。</p>
</blockquote>
</li>
<li><p>避免误导</p>
<blockquote>
<p>0和O、1、I和l。这类视觉上容易混淆的名字不需要使用。</p>
<p>假设存在一个vector，里面存储这actor_rid，但是你命名为actor_list，导致阅读者误认为是用链表实现的。</p>
</blockquote>
</li>
<li><p>做有意义的区分</p>
<blockquote>
<p>类似a1、a2、a3不能够带来任何信息的变量命名</p>
<p>类似thexx、xxdata、xxinfo、xxobject这类没有意义的前缀、后缀</p>
<p>不使用匈牙利命名法带上类型信息，现在ide随时可以看到类型</p>
<p>变量的命名需要带有含义，不要带上冗余的无效的信息。</p>
</blockquote>
</li>
<li><p>使用读得出来的名称</p>
<blockquote>
<p>如果变量难易阅读的话，对阅读者总是负担，难以记住也难易和他人交流</p>
</blockquote>
</li>
<li><p>使用可搜索的名称</p>
<blockquote>
<p>作用域越大变量名越长，便于搜索同时不会重复。</p>
</blockquote>
</li>
<li><p>避免使用编码</p>
<blockquote>
<p>匈牙利命名法在现代ide没有必要，同时影响ide的自动补全，修改类型名同时需要修改变量名</p>
<p>类似m_的前缀没有必要</p>
</blockquote>
</li>
<li><p>避免翻译</p>
<blockquote>
<p>缩写</p>
</blockquote>
</li>
<li><p>类名</p>
<blockquote>
<p>类名应该是名词或者名词短语，不应该是动词</p>
</blockquote>
</li>
<li><p>方法名</p>
<blockquote>
<p>方法名应该是动词或者动词短语，类似set_xx、is_xx</p>
</blockquote>
</li>
<li><p>别扮可爱</p>
<blockquote>
<p>不要使用难以联想到的词，即使你认为很精妙，直接了当的命名。</p>
</blockquote>
</li>
<li><p>每个概念对应一个词</p>
<blockquote>
<p>controller、manager、driver。英语中有很多语义相似的词语，代码中统一使用一个词来描述。</p>
</blockquote>
</li>
<li><p>不使用双关</p>
<blockquote>
<p>双关代表者二义性。比如add，有可能是insert的意思，有可能是append的意思。</p>
</blockquote>
</li>
<li><p>使用解决方案领域名称</p>
<blockquote>
<p>计算机科学属于、算法名、模式名。使用领域内专有名词利于有共同经验的人理解程序</p>
</blockquote>
</li>
<li><p>使用源自所涉问题领域名称</p>
<blockquote>
<p>我们是游戏编程，有很多游戏专有名词。比如exp、level、dps等，更业务的代码使用这些名词易于理解</p>
</blockquote>
</li>
<li><p>添加有意义的语境</p>
<blockquote>
<p>将相关的变量设置统一的前缀、后缀，建立语境。</p>
</blockquote>
</li>
<li><p>不要添加没用的语境</p>
<blockquote>
<p>比如给同一个项目里的所有类添加上项目名称。</p>
</blockquote>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[这几个月的一点随感]]></title>
      <url>/2017/10/15/%E8%BF%99%E5%87%A0%E4%B8%AA%E6%9C%88%E7%9A%84%E4%B8%80%E7%82%B9%E9%9A%8F%E6%84%9F/</url>
      <content type="html"><![CDATA[<p>又有几个月没写博客了，自上次Redis系列之后，三个月过去。中间结束一个项目、面试了很多次、换了个工作、搬了次家、在家度过了一次国庆长假。</p>
<h1 id="结束一个项目"><a href="#结束一个项目" class="headerlink" title="结束一个项目"></a>结束一个项目</h1><p>结束的一个项目，算是基本独立完成的比较大的一个项目。项目团队四个人，两程序、两自动化。</p>
<p>出差到施工现场三个月，在那里完成了从客户端界面到服务端大部分编码测试工作，独立解决各种现场需求。很顺利的完成了工作，结题一个多月。项目在之前做的一个十多万行的项目基础上开发，新增了几万行代码，需要对程序进行设计架构的要求少，大部分还是在原来代码基础上修改，增加删除功能。做完这个项目之后，感觉编码上能遇到的问题越来越少，到了一个算是瓶颈的位置。</p>
<p>原公司是一个做轧钢工业控制系统的公司，十几个人，一半是程序员，一半是自动化工程师。毕业时候进去的。它给了我成为程序员的机会，工作氛围也很好，让我在基础薄弱的时候自由学习，并应用到项目之上。</p>
<p>从技术上看，软件需要对工业设备进行控制，对稳定性安全性要求高，程序崩溃或者控制逻辑上产生问题，可能导致很大的生产事故。用户量小，一般只需要一个服务器，搭配几个客户端界面。</p>
<p>公司依靠自动化起家，软件部门薄弱。老板对于软件的认识不足，认为编码简单，只要找些应届生学学就能上。又由于行业比较小，难以从社会上补充有经验的人员。不过话说回来，从公司需求来说，确实不需要大牛。维持住业务，两年三年工作经验程序经验即可胜任，基础好的应届生也能完成大部分工作。工作的主要难度在业务的理解上，这也是我能成为程序的原因。</p>
<p>刚进去的时候，之前的干了八年的主程序因故出走，剩下的都是只有一年经验的程序。还好老板在之后请来了老同学（20年经验），管理队伍。但是由于工作性质，需要长期出差，大部分代码在施工现场完成，一般一两人负责一个项目，没有完善的流程，更多是靠个人的自我约束，自我驱动去完成项目。从代码质量来看，肯定不会好。</p>
<p>如果要对我过去两年工作进行一个总结的话，那就是野蛮生长，整个过程中很少有人能够给予我指导，都是依靠个人去搜索资料、学习知识。对于程序更多的停留在编码阶段，对与程序设计、软件工程的管理认识浅薄。</p>
<h1 id="面了很多次试"><a href="#面了很多次试" class="headerlink" title="面了很多次试"></a>面了很多次试</h1><p>项目结束之后，休了个一周的长假。顺便也投了很多简历，面了很多次试。</p>
<p>面试的本意是看看自己在市场上到底值多少，了解市场的需求。八月份，不是招聘旺季，拉勾上C++的岗位只有三百多一点，适合我这个经验的100多个。由于之前的工作业务关系，干什么都是转行，同时不管是客户端还是服务端都干过，很多工作对我来说即适合又不适合。尝试着投递了一些岗位。后来感觉面试邀约不多，陆陆续续投递简历半个多月，最后发现快把适合我这个经验的岗位投递完了。一百来份简历，最终收到不到20个面试邀请。</p>
<p>从市场上看，C++需求的主要是两种windows客户端和linux服务端开发。需求最旺的依次是游戏、金融、工业控制领域。面试考察的大部分还是计算机原理、c++基础、数据结构、tcp网络基础，这可能由于我没行业背景有关。个人感觉我对于C++基础、数据结构没有太多问题，计算机原理稍薄弱，tcp网络了解很少，行业知识有限，对Linux开发没有经验。对于市场上很多岗位不能很好的匹配，于是给我面试机会的相对也比较少。</p>
<h1 id="换了个工作"><a href="#换了个工作" class="headerlink" title="换了个工作"></a>换了个工作</h1><p>本意是出去见见世面的我，最终换了一份工作。面试的多了，愈加感觉到自己的不足。虽然在过去两年里还算努力的进行学习（总是有惰性，要是真的非常努力，肯定混的比现在好）。但是由于自身视野的问题和业务性质，我觉得要想更快速的更进一步，是时候去一个新的地方闯荡了。</p>
<p>于是，最终选择加入游戏公司成为linux服务端程序员。面试的时候，新公司主程序对我的评价是很对的：一个处在进阶阶段的程序。在这么一个阶段，需要更多的环境上的促进。这样我才能接触到更多的问题，发现一个更大的世界，逼着我去处理各种问题，不断的前进。很多时候，对于程序员来说，如果没有接触到问题的环境，你很难去想象到怎么处理问题，这也是很多公司要求行业经验的原因。不仅仅是业务上的熟悉，同时也是你只有在那个环境，比如用户量达到一定量级，才可能接触到问题，才可能知道怎么去处理问题。</p>
<p>另一个原因是我个人的心愿与理想。我是一个喜欢游戏的人，一直希望能够进入游戏公司，去看看怎么做游戏的。毕业的时候，一直在尝试找一个游戏策划的工作，但最终只收到一个小公司的游戏测试岗位offer，没有去。最后成员工业控制程序员，有一部分原因是c++在游戏领域用的很多，以后有机会跳槽。</p>
<p>现在能有机会进入一家在我看来还算不错的游戏公司，也算是了却一个心愿。虽然网上对于国内游戏开发有很多负面评论，但是不管怎么样，我也要去看看。不管未来这个工作会不会真的喜欢，我也要去尝试。</p>
<h1 id="搬了次家"><a href="#搬了次家" class="headerlink" title="搬了次家"></a>搬了次家</h1><p>又搬了次家，这次是由于新工作离原来住的地方有点远，接近两小时的路程，必须得搬家了。毕业两年，包括离校的那次，搬了七次家，算下来三四个月就要搬一次家。过去两年里，出差过三个地方，广东湛江、河南安阳、辽宁营口，一出差就是几个月半年的，天南海北的。</p>
<p>飘临。</p>
<p>我算是一个适应能力很强的一个人了，在一个新地方能够比较快的熟悉起来。但是这么多次搬家，又经常长期出差到不熟悉的地方，那种人在异乡的感觉就愈加强烈了。以前觉得出差没什么，反正单身狗一个，一人吃饱全家不饿的，但是真的出差久了，就发现你跑到一个陌生的地方，人要重新熟悉，城市要重新熟悉，又不能带很多东西。这意味着你之前的积累都没了，你只能带着其实就是你这个人。外物积累都没了，周围的熟悉事物没了，你其实对于一个新的环境来说是一个异物，你是个格格不入的东西。但是我又不是旅游，我必须去熟悉，因为要做项目，要与人打交道，要在这生活一段时间。可熟悉了，立马又要进入一个新的陌生环境。搬家一样，搬到一个新的地方，室友不认识，周围环境不熟悉，又要重新认识熟悉。</p>
<p>很多精力，就在这样的过程中被磨灭了。</p>
<h1 id="在家度过了一个国庆"><a href="#在家度过了一个国庆" class="headerlink" title="在家度过了一个国庆"></a>在家度过了一个国庆</h1><p>​上一次回家是过年的时候了，中间的一些假期不是在加班就是在出差。项目结束的假期又在面试。这样一算又是大半年没回去了。</p>
<p>时间。</p>
<p>很多时候你没有意识到，其实离开家已经很久了。现在24岁，人生的前12年在小镇上度过，初高中到了新余市，过了6年。大学到了上海4年，加上毕业2年，已经6年了。人生的四分之一是在外面度过的，可以预料到的是之后很长一段时间依旧会在上海。在家的时间越来越少。</p>
<p>我是喜欢回家的，在家的话很多事情不需要考虑，饭来张口衣来伸手，每天看看电脑，看看电视，啥事不管。对我来说，最大的幸福就是和自己爱的人待在一个地方，可以不说话，只要在一起，互相能够感觉到对方。回家对我来说就是这样一件事情，大家都很熟悉了，不管是父母、亲戚、朋友，只要在一起，互相有默契。这种长时间磨合之后产生的默契的感觉是最让我留恋的。</p>
]]></content>
      
        <categories>
            
            <category> 随感 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随感 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码阅读-总结]]></title>
      <url>/2017/07/18/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>之前的一系列Redis源码阅读的博客都是基于《Redis设计与实现》的，内容上不免和书有雷同。</p>
<p>本来计划是三月份开始看，但是中间由于接到一个开发速度要求很高的项目，加班很多耽误了些进度，只在这一段时间里看了部分小书（部分书摘录成了博客），耽搁了。</p>
<p>然后快到七月的时候，项目在经过编码、测试，最终投用起来之后，又有了更多的时间来学习。便开始了源码的继续阅读。</p>
<p>阅读redis源码的目的:</p>
<ul>
<li>为了之后项目如果使用redis的话能够游刃有余。</li>
<li>学习其优秀的编码。</li>
</ul>
<p>参加工作两年。</p>
<p>第一年是从机械专业学生转变为程序员，更多的是在打基础，看了挺多计算机的基础书籍。那段时间相对是痛苦的，遇到一个问题往往不明白，不断去探究又探究出一个新的不明白的问题。</p>
<p>第二年在积累了几万行之后，开始感觉基础编码方面比较游刃有余了，遇到的问题大多数能提取重点，找到解决方案。但是想着继续提升，于是开始了部分项目的源码阅读。除了公司项目源码的阅读，网上开源项目的源码阅读也提上了日程，在经过了sgi stl的仿写之后，开始了redis的阅读。</p>
<p>redis是我第一个比较完整的看完的现在流行的开源项目源码。不算中间停下来的时间，大概看了三个星期。这三个星期里不能说对redis理解很深透，但是起码整个项目的结构，怎么实现主要的功能，内部模块的互相调用算是理解了。</p>
<p>收获有很多，修炼还需要继续。</p>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-一个命令的旅程]]></title>
      <url>/2017/07/18/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%85%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>redis服务器会与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行的命令，并通过资源管理来维持整个服务器自身的运转。</p>
<p>本文目的是为了理清楚服务器对于命令请求的整个处理过程，说明这个过程中服务器与客户端如何互相交互，服务器内部如何调用内部组件达到对命令的执行。</p>
<h2 id="命令的处理流程"><a href="#命令的处理流程" class="headerlink" title="命令的处理流程"></a>命令的处理流程</h2><p>之前在事务代码部分的阅读，已经对于服务器接收客户端的连接并创建命令请求处理器等待命令请求的过程。</p>
<p>现在以一个简单的set命令为例子，看服务器在接收请求之后如何处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET KEY VALUE</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>从客户端发送set key value命令到接收回复ok，都做了如下操作：</p>
<ul>
<li>客户端发送命令。</li>
<li>服务器命令请求处理器接收，引发命令的执行，并产生命令回复处理器。</li>
<li>命令回复处理器发送ok给客户端。</li>
<li>客户端接收ok，并打印。</li>
</ul>
<a id="more"></a>
<h2 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h2><p>客户端将键入的命令转换为协议格式并套接字发送到服务器</p>
<h2 id="读取命令"><a href="#读取命令" class="headerlink" title="读取命令"></a>读取命令</h2><p>服务器发现客户端连接套接字变为可读时，通过命令请求处理器readQueryFromClient()函数来进行处理。</p>
<h3 id="读取命令到缓冲区并处理"><a href="#读取命令到缓冲区并处理" class="headerlink" title="读取命令到缓冲区并处理"></a>读取命令到缓冲区并处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 读取客户端的查询缓冲区内容</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    redisClient *c = (redisClient*) privdata;</div><div class="line">    <span class="keyword">int</span> nread, readlen;</div><div class="line">    <span class="keyword">size_t</span> qblen;</div><div class="line">    REDIS_NOTUSED(el);</div><div class="line">    REDIS_NOTUSED(mask);</div><div class="line"></div><div class="line">    server.current_client = c; <span class="comment">// 设置服务器的当前客户端</span></div><div class="line">    readlen = REDIS_IOBUF_LEN; <span class="comment">// 读取的默认长度</span></div><div class="line">    <span class="comment">/* If this is a multi bulk request, and we are processing a bulk reply</span></div><div class="line"><span class="comment">     * that is large enough, try to maximize the probability that the query</span></div><div class="line"><span class="comment">     * buffer contains exactly the SDS string representing the object, even</span></div><div class="line"><span class="comment">     * at the risk of requiring more read(2) calls. This way the function</span></div><div class="line"><span class="comment">     * processMultiBulkBuffer() can avoid copying buffers to create the</span></div><div class="line"><span class="comment">     * Redis Object representing the argument. */</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;reqtype == REDIS_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></div><div class="line">        &amp;&amp; c-&gt;bulklen &gt;= REDIS_MBULK_BIG_ARG)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> remaining = (<span class="keyword">unsigned</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (remaining &lt; readlen) readlen = remaining;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取缓存区遗留数据长度</span></div><div class="line">    qblen = sdslen(c-&gt;querybuf);</div><div class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen; <span class="comment">// 查询缓冲区长度峰值更新</span></div><div class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen); <span class="comment">// 重新分配查询缓冲区空间</span></div><div class="line">    nread = read(fd, c-&gt;querybuf+qblen, readlen); <span class="comment">// 读取fd中数据，在遗留数据之后</span></div><div class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// 读取错误处理</span></div><div class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</div><div class="line">            nread = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            redisLog(REDIS_VERBOSE, <span class="string">"Reading from client: %s"</span>,strerror(errno));</div><div class="line">            freeClient(c);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 遇到EOF,关闭客户端</span></div><div class="line">        redisLog(REDIS_VERBOSE, <span class="string">"Client closed connection"</span>);</div><div class="line">        freeClient(c);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (nread) &#123;</div><div class="line">        <span class="comment">// 读取成功</span></div><div class="line">        sdsIncrLen(c-&gt;querybuf,nread); <span class="comment">// 正确更新 free 和 len 属性的。</span></div><div class="line">        c-&gt;lastinteraction = server.unixtime; <span class="comment">// 记录最后一次互动时间</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MASTER) c-&gt;reploff += nread; <span class="comment">// 客户端为master,更新复制偏移量</span></div><div class="line">        server.stat_net_input_bytes += nread;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 在 nread == -1 且 errno == EAGAIN 时运行</span></div><div class="line">        server.current_client = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 缓冲区长度超过服务器最大缓冲区长度</span></div><div class="line">    <span class="comment">// 清空缓冲区并释放客户端</span></div><div class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</div><div class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</div><div class="line"></div><div class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"</span>, ci, bytes);</div><div class="line">        sdsfree(ci);</div><div class="line">        sdsfree(bytes);</div><div class="line">        freeClient(c);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 从缓冲区中读取内容，创建参数，并执行命令</span></div><div class="line">    <span class="comment">// 直到缓冲区所有的内容被处理完为止</span></div><div class="line">    processInputBuffer(c);</div><div class="line">    server.current_client = <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="从缓冲区中读取命令并处理"><a href="#从缓冲区中读取命令并处理" class="headerlink" title="从缓冲区中读取命令并处理"></a>从缓冲区中读取命令并处理</h3><p>redis的readQueryFromClient()函数在将命令读取到缓冲区之后，调用processInputBuffer()对缓冲区内的命令进行处理，直到所有命令处理完毕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理客户端输入的内容</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInputBuffer</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Keep processing while there is something in the input buffer */</span></div><div class="line">    <span class="keyword">while</span>(sdslen(c-&gt;querybuf)) &#123;</div><div class="line">        <span class="comment">// 客户端处于暂停状态，直接返回</span></div><div class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_SLAVE) &amp;&amp; clientsArePaused()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 客户端被阻塞直接返回</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_BLOCKED) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 客户端被设置为关闭，返回</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_CLOSE_AFTER_REPLY) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 判断请求类型</span></div><div class="line">        <span class="keyword">if</span> (!c-&gt;reqtype) &#123;</div><div class="line">            <span class="keyword">if</span> (c-&gt;querybuf[<span class="number">0</span>] == <span class="string">'*'</span>) &#123;</div><div class="line">                c-&gt;reqtype = REDIS_REQ_MULTIBULK;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                c-&gt;reqtype = REDIS_REQ_INLINE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 将缓冲区中的内容转换为命令，以及命令参数</span></div><div class="line">        <span class="comment">// processMultibulkBuffer()处理一般客户端发送的信息</span></div><div class="line">      	<span class="comment">// processInlineBuffer()处理TELNET发送的信息</span></div><div class="line">        <span class="comment">// 命令转换失败跳出循环，也就是可能在没有处理完缓冲区所有数据的情况下跳出。</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;reqtype == REDIS_REQ_INLINE) &#123;</div><div class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != REDIS_OK) <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;reqtype == REDIS_REQ_MULTIBULK) &#123;</div><div class="line">            <span class="keyword">if</span> (processMultibulkBuffer(c) != REDIS_OK) <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            redisPanic(<span class="string">"Unknown request type"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 命令参数为0，不需要执行</span></div><div class="line">            resetClient(c);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 执行命令，在成功执行之后重置客户端</span></div><div class="line">            <span class="keyword">if</span> (processCommand(c) == REDIS_OK)</div><div class="line">                resetClient(c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 命令的转换介绍下processMultibulkBuffer()，此为处理客户端发送来命令，相对协议更复杂。</span></div><div class="line"><span class="comment">// processInlineBuffer()相对协议简单就不介绍了。</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 将 c-&gt;querybuf 中的协议内容转换成 c-&gt;argv 中的参数对象</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * 比如 *3\r\n$3\r\nSET\r\n$3\r\nMSG\r\n$5\r\nHELLO\r\n</span></div><div class="line"><span class="comment"> * 将被转换为：</span></div><div class="line"><span class="comment"> * argv[0] = SET</span></div><div class="line"><span class="comment"> * argv[1] = MSG</span></div><div class="line"><span class="comment"> * argv[2] = HELLO</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processMultibulkBuffer</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *newline = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, ok;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line">    <span class="comment">// 读取命令参数个数</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;multibulklen == <span class="number">0</span>) &#123;</div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;argc == <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 校验命令参数中"\r\n"的存在</span></div><div class="line">        newline = <span class="built_in">strchr</span>(c-&gt;querybuf,<span class="string">'\r'</span>);</div><div class="line">        <span class="keyword">if</span> (newline == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; REDIS_INLINE_MAX_SIZE) &#123;</div><div class="line">                addReplyError(c,<span class="string">"Protocol error: too big mbulk count string"</span>);</div><div class="line">                setProtocolError(c,<span class="number">0</span>); <span class="comment">// 异步关闭客户端</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (newline-(c-&gt;querybuf) &gt; ((<span class="keyword">signed</span>)sdslen(c-&gt;querybuf)<span class="number">-2</span>))</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">        <span class="comment">// 第一个字符必须时*</span></div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;querybuf[<span class="number">0</span>] == <span class="string">'*'</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 转换出参数的个数</span></div><div class="line">        ok = string2ll(c-&gt;querybuf+<span class="number">1</span>,newline-(c-&gt;querybuf+<span class="number">1</span>),&amp;ll);</div><div class="line"></div><div class="line">        <span class="comment">// 检测参数个数是否超限</span></div><div class="line">        <span class="keyword">if</span> (!ok || ll &gt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</div><div class="line">            addReplyError(c,<span class="string">"Protocol error: invalid multibulk length"</span>);</div><div class="line">            setProtocolError(c,pos); <span class="comment">// 异步关闭客户端</span></div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        pos = (newline-c-&gt;querybuf)+<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (ll &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 参数小于等于0，删除c-&gt;querybuf中从pos到-1的内容</span></div><div class="line">            <span class="comment">// 返回读取成功</span></div><div class="line">            sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</div><div class="line">            <span class="keyword">return</span> REDIS_OK;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 设置参数个数</span></div><div class="line">        c-&gt;multibulklen = ll;</div><div class="line"></div><div class="line">        <span class="comment">// 分配参数空间</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;argv) zfree(c-&gt;argv);</div><div class="line">        c-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;multibulklen);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    redisAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;multibulklen &gt; <span class="number">0</span>);</div><div class="line">    <span class="keyword">while</span>(c-&gt;multibulklen) &#123;</div><div class="line">        <span class="comment">// 读取参数长度</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;bulklen == <span class="number">-1</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 校验命令参数中"\r\n"的存在</span></div><div class="line">            newline = <span class="built_in">strchr</span>(c-&gt;querybuf+pos,<span class="string">'\r'</span>);</div><div class="line">            <span class="keyword">if</span> (newline == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; REDIS_INLINE_MAX_SIZE) &#123;</div><div class="line">                    addReplyError(c,</div><div class="line">                        <span class="string">"Protocol error: too big bulk count string"</span>);</div><div class="line">                    setProtocolError(c,<span class="number">0</span>);</div><div class="line">                    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (newline-(c-&gt;querybuf) &gt; ((<span class="keyword">signed</span>)sdslen(c-&gt;querybuf)<span class="number">-2</span>))</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 确认格式</span></div><div class="line">            <span class="keyword">if</span> (c-&gt;querybuf[pos] != <span class="string">'$'</span>) &#123;</div><div class="line">                addReplyErrorFormat(c,</div><div class="line">                    <span class="string">"Protocol error: expected '$', got '%c'"</span>,</div><div class="line">                    c-&gt;querybuf[pos]);</div><div class="line">                setProtocolError(c,pos);</div><div class="line">                <span class="keyword">return</span> REDIS_ERR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 读取长度</span></div><div class="line">            ok = string2ll(c-&gt;querybuf+pos+<span class="number">1</span>,newline-(c-&gt;querybuf+pos+<span class="number">1</span>),&amp;ll);</div><div class="line">            <span class="keyword">if</span> (!ok || ll &lt; <span class="number">0</span> || ll &gt; <span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>) &#123;</div><div class="line">                addReplyError(c,<span class="string">"Protocol error: invalid bulk length"</span>);</div><div class="line">                setProtocolError(c,pos);</div><div class="line">                <span class="keyword">return</span> REDIS_ERR;</div><div class="line">            &#125;</div><div class="line">            pos += newline-(c-&gt;querybuf+pos)+<span class="number">2</span>;</div><div class="line">            </div><div class="line">            <span class="comment">// 参数太长的特殊处理</span></div><div class="line">            <span class="keyword">if</span> (ll &gt;= REDIS_MBULK_BIG_ARG) &#123;</div><div class="line">                <span class="keyword">size_t</span> qblen;</div><div class="line"></div><div class="line">                <span class="comment">/* If we are going to read a large object from network</span></div><div class="line"><span class="comment">                 * try to make it likely that it will start at c-&gt;querybuf</span></div><div class="line"><span class="comment">                 * boundary so that we can optimize object creation</span></div><div class="line"><span class="comment">                 * avoiding a large copy of data. */</span></div><div class="line">                sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</div><div class="line">                pos = <span class="number">0</span>;</div><div class="line">                qblen = sdslen(c-&gt;querybuf);</div><div class="line">                <span class="comment">/* Hint the sds library about the amount of bytes this string is</span></div><div class="line"><span class="comment">                 * going to contain. */</span></div><div class="line">                <span class="keyword">if</span> (qblen &lt; (<span class="keyword">size_t</span>)ll+<span class="number">2</span>)</div><div class="line">                    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf,ll+<span class="number">2</span>-qblen);</div><div class="line">            &#125;</div><div class="line">            c-&gt;bulklen = ll;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 读取参数</span></div><div class="line">        <span class="keyword">if</span> (sdslen(c-&gt;querybuf)-pos &lt; (<span class="keyword">unsigned</span>)(c-&gt;bulklen+<span class="number">2</span>)) &#123;</div><div class="line">            <span class="comment">// 确认协议内容</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//复制参数</span></div><div class="line">            <span class="keyword">if</span> (pos == <span class="number">0</span> &amp;&amp;</div><div class="line">                c-&gt;bulklen &gt;= REDIS_MBULK_BIG_ARG &amp;&amp;</div><div class="line">                (<span class="keyword">signed</span>) sdslen(c-&gt;querybuf) == c-&gt;bulklen+<span class="number">2</span>)</div><div class="line">            &#123;</div><div class="line">                c-&gt;argv[c-&gt;argc++] = createObject(REDIS_STRING,c-&gt;querybuf);</div><div class="line">                sdsIncrLen(c-&gt;querybuf,<span class="number">-2</span>); <span class="comment">/* remove CRLF */</span></div><div class="line">                c-&gt;querybuf = sdsempty();</div><div class="line">                <span class="comment">/* Assume that if we saw a fat argument we'll see another one</span></div><div class="line"><span class="comment">                 * likely... */</span></div><div class="line">                c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf,c-&gt;bulklen+<span class="number">2</span>);</div><div class="line">                pos = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                c-&gt;argv[c-&gt;argc++] =</div><div class="line">                    createStringObject(c-&gt;querybuf+pos,c-&gt;bulklen);</div><div class="line">                pos += c-&gt;bulklen+<span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">            c-&gt;bulklen = <span class="number">-1</span>;</div><div class="line">            c-&gt;multibulklen--; <span class="comment">// 继续读取</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清除已经读取的内容</span></div><div class="line">    <span class="keyword">if</span> (pos) sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 读取完毕返回</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;multibulklen == <span class="number">0</span>) <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">    <span class="comment">// 可能内容不符合协议返回失败</span></div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h2><p>processInputBuffer()在解析成功命令之后，调用processCommand()对命令进行执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInputBuffer</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">  		<span class="comment">// ....</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 命令参数为0，不需要执行</span></div><div class="line">            resetClient(c);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 执行命令，在成功执行之后重置客户端</span></div><div class="line">            <span class="keyword">if</span> (processCommand(c) == REDIS_OK)</div><div class="line">                resetClient(c);</div><div class="line">        &#125;</div><div class="line">  		<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命令的查找"><a href="#命令的查找" class="headerlink" title="命令的查找"></a>命令的查找</h3><p>在processCommand()执行的第一步就是查询命令表，找到对于的命令实现信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 命令的执行</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="comment">// quit命令特殊处理，异步关闭服务器</span></div><div class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</div><div class="line">        addReply(c,shared.ok);</div><div class="line">        c-&gt;flags |= REDIS_CLOSE_AFTER_REPLY;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 查找命令</span></div><div class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</div><div class="line">    <span class="keyword">if</span> (!c-&gt;cmd) &#123;</div><div class="line">        <span class="comment">// 没有查找倒</span></div><div class="line">        flagTransaction(c);</div><div class="line">        addReplyErrorFormat(c,<span class="string">"unknown command '%s'"</span>,</div><div class="line">            (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</div><div class="line">        <span class="keyword">return</span> REDIS_OK;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c-&gt;cmd-&gt;arity &gt; <span class="number">0</span> &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</div><div class="line">               (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</div><div class="line">        <span class="comment">// 命令实现与输入的参数数量不匹配</span></div><div class="line">        flagTransaction(c);</div><div class="line">        addReplyErrorFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>,</div><div class="line">            c-&gt;cmd-&gt;name);</div><div class="line">        <span class="keyword">return</span> REDIS_OK;</div><div class="line">    &#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>redis维护了一个命令表，该命令表为一个字典，键为命令名字，值是一个redisCommand结构，该结构记录了一个Redis的命令实现。</p>
<p>服务器启动时，调用初始化服务器配置函数initServerConfig()，该函数会进行命令表的初始化，保存在两个字典中commands、orig_commands。原始的命令表初始参数保存在redis.c文件中的redisCommandTable定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></div><div class="line"> 	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 命令表（受到 rename 配置选项的作用）</span></div><div class="line">    dict *commands;</div><div class="line">    <span class="comment">// 命令表（无 rename 配置选项的作用）</span></div><div class="line">    dict *orig_commands;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">    initServerConfig();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServerConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">  	</div><div class="line">    <span class="comment">// 初始化命令表</span></div><div class="line">  	<span class="comment">// 创建命令字典</span></div><div class="line">    server.commands = dictCreate(&amp;commandTableDictType,<span class="literal">NULL</span>);</div><div class="line">    server.orig_commands = dictCreate(&amp;commandTableDictType,<span class="literal">NULL</span>);</div><div class="line">    populateCommandTable(); <span class="comment">// 初始化命令表</span></div><div class="line">  </div><div class="line">  	<span class="comment">// 初始化常用命令快捷</span></div><div class="line">    server.delCommand = lookupCommandByCString(<span class="string">"del"</span>);</div><div class="line">    server.multiCommand = lookupCommandByCString(<span class="string">"multi"</span>);</div><div class="line">    server.lpushCommand = lookupCommandByCString(<span class="string">"lpush"</span>);</div><div class="line">    server.lpopCommand = lookupCommandByCString(<span class="string">"lpop"</span>);</div><div class="line">    server.rpopCommand = lookupCommandByCString(<span class="string">"rpop"</span>);</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">populateCommandTable</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="comment">// 命令数量</span></div><div class="line">    <span class="keyword">int</span> numcommands = <span class="keyword">sizeof</span>(redisCommandTable)/<span class="keyword">sizeof</span>(struct redisCommand);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numcommands; j++) &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">c</span> = <span class="title">redisCommandTable</span>+<span class="title">j</span>;</span> <span class="comment">// 命令</span></div><div class="line">        <span class="keyword">char</span> *f = c-&gt;sflags;</div><div class="line">        <span class="keyword">int</span> retval1, retval2;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(*f != <span class="string">'\0'</span>) &#123;</div><div class="line">            <span class="keyword">switch</span>(*f) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'w'</span>: c-&gt;flags |= REDIS_CMD_WRITE; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'r'</span>: c-&gt;flags |= REDIS_CMD_READONLY; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'m'</span>: c-&gt;flags |= REDIS_CMD_DENYOOM; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'a'</span>: c-&gt;flags |= REDIS_CMD_ADMIN; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'p'</span>: c-&gt;flags |= REDIS_CMD_PUBSUB; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'s'</span>: c-&gt;flags |= REDIS_CMD_NOSCRIPT; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'R'</span>: c-&gt;flags |= REDIS_CMD_RANDOM; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'S'</span>: c-&gt;flags |= REDIS_CMD_SORT_FOR_SCRIPT; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'l'</span>: c-&gt;flags |= REDIS_CMD_LOADING; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'t'</span>: c-&gt;flags |= REDIS_CMD_STALE; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'M'</span>: c-&gt;flags |= REDIS_CMD_SKIP_MONITOR; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'k'</span>: c-&gt;flags |= REDIS_CMD_ASKING; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'F'</span>: c-&gt;flags |= REDIS_CMD_FAST; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>: redisPanic(<span class="string">"Unsupported command flag"</span>); <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            f++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 添加</span></div><div class="line">        retval1 = dictAdd(server.commands, sdsnew(c-&gt;name), c);</div><div class="line">        <span class="comment">/* Populate an additional dictionary that will be unaffected</span></div><div class="line"><span class="comment">         * by rename-command statements in redis.conf. */</span></div><div class="line">        retval2 = dictAdd(server.orig_commands, sdsnew(c-&gt;name), c);</div><div class="line">        redisAssert(retval1 == DICT_OK &amp;&amp; retval2 == DICT_OK);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>redisCommandTable定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Redis 命令</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></div><div class="line">    <span class="keyword">char</span> *name; <span class="comment">// 命令名</span></div><div class="line">    redisCommandProc *proc; <span class="comment">// 实现函数</span></div><div class="line">    <span class="keyword">int</span> arity; <span class="comment">// 参数个数</span></div><div class="line">    <span class="keyword">char</span> *sflags; <span class="comment">// 字符串表示FLAG</span></div><div class="line">    <span class="keyword">int</span> flags;   <span class="comment">// 实际FLAG</span></div><div class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></div><div class="line"><span class="comment">     * Used for Redis Cluster redirect. */</span></div><div class="line">    redisGetKeysProc *getkeys_proc;</div><div class="line">    <span class="comment">// 指定哪个参数为key</span></div><div class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></div><div class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></div><div class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls; <span class="comment">// 统计信息</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] = &#123;</span></div><div class="line">    &#123;<span class="string">"get"</span>,getCommand,<span class="number">2</span>,<span class="string">"r"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</div><div class="line">    &#123;<span class="string">"set"</span>,setCommand,<span class="number">-3</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样通过一个命令表，能够快捷的找到命令实现及相关参数。</p>
<h3 id="命令的执行-1"><a href="#命令的执行-1" class="headerlink" title="命令的执行"></a>命令的执行</h3><p>找到命令之后即可执行命令。继续看processCommand()函数。在经过一系列特殊情况处理之后，开始执行命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 命令的执行</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...查找命令</span></div><div class="line">  </div><div class="line">    <span class="comment">// 一系列特殊情况处理</span></div><div class="line"></div><div class="line">    <span class="comment">/* Exec the command */</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 事务状态下的特殊处理</span></div><div class="line">        queueMultiCommand(c);</div><div class="line">        addReply(c,shared.queued);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 执行命令</span></div><div class="line">        call(c,REDIS_CALL_FULL);</div><div class="line">        c-&gt;woff = server.master_repl_offset;</div><div class="line"></div><div class="line">        <span class="comment">// 处理那些解除阻塞的键</span></div><div class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</div><div class="line">            handleClientsBlockedOnLists();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 执行命令</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(redisClient *c, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty, start, duration;</div><div class="line">    <span class="keyword">int</span> client_old_flags = c-&gt;flags;</div><div class="line"></div><div class="line">    <span class="comment">// 命令发送倒MONITOR</span></div><div class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp;</div><div class="line">        !server.loading &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;flags &amp; (REDIS_CMD_SKIP_MONITOR|REDIS_CMD_ADMIN)))</div><div class="line">    &#123;</div><div class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 执行命令</span></div><div class="line">    c-&gt;flags &amp;= ~(REDIS_FORCE_AOF|REDIS_FORCE_REPL);</div><div class="line">    redisOpArrayInit(&amp;server.also_propagate);</div><div class="line">    dirty = server.dirty;</div><div class="line">    start = ustime();</div><div class="line">    c-&gt;cmd-&gt;proc(c); <span class="comment">// 命令实现函数</span></div><div class="line">    duration = ustime()-start; <span class="comment">// 执行时间</span></div><div class="line">    dirty = server.dirty-dirty; <span class="comment">// 命令执行dirty的数量</span></div><div class="line">    <span class="keyword">if</span> (dirty &lt; <span class="number">0</span>) dirty = <span class="number">0</span>;</div><div class="line">	<span class="comment">// ... 一系列附加操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用到setCommand(redisClient *c)函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* SET key value [NX] [XX] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;] */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    robj *expire = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</div><div class="line">    <span class="keyword">int</span> flags = REDIS_SET_NO_FLAGS;</div><div class="line"></div><div class="line">    <span class="comment">// 设置选项参数</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; c-&gt;argc; j++) &#123;</div><div class="line">        <span class="keyword">char</span> *a = c-&gt;argv[j]-&gt;ptr;</div><div class="line">        robj *next = (j == c-&gt;argc<span class="number">-1</span>) ? <span class="literal">NULL</span> : c-&gt;argv[j+<span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'n'</span> || a[<span class="number">0</span>] == <span class="string">'N'</span>) &amp;&amp;</div><div class="line">            (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span>) &#123;</div><div class="line">            flags |= REDIS_SET_NX;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'x'</span> || a[<span class="number">0</span>] == <span class="string">'X'</span>) &amp;&amp;</div><div class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span>) &#123;</div><div class="line">            flags |= REDIS_SET_XX;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'e'</span> || a[<span class="number">0</span>] == <span class="string">'E'</span>) &amp;&amp;</div><div class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp; next) &#123;</div><div class="line">            unit = UNIT_SECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'p'</span> || a[<span class="number">0</span>] == <span class="string">'P'</span>) &amp;&amp;</div><div class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp; next) &#123;</div><div class="line">            unit = UNIT_MILLISECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            addReply(c,shared.syntaxerr);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 尝试编码转换</span></div><div class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">    <span class="comment">// set命令通用的实现</span></div><div class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> flags, robj *key, robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply, robj *abort_reply)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> milliseconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></div><div class="line"></div><div class="line">    <span class="comment">// 取出过期时间 expire为过期时间参数</span></div><div class="line">    <span class="keyword">if</span> (expire) &#123;</div><div class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != REDIS_OK)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</div><div class="line">            addReplyErrorFormat(c,<span class="string">"invalid expire time in %s"</span>,c-&gt;cmd-&gt;name);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果REDIS_SET_NX REDIS_SET_XX 判断是否符合规范</span></div><div class="line">    <span class="keyword">if</span> ((flags &amp; REDIS_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>) ||</div><div class="line">        (flags &amp; REDIS_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>))</div><div class="line">    &#123;</div><div class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置键</span></div><div class="line">    setKey(c-&gt;db,key,val);</div><div class="line">    server.dirty++; <span class="comment">// 脏计数增加</span></div><div class="line">    <span class="keyword">if</span> (expire) setExpire(c-&gt;db,key,mstime()+milliseconds); <span class="comment">// 设置过期时间</span></div><div class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,<span class="string">"set"</span>,key,c-&gt;db-&gt;id); <span class="comment">// 发送事件通知</span></div><div class="line">    <span class="keyword">if</span> (expire) notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,</div><div class="line">        <span class="string">"expire"</span>,key,c-&gt;db-&gt;id);<span class="comment">// 发送事件通知</span></div><div class="line">    addReply(c, ok_reply ? ok_reply : shared.ok); <span class="comment">// 回复</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="回复客户端"><a href="#回复客户端" class="headerlink" title="回复客户端"></a>回复客户端</h2><p>在执行命令出错或者成功后使用addReply()生成回复信息，该函数将通过prepareClientToWrite()产生回复客户端的文件事件，同时将回复内容复制到回复缓存区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReply</span><span class="params">(redisClient *c, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != REDIS_OK) <span class="keyword">return</span>; <span class="comment">// 生成回复客户端的文件事件</span></div><div class="line"></div><div class="line">    <span class="comment">// 根据不同情况，生成回复内容,写入不同的缓冲区</span></div><div class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</div><div class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != REDIS_OK)</div><div class="line">            _addReplyObjectToList(c,obj);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == REDIS_ENCODING_INT) &#123;</div><div class="line">        <span class="comment">/* Optimization: if there is room in the static buffer for 32 bytes</span></div><div class="line"><span class="comment">         * (more than the max chars a 64 bit integer can take as string) we</span></div><div class="line"><span class="comment">         * avoid decoding the object and go for the lower level approach. */</span></div><div class="line">        <span class="keyword">if</span> (listLength(c-&gt;reply) == <span class="number">0</span> &amp;&amp; (<span class="keyword">sizeof</span>(c-&gt;buf) - c-&gt;bufpos) &gt;= <span class="number">32</span>) &#123;</div><div class="line">            <span class="keyword">char</span> buf[<span class="number">32</span>];</div><div class="line">            <span class="keyword">int</span> len;</div><div class="line"></div><div class="line">            len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="keyword">long</span>)obj-&gt;ptr);</div><div class="line">            <span class="keyword">if</span> (_addReplyToBuffer(c,buf,len) == REDIS_OK)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="comment">/* else... continue with the normal code path, but should never</span></div><div class="line"><span class="comment">             * happen actually since we verified there is room. */</span></div><div class="line">        &#125;</div><div class="line">        obj = getDecodedObject(obj);</div><div class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != REDIS_OK)</div><div class="line">            _addReplyObjectToList(c,obj);</div><div class="line">        decrRefCount(obj);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        redisPanic(<span class="string">"Wrong obj-&gt;encoding in addReply()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="comment">// lua 脚本伪客户端</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_LUA_CLIENT) <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">    <span class="comment">// 客户端为REDIS_MASTER REDIS_MASTER_FORCE_REPLY</span></div><div class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; REDIS_MASTER_FORCE_REPLY)) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;fd &lt;= <span class="number">0</span>) <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Fake client for AOF loading. */</span></div><div class="line"></div><div class="line">    <span class="comment">// 一般的客户端生成写事件</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(c-&gt;reply) == <span class="number">0</span> &amp;&amp;</div><div class="line">        (c-&gt;replstate == REDIS_REPL_NONE ||</div><div class="line">         (c-&gt;replstate == REDIS_REPL_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)))</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* Try to install the write handler. */</span></div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE,</div><div class="line">                sendReplyToClient, c) == AE_ERR)</div><div class="line">        &#123;</div><div class="line">            freeClientAsync(c);</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Authorize the caller to queue in the output buffer of this client. */</span></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终文件事件调用sendReplyToClient()回复客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendReplyToClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    redisClient *c = privdata;</div><div class="line">    <span class="keyword">int</span> nwritten = <span class="number">0</span>, totwritten = <span class="number">0</span>, objlen;</div><div class="line">    <span class="keyword">size_t</span> objmem;</div><div class="line">    robj *o;</div><div class="line">    REDIS_NOTUSED(el);</div><div class="line">    REDIS_NOTUSED(mask);</div><div class="line"></div><div class="line">    <span class="comment">// 从缓存区获取数据，写入，直到写完</span></div><div class="line">    <span class="keyword">while</span>(c-&gt;bufpos &gt; <span class="number">0</span> || listLength(c-&gt;reply)) &#123;</div><div class="line">        <span class="keyword">if</span> (c-&gt;bufpos &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 先写入回复缓冲区数据</span></div><div class="line">            nwritten = write(fd,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);</div><div class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 出错跳出</span></div><div class="line"></div><div class="line">            <span class="comment">// 成功计数</span></div><div class="line">            c-&gt;sentlen += nwritten;</div><div class="line">            totwritten += nwritten;</div><div class="line"></div><div class="line">            <span class="comment">// 如果内容写完则清空两个计数器</span></div><div class="line">            <span class="keyword">if</span> (c-&gt;sentlen == c-&gt;bufpos) &#123;</div><div class="line">                c-&gt;bufpos = <span class="number">0</span>;</div><div class="line">                c-&gt;sentlen = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 回复缓冲区为空的话，在回复链表查找</span></div><div class="line">            o = listNodeValue(listFirst(c-&gt;reply));</div><div class="line">            objlen = sdslen(o-&gt;ptr);</div><div class="line">            objmem = getStringObjectSdsUsedMemory(o);</div><div class="line"></div><div class="line">            <span class="comment">// 跳过空对象</span></div><div class="line">            <span class="keyword">if</span> (objlen == <span class="number">0</span>) &#123;</div><div class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</div><div class="line">                c-&gt;reply_bytes -= objmem;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 写入</span></div><div class="line">            nwritten = write(fd, ((<span class="keyword">char</span>*)o-&gt;ptr)+c-&gt;sentlen,objlen-c-&gt;sentlen);</div><div class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 出错跳出</span></div><div class="line"></div><div class="line">            <span class="comment">// 计数</span></div><div class="line">            c-&gt;sentlen += nwritten;</div><div class="line">            totwritten += nwritten;</div><div class="line"></div><div class="line">            <span class="comment">// 如果汉冲去内容写入完毕，删除已经写入的节点</span></div><div class="line">            <span class="keyword">if</span> (c-&gt;sentlen == objlen) &#123;</div><div class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</div><div class="line">                c-&gt;sentlen = <span class="number">0</span>;</div><div class="line">                c-&gt;reply_bytes -= objmem;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 写入量超过限制 在最大内存没设或者最大内存没使用完的情况下跳出</span></div><div class="line">        server.stat_net_output_bytes += totwritten;</div><div class="line">        <span class="keyword">if</span> (totwritten &gt; REDIS_MAX_WRITE_PER_EVENT &amp;&amp;</div><div class="line">            (server.maxmemory == <span class="number">0</span> ||</div><div class="line">             zmalloc_used_memory() &lt; server.maxmemory)) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 写入出错</span></div><div class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</div><div class="line">            nwritten = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            redisLog(REDIS_VERBOSE,</div><div class="line">                <span class="string">"Error writing to client: %s"</span>, strerror(errno));</div><div class="line">            freeClient(c);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (totwritten &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/* For clients representing masters we don't count sending data</span></div><div class="line"><span class="comment">         * as an interaction, since we always send REPLCONF ACK commands</span></div><div class="line"><span class="comment">         * that take some time to just fill the socket output buffer.</span></div><div class="line"><span class="comment">         * We just rely on data / pings received for timeout detection. */</span></div><div class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_MASTER)) c-&gt;lastinteraction = server.unixtime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(c-&gt;reply) == <span class="number">0</span>) &#123;</div><div class="line">        c-&gt;sentlen = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 写完了删除write handler</span></div><div class="line">        aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</div><div class="line"></div><div class="line">        <span class="comment">// 必要的话关闭客户端</span></div><div class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_CLOSE_AFTER_REPLY) freeClient(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>至此一个命令的旅程就结束了。</p>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-事件]]></title>
      <url>/2017/07/16/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="redis源码阅读-事件"><a href="#redis源码阅读-事件" class="headerlink" title="redis源码阅读-事件"></a>redis源码阅读-事件</h1><p>redis服务器是一个事件驱动程序。当触发一个事件时,redis会创建一个事件,放入到待处理的队列，依次进行处理。</p>
<p>redis事件分为文件时间和时间事件。</p>
<p>文件事件：文件事件是对套接字操作的抽象，当服务器与客户端进行通讯，会产生出各种文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通讯操作。</p>
<p>时间事件：redis一些操作是需要定时进行执行的，而时间事件就是对这类操作的抽象。</p>
<h2 id="事件的实现"><a href="#事件的实现" class="headerlink" title="事件的实现"></a>事件的实现</h2><p>以下是事件结构体定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* File event structure */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> mask; <span class="comment">// one of AE_(READABLE|WRITABLE) 类型</span></div><div class="line">    aeFileProc *rfileProc; <span class="comment">// 读事件处理器</span></div><div class="line">    aeFileProc *wfileProc; <span class="comment">// 写事件处理器</span></div><div class="line">    <span class="keyword">void</span> *clientData; <span class="comment">// 多路复用库的私有数据</span></div><div class="line">&#125; aeFileEvent;</div><div class="line"></div><div class="line"><span class="comment">/* Time event structure */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;  <span class="comment">// 唯一标志</span></div><div class="line">    <span class="keyword">long</span> when_sec; <span class="comment">// 事件到达事件s</span></div><div class="line">    <span class="keyword">long</span> when_ms;  <span class="comment">// 事件到达事件ms</span></div><div class="line">    aeTimeProc *timeProc; <span class="comment">// 事件处理函数</span></div><div class="line">    aeEventFinalizerProc *finalizerProc; <span class="comment">// 事件释放函数</span></div><div class="line">    <span class="keyword">void</span> *clientData; <span class="comment">// 多路复用库的私有数据</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span> <span class="comment">//　指向下一个时间事件结构，形成链表</span></div><div class="line">&#125; aeTimeEvent;</div><div class="line"></div><div class="line"><span class="comment">/* A fired event */</span></div><div class="line"><span class="comment">// 触发的事件结构体</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFiredEvent</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> fd; <span class="comment">// 文件事件描述符</span></div><div class="line">    <span class="keyword">int</span> mask;　<span class="comment">// one of AE_(READABLE|WRITABLE) 类型</span></div><div class="line">&#125; aeFiredEvent;</div><div class="line"></div><div class="line"><span class="comment">// 事件循环结构体</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">// 当前注册的最大描述符</span></div><div class="line">    <span class="keyword">int</span> setsize; <span class="comment">// 需要监听的描述符个数</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId; <span class="comment">// 下一个时间事件ID</span></div><div class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">// 上一次时间循环时间</span></div><div class="line">    aeFileEvent *events; <span class="comment">// 注册要使用的文件时间</span></div><div class="line">    aeFiredEvent *fired; <span class="comment">// 已准备好，待处理事件</span></div><div class="line">    aeTimeEvent *timeEventHead; <span class="comment">// 时间事件</span></div><div class="line">    <span class="keyword">int</span> stop; <span class="comment">// 事件处理器开关</span></div><div class="line">    <span class="keyword">void</span> *apidata; <span class="comment">// 处理多路服用库的私有数据</span></div><div class="line">    aeBeforeSleepProc *beforesleep; <span class="comment">// 处理事件前要执行的函数</span></div><div class="line">&#125; aeEventLoop;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="事件处理流程"><a href="#事件处理流程" class="headerlink" title="事件处理流程"></a>事件处理流程</h2><p>redis使用i/o多路复用程序同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。文件处理流程如图。时间事件则定时执行。</p>
<p><img src="/img/20170716.jpg" alt=""><br>图片(来自《Redis设计与实现》</p>
<h2 id="事件的API"><a href="#事件的API" class="headerlink" title="事件的API"></a>事件的API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Prototypes */</span></div><div class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span></span>; <span class="comment">// 初始化时间处理器状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteEventLoop</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 删除事件处理器</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeStop</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 停止事件处理器</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></div><div class="line"><span class="function"><span class="params">        aeFileProc *proc, <span class="keyword">void</span> *clientData)</span></span>; <span class="comment">// 根据mask参数，监听fd文件的状态，fd可用，执行proc函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>;<span class="comment">// 将fd从mask指定的监听队列中删除</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetFileEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 获取给定fd正在监听的事件类型</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aeCreateTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds,</span></span></div><div class="line"><span class="function"><span class="params">        aeTimeProc *proc, <span class="keyword">void</span> *clientData,</span></span></div><div class="line"><span class="function"><span class="params">        aeEventFinalizerProc *finalizerProc)</span></span>; <span class="comment">// 创建时间事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeDeleteTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id)</span></span>; <span class="comment">// 删除给定ID的时间事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 处理所有已经到达时间的事件，以及所有就绪的文件事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeWait</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> mask, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds)</span></span>; <span class="comment">// 指定时间等待fd变为可读、可写</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span></span>;<span class="comment">// 事件处理主循环</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">aeGetApiName</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 返回所使用的多路服用库的名字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeSetBeforeSleepProc</span><span class="params">(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)</span></span>; <span class="comment">// 设置事件前所需要执行的函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetSetSize</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 返回当前事件槽大小</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeResizeSetSize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span></span>; <span class="comment">// 调整事件槽大小</span></div></pre></td></tr></table></figure>
<h2 id="文件事件的创建"><a href="#文件事件的创建" class="headerlink" title="文件事件的创建"></a>文件事件的创建</h2><p>文件事件有三个方面需要创建：</p>
<ul>
<li>连接应答处理器，用来处理对连接服务器监听套接字的客户端进行应答。</li>
<li>命令请求处理器，用来处理从套接字读取客户端发送的命令请求内容。</li>
<li>命令回复处理器，用来处理执行命令后得到的命令回复通过套接字返回给客户端。</li>
</ul>
<h3 id="连接应答处理器"><a href="#连接应答处理器" class="headerlink" title="连接应答处理器"></a>连接应答处理器</h3><p>acceptTcpHandler是连接应答处理器，当监听套接字产生AE_READABLE事件时，就会引发连接应答处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	<span class="comment">// 为 TCP 连接关联连接应答（accept）处理器</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</div><div class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</div><div class="line">            &#123;</div><div class="line">                redisPanic(</div><div class="line">                    <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 为本地套接字关联应答处理器</span></div><div class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</div><div class="line">        acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) redisPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命令请求处理器"><a href="#命令请求处理器" class="headerlink" title="命令请求处理器"></a>命令请求处理器</h3><p>在连接应答处理器调用的函数acceptTcpHandler中，会在连接成功之后，创建命令请求处理器readQueryFromClient()，在客户端发送的命令请求时，调用命令请求处理器进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个 TCP 连接处理器</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</div><div class="line">    <span class="keyword">char</span> cip[REDIS_IP_STR_LEN];</div><div class="line">    REDIS_NOTUSED(el);</div><div class="line">    REDIS_NOTUSED(mask);</div><div class="line">    REDIS_NOTUSED(privdata);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(max--) &#123;</div><div class="line">        <span class="comment">// accept 客户端连接</span></div><div class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</div><div class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</div><div class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    <span class="string">"Accepting client connection: %s"</span>, server.neterr);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        redisLog(REDIS_VERBOSE,<span class="string">"Accepted %s:%d"</span>, cip, cport);</div><div class="line"></div><div class="line">      	<span class="comment">// 连接完成，创建一个客户端状态</span></div><div class="line">        acceptCommonHandler(cfd,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ACCEPTS_PER_CALL 1000</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 创建客户端</span></div><div class="line">    redisClient *c;</div><div class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,</div><div class="line">            <span class="string">"Error registering fd event for the new client: %s (fd=%d)"</span>,</div><div class="line">            strerror(errno),fd);</div><div class="line">        close(fd); <span class="comment">/* May be already closed, just ignore errors */</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 达到上限</span></div><div class="line">    <span class="keyword">if</span> (listLength(server.clients) &gt; server.maxclients) &#123;</div><div class="line">        <span class="keyword">char</span> *err = <span class="string">"-ERR max number of clients reached\r\n"</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (write(c-&gt;fd,err,<span class="built_in">strlen</span>(err)) == <span class="number">-1</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 更新拒绝连接数</span></div><div class="line">        server.stat_rejected_conn++;</div><div class="line">        freeClient(c);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    server.stat_numconnections++;</div><div class="line">    c-&gt;flags |= flags;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">redisClient *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">    redisClient *c = zmalloc(<span class="keyword">sizeof</span>(redisClient));</div><div class="line"></div><div class="line">    <span class="comment">// -1时使用的是无网络连接的伪客户端</span></div><div class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</div><div class="line">        anetNonBlock(<span class="literal">NULL</span>,fd); <span class="comment">// 非阻塞</span></div><div class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd); <span class="comment">// 关闭nagle算法，那个合并小报文的算法</span></div><div class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</div><div class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</div><div class="line"></div><div class="line">        <span class="comment">// 创建命令请求处理器</span></div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</div><div class="line">            readQueryFromClient, c) == AE_ERR)</div><div class="line">        &#123;</div><div class="line">            close(fd);</div><div class="line">            zfree(c);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 客户端的初始化</span></div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命令回复处理器"><a href="#命令回复处理器" class="headerlink" title="命令回复处理器"></a>命令回复处理器</h3><p>当服务器有命令回复需要传送给客户端时，服务器将客户端套接字的AE_WRITABLE事件与命令回复处理器关联，当客户端准备好接收时，就会执行AE_WRITABLE事件，触发命令回复处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_LUA_CLIENT) <span class="keyword">return</span> REDIS_OK;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; REDIS_MASTER_FORCE_REPLY)) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;fd &lt;= <span class="number">0</span>) <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Fake client */</span></div><div class="line"></div><div class="line">    <span class="comment">// 为客户端套接字安装写处理器到事件循环</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(c-&gt;reply) == <span class="number">0</span> &amp;&amp;</div><div class="line">        (c-&gt;replstate == REDIS_REPL_NONE ||</div><div class="line">         c-&gt;replstate == REDIS_REPL_ONLINE) &amp;&amp;</div><div class="line">        aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE,</div><div class="line">        sendReplyToClient, c) == AE_ERR) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间事件的创建"><a href="#时间事件的创建" class="headerlink" title="时间事件的创建"></a>时间事件的创建</h2><p>redis在初始化时创建时间时间，用来周期执行serverCron()。</p>
<p>serverCron()主要功能：</p>
<ul>
<li>更新服务器的各类统计信息</li>
<li>清理过期的键值对</li>
<li>关闭和清理连接失效的客户端</li>
<li>尝试AOF\RDB持久化</li>
<li>主服务器则定期同步</li>
<li>集群模式，对集群定期同步和连接测试</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 为 serverCron() 创建时间事件</span></div><div class="line">    <span class="keyword">if</span>(aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</div><div class="line">        redisPanic(<span class="string">"Can't create the serverCron time event."</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环主函数为aeMain()，该函数在redis的main()函数中被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 运行事件处理器，一直到服务器关闭为止</span></div><div class="line">    aeSetBeforeSleepProc(server.el,beforeSleep); <span class="comment">// 设置事件前调用函数</span></div><div class="line">    aeMain(server.el);</div><div class="line">  </div><div class="line">    <span class="comment">// 服务器关闭，停止事件循环</span></div><div class="line">    aeDeleteEventLoop(server.el);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">｝</div></pre></td></tr></table></figure>
<p>事件循环的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 事件处理器的主循环</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line"></div><div class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</div><div class="line">        <span class="comment">// 如果有需要在事件处理前执行的函数，那么运行它</span></div><div class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line"></div><div class="line">        <span class="comment">// 开始处理事件</span></div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 事件处理函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</div><div class="line"></div><div class="line">    <span class="comment">// 没有需要处理的事件则返回</span></div><div class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</div><div class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></div><div class="line"></div><div class="line">        <span class="comment">// 获取最近的时间事件</span></div><div class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</div><div class="line">            shortest = aeSearchNearestTimer(eventLoop);</div><div class="line">        <span class="keyword">if</span> (shortest) &#123;</div><div class="line">            <span class="keyword">long</span> now_sec, now_ms;</div><div class="line"></div><div class="line">            <span class="comment">/* Calculate the time missing for the nearest</span></div><div class="line"><span class="comment">             * timer to fire. */</span></div><div class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">            tvp = &amp;tv;</div><div class="line">            tvp-&gt;tv_sec = shortest-&gt;when_sec - now_sec;</div><div class="line">            <span class="keyword">if</span> (shortest-&gt;when_ms &lt; now_ms) &#123;</div><div class="line">                tvp-&gt;tv_usec = ((shortest-&gt;when_ms+<span class="number">1000</span>) - now_ms)*<span class="number">1000</span>;</div><div class="line">                tvp-&gt;tv_sec --;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tvp-&gt;tv_usec = (shortest-&gt;when_ms - now_ms)*<span class="number">1000</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 获取要执行事件事件，要等待的时间</span></div><div class="line">            <span class="keyword">if</span> (tvp-&gt;tv_sec &lt; <span class="number">0</span>) tvp-&gt;tv_sec = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (tvp-&gt;tv_usec &lt; <span class="number">0</span>) tvp-&gt;tv_usec = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 没有时间事件</span></div><div class="line">            <span class="comment">// 根据AE_DONT_WAIT参数来设置文件事件的阻塞、阻塞时间</span></div><div class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</div><div class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</div><div class="line">                tvp = &amp;tv;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* Otherwise we can block */</span></div><div class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 调用io复用函数获取准备好的事件，底层使用select或epoll或其他实现</span></div><div class="line">      	<span class="comment">// tvp阻塞时间</span></div><div class="line">        numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 获取所有能够执行的文件事件，并执行</span></div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</div><div class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</div><div class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</div><div class="line">            <span class="keyword">int</span> rfired = <span class="number">0</span>;</div><div class="line"></div><div class="line">	        <span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></div><div class="line"><span class="comment">             * event removed an element that fired and we still didn't</span></div><div class="line"><span class="comment">             * processed, so we check if the event is still valid. */</span></div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                <span class="comment">// 读事件</span></div><div class="line">                rfired = <span class="number">1</span>;</div><div class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 写事件</span></div><div class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</div><div class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            processed++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Check time events */</span></div><div class="line">    <span class="comment">// 执行时间事件，在阻塞等待一段时间之后，时间事件已经能够执行</span></div><div class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</div><div class="line">        processed += processTimeEvents(eventLoop);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>事件其实不算复杂，整个redis没有太多的事件。但是要理解IO多路服用和redis事件的调用逻辑。理清楚之后就比较好办了。</p>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-事务]]></title>
      <url>/2017/07/16/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>redis的事务提供了一种将单个命令请求打包，然后一次性、按照顺序执行多个命令的机制，这种方式服务器会一次性把命令执行完，中间不会执行其他客户端的命令。不过redis的命令不支持错误命令执行后的回滚机制，也就是命令设计者要对命令的正确性负责，即使多个命令中存在部分错误的命令，剩余命令也会继续执行下去。</p>
<h2 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h2><table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MULTI</td>
<td style="text-align:center">开始一个新的事务</td>
</tr>
<tr>
<td style="text-align:center">DISCARD</td>
<td style="text-align:center">放弃执行事务</td>
</tr>
<tr>
<td style="text-align:center">EXEC</td>
<td style="text-align:center">执行事务中的所有命令</td>
</tr>
<tr>
<td style="text-align:center">WATCH</td>
<td style="text-align:center">监视key，如果在exec之前被修改，则不执行事务</td>
</tr>
<tr>
<td style="text-align:center">UNWATCH</td>
<td style="text-align:center">取消对所有键的监视</td>
</tr>
</tbody>
</table>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>一个事务分为三个阶段：</p>
<ul>
<li>事务开始</li>
<li>命令入队</li>
<li>事务执行</li>
</ul>
<h3 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h3><p>使用multi开启事务，redis主要使用redisClient中flag成员记录状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 已经开启事务</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</div><div class="line">        addReplyError(c,<span class="string">"MULTI calls can not be nested"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 标记事务开启</span></div><div class="line">    c-&gt;flags |= REDIS_MULTI;</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="事务入队"><a href="#事务入队" class="headerlink" title="事务入队"></a>事务入队</h3><p>当客户端进入事务状态时，客户端不会立即执行命令EXEC、DISCARD、WATCH、MULTI之外的命令，这些命令先进入事务队列，在之后事务执行时候执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端结构体</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></div><div class="line">  	<span class="comment">// ....</span></div><div class="line">  	multiState mstate; <span class="comment">// 事务状态</span></div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 事务状态</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></div><div class="line">    multiCmd *commands; <span class="comment">// 事务队列</span></div><div class="line">    <span class="keyword">int</span> count; <span class="comment">// 命令计数</span></div><div class="line">    <span class="keyword">int</span> minreplicas; <span class="comment">// 用于同步复制</span></div><div class="line">    <span class="keyword">time_t</span> minreplicas_timeout; <span class="comment">// 超时时间</span></div><div class="line">&#125; multiState;</div><div class="line"></div><div class="line"><span class="comment">// 事务命令</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></div><div class="line">    robj **argv; <span class="comment">// 参数</span></div><div class="line">    <span class="keyword">int</span> argc; <span class="comment">// 参数数量 </span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span> <span class="comment">// 命令指针</span></div><div class="line">&#125; multiCmd;</div></pre></td></tr></table></figure>
<p>redis在执行客户端命令时，会判断事务是否开启，如果开启且不是上面提到的几个命令，那么就会将命令压入队列,在redis的命令处理函数processCommand()中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">    <span class="comment">/* Exec the command */</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 处在事务状态</span></div><div class="line">        <span class="comment">// 不是execCommand、discardCommand、multiCommand、watchCommand</span></div><div class="line">        <span class="comment">// 执行入队操作</span></div><div class="line">        queueMultiCommand(c);</div><div class="line">        addReply(c,shared.queued);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 命令直接执行</span></div><div class="line">        call(c,REDIS_CALL_FULL);</div><div class="line">        c-&gt;woff = server.master_repl_offset;</div><div class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</div><div class="line">            handleClientsBlockedOnLists();</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入队的实现:入队功能依靠queueMultiCommand()实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    multiCmd *mc;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="comment">// 重新分配足够的空间</span></div><div class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</div><div class="line">            <span class="keyword">sizeof</span>(multiCmd)*(c-&gt;mstate.count+<span class="number">1</span>));</div><div class="line">    mc = c-&gt;mstate.commands+c-&gt;mstate.count; <span class="comment">// 压入点</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化事务结构体</span></div><div class="line">    mc-&gt;cmd = c-&gt;cmd; </div><div class="line">    mc-&gt;argc = c-&gt;argc;</div><div class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</div><div class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv,c-&gt;argv,<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</div><div class="line">        incrRefCount(mc-&gt;argv[j]);</div><div class="line">    c-&gt;mstate.count++; <span class="comment">// 计数+1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="事务的执行"><a href="#事务的执行" class="headerlink" title="事务的执行"></a>事务的执行</h3><p>当处于事务状态的客户端向服务器发送EXEC命令时，这个命令被立即执行，具体见processCommand()函数。</p>
<p>最终命令调用execCommand()执行exec命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    robj **orig_argv;</div><div class="line">    <span class="keyword">int</span> orig_argc;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></div><div class="line">    <span class="keyword">int</span> must_propagate = <span class="number">0</span>; <span class="comment">/* Need to propagate MULTI/EXEC to AOF / slaves? */</span></div><div class="line"></div><div class="line">    <span class="comment">// 判断是否执行事务中</span></div><div class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_MULTI)) &#123;</div><div class="line">        addReplyError(c,<span class="string">"EXEC without MULTI"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断监视键是否被修改</span></div><div class="line">    <span class="comment">// 命令在入队时发送错误</span></div><div class="line">    <span class="comment">// 均不执行命令</span></div><div class="line">    <span class="comment">// 取消事务</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC)) &#123;</div><div class="line">        addReply(c, c-&gt;flags &amp; REDIS_DIRTY_EXEC ? shared.execaborterr :</div><div class="line">                                                  shared.nullmultibulk);</div><div class="line">        discardTransaction(c); <span class="comment">// 取消事务</span></div><div class="line">        <span class="keyword">goto</span> handle_monitor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 取消对键的监视</span></div><div class="line">    unwatchAllKeys(c); <span class="comment">/* Unwatch ASAP otherwise we'll waste CPU cycles */</span></div><div class="line"></div><div class="line">    <span class="comment">// 备份</span></div><div class="line">    orig_argv = c-&gt;argv;</div><div class="line">    orig_argc = c-&gt;argc;</div><div class="line">    orig_cmd = c-&gt;cmd;</div><div class="line">    addReplyMultiBulkLen(c,c-&gt;mstate.count);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历事务中的命令，执行</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 备份</span></div><div class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</div><div class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</div><div class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</div><div class="line"></div><div class="line">        <span class="comment">// 在事务中，发现了写命令，传播multi</span></div><div class="line">        <span class="keyword">if</span> (!must_propagate &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; REDIS_CMD_READONLY)) &#123;</div><div class="line">            execCommandPropagateMulti(c);</div><div class="line">            must_propagate = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 执行命令</span></div><div class="line">        call(c,REDIS_CALL_FULL);</div><div class="line"></div><div class="line">        <span class="comment">// 恢复</span></div><div class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</div><div class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</div><div class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 恢复</span></div><div class="line">    c-&gt;argv = orig_argv;</div><div class="line">    c-&gt;argc = orig_argc;</div><div class="line">    c-&gt;cmd = orig_cmd;</div><div class="line">    discardTransaction(c); <span class="comment">// 关闭事务状态</span></div><div class="line">    <span class="comment">/* Make sure the EXEC command will be propagated as well if MULTI</span></div><div class="line"><span class="comment">     * was already propagated. */</span></div><div class="line">    <span class="keyword">if</span> (must_propagate) server.dirty++;</div><div class="line"></div><div class="line">handle_monitor:</div><div class="line">    <span class="comment">/* Send EXEC to clients waiting data from MONITOR. We do it here</span></div><div class="line"><span class="comment">     * since the natural order of commands execution is actually:</span></div><div class="line"><span class="comment">     * MUTLI, EXEC, ... commands inside transaction ...</span></div><div class="line"><span class="comment">     * Instead EXEC is flagged as REDIS_CMD_SKIP_MONITOR in the command</span></div><div class="line"><span class="comment">     * table, and we do it here with correct ordering. */</span></div><div class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp; !server.loading)</div><div class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="事务取消"><a href="#事务取消" class="headerlink" title="事务取消"></a>事务取消</h3><p>DISCARD函数取消客户端的事务状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// discardCommand命令处理函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 没有在事务状态</span></div><div class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_MULTI)) &#123;</div><div class="line">        addReplyError(c,<span class="string">"DISCARD without MULTI"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 取消事务状态</span></div><div class="line">    discardTransaction(c);</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 取消事务状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    freeClientMultiState(c); <span class="comment">// 释放事务</span></div><div class="line">    initClientMultiState(c); <span class="comment">// 初始化事务</span></div><div class="line"></div><div class="line">    <span class="comment">// 取消事务状态</span></div><div class="line">    c-&gt;flags &amp;= ~(REDIS_MULTI|REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC);</div><div class="line">    unwatchAllKeys(c); <span class="comment">// 取消键的监视</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeClientMultiState</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        multiCmd *mc = c-&gt;mstate.commands+j;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mc-&gt;argc; i++)</div><div class="line">            decrRefCount(mc-&gt;argv[i]);</div><div class="line">        zfree(mc-&gt;argv);</div><div class="line">    &#125;</div><div class="line">    zfree(c-&gt;mstate.commands);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initClientMultiState</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    c-&gt;mstate.commands = <span class="literal">NULL</span>;</div><div class="line">    c-&gt;mstate.count = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h3><p>WATCH命令用来监视键是否被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line">    dict *watched_keys; <span class="comment">// 监视键的字典，字典的键为数据库的键，值为链表，保存所有监视的客户端</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125; redisDb;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="built_in">list</span> *watched_keys;  <span class="comment">// 保存该客户端所有被监视的键,保存watchedKey结构</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchedKey</span> &#123;</span></div><div class="line">    robj *key;  <span class="comment">// 保存键</span></div><div class="line">    redisDb *db;  <span class="comment">// 保存键所在的数据库</span></div><div class="line">&#125; watchedKey;</div></pre></td></tr></table></figure>
<h4 id="WATCH的触发"><a href="#WATCH的触发" class="headerlink" title="WATCH的触发"></a>WATCH的触发</h4><p>所有的对数据库进行修改的命令，比如set、del等，在执行之后都会调用signalModifiedKey(redisDb <em>db, robj </em>key)，而该函数调用touchWatchedKey(redisDb <em>db, robj </em>key)。touchWatchedKey(redisDb <em>db, robj </em>key)查找监视字典，对被修改的键进行标记。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    touchWatchedKey(db,key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="built_in">list</span> *clients;</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line"></div><div class="line">    <span class="comment">// 字典为空</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 获取进行监视的客户端</span></div><div class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</div><div class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历所有客户端，进行标记</span></div><div class="line">    listRewind(clients,&amp;li);</div><div class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</div><div class="line">        redisClient *c = listNodeValue(ln);</div><div class="line"></div><div class="line">        c-&gt;flags |= REDIS_DIRTY_CAS;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="监视的开启"><a href="#监视的开启" class="headerlink" title="监视的开启"></a>监视的开启</h4><p>监视的开启就是在字典里添加键</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</div><div class="line">        addReplyError(c,<span class="string">"WATCH inside MULTI is not allowed"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">        watchForKey(c,c-&gt;argv[j]);</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 客户端C监视键Key</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(redisClient *c, robj *key)</span> </span>&#123;</div><div class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line">    watchedKey *wk;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否已经被监视了</span></div><div class="line">    <span class="comment">// 发现则直接返回</span></div><div class="line">    listRewind(c-&gt;watched_keys,&amp;li);</div><div class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</div><div class="line">        wk = listNodeValue(ln);</div><div class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key,wk-&gt;key))</div><div class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 检查key是否存在数据库的watched_keys字典力</span></div><div class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys,key);</div><div class="line">    <span class="keyword">if</span> (!clients) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 不存在就增加一个链表</span></div><div class="line">        clients = listCreate();</div><div class="line">        dictAdd(c-&gt;db-&gt;watched_keys,key,clients);</div><div class="line">        incrRefCount(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在链表末尾增加key</span></div><div class="line">    <span class="comment">// 前面已经保证没有被监视过，所以这里不需要再判断，直接插入到末尾</span></div><div class="line">    listAddNodeTail(clients,c);</div><div class="line">    <span class="comment">/* Add the new key to the list of keys watched by this client */</span></div><div class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</div><div class="line">    wk-&gt;key = key;</div><div class="line">    wk-&gt;db = c-&gt;db;</div><div class="line">    incrRefCount(key);</div><div class="line">    listAddNodeTail(c-&gt;watched_keys,wk);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="监视的关闭"><a href="#监视的关闭" class="headerlink" title="监视的关闭"></a>监视的关闭</h4><p>监视的关闭即将字典中键删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="comment">// 取消客户端对所有键的监视</span></div><div class="line">    unwatchAllKeys(c);</div><div class="line">    <span class="comment">// 重置状态</span></div><div class="line">    c-&gt;flags &amp;= (~REDIS_DIRTY_CAS);</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 清除所有监视</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchAllKeys</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line"></div><div class="line">    <span class="comment">// 没有键被监视，直接返回</span></div><div class="line">    <span class="keyword">if</span> (listLength(c-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历被监视的键</span></div><div class="line">    listRewind(c-&gt;watched_keys,&amp;li);</div><div class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</div><div class="line">        <span class="built_in">list</span> *clients;</div><div class="line">        watchedKey *wk;</div><div class="line"></div><div class="line">        wk = listNodeValue(ln); <span class="comment">// 键</span></div><div class="line">        clients = dictFetchValue(wk-&gt;db-&gt;watched_keys, wk-&gt;key); <span class="comment">// 数据库中查找</span></div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,clients != <span class="literal">NULL</span>);</div><div class="line">        listDelNode(clients,listSearchKey(clients,c)); <span class="comment">// 删除数据库中监视节点</span></div><div class="line">        </div><div class="line">        <span class="comment">// 如果链表为空，删除键</span></div><div class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>)</div><div class="line">            dictDelete(wk-&gt;db-&gt;watched_keys, wk-&gt;key);</div><div class="line">        </div><div class="line">        <span class="comment">// 删除客户端监视的节点key</span></div><div class="line">        listDelNode(c-&gt;watched_keys,ln);</div><div class="line">        decrRefCount(wk-&gt;key);</div><div class="line">        zfree(wk);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码阅读-AOF持久化]]></title>
      <url>/2017/07/16/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-AOF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>之前看了RDB持久化，功能是把数据库的数据全部使用一种特定格式进行存储。恢复时一个一个数据库键恢复。</p>
<p>AOF持久化与RDB持久化不同，AOF通过保存Redis服务器执行的写命令来记录数据库的状态。</p>
<h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>AOF持久化功能分为命令追加、文件写入、文件同步三个步骤。</p>
<ul>
<li>命令追加：将命令数据写入aof_buf缓冲区</li>
<li>文件写入：将aof_buff缓冲区数据写入系统IO缓冲区</li>
<li>文件同步：将系统IO缓冲区的数据同步到磁盘文件</li>
</ul>
<h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>AOF持久化打开时，服务器在执行一个写命令之后，会以协议的格式将执行的命令追加倒服务器状态aof_buf缓冲区尾部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span> </div><div class="line">  <span class="comment">// ...</span></div><div class="line">  sds aof_buf;  <span class="comment">// aof缓冲区</span></div><div class="line">  <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>命令追加的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将命令追加到AOF缓冲区中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</div><div class="line">    sds buf = sdsempty();</div><div class="line">    robj *tmpargv[<span class="number">3</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 如果没切换到正确的数据库，则追加切换数据库命令</span></div><div class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</div><div class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</div><div class="line"></div><div class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid);</div><div class="line">        buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>,</div><div class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</div><div class="line">        server.aof_selected_db = dictid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据命令类型追加命令</span></div><div class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</div><div class="line">        cmd-&gt;proc == expireatCommand) &#123;</div><div class="line">        <span class="comment">// 追加过期键命令</span></div><div class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</div><div class="line">        <span class="comment">// 追加setexCommand或者psetexCommand</span></div><div class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">"SET"</span>,<span class="number">3</span>);</div><div class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</div><div class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</div><div class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv);</div><div class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</div><div class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 追加其他一般修改数据库命令</span></div><div class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将格式化的命令字符串追加到aof_buf缓冲区中</span></div><div class="line">    <span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON)</div><div class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</div><div class="line">        <span class="comment">// 如果在执行AOF重写，那么追加的新的AOF文件中</span></div><div class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</div><div class="line"></div><div class="line">    sdsfree(buf);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 根据参数，格式化命令</span></div><div class="line"><span class="function">sds <span class="title">catAppendOnlyGenericCommand</span><span class="params">(sds dst, <span class="keyword">int</span> argc, robj **argv)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</div><div class="line">    <span class="keyword">int</span> len, j;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    buf[<span class="number">0</span>] = <span class="string">'*'</span>;</div><div class="line">    len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,argc);</div><div class="line">    buf[len++] = <span class="string">'\r'</span>;</div><div class="line">    buf[len++] = <span class="string">'\n'</span>;</div><div class="line">    dst = sdscatlen(dst,buf,len);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历每一个参数，支架到AOF缓冲区中</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</div><div class="line">        o = getDecodedObject(argv[j]);</div><div class="line">        buf[<span class="number">0</span>] = <span class="string">'$'</span>;</div><div class="line">        len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,sdslen(o-&gt;ptr));</div><div class="line">        buf[len++] = <span class="string">'\r'</span>;</div><div class="line">        buf[len++] = <span class="string">'\n'</span>;</div><div class="line">        dst = sdscatlen(dst,buf,len);</div><div class="line">        dst = sdscatlen(dst,o-&gt;ptr,sdslen(o-&gt;ptr));</div><div class="line">        dst = sdscatlen(dst,<span class="string">"\r\n"</span>,<span class="number">2</span>);</div><div class="line">        decrRefCount(o);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dst;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="文件写入与同步"><a href="#文件写入与同步" class="headerlink" title="文件写入与同步"></a>文件写入与同步</h3><p>Redis服务器就是一个事件循环，这个循环中的文件时间负责接收客户端的命令请求，同时存在serverCron函数定时运行函数。</p>
<p>服务器每次结束事件循环之前，会调用flushAppendOnlyFile函数，执行文件写入操作。</p>
<p>调用write函数时，系统会将数据保存到一个内存缓冲区，等到填满时才进行写入，或者在指定时间之后才真正写入。虽然提高了效率，但是带来了数据安全问题。</p>
<p>redis提供了appendgsync选项来设置aof持久化怎么同步，三种方案：</p>
<ul>
<li>always，一直同步，安全性好，但是最慢。</li>
<li>everysec，当aof文件内容全部写入时，每隔一秒在子线程中对aof文件进行一次同步。</li>
<li>no，由操作系统决定什么时候同步。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</div><div class="line">    <span class="keyword">ssize_t</span> nwritten;</div><div class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</div><div class="line">    <span class="keyword">mstime_t</span> latency;</div><div class="line"></div><div class="line">    <span class="comment">// 缓冲区没有内容直接返回</span></div><div class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</div><div class="line">        sync_in_progress = bioPendingJobsOfType(REDIS_BIO_AOF_FSYNC) != <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</div><div class="line">        <span class="comment">/* With this append fsync policy we do background fsyncing.</span></div><div class="line"><span class="comment">         * If the fsync is still in progress we can try to delay</span></div><div class="line"><span class="comment">         * the write for a couple of seconds. */</span></div><div class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</div><div class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">/* No previous write postponing, remember that we are</span></div><div class="line"><span class="comment">                 * postponing the flush and return. */</span></div><div class="line">                server.aof_flush_postponed_start = server.unixtime;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</div><div class="line">                <span class="comment">/* We were already waiting for fsync to finish, but for less</span></div><div class="line"><span class="comment">                 * than two seconds this is still ok. Postpone again. */</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* Otherwise fall trough, and go write since we can't wait</span></div><div class="line"><span class="comment">             * over two seconds. */</span></div><div class="line">            server.aof_delayed_fsync++;</div><div class="line">            redisLog(REDIS_NOTICE,<span class="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 调用write命令将缓冲区数据写入磁盘文件中，</span></div><div class="line">    latencyStartMonitor(latency);</div><div class="line">    nwritten = write(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</div><div class="line">    latencyEndMonitor(latency);</div><div class="line">    <span class="comment">/* We want to capture different events for delayed writes:</span></div><div class="line"><span class="comment">     * when the delay happens with a pending fsync, or with a saving child</span></div><div class="line"><span class="comment">     * active, and when the above two conditions are missing.</span></div><div class="line"><span class="comment">     * We also use an additional event name to save all samples which is</span></div><div class="line"><span class="comment">     * useful for graphing / monitoring purposes. */</span></div><div class="line"></div><div class="line">    <span class="comment">// ...部分同步功能</span></div><div class="line"></div><div class="line">    <span class="comment">// 重置aof写入的延迟时间</span></div><div class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 写入操作出现错误</span></div><div class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">signed</span>)sdslen(server.aof_buf)) &#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */</span></div><div class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</div><div class="line">            can_log = <span class="number">1</span>;</div><div class="line">            last_write_error_log = server.unixtime;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Log the AOF write error and record the error code. */</span></div><div class="line">        <span class="comment">// 写错误日志</span></div><div class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Error writing to the AOF file: %s"</span>,</div><div class="line">                    strerror(errno));</div><div class="line">                server.aof_last_write_errno = errno;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Short write while writing to "</span></div><div class="line">                                       <span class="string">"the AOF file: (nwritten=%lld, "</span></div><div class="line">                                       <span class="string">"expected=%lld)"</span>,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 尝试移除新追加的不完整内容</span></div><div class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                    redisLog(REDIS_WARNING, <span class="string">"Could not remove short write "</span></div><div class="line">                             <span class="string">"from the append-only file.  Redis may refuse "</span></div><div class="line">                             <span class="string">"to load the AOF the next time it starts.  "</span></div><div class="line">                             <span class="string">"ftruncate: %s"</span>, strerror(errno));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* If the ftruncate() succeeded we can set nwritten to</span></div><div class="line"><span class="comment">                 * -1 since there is no longer partial data into the AOF. */</span></div><div class="line">                nwritten = <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line">            server.aof_last_write_errno = ENOSPC;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 处理写入时错误</span></div><div class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">            <span class="comment">/* We can't recover when the fsync policy is ALWAYS since the</span></div><div class="line"><span class="comment">             * reply for the client is already in the output buffers, and we</span></div><div class="line"><span class="comment">             * have the contract with the user that on acknowledged write data</span></div><div class="line"><span class="comment">             * is synced on disk. */</span></div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* Recover from failed write leaving data into the buffer. However</span></div><div class="line"><span class="comment">             * set an error to stop accepting writes as long as the error</span></div><div class="line"><span class="comment">             * condition is not cleared. */</span></div><div class="line">            server.aof_last_write_status = REDIS_ERR;</div><div class="line"></div><div class="line">            <span class="comment">/* Trim the sds buffer if there was a partial write, and there</span></div><div class="line"><span class="comment">             * was no way to undo it with ftruncate(2). */</span></div><div class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</div><div class="line">                server.aof_current_size += nwritten;</div><div class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>; <span class="comment">/* We'll try again on the next call... */</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 写入成功</span></div><div class="line">        <span class="keyword">if</span> (server.aof_last_write_status == REDIS_ERR) &#123;</div><div class="line">            redisLog(REDIS_WARNING,</div><div class="line">                <span class="string">"AOF write error looks solved, Redis can write again."</span>);</div><div class="line">            server.aof_last_write_status = REDIS_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    server.aof_current_size += nwritten;</div><div class="line"></div><div class="line">    <span class="comment">// 当缓冲区使用很小时，考虑重用</span></div><div class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</div><div class="line">        sdsclear(server.aof_buf);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        sdsfree(server.aof_buf);</div><div class="line">        server.aof_buf = sdsempty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在no_fsync_on_rewrite开启并且BGSAVE或者BGREWRITE进行不执行fsync</span></div><div class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp;</div><div class="line">        (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">    <span class="comment">// 执行fsnyc,根据redis配置</span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">        <span class="comment">/* aof_fsync is defined as fdatasync() for Linux in order to avoid</span></div><div class="line"><span class="comment">         * flushing metadata. */</span></div><div class="line">        latencyStartMonitor(latency);</div><div class="line">        aof_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></div><div class="line">        latencyEndMonitor(latency);</div><div class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-fsync-always"</span>,latency);</div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</div><div class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</div><div class="line">        <span class="keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd);</div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h2><p>数据存储在AOF文件中后，服务器只要读取并重新执行一遍AOF文件里保存的写命令，就可以还原服务器关闭之前的数据库状态。</p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>重写的目的主要是因为很多命令在执行多次后，可以进行合并，恢复时起始并不需要执行这么多命令。其实只要找到数据库的所有数据，生成相对应的命令即可，至于其他的命令完全不需要。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// aof重写的实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    dictIterator *di = <span class="literal">NULL</span>;</div><div class="line">    dictEntry *de;</div><div class="line">    rio aof;</div><div class="line">    FILE *fp;</div><div class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = mstime();</div><div class="line">    <span class="keyword">char</span> byte;</div><div class="line">    <span class="keyword">size_t</span> processed = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个零食文件</span></div><div class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-rewriteaof-%d.aof"</span>, (<span class="keyword">int</span>) getpid());</div><div class="line">    fp = fopen(tmpfile,<span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span> (!fp) &#123;</div><div class="line">        redisLog(REDIS_WARNING, <span class="string">"Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s"</span>, strerror(errno));</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server.aof_child_diff = sdsempty();</div><div class="line"></div><div class="line">    <span class="comment">// redis内部文件结构体初始化</span></div><div class="line">    rioInitWithFile(&amp;aof,fp);</div><div class="line">    <span class="keyword">if</span> (server.aof_rewrite_incremental_fsync)</div><div class="line">        rioSetAutoSync(&amp;aof,REDIS_AOF_AUTOSYNC_BYTES);</div><div class="line">    </div><div class="line">    <span class="comment">// 遍历数据库</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line">        <span class="keyword">char</span> selectcmd[] = <span class="string">"*2\r\n$6\r\nSELECT\r\n"</span>;</div><div class="line">        redisDb *db = server.db+j;</div><div class="line">        dict *d = db-&gt;dict;</div><div class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        di = dictGetSafeIterator(d);</div><div class="line">        <span class="keyword">if</span> (!di) &#123;</div><div class="line">            fclose(fp);</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 生成数据库选择语句</span></div><div class="line">        <span class="keyword">if</span> (rioWrite(&amp;aof,selectcmd,<span class="keyword">sizeof</span>(selectcmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">        <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,j) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">        <span class="comment">// 获取每一个键，生成命令</span></div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr;</div><div class="line">            robj key, *o;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expiretime;</div><div class="line"></div><div class="line">            keystr = dictGetKey(de);</div><div class="line">            o = dictGetVal(de);</div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line"></div><div class="line">            expiretime = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">// 跳过过期键</span></div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 根据类型保存</span></div><div class="line">            <span class="keyword">if</span> (o-&gt;type == REDIS_STRING) &#123;</div><div class="line">                <span class="comment">/* Emit a SET command */</span></div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$3\r\nSET\r\n"</span>;</div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="comment">/* Key and value */</span></div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_LIST) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteListObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_SET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_ZSET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSortedSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_HASH) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteHashObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                redisPanic(<span class="string">"Unknown object type"</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 保存过期时间</span></div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$9\r\nPEXPIREAT\r\n"</span>;</div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,expiretime) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* Read some diff from the parent process from time to time. */</span></div><div class="line">            <span class="keyword">if</span> (aof.processed_bytes &gt; processed+<span class="number">1024</span>*<span class="number">10</span>) &#123;</div><div class="line">                processed = aof.processed_bytes;</div><div class="line">                aofReadDiffFromParent();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dictReleaseIterator(di);</div><div class="line">        di = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* Read again a few times to get more data from the parent.</span></div><div class="line"><span class="comment">     * We can't read forever (the server may receive data from clients</span></div><div class="line"><span class="comment">     * faster than it is able to send data to the child), so we try to read</span></div><div class="line"><span class="comment">     * some more data in a loop as soon as there is a good chance more data</span></div><div class="line"><span class="comment">     * will come. If it looks like we are wasting time, we abort (this</span></div><div class="line"><span class="comment">     * happens after 20 ms without new data). */</span></div><div class="line">    <span class="keyword">int</span> nodata = <span class="number">0</span>;</div><div class="line">    <span class="keyword">mstime_t</span> start = mstime();</div><div class="line">    <span class="keyword">while</span>(mstime()-start &lt; <span class="number">1000</span> &amp;&amp; nodata &lt; <span class="number">20</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="number">1</span>) &lt;= <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            nodata++;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        nodata = <span class="number">0</span>; <span class="comment">/* Start counting from zero, we stop on N *contiguous*</span></div><div class="line"><span class="comment">                       timeouts. */</span></div><div class="line">        aofReadDiffFromParent();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Ask the master to stop sending diffs. */</span></div><div class="line">    <span class="keyword">if</span> (write(server.aof_pipe_write_ack_to_parent,<span class="string">"!"</span>,<span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,server.aof_pipe_read_ack_from_parent) != ANET_OK)</div><div class="line">        <span class="keyword">goto</span> werr;</div><div class="line">    <span class="comment">/* We read the ACK from the server using a 10 seconds timeout. Normally</span></div><div class="line"><span class="comment">     * it should reply ASAP, but just in case we lose its reply, we are sure</span></div><div class="line"><span class="comment">     * the child will eventually get terminated. */</span></div><div class="line">    <span class="keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,<span class="number">1</span>,<span class="number">5000</span>) != <span class="number">1</span> ||</div><div class="line">        byte != <span class="string">'!'</span>) <span class="keyword">goto</span> werr;</div><div class="line">    redisLog(REDIS_NOTICE,<span class="string">"Parent agreed to stop sending diffs. Finalizing AOF..."</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the final diff if any. */</span></div><div class="line">    aofReadDiffFromParent();</div><div class="line"></div><div class="line">    <span class="comment">/* Write the received diff to the file. */</span></div><div class="line">    redisLog(REDIS_NOTICE,</div><div class="line">        <span class="string">"Concatenating %.2f MB of AOF diff received from parent."</span>,</div><div class="line">        (<span class="keyword">double</span>) sdslen(server.aof_child_diff) / (<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">    <span class="keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// flush并关闭文件</span></div><div class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// 重命名aof文件</span></div><div class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Error moving temp append only file on the final destination: %s"</span>, strerror(errno));</div><div class="line">        unlink(tmpfile);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line">    redisLog(REDIS_NOTICE,<span class="string">"SYNC append only file rewrite performed"</span>);</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">werr:</div><div class="line">    fclose(fp);</div><div class="line">    unlink(tmpfile);</div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Write error writing append only file on disk: %s"</span>, strerror(errno));</div><div class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h2><p>与RDB一样，AOF也提供一个fork线程后台重写的功能，异步调用的实现类似与RDB。</p>
<p>在子线程完成重写之后(创建一个新文件)，调用backgroundRewriteDoneHandler()，再调用aofRewriteBufferWrite(),将子线程执行重写过程中产生的新AOF数据写入新文件，然后改名覆盖源文件。</p>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码阅读-订阅与发布]]></title>
      <url>/2017/07/12/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/</url>
      <content type="html"><![CDATA[<p>Redis的发布与订阅主要是实现客户端订阅一个频道或者模式，当某客户端向一个频道发送消息时，该频道或者匹配模式订阅者都能够收到消息。</p>
<h2 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h2><p>Redis在服务器结构体中的pubsub_channels字典中保存了所有的频道订阅关系。pubsub_channels键为频道，值为订阅的客户端组成的链表。</p>
<p>客户端结构体的pubsub_channels保存了客户端订阅的所有频道，pubsub_channels的键为频道，值为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  dict *pubsub_channels;  <span class="comment">// 保存所有的频道订阅关系</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  dict *pubsub_channels; <span class="comment">// 记录客户端订阅的频道</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 订阅命令处理函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历指令中的所有频道</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">        pubsubSubscribeChannel(c,c-&gt;argv[j]);</div><div class="line">    c-&gt;flags |= REDIS_PUBSUB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设置客户端c订阅频道channel</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(redisClient *c, robj *channel)</span> </span>&#123;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Add the channel to the client -&gt; channels hash table */</span></div><div class="line">    <span class="comment">// 将channels加倒c-&gt;c-&gt;pubsub_channels的字典里</span></div><div class="line">    <span class="keyword">if</span> (dictAdd(c-&gt;pubsub_channels,channel,<span class="literal">NULL</span>) == DICT_OK) &#123;</div><div class="line">        retval = <span class="number">1</span>;</div><div class="line">        incrRefCount(channel);</div><div class="line">        <span class="comment">/* Add the client to the channel -&gt; list of clients hash table */</span></div><div class="line">        <span class="comment">// 找出服务器中的频道</span></div><div class="line">        de = dictFind(server.pubsub_channels,channel);</div><div class="line">        </div><div class="line">        <span class="comment">// 不存在就添加一个频道</span></div><div class="line">        <span class="comment">// 获取客户端链表</span></div><div class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</div><div class="line">            clients = listCreate();</div><div class="line">            dictAdd(server.pubsub_channels,channel,clients);</div><div class="line">            incrRefCount(channel);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            clients = dictGetVal(de);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 添加到客户端链表尾部</span></div><div class="line">        listAddNodeTail(clients,c);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Notify the client */</span></div><div class="line">    <span class="comment">// 回复客户端</span></div><div class="line">    addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">    addReply(c,shared.subscribebulk);</div><div class="line">    addReplyBulk(c,channel);</div><div class="line">    addReplyLongLong(c,clientSubscriptionsCount(c));</div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="退订"><a href="#退订" class="headerlink" title="退订"></a>退订</h2><p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 退订所有频道</span></div><div class="line">        pubsubUnsubscribeAllChannels(c,<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历频道一一退订</span></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">            pubsubUnsubscribeChannel(c,c-&gt;argv[j],<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~REDIS_PUBSUB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 退订所有频道</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllChannels</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span> </span>&#123;</div><div class="line">    dictIterator *di = dictGetSafeIterator(c-&gt;pubsub_channels);</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历一一退订</span></div><div class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">        robj *channel = dictGetKey(de);</div><div class="line"></div><div class="line">        count += pubsubUnsubscribeChannel(c,channel,notify);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* We were subscribed to nothing? Still reply to the client. */</span></div><div class="line">    <span class="keyword">if</span> (notify &amp;&amp; count == <span class="number">0</span>) &#123;</div><div class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">        addReply(c,shared.unsubscribebulk);</div><div class="line">        addReply(c,shared.nullbulk);</div><div class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</div><div class="line">                       listLength(c-&gt;pubsub_patterns));</div><div class="line">    &#125;</div><div class="line">    dictReleaseIterator(di);</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 客户端退订频道</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeChannel</span><span class="params">(redisClient *c, robj *channel, <span class="keyword">int</span> notify)</span> </span>&#123;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="built_in">list</span> *clients;</div><div class="line">    listNode *ln;</div><div class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Remove the channel from the client -&gt; channels hash table */</span></div><div class="line">    incrRefCount(channel); <span class="comment">/* channel may be just a pointer to the same object</span></div><div class="line"><span class="comment">                            we have in the hash tables. Protect it... */</span></div><div class="line"></div><div class="line">    <span class="comment">// 移除客户端字典中频道的订阅</span></div><div class="line">    <span class="keyword">if</span> (dictDelete(c-&gt;pubsub_channels,channel) == DICT_OK) &#123;</div><div class="line">        retval = <span class="number">1</span>;</div><div class="line">        <span class="comment">/* Remove the client from the channel -&gt; clients list hash table */</span></div><div class="line">        <span class="comment">// 找到服务器频道</span></div><div class="line">        de = dictFind(server.pubsub_channels,channel);</div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</div><div class="line">        clients = dictGetVal(de); <span class="comment">// 获取链表</span></div><div class="line">        ln = listSearchKey(clients,c); <span class="comment">// 寻找链表中的订阅</span></div><div class="line">        redisAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</div><div class="line">        listDelNode(clients,ln); <span class="comment">// 删除节点</span></div><div class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">/* Free the list and associated hash entry at all if this was</span></div><div class="line"><span class="comment">             * the latest client, so that it will be possible to abuse</span></div><div class="line"><span class="comment">             * Redis PUBSUB creating millions of channels. */</span></div><div class="line">            <span class="comment">// 删除节点后 链表为空 删除字典中的节点</span></div><div class="line">            dictDelete(server.pubsub_channels,channel);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Notify the client */</span></div><div class="line">    <span class="comment">// 回复客户端</span></div><div class="line">    <span class="keyword">if</span> (notify) &#123;</div><div class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">        addReply(c,shared.unsubscribebulk);</div><div class="line">        addReplyBulk(c,channel);</div><div class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</div><div class="line">                       listLength(c-&gt;pubsub_patterns));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    decrRefCount(channel); <span class="comment">/* it is finally safe to release it */</span></div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h2><p>Redis在服务器结构体中的pubsub_patterns链表中保存了所有订阅模式关系。使用pubsubPattern结构的数据作为节点。</p>
<p>客户端结构体的pubsub_patterns保存了客户端订阅的所有模式，节点使用pubsubPattern结构的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">// 所有订阅模式关系</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">// 订阅模式关系</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></div><div class="line">    client *client; <span class="comment">// 订阅模式的客户端</span></div><div class="line">    robj *pattern;  <span class="comment">// 被订阅模式</span></div><div class="line">&#125; pubsubPattern;</div></pre></td></tr></table></figure>
<h2 id="订阅-1"><a href="#订阅-1" class="headerlink" title="订阅"></a>订阅</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 订阅模式</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">psubscribeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历命令中的模式</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">        pubsubSubscribePattern(c,c-&gt;argv[j]);</div><div class="line">    c-&gt;flags |= REDIS_PUBSUB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设置客户端c订阅模式pattern</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribePattern</span><span class="params">(redisClient *c, robj *pattern)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 客户端模式链表中查找模式</span></div><div class="line">    <span class="comment">// 为空则创建</span></div><div class="line">    <span class="keyword">if</span> (listSearchKey(c-&gt;pubsub_patterns,pattern) == <span class="literal">NULL</span>) &#123;</div><div class="line">        retval = <span class="number">1</span>;</div><div class="line">        pubsubPattern *pat;</div><div class="line">        <span class="comment">// 客户端模式链表尾部添加模式</span></div><div class="line">        listAddNodeTail(c-&gt;pubsub_patterns,pattern);</div><div class="line">        incrRefCount(pattern);</div><div class="line"></div><div class="line">        <span class="comment">// 服务端模式链表尾部添加模式</span></div><div class="line">        pat = zmalloc(<span class="keyword">sizeof</span>(*pat));</div><div class="line">        pat-&gt;pattern = getDecodedObject(pattern);</div><div class="line">        pat-&gt;client = c;</div><div class="line">        listAddNodeTail(server.pubsub_patterns,pat);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Notify the client */</span></div><div class="line">    addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">    addReply(c,shared.psubscribebulk);</div><div class="line">    addReplyBulk(c,pattern);</div><div class="line">    addReplyLongLong(c,clientSubscriptionsCount(c));</div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="退订-1"><a href="#退订-1" class="headerlink" title="退订"></a>退订</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 退订模式</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">punsubscribeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 退订所有模式</span></div><div class="line">        pubsubUnsubscribeAllPatterns(c,<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">        <span class="comment">// 退订命令中的模式</span></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</div><div class="line">            pubsubUnsubscribePattern(c,c-&gt;argv[j],<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~REDIS_PUBSUB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 退订客户端c订阅的所有模式</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllPatterns</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span> </span>&#123;</div><div class="line">    listNode *ln;</div><div class="line">    listIter li;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历，一一退订</span></div><div class="line">    listRewind(c-&gt;pubsub_patterns,&amp;li);</div><div class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</div><div class="line">        robj *pattern = ln-&gt;value;</div><div class="line"></div><div class="line">        count += pubsubUnsubscribePattern(c,pattern,notify);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (notify &amp;&amp; count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/* We were subscribed to nothing? Still reply to the client. */</span></div><div class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">        addReply(c,shared.punsubscribebulk);</div><div class="line">        addReply(c,shared.nullbulk);</div><div class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</div><div class="line">                       listLength(c-&gt;pubsub_patterns));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 取消客户端c对模式pattern的订阅</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribePattern</span><span class="params">(redisClient *c, robj *pattern, <span class="keyword">int</span> notify)</span> </span>&#123;</div><div class="line">    listNode *ln;</div><div class="line">    pubsubPattern pat;</div><div class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">    incrRefCount(pattern); <span class="comment">/* Protect the object. May be the same we remove */</span></div><div class="line"></div><div class="line">    <span class="comment">// 订阅了才进行操作</span></div><div class="line">    <span class="keyword">if</span> ((ln = listSearchKey(c-&gt;pubsub_patterns,pattern)) != <span class="literal">NULL</span>) &#123;</div><div class="line">        retval = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 从客户端订阅中删除</span></div><div class="line">        listDelNode(c-&gt;pubsub_patterns,ln);</div><div class="line">        pat.client = c;</div><div class="line">        pat.pattern = pattern;</div><div class="line"></div><div class="line">        <span class="comment">// 从服务端订阅中删除</span></div><div class="line">        ln = listSearchKey(server.pubsub_patterns,&amp;pat);</div><div class="line">        listDelNode(server.pubsub_patterns,ln);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Notify the client */</span></div><div class="line">    <span class="keyword">if</span> (notify) &#123;</div><div class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">        addReply(c,shared.punsubscribebulk);</div><div class="line">        addReplyBulk(c,pattern);</div><div class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</div><div class="line">                       listLength(c-&gt;pubsub_patterns));</div><div class="line">    &#125;</div><div class="line">    decrRefCount(pattern);</div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发布消息</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> receivers = pubsubPublishMessage(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">    <span class="comment">// 暂时不考虑集群</span></div><div class="line">    <span class="keyword">if</span> (server.cluster_enabled)</div><div class="line">        clusterPropagatePublish(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        forceCommandPropagation(c,REDIS_PROPAGATE_REPL);</div><div class="line">    addReplyLongLong(c,receivers);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将消息发送到所有订阅了频道的客户端</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> receivers = <span class="number">0</span>;</div><div class="line">    dictEntry *de;</div><div class="line">    listNode *ln;</div><div class="line">    listIter li;</div><div class="line"></div><div class="line">    <span class="comment">/* Send to clients listening for that channel */</span></div><div class="line">    <span class="comment">// 先查找订阅了频道的</span></div><div class="line">    de = dictFind(server.pubsub_channels,channel);</div><div class="line">    <span class="keyword">if</span> (de) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 获取链表</span></div><div class="line">        <span class="built_in">list</span> *<span class="built_in">list</span> = dictGetVal(de);</div><div class="line">        listNode *ln;</div><div class="line">        listIter li;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历链表 发送消息</span></div><div class="line">        listRewind(<span class="built_in">list</span>,&amp;li);</div><div class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            redisClient *c = ln-&gt;value;</div><div class="line"></div><div class="line">            addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</div><div class="line">            addReply(c,shared.messagebulk);</div><div class="line">            addReplyBulk(c,channel);</div><div class="line">            addReplyBulk(c,message);</div><div class="line">            receivers++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Send to clients listening to matching channels */</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (listLength(server.pubsub_patterns)) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历模式链表</span></div><div class="line">        listRewind(server.pubsub_patterns,&amp;li);</div><div class="line">        channel = getDecodedObject(channel);</div><div class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            pubsubPattern *pat = ln-&gt;value;</div><div class="line"></div><div class="line">            <span class="comment">// 匹配模式 发送消息</span></div><div class="line">            <span class="keyword">if</span> (stringmatchlen((<span class="keyword">char</span>*)pat-&gt;pattern-&gt;ptr,</div><div class="line">                                sdslen(pat-&gt;pattern-&gt;ptr),</div><div class="line">                                (<span class="keyword">char</span>*)channel-&gt;ptr,</div><div class="line">                                sdslen(channel-&gt;ptr),<span class="number">0</span>)) &#123;</div><div class="line">                addReply(pat-&gt;client,shared.mbulkhdr[<span class="number">4</span>]);</div><div class="line">                addReply(pat-&gt;client,shared.pmessagebulk);</div><div class="line">                addReplyBulk(pat-&gt;client,pat-&gt;pattern);</div><div class="line">                addReplyBulk(pat-&gt;client,channel);</div><div class="line">                addReplyBulk(pat-&gt;client,message);</div><div class="line">                receivers++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        decrRefCount(channel);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> receivers;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-RDB持久化]]></title>
      <url>/2017/07/12/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-RDB%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>Redis是一个内存数据库，数据存储在内存之中。有一个问题就是如果数据不存储到硬盘，那么在服务器进程退出之后，服务器中所有的数据库数据就会丢失。</p>
<p>Redis为了解决这个问题，提供了持久化功能，目前有两种一种是RDB持久化，一种是AOF持久化。</p>
<p>RDB持久化是生成一个RDB文件，该文件是一个经过压缩的二进制文件，通过该文件可以还原数据库的状态。</p>
<h2 id="RDB文件的保存命令"><a href="#RDB文件的保存命令" class="headerlink" title="RDB文件的保存命令"></a>RDB文件的保存命令</h2><p>Redis有两个命令可以生成RDB文件一个是SAVE，一个是BGSAVE。<br>SAVE命令调用saveCommand进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否正在执行BGSAVE，是则退出</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        addReplyError(c,<span class="string">"Background save already in progress"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//调用rdbSave生成RDB文件</span></div><div class="line">    <span class="keyword">if</span> (rdbSave(server.rdb_filename) == REDIS_OK) &#123;</div><div class="line">        addReply(c,shared.ok);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReply(c,shared.err);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BGSAVE调用bgsaveCommand进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgsaveCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否已经在执行BGSAVE</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        addReplyError(c,<span class="string">"Background save already in progress"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        </div><div class="line">    <span class="comment">// 判断是否在执行BGREWRIEAOF</span></div><div class="line">        addReplyError(c,<span class="string">"Can't BGSAVE while AOF log rewriting is in progress"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 执行rdbSaveBackground 生成RDB文件</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbSaveBackground(server.rdb_filename) == REDIS_OK) &#123;</div><div class="line">        addReplyStatus(c,<span class="string">"Background saving started"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReply(c,shared.err);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">pid_t</span> childpid;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</div><div class="line"></div><div class="line">    <span class="comment">// 如果BGSAVE正在执行直接返回</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 获取dirty数据 执行时间</span></div><div class="line">    server.dirty_before_bgsave = server.dirty;</div><div class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// fork() 开始前时间</span></div><div class="line">    start = ustime();</div><div class="line"></div><div class="line">    <span class="comment">// 调用fork，克隆该进程</span></div><div class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">        <span class="comment">/* Child */</span></div><div class="line">        closeListeningSockets(<span class="number">0</span>);</div><div class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 执行保存操作</span></div><div class="line">        retval = rdbSave(filename);</div><div class="line"></div><div class="line">        <span class="comment">// 打印 copy-on-write 时使用的内存数</span></div><div class="line">        <span class="keyword">if</span> (retval == REDIS_OK) &#123;</div><div class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (private_dirty) &#123;</div><div class="line">                redisLog(REDIS_NOTICE,</div><div class="line">                    <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</div><div class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 向父进程发送信号</span></div><div class="line">        exitFromChild((retval == REDIS_OK) ? <span class="number">0</span> : <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Parent */</span></div><div class="line"></div><div class="line">        <span class="comment">// 计算 fork() 执行的时间</span></div><div class="line">        server.stat_fork_time = ustime()-start;</div><div class="line">        server.stat_fork_rate = (<span class="keyword">double</span>) zmalloc_used_memory() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></div><div class="line">        latencyAddSampleIfNeeded(<span class="string">"fork"</span>,server.stat_fork_time/<span class="number">1000</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 执行fork()错误信息</span></div><div class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</div><div class="line">            server.lastbgsave_status = REDIS_ERR;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't save in background: fork: %s"</span>,</div><div class="line">                strerror(errno));</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line">        redisLog(REDIS_NOTICE,<span class="string">"Background saving started by pid %d"</span>,childpid);</div><div class="line">        </div><div class="line">        <span class="comment">// 记录数据库开始BGSAVE时间</span></div><div class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 子进程ID 类型</span></div><div class="line">        server.rdb_child_pid = childpid;</div><div class="line">        server.rdb_child_type = REDIS_RDB_CHILD_TYPE_DISK;</div><div class="line"></div><div class="line">        <span class="comment">// 关闭自动Rehash</span></div><div class="line">        updateDictResizePolicy();</div><div class="line">        <span class="keyword">return</span> REDIS_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> REDIS_OK; <span class="comment">/* unreached */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>那么怎么才能够知道BGSAVE执行完毕，BGSAVE执行完毕后使用exitFromChild((retval == REDIS_OK) ? 0 : 1);向父进程发送信号。父进程调用serverCron接收该信号。</p>
<p>以下是处理函数的部分代码，处理BGREWRITEAOF与BGSAVE的完成信号。最终调用backgroundSaveDoneHandler根据返回信号信息进行对应处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span> </span>&#123;</div><div class="line">\\ ...</div><div class="line">    <span class="comment">// 检查 BGSAVE 或者 BGREWRITEAOF 是否已经执行完毕</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> || server.aof_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">int</span> statloc;</div><div class="line">        <span class="keyword">pid_t</span> pid;</div><div class="line"></div><div class="line">        <span class="comment">// 接收子进程发来的信号</span></div><div class="line">        <span class="keyword">if</span> ((pid = wait3(&amp;statloc,WNOHANG,<span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> exitcode = WEXITSTATUS(statloc);</div><div class="line">            <span class="keyword">int</span> bysignal = <span class="number">0</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</div><div class="line"></div><div class="line">            <span class="comment">// BGSAVE 执行完毕</span></div><div class="line">            <span class="keyword">if</span> (pid == server.rdb_child_pid) &#123;</div><div class="line">                backgroundSaveDoneHandler(exitcode,bysignal);</div><div class="line"></div><div class="line">            <span class="comment">// BGREWRITEAOF 执行完毕</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.aof_child_pid) &#123;</div><div class="line">                backgroundRewriteDoneHandler(exitcode,bysignal);</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    <span class="string">"Warning, detected child with unmatched pid: %ld"</span>,</div><div class="line">                    (<span class="keyword">long</span>)pid);</div><div class="line">            &#125;</div><div class="line">            updateDictResizePolicy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">\\ ...</div><div class="line">  </div><div class="line"><span class="comment">/* A background saving child (BGSAVE) terminated its work. Handle this.</span></div><div class="line"><span class="comment"> * This function covers the case of actual BGSAVEs. */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundSaveDoneHandlerDisk</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 成功</span></div><div class="line">    <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) &#123;</div><div class="line">        redisLog(REDIS_NOTICE,</div><div class="line">            <span class="string">"Background saving terminated with success"</span>);</div><div class="line">        server.dirty = server.dirty - server.dirty_before_bgsave;</div><div class="line">        server.lastsave = time(<span class="literal">NULL</span>);</div><div class="line">        server.lastbgsave_status = REDIS_OK;</div><div class="line"></div><div class="line">    <span class="comment">// 出错</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode != <span class="number">0</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING, <span class="string">"Background saving error"</span>);</div><div class="line">        server.lastbgsave_status = REDIS_ERR;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">mstime_t</span> latency;</div><div class="line"></div><div class="line">        redisLog(REDIS_WARNING,</div><div class="line">            <span class="string">"Background saving terminated by signal %d"</span>, bysignal);</div><div class="line">        latencyStartMonitor(latency);</div><div class="line">        rdbRemoveTempFile(server.rdb_child_pid);</div><div class="line">        latencyEndMonitor(latency);</div><div class="line">        latencyAddSampleIfNeeded(<span class="string">"rdb-unlink-temp-file"</span>,latency);</div><div class="line">        <span class="comment">/* SIGUSR1 is whitelisted, so we have a way to kill a child without</span></div><div class="line"><span class="comment">         * tirggering an error conditon. */</span></div><div class="line">        <span class="keyword">if</span> (bysignal != SIGUSR1)</div><div class="line">            server.lastbgsave_status = REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新状态</span></div><div class="line">    server.rdb_child_pid = <span class="number">-1</span>;</div><div class="line">    server.rdb_child_type = REDIS_RDB_CHILD_TYPE_NONE;</div><div class="line">    server.rdb_save_time_last = time(<span class="literal">NULL</span>)-server.rdb_save_time_start;</div><div class="line">    server.rdb_save_time_start = <span class="number">-1</span>;</div><div class="line">    <span class="comment">/* Possibly there are slaves waiting for a BGSAVE in order to be served</span></div><div class="line"><span class="comment">     * (the first stage of SYNC is a bulk transfer of dump.rdb) */</span></div><div class="line">    updateSlavesWaitingBgsave((!bysignal &amp;&amp; exitcode == <span class="number">0</span>) ? REDIS_OK : REDIS_ERR, REDIS_RDB_CHILD_TYPE_DISK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="rdbSave"><a href="#rdbSave" class="headerlink" title="rdbSave"></a>rdbSave</h3><p>int rdbSave(char *filename);是SAVE与BGSAVE命令执行时正在用来生成RDB文件的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line">    <span class="keyword">int</span> error;</div><div class="line"></div><div class="line">    <span class="comment">// 生成临时文件</span></div><div class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) getpid());</div><div class="line">    fp = fopen(tmpfile,<span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span> (!fp) &#123;</div><div class="line">        redisLog(REDIS_WARNING, <span class="string">"Failed opening .rdb for saving: %s"</span>,</div><div class="line">            strerror(errno));</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化I/O</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line">    </div><div class="line">    <span class="comment">// 生成RDB文件</span></div><div class="line">    <span class="keyword">if</span> (rdbSaveRio(&amp;rdb,&amp;error) == REDIS_ERR) &#123;</div><div class="line">        errno = error;</div><div class="line">        <span class="keyword">goto</span> werr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 确保缓存中没有数据</span></div><div class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// 使用RENAME改名</span></div><div class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Error moving temp DB file on the final destination: %s"</span>, strerror(errno));</div><div class="line">        unlink(tmpfile);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 日志 设置状态</span></div><div class="line">    redisLog(REDIS_NOTICE,<span class="string">"DB saved on disk"</span>);</div><div class="line">    server.dirty = <span class="number">0</span>;</div><div class="line">    server.lastsave = time(<span class="literal">NULL</span>);</div><div class="line">    server.lastbgsave_status = REDIS_OK;</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">werr:</div><div class="line"></div><div class="line">    <span class="comment">// 异常处理</span></div><div class="line">    fclose(fp);</div><div class="line">    unlink(tmpfile);</div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Write error saving DB on disk: %s"</span>, strerror(errno));</div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际是调用rdbSaveRio执行写入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error)</span> </span>&#123;</div><div class="line">    dictIterator *di = <span class="literal">NULL</span>;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = mstime();</div><div class="line">    <span class="keyword">uint64_t</span> cksum;</div><div class="line"></div><div class="line">    <span class="comment">// 设置校验和</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_checksum)</div><div class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</div><div class="line"></div><div class="line">    <span class="comment">// 写入REDIS版本号</span></div><div class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">"REDIS%04d"</span>,REDIS_RDB_VERSION);</div><div class="line">    <span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历数据库</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line">        redisDb *db = server.db+j;</div><div class="line">        dict *d = db-&gt;dict;</div><div class="line"></div><div class="line">        <span class="comment">// 跳过空数据库</span></div><div class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 键空间迭代器</span></div><div class="line">        di = dictGetSafeIterator(d);</div><div class="line">        <span class="keyword">if</span> (!di) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">        <span class="comment">/* Write the SELECT DB opcode */</span></div><div class="line">        <span class="comment">// 写入DB选择器</span></div><div class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,REDIS_RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">        <span class="comment">/* Iterate this DB writing every entry */</span></div><div class="line">      <span class="comment">// 遍历数据库，写入键值对</span></div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr = dictGetKey(de);</div><div class="line">            robj key, *o = dictGetVal(de);</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</div><div class="line"></div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line">            expire = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">// 写入键值对</span></div><div class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire,now) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        &#125;</div><div class="line">        dictReleaseIterator(di);</div><div class="line">    &#125;</div><div class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* EOF opcode */</span></div><div class="line">    <span class="comment">// 写入 EOF 代码</span></div><div class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,REDIS_RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></div><div class="line"><span class="comment">     * loading code skips the check in this case. */</span></div><div class="line">    <span class="comment">// CRC64 校验和。</span></div><div class="line">    cksum = rdb-&gt;cksum;</div><div class="line">    memrev64ifbe(&amp;cksum);</div><div class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">werr:</div><div class="line">    <span class="keyword">if</span> (error) *error = errno;</div><div class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h2><p>redis能够配置自动保存条件，当满足的情况下执行BGSAVE。</p>
<p>依赖上次保存时间和dirty计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// serverCron函数</span></div><div class="line"><span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> || server.aof_child_pid != <span class="number">-1</span> ||</div><div class="line">    ldbPendingChildren())</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 为之前处理BGSAVE完成的部分的代码</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 检查所有保存条件</span></div><div class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.saveparamslen; j++) &#123;</div><div class="line">    struct saveparam *sp = server.saveparams+j;</div><div class="line">    <span class="comment">// 检查某个保存条件是否符合</span></div><div class="line">    <span class="keyword">if</span> (server.dirty &gt;= sp-&gt;changes &amp;&amp;</div><div class="line">        server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</div><div class="line">        (server.unixtime-server.lastbgsave_try &gt;</div><div class="line">         CONFIG_BGSAVE_RETRY_DELAY ||</div><div class="line">         server.lastbgsave_status == C_OK))</div><div class="line">    &#123;</div><div class="line">      serverLog(LL_NOTICE,<span class="string">"%d changes in %d seconds. Saving..."</span>,</div><div class="line">                sp-&gt;changes, (<span class="keyword">int</span>)sp-&gt;seconds);</div><div class="line">      </div><div class="line">      <span class="comment">// 保存</span></div><div class="line">      rdbSaveBackground(server.rdb_filename);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RDB的文件载入"><a href="#RDB的文件载入" class="headerlink" title="RDB的文件载入"></a>RDB的文件载入</h2><p>rdbload()用于将RDB文件从硬盘载入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> dbid;</div><div class="line">    <span class="keyword">int</span> type, rdbver;</div><div class="line">    redisDb *db = server.db+<span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> expiretime, now = mstime();</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line"></div><div class="line">    <span class="comment">// 打开rdb文件</span></div><div class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">"r"</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化rio</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line">    rdb.update_cksum = rdbLoadProgressCallback;</div><div class="line">    rdb.max_processing_chunk = server.loading_process_events_interval_bytes;</div><div class="line">    <span class="keyword">if</span> (rioRead(&amp;rdb,buf,<span class="number">9</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">    buf[<span class="number">9</span>] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 校验版本号</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(buf,<span class="string">"REDIS"</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Wrong signature trying to load DB from file"</span>);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line">    rdbver = atoi(buf+<span class="number">5</span>);</div><div class="line">    <span class="keyword">if</span> (rdbver &lt; <span class="number">1</span> || rdbver &gt; REDIS_RDB_VERSION) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Can't handle RDB format version %d"</span>,rdbver);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 标记开始载入</span></div><div class="line">    startLoading(fp);</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        robj *key, *val;</div><div class="line">        expiretime = <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Read type. */</span></div><div class="line">        <span class="comment">// 读取类型</span></div><div class="line">        <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">// 过期时间 秒为单位</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 过期时间</span></div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again. */</span></div><div class="line"></div><div class="line">            <span class="comment">// 键值对</span></div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">            <span class="comment">/* the EXPIRETIME opcode specifies time in seconds, so convert</span></div><div class="line"><span class="comment">             * into milliseconds. */</span></div><div class="line">            expiretime *= <span class="number">1000</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME_MS) &#123;</div><div class="line">            <span class="comment">/* Milliseconds precision expire times introduced with RDB</span></div><div class="line"><span class="comment">             * version 3. */</span></div><div class="line">             <span class="comment">// 过期时间 毫秒但闻</span></div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadMillisecondTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again. */</span></div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// EOF</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EOF)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Handle SELECT DB opcode as a special case */</span></div><div class="line">        <span class="comment">// 读取切换数据库指示</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_SELECTDB) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 数据库号</span></div><div class="line">            <span class="keyword">if</span> ((dbid = rdbLoadLen(&amp;rdb,<span class="literal">NULL</span>)) == REDIS_RDB_LENERR)</div><div class="line">                <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">// 校验</span></div><div class="line">            <span class="keyword">if</span> (dbid &gt;= (<span class="keyword">unsigned</span>)server.dbnum) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\n"</span>, server.dbnum);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 切换数据库</span></div><div class="line">            db = server.db+dbid;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* Read key */</span></div><div class="line">        <span class="comment">// 读取键</span></div><div class="line">        <span class="keyword">if</span> ((key = rdbLoadStringObject(&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        <span class="comment">/* Read value */</span></div><div class="line">        <span class="comment">// 读取值</span></div><div class="line">        <span class="keyword">if</span> ((val = rdbLoadObject(type,&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        <span class="comment">/* Check if the key already expired. This function is used when loading</span></div><div class="line"><span class="comment">         * an RDB file from disk, either at startup, or when an RDB was</span></div><div class="line"><span class="comment">         * received from the master. In the latter case, the master is</span></div><div class="line"><span class="comment">         * responsible for key expiry. If we would expire keys here, the</span></div><div class="line"><span class="comment">         * snapshot taken by the master may not be reflected on the slave. */</span></div><div class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</div><div class="line">            decrRefCount(key);</div><div class="line">            decrRefCount(val);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* Add the new object in the hash table */</span></div><div class="line">        <span class="comment">// 将键值关联到数据库内</span></div><div class="line">        dbAdd(db,key,val);</div><div class="line"></div><div class="line">        <span class="comment">/* Set the expire time if needed */</span></div><div class="line">        <span class="comment">// 设置过期时间</span></div><div class="line">        <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) setExpire(db,key,expiretime);</div><div class="line"></div><div class="line">        decrRefCount(key);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Verify the checksum if RDB version is &gt;= 5 */</span></div><div class="line">    <span class="comment">// 校验和比较</span></div><div class="line">    <span class="keyword">if</span> (rdbver &gt;= <span class="number">5</span> &amp;&amp; server.rdb_checksum) &#123;</div><div class="line">        <span class="keyword">uint64_t</span> cksum, expected = rdb.cksum;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (rioRead(&amp;rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        memrev64ifbe(&amp;cksum);</div><div class="line">        <span class="keyword">if</span> (cksum == <span class="number">0</span>) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"RDB file was saved with checksum disabled: no check performed."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != expected) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Wrong RDB checksum. Aborting now."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 结束</span></div><div class="line">    fclose(fp);</div><div class="line">    stopLoading();</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">eoferr: <span class="comment">/* unexpected end of file is handled here with a fatal exit */</span></div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Short read or OOM loading DB. Unrecoverable error, aborting now."</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Just to avoid warning */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-服务器]]></title>
      <url>/2017/07/10/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>redis运行存在一个redis服务器结构，一个服务器中保存着n个数据库。</p>
<p>dbnum由服务器配置决定，默认值为16。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></div><div class="line">    redisDb *db;  <span class="comment">// Redis的数据库</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">int</span> dbnum;  <span class="comment">// 表明数据库的数量</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></div><div class="line">    dict *dict;                 <span class="comment">/* 数据库键字典 */</span></div><div class="line">    dict *expires;              <span class="comment">/* 键过期时间字典 */</span></div><div class="line">    dict *blocking_keys;        <span class="comment">/* 处于阻塞状态的键 */</span></div><div class="line">    dict *ready_keys;           <span class="comment">/* 可以解除阻塞的键 */</span></div><div class="line">    dict *watched_keys;         <span class="comment">/* 被watch的键 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span>    <span class="comment">/* Eviction pool of keys */</span></div><div class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* 数据库编号 */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 数据库键的平均时间*/</span></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>每个redis客户端都有自己的目标数据库，当客户端执行数据库读写命令，目标数据库是这些命令的操作对象。</p>
<p>redis提供select命令来切换数据库，redisClient</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span> </div><div class="line">    <span class="keyword">int</span> fd;  <span class="comment">// 套接字描述符</span></div><div class="line">    redisDb *db; <span class="comment">// 当前正在使用的数据库</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(redisClient *c, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 校验id</span></div><div class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= server.dbnum)</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 切换客户端数据库</span></div><div class="line">    c-&gt;db = &amp;server.db[id];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><p>Redis数据库存放的数据都是以键值对形式存在，redisDB结构的dict字典保存数据库中的所有键值对，这个字典被成为键空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></div><div class="line">    dict *dict;                 <span class="comment">/* 数据库键字典 */</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>键空间的键就是数据库的键，每个键都是一个字符串对象。</p>
<p>键空间的值就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象、有序集合对象中任意一种。</p>
<h2 id="键空间的操作"><a href="#键空间的操作" class="headerlink" title="键空间的操作"></a>键空间的操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* db.c -- Keyspace access API */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeExpire</span><span class="params">(redisDb *db, robj *key)</span></span>;<span class="comment">// 移除键的过期时间</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 检查是否过期，是则删除键</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 获取过期时间</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span></span>; <span class="comment">// 设定过期时间</span></div><div class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 从db中取出键key的值</span></div><div class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 从db中取出键key的值</span></div><div class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 从db中取出键key的值</span></div><div class="line"><span class="function">robj *<span class="title">lookupKeyReadOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span></span>; <span class="comment">// 从db中取出键key的值</span></div><div class="line"><span class="function">robj *<span class="title">lookupKeyWriteOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span></span>;<span class="comment">// 从db中取出键key的值</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>;<span class="comment">// 尝试将键值对key\val添加到数据库中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 重写指定键的值,键不存在的话终止</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>;<span class="comment">// 设定指定键的值，不管存不存在</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbExists</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 判断指定键是否存在  </span></div><div class="line"><span class="function">robj *<span class="title">dbRandomKey</span><span class="params">(redisDb *db)</span></span>; <span class="comment">// 随机从数据库中取出一个键，并以字符串对象的方式返回这个键</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 从数据库中删除给定的键</span></div><div class="line"><span class="function">robj *<span class="title">dbUnshareStringValue</span><span class="params">(redisDb *db, robj *key, robj *o)</span></span>;</div><div class="line">long long emptyDb(void(callback)(void*));// 情况所有数据</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(redisClient *c, <span class="keyword">int</span> id)</span></span>; <span class="comment">// 切换db</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(redisDb *db, robj *key)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalFlushedDb</span><span class="params">(<span class="keyword">int</span> dbid)</span></span>;</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot, robj **keys, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">countKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot)</span></span>;</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">delKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">verifyClusterConfigWithData</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(redisClient *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> cursor)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseScanCursorOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> *cursor)</span></span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="键空间的初始化"><a href="#键空间的初始化" class="headerlink" title="键空间的初始化"></a>键空间的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Db-&gt;dict, keys are sds strings, vals are Redis objects. */</span></div><div class="line"><span class="comment">// 键空间的类型</span></div><div class="line">dictType dbDictType = &#123;</div><div class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></div><div class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></div><div class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></div><div class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></div><div class="line">    dictSdsDestructor,          <span class="comment">/* key destructor */</span></div><div class="line">    dictRedisObjectDestructor   <span class="comment">/* val destructor */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 服务器初始化的同时初始化键空间</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">/* Create the Redis databases, and initialize other internal state. */</span></div><div class="line">    <span class="comment">// 创建并初始化数据库结构</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line">        server.db[j].dict = dictCreate(&amp;dbDictType,<span class="literal">NULL</span>);</div><div class="line">		<span class="comment">// ...</span></div><div class="line">        server.db[j].id = j;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>有五个和查找相关的接口，代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function">robj *<span class="title">lookupKeyWriteOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span> </span>&#123;</div><div class="line"></div><div class="line">    robj *o = lookupKeyWrite(c-&gt;db, key);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!o) addReply(c,reply);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="function">robj *<span class="title">lookupKeyReadOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 查找</span></div><div class="line">    robj *o = lookupKeyRead(c-&gt;db, key);</div><div class="line"></div><div class="line">    <span class="comment">// 发送信息</span></div><div class="line">    <span class="keyword">if</span> (!o) addReply(c,reply);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 删除过期键</span></div><div class="line">    expireIfNeeded(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 查找并返回对象</span></div><div class="line">    <span class="keyword">return</span> lookupKey(db,key);</div><div class="line">&#125;</div><div class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    robj *val;</div><div class="line"></div><div class="line">    <span class="comment">// 删除过期键</span></div><div class="line">    expireIfNeeded(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 查找对象</span></div><div class="line">    val = lookupKey(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 更新命中/不命中信息</span></div><div class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</div><div class="line">        server.stat_keyspace_misses++;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        server.stat_keyspace_hits++;</div><div class="line"></div><div class="line">    <span class="comment">// 返回值</span></div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">&#125;</div><div class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 查找</span></div><div class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (de) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 取出值</span></div><div class="line">        robj *val = dictGetVal(de);</div><div class="line"></div><div class="line">        <span class="comment">// 更新时间信息</span></div><div class="line">        <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</div><div class="line">            val-&gt;lru = LRU_CLOCK();</div><div class="line"></div><div class="line">        <span class="comment">// 返回值</span></div><div class="line">        <span class="keyword">return</span> val;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</div><div class="line">    sds copy = sdsdup(key-&gt;ptr); <span class="comment">// 复制键名</span></div><div class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val); <span class="comment">// 尝试添加</span></div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,retval == REDIS_OK); <span class="comment">// 已经存在则停止</span></div><div class="line">    <span class="keyword">if</span> (val-&gt;type == REDIS_LIST) signalListAsReady(db, key);</div><div class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(key);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="修改键"><a href="#修改键" class="headerlink" title="修改键"></a>修改键</h3><p>两种方式一种重写，一种设定不管存不存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 重写指定键的值,键不存在的话终止</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>;<span class="comment">// 设定指定键的值，不管存不存在</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</div><div class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr); <span class="comment">// 查找</span></div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,de != <span class="literal">NULL</span>); <span class="comment">// 不存在，终止</span></div><div class="line">    dictReplace(db-&gt;dict, key-&gt;ptr, val); <span class="comment">// 修改旧值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lookupKeyWrite(db,key) == <span class="literal">NULL</span>) &#123;</div><div class="line">        dbAdd(db,key,val); <span class="comment">// 找不到就添加</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dbOverwrite(db,key,val); <span class="comment">// 找到就重写</span></div><div class="line">    &#125;</div><div class="line">    incrRefCount(val); <span class="comment">// 增加引用计数</span></div><div class="line">    removeExpire(db,key); <span class="comment">// 移除过期时间</span></div><div class="line">    signalModifiedKey(db,key); <span class="comment">// 发送键修改通知</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></div><div class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></div><div class="line">    <span class="comment">// 删除键的过期时间</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 删除键值对</span></div><div class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</div><div class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="键的生存时间或过期时间"><a href="#键的生存时间或过期时间" class="headerlink" title="键的生存时间或过期时间"></a>键的生存时间或过期时间</h2><p>与键空间类似redis建立了一个字典，存放每个键的对应的过期时间。在初始化的时候创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dictType keyptrDictType = &#123;</div><div class="line">    dictSdsHash,               <span class="comment">/* hash function */</span></div><div class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key dup */</span></div><div class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* val dup */</span></div><div class="line">    dictSdsKeyCompare,         <span class="comment">/* key compare */</span></div><div class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key destructor */</span></div><div class="line">    <span class="literal">NULL</span>                       <span class="comment">/* val destructor */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 创建并初始化数据库结构</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line">        server.db[j].expires = dictCreate(&amp;keyptrDictType,<span class="literal">NULL</span>);</div><div class="line">		<span class="comment">// ...</span></div><div class="line">        server.db[j].id = j;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="设定键的过期时间"><a href="#设定键的过期时间" class="headerlink" title="设定键的过期时间"></a>设定键的过期时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    dictEntry *kde, *de;</div><div class="line"></div><div class="line">    kde = dictFind(db-&gt;dict,key-&gt;ptr); <span class="comment">// 查找键</span></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,kde != <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">// 在过期时间字典中查找，没有则添加</span></div><div class="line">    de = dictReplaceRaw(db-&gt;expires,dictGetKey(kde));</div><div class="line">    dictSetSignedIntegerVal(de,when); <span class="comment">// 设置过期时间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取键的过期时间"><a href="#获取键的过期时间" class="headerlink" title="获取键的过期时间"></a>获取键的过期时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    dictEntry *de;</div><div class="line"></div><div class="line">    <span class="comment">//  如果不存在直接返回</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</div><div class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 返回过期时间</span></div><div class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除键的过期时间"><a href="#删除键的过期时间" class="headerlink" title="删除键的过期时间"></a>删除键的过期时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">     <span class="comment">// 确保键有过期时间</span></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">return</span> dictDelete(db-&gt;expires,key-&gt;ptr) == DICT_OK; <span class="comment">// 删除</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h3><p>三种策略：</p>
<ul>
<li>定时删除。定时删除占用cpu，可能使服务器长期无响应。但是对内存友好。</li>
<li>惰性删除，对键进行操作时，才删除。缺点是对内存不友好，过期键过多的话，没有及时清理。</li>
<li>定期删除。间隔依据算法确定。两者结合，主要看算法选择。</li>
</ul>
<p>redis采用定期和惰性两种删除方式。</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>redis在很多操作前都会调用expireIfNeeded进行惰性删除。例如lookupKeyRead。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</div><div class="line">    <span class="keyword">mstime_t</span> now;</div><div class="line"></div><div class="line">    <span class="comment">// 无过期时间</span></div><div class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></div><div class="line"></div><div class="line">    <span class="comment">// 正在加载不删除</span></div><div class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></div><div class="line"><span class="comment">     * blocked to when the Lua script started. This way a key can expire</span></div><div class="line"><span class="comment">     * only the first time it is accessed and not in the middle of the</span></div><div class="line"><span class="comment">     * script execution, making propagation to slaves / AOF consistent.</span></div><div class="line"><span class="comment">     * See issue #1525 on Github for more information. */</span></div><div class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</div><div class="line"></div><div class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></div><div class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></div><div class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></div><div class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></div><div class="line"><span class="comment">     * we think the key is expired at this time. */</span></div><div class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</div><div class="line"></div><div class="line">    <span class="comment">// 没过期，返回0</span></div><div class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 删除</span></div><div class="line">    server.stat_expiredkeys++;</div><div class="line">    propagateExpire(db,key);</div><div class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</div><div class="line">    <span class="keyword">return</span> dbDelete(db,key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>redis服务器周期性操作serverCron函数执行时，activeExpireCycle被调用，它在规定时间内分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-对象]]></title>
      <url>/2017/07/09/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>之前阅读了redis用到的主要的数据结构，这些数据结构是redis对象基础。redis在这些基础数据结构之上创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象五种类型的对象。</p>
<p>redis执行命令前，先判断命令是否能够执行给定命令。根据不同场合选择使用不同的数据结构。</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>redis使用对象来表示数据库中的键值，创建一个键值对时，会创建至少两个对象，一个对象用作键值对的键，一个对象用作键值对的值。</p>
<h3 id="对象的结构体"><a href="#对象的结构体" class="headerlink" title="对象的结构体"></a>对象的结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 编码</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></div><div class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 值</span></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>redis结构体使用位段结构节省空间</p>
<h4 id="类型type"><a href="#类型type" class="headerlink" title="类型type"></a>类型type</h4><p>记录redis对象类型，五种类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0 <span class="comment">// 字符串对象</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1 <span class="comment">// 列表对象</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2 <span class="comment">// 哈希对象</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3 <span class="comment">// 集合对象</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4 <span class="comment">// 有序集合对象</span></span></div></pre></td></tr></table></figure>
<h4 id="编码encoding"><a href="#编码encoding" class="headerlink" title="编码encoding"></a>编码encoding</h4><p>记录redis对象的编码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象编码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* 简单动态字符串 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* long类型的整数 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* 字典 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3  <span class="comment">/* zipmap 3.2.5不再使用 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* 双端队列 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* 压缩列表 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* 整数集合 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* 跳跃表 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8  <span class="comment">/* EMBSTR编码的简单字符串 */</span></span></div></pre></td></tr></table></figure>
<p>每种类型对应至少两种不同的编码。</p>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>编码方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW ,REDIS_ENCODING_INT ,REDIS_ENCODING_EMBSTR</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST ,REDIS_ENCODING_ZIPLIST</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET ,REDIS_ENCODING_HT</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_SKIPLIST</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST ,REDIS_ENCODING_HT</td>
</tr>
</tbody>
</table>
<h4 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h4><p>表示对象的最后一次访问时间。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>常见的管理方式，引用计数为0时回收。</p>
<a id="more"></a>
<h2 id="对象的API"><a href="#对象的API" class="headerlink" title="对象的API"></a>对象的API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span></span>; <span class="comment">// 引用计数-1，降为0时释放对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCountVoid</span><span class="params">(<span class="keyword">void</span> *o)</span></span>; <span class="comment">// 用于特定数据结构的释放</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span></span>; <span class="comment">// 引用计数+1</span></div><div class="line"><span class="function">robj *<span class="title">resetRefCount</span><span class="params">(robj *obj)</span></span>; <span class="comment">// 设置引用计数为0</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放字符串对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放列表对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span></span>;  <span class="comment">// 释放集合对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放有序集合对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放hash对象</span></div><div class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 创建一个新robj对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建一个字符串对象，根据大小选择编码</span></div><div class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;<span class="comment">// 创建一个 REDIS_ENCODING_RAW 编码的字符对象</span></div><div class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;<span class="comment">// 创建一个 REDIS_ENCODING_EMBSTR 编码的字符对象</span></div><div class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 复制一个字符串对象</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isObjectRepresentableAsLongLong</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *llongval)</span></span>; <span class="comment">// 检查对象的值是否为Long long</span></div><div class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span></span>; <span class="comment">// 尝试对字符串对象编码，以节约内存</span></div><div class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 返回一个对象的编码版本</span></div><div class="line"><span class="keyword">size_t</span> stringObjectLen(robj *o); <span class="comment">// 返回字符串对象的字符串值的长度</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>; <span class="comment">// 根据传入的值，创建一个字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value, <span class="keyword">int</span> humanfriendly)</span></span>; <span class="comment">// 根据传入的值，创建一个字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个linkedlist编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个ziplist编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个ht编码的集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个intset编码的集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个ziplist编码的哈希对象</span></div><div class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个skiplist编码的有序集合</span></div><div class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个ziplist编码的有序集合</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// 尝试从对象中获取Long类型值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkType</span><span class="params">(redisClient *c, robj *o, <span class="keyword">int</span> type)</span></span>; <span class="comment">// 检查对象0的类型是否和type相同</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// 尝试从对象中取出整数值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// 尝试从对象中取出double值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target)</span></span>; <span class="comment">// 尝试从对象中获取整数值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongDoubleFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">double</span> *target)</span></span>; <span class="comment">// 尝试从对象获取long double值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongDoubleFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// 尝试从对象获取long double值</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strEncoding</span><span class="params">(<span class="keyword">int</span> encoding)</span></span>; <span class="comment">// 返回编码的字符串表示</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 二进制方式比较两个字符串对象</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">collateStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 以collation方式比较两个字符串对象</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">equalStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 判断是否相同两个字符串对象</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span></span>; <span class="comment">// 计算对象的闲置时间</span></div></pre></td></tr></table></figure>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>对象的创建都比较类似，一般创建底层数据结构，然后创建对象。然后初始化。</p>
<p>以string对象为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="comment">// 长度小于39时使用EMBSTR</span></div><div class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</div><div class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 创建一个embstr编码的字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="comment">// 直接分配一个连续空间长度为redis和字符串结构+字符串保存内存</span></div><div class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(struct sdshdr)+len+<span class="number">1</span>);</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">o</span>+1);</span> <span class="comment">// 找到字符串的起始位置</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化字符串</span></div><div class="line">    o-&gt;type = REDIS_STRING;</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_EMBSTR;</div><div class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</div><div class="line">    o-&gt;refcount = <span class="number">1</span>;</div><div class="line">    o-&gt;lru = LRU_CLOCK();</div><div class="line"></div><div class="line">    sh-&gt;len = len;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (ptr) &#123;</div><div class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</div><div class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个 REDIS_ENCODING_RAW 编码的字符对象</span></div><div class="line"><span class="comment">// 对象的指针指向一个 sds 结构</span></div><div class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">  	<span class="comment">// sdsnewlen新建字符串</span></div><div class="line">    <span class="keyword">return</span> createObject(REDIS_STRING,sdsnewlen(ptr,len));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个新对象</span></div><div class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"></div><div class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</div><div class="line"></div><div class="line">    o-&gt;type = type;</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_RAW;</div><div class="line">    o-&gt;ptr = ptr;</div><div class="line">    o-&gt;refcount = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution). */</span></div><div class="line">    o-&gt;lru = LRU_CLOCK();</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象的释放"><a href="#对象的释放" class="headerlink" title="对象的释放"></a>对象的释放</h3><p>以字符串对象为例子，redis采用引用计数进行对象的释放，当对象不再使用时调用decrRefCount减少引用计数，在引用计数减到0后，释放对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</div><div class="line">        <span class="comment">// 根据类型释放 各个函数会调用各自的释放函数释放</span></div><div class="line">        <span class="keyword">case</span> REDIS_STRING: freeStringObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_LIST: freeListObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_SET: freeSetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_HASH: freeHashObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>: redisPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        zfree(o); <span class="comment">// 释放对象内存</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        o-&gt;refcount--;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果时RAW编码调用sdsfree释放，否则在释放robj时就释放了，因为采用了embstr编码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</div><div class="line">        sdsfree(o-&gt;ptr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>字符串编码可以是Int、raw或者embstr。</p>
<p>字符串对象为整数值，可以用long long类型表示，则为int编码。</p>
<p>字符串对象为浮点数，能够用long double类型表示，使用embstr还是raw根据长度来定。</p>
<p>如果一个字符串对象小于等于REDIS_ENCODING_EMBSTR_SIZE_LIMIT则用embstr编码。</p>
<p>大于REDIS_ENCODING_EMBSTR_SIZE_LIMIT采用raw编码。</p>
<p>int编码在执行一个会将int转变为字符串值时，编码变为raw。</p>
<p>embstr为只读的，当尝试修改时会转换为raw。</p>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象编码是ziplist或者linkedlist。</p>
<p>满足以下两个条件使用ziplist：</p>
<ul>
<li>保存的字符串长度都小于64</li>
<li>元素数量小于512</li>
</ul>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象编码是ziplist或者hashtable。</p>
<p>如果采用的是ziplist那么添加键值时，先将键推入压缩列表表尾部，再将值推入压缩列表表尾。</p>
<p>如果采用hashtable编码，那么字典的键就是键值对的键的字符串对象，字典的值时键值对的值。</p>
<p>满足以下两个条件使用ziplist：</p>
<ul>
<li>保存的字符串长度都小于64</li>
<li>元素数量小于512</li>
</ul>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合的编码是inset或者hashtable</p>
<p>满足以下条件使用intset编码：</p>
<ul>
<li>集合对象保存的值都为整数</li>
<li>集合对象保存的元素不超过512个</li>
</ul>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合编码是ziplist或者skiplist。</p>
<p>skiplist编码使用一个zskiplist和dict作为底层实现。zskiplist按照分值从大到小保存集合元素。dict保存从成员到分值的映射。</p>
<p>满足以下条件使用ziplist编码：</p>
<ul>
<li>有序集合保存的元素小于128个。</li>
<li>有序集合保存的所有元素成员的长度都小于64字节。</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>对象的命令处理在redis.h中。<br>执行命令之前会检查对象的类型，是否能够执行该命令。<br>如果能就调用对象的命令处理函数,否则返回错误。</p>
<p>在调用了对象的命令处理函数之后，则根据命令具体的编码，去选择使用什么底层数据结构的接口来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* Commands prototypes */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">authCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pingCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">echoCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">psetexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">delCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">existsCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbitCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getbitCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrbyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyfloatCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomkeyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">keysCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbsizeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lastsaveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgsaveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgrewriteaofCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdownCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">renameCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">renamenxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linsertCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lindexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltrimCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">typeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sremCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoveCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sismemberCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scardCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">srandmemberCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sscanCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushdbCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushallCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lremCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpoplpushCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">infoCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mgetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireatCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pexpireCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pexpireatCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ttlCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pttlCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">persistCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slaveofCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">debugCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetnxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincrbyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebyscoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebyscoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebylexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebylexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcountCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlexcountCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcardCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyscoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebylexCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">blpopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpoplpushCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">strlenCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrankCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrankCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetnxCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmsetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmgetCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdelCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hlenCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyrankCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zunionstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zinterstoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscanCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hkeysCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hvalsCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetallCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexistsCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hscanCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">configCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hincrbyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hincrbyfloatCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">psubscribeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">punsubscribeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pubsubCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">migrateCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">askingCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readonlyCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readwriteCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">evalCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">evalShaCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scriptCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitopCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitcountCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitposCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">replconfCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfselftestCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfaddCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfcountCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfmergeCommand</span><span class="params">(redisClient *c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfdebugCommand</span><span class="params">(redisClient *c)</span></span>;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-压缩列表ziplist]]></title>
      <url>/2017/07/08/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/</url>
      <content type="html"><![CDATA[<p>压缩列表时列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么是小整数，要么是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><p>压缩列表是redis为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">《redis设计与实现》</div><div class="line">空白 ziplist 示例图</div><div class="line"></div><div class="line">area        |&lt;---- ziplist header ----&gt;|&lt;-- end --&gt;|</div><div class="line"></div><div class="line">size          4 bytes   4 bytes 2 bytes  1 byte</div><div class="line">            +---------+--------+-------+-----------+</div><div class="line">component   | zlbytes | zltail | zllen | zlend     |</div><div class="line">            |         |        |       |           |</div><div class="line">value       |  1011   |  1010  |   0   | 1111 1111 |</div><div class="line">            +---------+--------+-------+-----------+</div><div class="line">                                       ^</div><div class="line">                                       |</div><div class="line">                               ZIPLIST_ENTRY_HEAD</div><div class="line">                                       &amp;</div><div class="line">address                        ZIPLIST_ENTRY_TAIL</div><div class="line">                                       &amp;</div><div class="line">                               ZIPLIST_ENTRY_END</div><div class="line"></div><div class="line">非空 ziplist 示例图</div><div class="line"></div><div class="line">area        |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|</div><div class="line"></div><div class="line">size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte</div><div class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</div><div class="line">component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |</div><div class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</div><div class="line">                                       ^                          ^        ^</div><div class="line">address                                |                          |        |</div><div class="line">                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END</div><div class="line">                                                                  |</div><div class="line">                                                        ZIPLIST_ENTRY_TAIL</div></pre></td></tr></table></figure>
<p>zlbytes记录整个压缩列表占用的字节数。</p>
<p>zltail记录压缩列表尾节点距离压缩列表的起始地址有多少字节。</p>
<p>zzlen记录压缩列表包含的节点数量。</p>
<p>entryX列表节点，数量不定。</p>
<p>zlend特殊值0xff，标记压缩列表末端。</p>
<a id="more"></a>
<h2 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h2><p>每个压缩列表可以保存一个字节数组或者一个整数值，字节数组可以有三种长度：</p>
<ol>
<li>长度小于等于63字节的字节数组</li>
<li>长度小于等于16383字节的字节数组</li>
<li>长度小于等于4294967295字节的字节数组</li>
</ol>
<p>每个压缩列表节点由previous_entry_length、encoding、content三个部分组成。</p>
<h3 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h3><p>节点previous_entry_length属性以字节为单位，记录一个压缩列表节点的长度。previous_entry_length属性的长度可以是1字节或者5字节：</p>
<ul>
<li>如果前一节点的长度小于254字节，长度为1,前一节点长度保存在这个字节里面。</li>
<li>如果前一节点的长度大于 等于254字节，长度为5：属性的第一个字节被设置为0xfe，而之后的四个字节用于保存前一 节点的长度。</li>
</ul>
<h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>记录节点的content属性所保存数据类型以及长度：</p>
<ul>
<li>一字节、两字节或者五字节长，值的最高位为00、01或者10的是 字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录</li>
<li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数数值，整数值的类型和长度由编码除去最高两位之后的其他位记录。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">编码</th>
<th>编码长度</th>
<th>content属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">00bbbbbb</td>
<td>1 bytes</td>
<td>&lt;= 63 bytes的字节数组</td>
</tr>
<tr>
<td style="text-align:left">01bbbbbb xxxxxxxx</td>
<td>2 bytes</td>
<td>&lt;= 16383 bytes字节数组</td>
</tr>
<tr>
<td style="text-align:left">10<strong>__</strong> aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td>5 bytes</td>
<td>&lt;= 4294967295 bytes字节数组</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11000000</td>
<td>1</td>
<td>int16_t（2 bytes）类型整数</td>
</tr>
<tr>
<td>11010000</td>
<td>1</td>
<td>int32_t（4 bytes）类型整数</td>
</tr>
<tr>
<td>11100000</td>
<td>1</td>
<td>int64_t（8 bytes）类型整数</td>
</tr>
<tr>
<td>11110000</td>
<td>1</td>
<td>24位有符整数</td>
</tr>
<tr>
<td>11111110</td>
<td>1</td>
<td>8位有符整数</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1</td>
<td>0~12</td>
</tr>
</tbody>
</table>
<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>previous_entry_length属性的长度可以是1字节或者5字节：</p>
<ul>
<li>如果前一节点的长度小于254字节，长度为1,前一节点长度保存在这个字节里面。</li>
<li>如果前一节点的长度大于 等于254字节，长度为5：属性的第一个字节被设置为0xfe，而之后的四个字节用于保存前一 节点的长度。</li>
</ul>
<p>那么一种情况：在压缩列表中，有多个连续的长度介于250字节到253字节之间的节点e1至eN。</p>
<p>在e1前插入一个大于254字节的节点，此时要更新e1的previous_entry_length属性，由于前一个节点大于254，那么要扩容，重新设置好压缩列表。之后又发现e2需要更新previous_entry_length属性，依旧大于254。产生了连锁反应。</p>
<p>同理删除节点也可能发生这种情况。</p>
<h2 id="压缩列表API"><a href="#压缩列表API" class="headerlink" title="压缩列表API"></a>压缩列表API</h2><h3 id="创建空ziplist"><a href="#创建空ziplist" class="headerlink" title="创建空ziplist"></a>创建空ziplist</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个空的ziplist</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">// ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小</span></div><div class="line">    <span class="comment">// 1 字节是表末端 ZIP_END 的大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</div><div class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes); <span class="comment">// 设置ziplist所占字节数，如有必要进行大小端转换</span></div><div class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE); <span class="comment">// 设定尾节点相对头部的偏移量</span></div><div class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>; <span class="comment">// 设定ziplist的节点数</span></div><div class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END; <span class="comment">// 设定尾部字节位0xff</span></div><div class="line">    <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将长度为slen的字符串s插入到z1中，位置为p前</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</div><div class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen; <span class="comment">// 当前ziplist长度，插入后的长度</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>; <span class="comment">// 前置节点长度和编码该长度所需要的长度</span></div><div class="line">    <span class="keyword">size_t</span> offset;</div><div class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value</span></div><div class="line"><span class="comment">                                    that is easy to see if for some reason</span></div><div class="line"><span class="comment">                                    we use it uninitialized. */</span></div><div class="line">    zlentry tail;</div><div class="line"></div><div class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></div><div class="line">    <span class="comment">// 找到待插入节点的前置节点长度</span></div><div class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">        <span class="comment">// 不为末尾解码长度</span></div><div class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 指向末尾则表示ziplist为空</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</div><div class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">            <span class="comment">// 计算尾节点长度</span></div><div class="line">            prevlen = zipRawEntryLength(ptail);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断编码是否为整数</span></div><div class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</div><div class="line">        <span class="comment">// 该节点编码为整数，通过encoding来获取编码长度</span></div><div class="line">        reqlen = zipIntSize(encoding);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 使用字符串来编码节点</span></div><div class="line">        reqlen = slen;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// 计算前置节点长度所需的大小</span></div><div class="line">    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</div><div class="line">    <span class="comment">// 计算编码当前节点值所需要的大小</span></div><div class="line">    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</div><div class="line"></div><div class="line">    <span class="comment">// 保存新旧编码之间的字节差</span></div><div class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</div><div class="line"></div><div class="line">    offset = p-zl; <span class="comment">// 保存偏移</span></div><div class="line">    <span class="comment">// 重分配长度</span></div><div class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</div><div class="line">    p = zl+offset;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 移动元素，为新元素腾出位置</span></div><div class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</div><div class="line"></div><div class="line">        <span class="comment">// 将新节点的长度编码到后置节点</span></div><div class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</div><div class="line"></div><div class="line">        <span class="comment">// 更新尾部的偏移量</span></div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</div><div class="line"></div><div class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></div><div class="line"><span class="comment">         * "nextdiff" in account as well. Otherwise, a change in the</span></div><div class="line"><span class="comment">         * size of prevlen doesn't have an effect on the *tail* offset. */</span></div><div class="line">        tail = zipEntry(p+reqlen);</div><div class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* This element will be the new tail. */</span></div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></div><div class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></div><div class="line">    <span class="comment">// 判断是不是需要连锁更新</span></div><div class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</div><div class="line">        offset = p-zl;</div><div class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</div><div class="line">        p = zl+offset;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Write the entry */</span></div><div class="line">    <span class="comment">// 写入节点前置节点长度</span></div><div class="line">    p += zipPrevEncodeLength(p,prevlen);</div><div class="line">    <span class="comment">// 节点值的长度写入节点</span></div><div class="line">    p += zipEncodeLength(p,encoding,slen);</div><div class="line">    <span class="comment">// 写入节点值</span></div><div class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</div><div class="line">        <span class="built_in">memcpy</span>(p,s,slen);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        zipSaveInteger(p,value,encoding);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新节点计数器</span></div><div class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="根据给定索引，遍历列表，并返回索引指定节点的指针。"><a href="#根据给定索引，遍历列表，并返回索引指定节点的指针。" class="headerlink" title="根据给定索引，遍历列表，并返回索引指定节点的指针。"></a>根据给定索引，遍历列表，并返回索引指定节点的指针。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistIndex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</div><div class="line">    <span class="comment">// index为负从尾部，正从头部</span></div><div class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">        index = (-index)<span class="number">-1</span>;</div><div class="line">        <span class="comment">// 获取尾部指针</span></div><div class="line">        p = ZIPLIST_ENTRY_TAIL(zl);</div><div class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">            <span class="comment">// 解码前置节点长度</span></div><div class="line">            ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</div><div class="line">            <span class="keyword">while</span> (prevlen &gt; <span class="number">0</span> &amp;&amp; index--) &#123;</div><div class="line">                p -= prevlen; <span class="comment">// 偏移</span></div><div class="line">                <span class="comment">// 解码前置节点长度</span></div><div class="line">                ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        p = ZIPLIST_ENTRY_HEAD(zl); <span class="comment">// 头部</span></div><div class="line">        <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END &amp;&amp; index--) &#123;</div><div class="line">            p += zipRawEntryLength(p); <span class="comment">// 移动</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回</span></div><div class="line">    <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END || index &gt; <span class="number">0</span>) ? <span class="literal">NULL</span> : p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除给定节点"><a href="#删除给定节点" class="headerlink" title="删除给定节点"></a>删除给定节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> offset = *p-zl;</div><div class="line">    zl = __ziplistDelete(zl,*p,<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Store pointer to current element in p, because ziplistDelete will</span></div><div class="line"><span class="comment">     * do a realloc which might result in a different "zl"-pointer.</span></div><div class="line"><span class="comment">     * When the delete direction is back to front, we might delete the last</span></div><div class="line"><span class="comment">     * entry and end up with "p" pointing to ZIP_END, so check this. */</span></div><div class="line">    *p = zl+offset;</div><div class="line">    <span class="keyword">return</span> zl;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistDelete(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> num) &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, totlen, deleted = <span class="number">0</span>;</div><div class="line">    <span class="keyword">size_t</span> offset;</div><div class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</div><div class="line">    zlentry first, tail;</div><div class="line"></div><div class="line">    <span class="comment">// 计算被删除节点总共占用的内存字节数</span></div><div class="line">    <span class="comment">// 删除的节点总数</span></div><div class="line">    first = zipEntry(p);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; p[<span class="number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</div><div class="line">        p += zipRawEntryLength(p);</div><div class="line">        deleted++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    totlen = p-first.p; <span class="comment">// 被删除节点总共占用内存字节数</span></div><div class="line">    <span class="keyword">if</span> (totlen &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 计算新旧前置节点字节数差</span></div><div class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</div><div class="line">            p -= nextdiff; <span class="comment">// 有需要将p后退nextdiff字节，为新header空出空间</span></div><div class="line">            zipPrevEncodeLength(p,first.prevrawlen); <span class="comment">// 将first的前置节点长度编码至p中</span></div><div class="line"></div><div class="line">            <span class="comment">/* Update offset for tail */</span></div><div class="line">            <span class="comment">// 更新尾部偏移</span></div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</div><div class="line"></div><div class="line">            <span class="comment">/* When the tail contains more than one entry, we need to take</span></div><div class="line"><span class="comment">             * "nextdiff" in account as well. Otherwise, a change in the</span></div><div class="line"><span class="comment">             * size of prevlen doesn't have an effect on the *tail* offset. */</span></div><div class="line">            <span class="comment">// 被删除节点之后还存在节点，就需要将nextdiff计算在内</span></div><div class="line">            tail = zipEntry(p);</div><div class="line">            <span class="keyword">if</span> (p[tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">                ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Move tail to the front of the ziplist */</span></div><div class="line">            <span class="comment">// 将删除节点后面内存空间移动到删除节点之后</span></div><div class="line">            memmove(first.p,p,</div><div class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)<span class="number">-1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* The entire tail was deleted. No need to move memory. */</span></div><div class="line">            <span class="comment">// 被删除节点后无节点，不需要移动</span></div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Resize and update length */</span></div><div class="line">        <span class="comment">// 更新ziplist长度</span></div><div class="line">        offset = first.p-zl;</div><div class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</div><div class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</div><div class="line">        p = zl+offset;</div><div class="line"></div><div class="line">        <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></div><div class="line"><span class="comment">         * we need to cascade the update throughout the ziplist */</span></div><div class="line">         <span class="comment">// 看看是否需要连锁更新</span></div><div class="line">        <span class="keyword">if</span> (nextdiff != <span class="number">0</span>)</div><div class="line">            zl = __ziplistCascadeUpdate(zl,p);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体上ziplist设计出来的目的是为了节省内存，采用了在连续内存空间上建立一个双向列表来实现。</p>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-整数集合]]></title>
      <url>/2017/07/08/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<p>创建一个只包含整数值元素的集合，同时元素数量不多时，redis会使用整数集合作为键的底层实现。</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></div><div class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 元素数量</span></div><div class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">// 保存元素的数组</span></div><div class="line">&#125; intset;</div></pre></td></tr></table></figure>
<p>encoding表示整数集合的编码模式，目前提供三种模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>整数集合有三种编码模式，为了能够节省空间，一般采用能够符合所有元素要求的编码。</p>
<p>当新添加元素比整数集合中现有元素类型都长，那么就需要进行升级，将编码位数提升，负荷新添加元素类型长度。</p>
<p>步骤：</p>
<ol>
<li><p>根据新元素的类型，扩展整数集合底层数组空间大小，并为新元素分配空间。</p>
</li>
<li><p>将底层数组现有的所有元素都转换为新元素相同的类型，并将类型转换后的元素放置到正确的位置上。</p>
</li>
<li><p>将新元素添加到数组中。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding); <span class="comment">// 当前编码</span></div><div class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value); <span class="comment">// 获取编码</span></div><div class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length); <span class="comment">// 元素数量</span></div><div class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 根据情况判断添加到数组的最前还是最后（要升级只有这种可能）</span></div><div class="line"></div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc); <span class="comment">// 更新编码方式</span></div><div class="line">    <span class="comment">// 重新分配空间</span></div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 从后往前重新编码</span></div><div class="line">    <span class="keyword">while</span>(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    <span class="comment">// 根据情况添加到尾部后者头部</span></div><div class="line">    <span class="keyword">if</span> (prepend)</div><div class="line">        _intsetSet(is,<span class="number">0</span>,value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配空间</span></div><div class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</div><div class="line">    <span class="comment">// 设置初始编码</span></div><div class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);</div><div class="line">    <span class="comment">// 初始化元素数量</span></div><div class="line">    is-&gt;length = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>判断数据大小，如果超出现有编码的范围，升级。</p>
<p>如果没有，则插入到指定位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value); <span class="comment">// 计算新插入值编码</span></div><div class="line">    <span class="keyword">uint32_t</span> pos;</div><div class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果需要则升级</span></div><div class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</div><div class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 查找，如果存在返回失败信息</span></div><div class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> is;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 重新分配空间</span></div><div class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">        <span class="comment">// 如果插入中间位置，则将该位置之后的值移动到尾部</span></div><div class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置值</span></div><div class="line">    _intsetSet(is,pos,value);</div><div class="line"></div><div class="line">    <span class="comment">// 计数器增加</span></div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="移除数据"><a href="#移除数据" class="headerlink" title="移除数据"></a>移除数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value); <span class="comment">// 计算编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> pos;</div><div class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 查找值，并删除</span></div><div class="line">    <span class="keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">        <span class="keyword">uint32_t</span> len = intrev32ifbe(is-&gt;length);</div><div class="line">        <span class="comment">// 删除成功标志</span></div><div class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</div><div class="line">        <span class="comment">// 删除数据</span></div><div class="line">        <span class="keyword">if</span> (pos &lt; (len<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</div><div class="line">        <span class="comment">// 调整内存大小</span></div><div class="line">        is = intsetResize(is,len<span class="number">-1</span>);</div><div class="line">        <span class="comment">// 更新length值</span></div><div class="line">        is-&gt;length = intrev32ifbe(len<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><ol>
<li>intsetFind 判断值是否在集合中</li>
<li>intsetRandom 随机返回整数集合中的一个数</li>
<li>intsetGet 取出底层数组在给定索引上的元素</li>
<li>intsetLen 返回整数集合中的元素个数</li>
<li>intsetloblen 返回整数集合占用的内存字节数</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-跳跃表]]></title>
      <url>/2017/07/08/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>跳跃表一种有序数据结构，每个节点维护多个指向其他节点的指针，达到快速访问节点的目的。</p>
<p>大部分情况下跳跃表的效率可以和平衡数媲美，实现比平衡树简单，不少程序使用跳跃表来代替平衡树。</p>
<p>跳跃表有时会作为有序集合的实现。以分值排序。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳跃表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></div><div class="line">    robj *obj; <span class="comment">// 保存的对象</span></div><div class="line">    <span class="keyword">double</span> score; <span class="comment">// 分值 跳跃表按照分值进行排序</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 上一节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span; <span class="comment">// 跨度 记录两个节点之间的距离</span></div><div class="line">    &#125; level[]; <span class="comment">// 层</span></div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line"><span class="comment">// 跳跃表</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// 头、尾指针</span></div><div class="line">    PORT_ULONG length; <span class="comment">// 跳跃表长度</span></div><div class="line">    <span class="keyword">int</span> level; <span class="comment">// 层数最大节点层数</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<h2 id="跳跃表的创建"><a href="#跳跃表的创建" class="headerlink" title="跳跃表的创建"></a>跳跃表的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建节点</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// 申请内存</span></div><div class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</div><div class="line">    zn-&gt;score = score; <span class="comment">// 赋值分数</span></div><div class="line">    zn-&gt;obj = obj; <span class="comment">// 设定成员对象</span></div><div class="line">    <span class="keyword">return</span> zn;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建跳跃表</span></div><div class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    <span class="comment">// 申请内存</span></div><div class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</div><div class="line">    zsl-&gt;level = <span class="number">1</span>; <span class="comment">// 设置层数初始为1</span></div><div class="line">    zsl-&gt;length = <span class="number">0</span>; <span class="comment">// 设置长度初始为0</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建头节点 层数为32 分数为0</span></div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 将每层的forward指针指向null，跨度0</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</div><div class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设定backward指向null</span></div><div class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</div><div class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>逻辑是先找到节点插入位置，插入位置前一个节点的信息。<br>插入，并更新前一节点信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个成员为obj，分值为score的新节点</span></div><div class="line"><span class="comment">// 将新节点插入到跳跃表中</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// updata[]数组记录每一层位于插入节点的前一个节点</span></div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="comment">// rank[]记录每一层位于插入节点的前一个节点的排名</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    <span class="keyword">int</span> i, level;</div><div class="line"></div><div class="line">    redisAssert(!isnan(score));</div><div class="line">    x = zsl-&gt;header; <span class="comment">// 表头节点</span></div><div class="line">    <span class="comment">// 从最高层开始查找</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">// i == (zsl-&gt;level-1) 为0</span></div><div class="line">        <span class="comment">//否则第i层起始rank值为i+1的rank值</span></div><div class="line">        <span class="comment">// 最终rank[0]的值+1就是新节点的前置节点排位</span></div><div class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</div><div class="line">        <span class="comment">// 沿着前几指针遍历跳跃表</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            <span class="comment">// 比对分值</span></div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                <span class="comment">// 比对成员</span></div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 记录沿途跨越多少节点</span></div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            <span class="comment">// 移动到下一个指针</span></div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 记录将要和新节点相连接的节点</span></div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">       *</div><div class="line">    <span class="comment">// zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</span></div><div class="line">    <span class="comment">// 所以这里不需要进一步进行检查，可以直接创建新元素。</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取一个随机值作为新节点的层数</span></div><div class="line">    level = zslRandomLevel();</div><div class="line"></div><div class="line">    <span class="comment">// 如果新节点的层数比其他节点层数大</span></div><div class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</div><div class="line">        <span class="comment">// 初始化未使用层</span></div><div class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = <span class="number">0</span>;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 创建新节点</span></div><div class="line">    x = zslCreateNode(level,score,obj);</div><div class="line"></div><div class="line">    <span class="comment">// 将前面记录的指针指向新节点，并做相应的设置</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 设置新节点的前进指针</span></div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        update[i]-&gt;level[i].forward = x; <span class="comment">// 将沿途记录的各个节点的前进指针指向新节点</span></div><div class="line"></div><div class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></div><div class="line">        <span class="comment">// 计算新节点跨越的节点数量</span></div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</div><div class="line">        <span class="comment">// 更新新节点插入后，沿途节点的span值</span></div><div class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* increment span for untouched levels */</span></div><div class="line">    <span class="comment">// 未接触的节点的span值也需要增加1，这些节点从表头指向新节点</span></div><div class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置新节点的后退指针</span></div><div class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        zsl-&gt;tail = x;</div><div class="line"></div><div class="line">    <span class="comment">// 长度+1</span></div><div class="line">    zsl-&gt;length++;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>Redis提供三种删除跳跃表节点的方式：</p>
<ol>
<li><p>根据给定分值和成员来删除节点，zslDelete。</p>
</li>
<li><p>根据给定分值来删除节点，zslDeleteByScore。</p>
</li>
<li><p>根据给定排名来删除节点，zslDeleteByRank。</p>
</li>
</ol>
<p>删除操作均由zslDeleteNode执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 更新所有和被删除节点x有关的节点指针，解除它们之间的关系</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新被删除节点x的前进后退指针</span></div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新跳跃表的最大层数</span></div><div class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</div><div class="line">        zsl-&gt;level--;</div><div class="line"></div><div class="line">    <span class="comment">// 计数器-1</span></div><div class="line">    zsl-&gt;length--;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据节点的分值和成员删除节点,其余两种情况只是查找方法与判断方式不同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历跳跃表，查找目标节点，并记录所有沿途及节点</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 分值和对象相同时，将其删除</span></div><div class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</div><div class="line">        zslDeleteNode(zsl, x, update);</div><div class="line">        zslFreeNode(x);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查找给定分值和成员对象的节点在跳跃表中的排位"><a href="#查找给定分值和成员对象的节点在跳跃表中的排位" class="headerlink" title="查找给定分值和成员对象的节点在跳跃表中的排位"></a>查找给定分值和成员对象的节点在跳跃表中的排位</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历整个跳跃表</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历节点并对比元素</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                <span class="comment">// 比对分值</span></div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                <span class="comment">// 比对成员对象</span></div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 累积跨越的节点数量</span></div><div class="line">            rank += x-&gt;level[i].span;</div><div class="line"></div><div class="line">            <span class="comment">// 沿着前进指针遍历跳跃表</span></div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 必须确保不仅分值相等，而且成员对象也要相等</span></div><div class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</div><div class="line">            <span class="keyword">return</span> rank;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 没找到</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-字典]]></title>
      <url>/2017/06/30/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%AD%97%E5%85%B8/</url>
      <content type="html"><![CDATA[<p>Redis字典由哈希表实现的保存键值对的抽象数据结构。</p>
<p>实现文件在dict.h\dict.c中。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>Redis字典结构体定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *key;<span class="comment">// key 键</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">        <span class="keyword">double</span> d;</div><div class="line">    &#125; v;<span class="comment">// 值，支持多种类型,使用联合。</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">// 下一个点 采用链式来解决索引冲突问题</span></div><div class="line">&#125; dictEntry;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;<span class="comment">// hash函数</span></div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">// key复制函数</span></div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);<span class="comment">// value复制函数</span></div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);<span class="comment">// key比较函数</span></div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);<span class="comment">// key释放函数</span></div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);<span class="comment">// value释放函数</span></div><div class="line">&#125; dictType;</div><div class="line"></div><div class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></div><div class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></div><div class="line">    dictEntry **table;<span class="comment">// 指针的数组头的指针</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;<span class="comment">// 大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">// 大小的掩码 总是等于size-1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;<span class="comment">// 被使用的节点数</span></div><div class="line">&#125; dictht;<span class="comment">// hash表</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></div><div class="line">    dictType *type;<span class="comment">// 绑定的函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;<span class="comment">// 私有数据</span></div><div class="line">    dictht ht[<span class="number">2</span>];<span class="comment">// hash表，一般只使用[0]，在rehash的时候使用[1]</span></div><div class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">// 记录rehash的进度，不进行rehash的时候为-1</span></div><div class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></div><div class="line">&#125; dict;<span class="comment">// 字典</span></div><div class="line"></div><div class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></div><div class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></div><div class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></div><div class="line"><span class="comment"> * should be called while iterating. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></div><div class="line">    dict *d;</div><div class="line">    <span class="keyword">long</span> index;</div><div class="line">    <span class="keyword">int</span> table, safe;</div><div class="line">    dictEntry *entry, *nextEntry;</div><div class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</div><div class="line">&#125; dictIterator;<span class="comment">// 迭代器</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>确认一个键值插入到字典的位置是哪，需要调用hash算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算key的hash值</span></div><div class="line">hash = dict-&gt;type-&gt;hashFunction(key);</div><div class="line"><span class="comment">//按位与确认在hash表中的位置</span></div><div class="line"><span class="comment">//根据情况，可能是ht[0]或者ht[1]</span></div><div class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</div></pre></td></tr></table></figure>
<p>字典在redis中使用MurmurHash2算法进行计算键的哈希值。有点在于计算速度非常快，即使输入的键有规律也能够很好的给出一个随机分布。</p>
<h2 id="键的冲突解决"><a href="#键的冲突解决" class="headerlink" title="键的冲突解决"></a>键的冲突解决</h2><p>在key获取的index相同的情况下，产生了键的冲突。redis采用链式解决冲突，新的键值放在链的头部。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着hash表不断插入删除数据，hash表的负载因子会不断变化。当负载因子在一个不合理的范围内，则redis的会对hash表进行rehash。</p>
<h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><p>渐进式rehash的目的是为了防止一次性rehash的情况下，服务器停止响应。</p>
<p>redis渐进式rehash的步骤:</p>
<p>1）为ht[1]分配空间，让字典同时持有 ht[0]和ht[1]两个哈希表</p>
<p>2）在字典位置一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</p>
<p>3）在rehash进行期间，每次对字典执行删除、添加、查找或者更新操作时候，程序除了执行指定的操作外，还顺便将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后将rehashidx属性的值增加1</p>
<p>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehsh至ht[1]，这时程序将rehashidx属性值设为-1，表示rehash操作已完成。</p>
<p>渐进式rehash过程中，字典会同时对ht[0]和ht[1]两个哈希表进行操作，字典在删除、查找、更新等操作会在两个哈希表进行。</p>
<p>在渐进式rehash执行期间，新添加到字典的键值对一律会被保存在ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减少不增加，并随着rehash操作的执行最终变为空。</p>
<p>rehash有两种方式，一种是单步，在字典没有安全迭代器的情况下能够执行。一种是执行一段时间跳出。两种方法均调用int dictRehash(dict *d, int n) 完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</div><div class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</div><div class="line">    <span class="comment">// 开始时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</div><div class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</div><div class="line">        rehashes += <span class="number">100</span>;</div><div class="line">        <span class="comment">// 时间到达，跳出</span></div><div class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rehashes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>int dictRehash(dict *d, int n) 算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//执行N步渐进式rehash操作，rehash之后如果旧表还存在数据，则返回1，不存在返回0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">// 最大允许访问的空桶值</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 判断是否允许rehash</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        <span class="comment">// rehashidx不能大于哈希表的大小</span></div><div class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</div><div class="line">        <span class="comment">// 跳过空节点</span></div><div class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            <span class="comment">// 超过空节点最大值，直接跳出</span></div><div class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取需要rehash的节点</span></div><div class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</div><div class="line">        <span class="comment">// 将该桶下所有节点移动到新表</span></div><div class="line">        <span class="keyword">while</span>(de) &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            <span class="comment">// 获取新表中hash索引</span></div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div><div class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</div><div class="line">            d-&gt;ht[<span class="number">0</span>].used--;</div><div class="line">            d-&gt;ht[<span class="number">1</span>].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否都迁移完成，完成返回0</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 释放旧表,将rehashidx设置为-1</span></div><div class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</div><div class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</div><div class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 未完成返回1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="dict部分API"><a href="#dict部分API" class="headerlink" title="dict部分API"></a>dict部分API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type, <span class="keyword">void</span> *privDataPtr)</span></span>; <span class="comment">// 创建一个新字典</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>; <span class="comment">// 在字典中创建一个新hash表</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>; <span class="comment">// 尝试将给定键值添加到字典中</span></div><div class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 尝试将给定键插入到字典中，键已经存在则返回null</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>; <span class="comment">// 将给定键值添加到字典中，如果已经存在就替换</span></div><div class="line"><span class="function">dictEntry *<span class="title">dictReplaceRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 将给定键值添加到字典中，如果已经存在则不添加，返回已经存在的值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 删除字典中给定键的节点</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;<span class="comment">// 删除包含给定键的及诶单，但是不释放</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span>; <span class="comment">// 删除并释放整个字典</span></div><div class="line"><span class="function">dictEntry * <span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 查找节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dictFetchValue</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 获取包含给定键的节点值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span>; <span class="comment">// 缩小字典，使得已用节点和字典大小比率接近1:1</span></div><div class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span>; <span class="comment">// 创建并返回给定字典的不安全迭代器</span></div><div class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span></span>; <span class="comment">// 创建并返回给定节点的安全迭代器</span></div><div class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span>; <span class="comment">// 返回当前节点，指向下个节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span>; <span class="comment">// 释放迭代器</span></div><div class="line"><span class="function">dictEntry *<span class="title">dictGetRandomKey</span><span class="params">(dict *d)</span></span>; <span class="comment">// 随机返回字典中一个节点</span></div><div class="line">void dictEmpty(dict *d, void(callback)(void*)); // 清空字典中所有哈希表节点，并重置属性</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 开启自动rehash</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 关闭自动rehash</span></div></pre></td></tr></table></figure>
<h3 id="创建dict"><a href="#创建dict" class="headerlink" title="创建dict"></a>创建dict</h3><p>使用dictCreate创建字典。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建字典</span></div><div class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *privDataPtr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// 分配空间</span></div><div class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</div><div class="line"></div><div class="line">    <span class="comment">// 初始化字典</span></div><div class="line">    _dictInit(d,type,privDataPtr);</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</div><div class="line">&#123;</div><div class="line">    ht-&gt;table = <span class="literal">NULL</span>;</div><div class="line">    ht-&gt;size = <span class="number">0</span>;</div><div class="line">    ht-&gt;sizemask = <span class="number">0</span>;</div><div class="line">    ht-&gt;used = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化字典</span></div><div class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</div><div class="line">        <span class="keyword">void</span> *privDataPtr)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 重置hash表</span></div><div class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</div><div class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">    d-&gt;type = type; <span class="comment">// 设置字典类型</span></div><div class="line">    d-&gt;privdata = privDataPtr;</div><div class="line">    d-&gt;rehashidx = <span class="number">-1</span>; <span class="comment">// 初始为-1，表明没有进行rehash</span></div><div class="line">    d-&gt;iterators = <span class="number">0</span>; <span class="comment">//正在使用的迭代器数量</span></div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h3><p>使用int dictAdd(dict <em>d, void </em>key, void *val)添加键值对</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加一个键值对到dict中</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// 往字典中添加一个只有key的键值对</span></div><div class="line">    dictEntry *entry = dictAddRaw(d,key);</div><div class="line"></div><div class="line">    <span class="comment">// 添加失败，则返回错误</span></div><div class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</div><div class="line">    <span class="comment">//使用宏，添加成功则设置key键值对的值</span></div><div class="line">    dictSetVal(d, entry, val);</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 添加键到字典中</span></div><div class="line"> <span class="comment">// 键存在则返回null</span></div><div class="line"> <span class="comment">// 不存在则创建节点，与键关联，并返回节点</span></div><div class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    dictEntry *entry;</div><div class="line">    dictht *ht;</div><div class="line"></div><div class="line">    <span class="comment">// 尝试进行单步式rehash</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    <span class="comment">// 尝试获取hash表中的索引值，返回-1表示键已经存在</span></div><div class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// rehash使用1号哈希表，不在rehash使用0号</span></div><div class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 分配空间，将节点添加到链表表头</span></div><div class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</div><div class="line">    entry-&gt;next = ht-&gt;table[index];</div><div class="line">    ht-&gt;table[index] = entry;</div><div class="line">    ht-&gt;used++;</div><div class="line"></div><div class="line">    <span class="comment">// 使用宏，设置新节点的键</span></div><div class="line">    dictSetKey(d, entry, key);</div><div class="line">    <span class="keyword">return</span> entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="替换键值对"><a href="#替换键值对" class="headerlink" title="替换键值对"></a>替换键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 如果键值不存在，返回1</span></div><div class="line"> <span class="comment">//存在，更新键值，返回0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    dictEntry *entry, auxentry;</div><div class="line"></div><div class="line">    <span class="comment">// 添加成功返回1</span></div><div class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 查找键</span></div><div class="line">    entry = dictFind(d, key);</div><div class="line">    </div><div class="line">    <span class="comment">// 更新键值</span></div><div class="line">    auxentry = *entry;</div><div class="line">    dictSetVal(d, entry, val);</div><div class="line"></div><div class="line">    <span class="comment">// 释放原值</span></div><div class="line">    dictFreeVal(d, &amp;auxentry);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找键值对"><a href="#查找键值对" class="headerlink" title="查找键值对"></a>查找键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    dictEntry *he;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</div><div class="line"></div><div class="line">    <span class="comment">// hash表大小为0，表名无值</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* We don't have a table at all */</span></div><div class="line">    <span class="comment">// 如果在rehash，则单步rehash</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    <span class="comment">// 查找索引</span></div><div class="line">    h = dictHashKey(d, key);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历索引下的键</span></div><div class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                <span class="keyword">return</span> he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果没有进行rehash，则不再查找ht[1]</span></div><div class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 删除该键值对，并释放键和值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除该键值对，不释放键和值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 查找并删除对应的键值对</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx;</div><div class="line">    dictEntry *he, *prevHe;</div><div class="line">    <span class="keyword">int</span> table;</div><div class="line"></div><div class="line">    <span class="comment">// 空则直接返回错误信息</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR; <span class="comment">/* d-&gt;ht[0].table is NULL */</span></div><div class="line"></div><div class="line">    <span class="comment">// rehash时，进行一次rehash</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line">    h = dictHashKey(d, key); <span class="comment">// 获取hash索引</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        prevHe = <span class="literal">NULL</span>;</div><div class="line">        <span class="comment">// 查找，遍历整个链表</span></div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key)) &#123;</div><div class="line">                <span class="comment">/* Unlink the element from the list */</span></div><div class="line">                <span class="keyword">if</span> (prevHe)</div><div class="line">                    prevHe-&gt;next = he-&gt;next;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</div><div class="line">                <span class="keyword">if</span> (!nofree) &#123;</div><div class="line">                    <span class="comment">// 根据传入参数是否释放键值</span></div><div class="line">                    dictFreeKey(d, he);</div><div class="line">                    dictFreeVal(d, he);</div><div class="line">                &#125;</div><div class="line">                zfree(he);</div><div class="line">                d-&gt;ht[table].used--;</div><div class="line">                <span class="keyword">return</span> DICT_OK;</div><div class="line">            &#125;</div><div class="line">            prevHe = he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没有进行rehash则不查找ht[1]</span></div><div class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字典删除"><a href="#字典删除" class="headerlink" title="字典删除"></a>字典删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清理释放整个字典</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// 释放ht[0]</span></div><div class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>],<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 释放ht[1]</span></div><div class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>],<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 释放字典</span></div><div class="line">    zfree(d);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _dictClear(dict *d, dictht *ht, <span class="keyword">void</span>(callback)(<span class="keyword">void</span> *)) &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 释放所有元素</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; <span class="number">0</span>; i++) &#123;</div><div class="line">        dictEntry *he, *nextHe;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (callback &amp;&amp; (i &amp; <span class="number">65535</span>) == <span class="number">0</span>) callback(d-&gt;privdata);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((he = ht-&gt;table[i]) == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            nextHe = he-&gt;next;</div><div class="line">            <span class="comment">// 释放键值对</span></div><div class="line">            dictFreeKey(d, he);</div><div class="line">            dictFreeVal(d, he);</div><div class="line">            zfree(he);</div><div class="line">            ht-&gt;used--;</div><div class="line">            he = nextHe;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 释放hash表</span></div><div class="line">    zfree(ht-&gt;table);</div><div class="line">    </div><div class="line">    <span class="comment">// 重置hsh表</span></div><div class="line">    _dictReset(ht);</div><div class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">/* never fails */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[读书摘录-编程大师访谈录]]></title>
      <url>/2017/05/04/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>【美】Susan Lammers</p>
<p>第1篇　查尔斯•西蒙尼<br>2017-04-30<br>采访者：编程是一种技巧或技能吗？ 西蒙尼：什么是编程？人们对此一直各持己见。有人说它是科学，有人说它是艺术，还有人称之为技能或手艺。我认为这三方面兼而有之。我们喜欢说它蕴含大量艺术成分，但是我们都知道它里面更多的是科学。 孩子们在学校里学习数学，高中毕业时，他们会以为数学就是加法和乘法，甚或代数和微积分。其实，算术，即使简单如加法的运算，背后也有令人难以置信的科学理论作支持。 计算机编程背后也有大量科学理论作支持。例如，哥德尔定理的数学证明冗长而复杂，但是如果借用计算机科学的图灵定理，证明起来不费吹灰之力。信息理论和计算机科学其他领域对数学影响巨大，反之亦然。 编程包含有大量科学，同时，它也有点像手艺。实际上，在许多人看来，编程是一项复杂的技能，这跟工具制造很像，需要精雕细琢。我认为，只要将科学、艺术和技能这三者拿捏得恰到好处，你就能取得一些引人瞩目的成绩。<br>2017-04-30<br>别人读几段你的源代码，有没有可能断定“这代码是查尔斯·西蒙尼写的”？ 西蒙尼：噢，是的，毫无疑问。是不是我本人写的可能很难分辨，但有一点是确定无疑的：只要看了代码，你就能知道它是不是我的团队写的，或者是不是受我的影响写的。这是因为我从1972年起写的代码都遵循特定的命名规范，许多人称之为“匈牙利命名法”。你一眼就能分辨出哪些代码是受我的影响写出来的，包括Microsoft Word、Multiplan和Bravo，以及其他许多遵循这些规范写成的程序。<br>註: 原来是他<br>2017-04-30<br>进入公司第一天，程序员就会拿到几本书。其中一本是数学家乔治·波利亚写的《怎样解题》。（西蒙尼边说边从他办公桌旁的书柜里取出那本书，翻到某一页。）这两页很重要。这本书的其余内容就是基于这两页展开的。这就像一张问题求解的检查单。这是起飞前、起飞和着陆检查单。它不会教你如何飞行，但是如果不照做，即使你已经懂得怎么飞行，也有可能会坠机身亡。 求解问题时，我们遵循以下四个步骤：首先理解问题，然后拟定计划，接着执行计划，最后回顾整个过程。这样的书我们大概有四本，我觉得我们能使程序员比刚加入公司时变得更加优秀。</p>
<a id="more"></a>
<p>第2篇　巴特勒•兰普森<br>2017-04-30<br>但是我坚持认为，如果你打算在研究生院攻读计算机科学，那么本科学习计算机科学就是犯了大忌。 采访者：为什么？ 兰普森：因为从长远来看，你学的内容大部分都没什么价值。你学不到施展聪明才智的新方法，而这些方法对你来说，要比学习如何编写编译器的细枝末节有 用得多，尽管后者可能是你本科念计算机科学时的学习内容。我认为，要是所有计算机科学研究生院联合起来，一致决定不接受本科念计算机科学的毕业生，世界会变得更好。学校应当要求这些人补习一年，学习数学或历史等科目，才能继续攻读计算机科学的研究生。不过，我还没看到有学校这么做的。<br>2017-04-30<br>举例来说，鲍勃·斯普劳尔（Bob Sproull）和我花了大量时间设计Interpress项目，那是一种印刷标准。我为此投入了很大精力，原本衷心希望施乐公司接受并促使所有人采纳。相反，他们完全把它搞砸了。结果，参与开发的部分人员离职并创办了Adobe系统公司，开发出一种类似的产品PostScript。很显然，后者成了大家现在都会采用的标准。这种事情很恼人，但是研究实验室的主要产品就是创意。<br>註: 这不就和盛大研究院一样<br>2017-04-30<br>：程序员需要具备什么样的素质才能写出成功的程序？ 兰普森：最重要的素质是能够把问题的解决方案组织成容易操控的结构，其中每个组件都可以用简单的方式说明。有时，成功的程序员可以做到这一点，但他们无法解释自己做了什么，因为他们看不到那个结构。有些人之所以成为出色的程序员，是因为他们可以比多数人处理更多的细节。<br>2017-04-30<br>你有没有看到20年后每个指尖上都有一台计算机会出现什么问题？ 兰普森：我不觉得那有什么问题。显然每只手腕上都会有计算机。计算机的存在是予人帮助，我希望它们会给人们带来正面的影响。<br>註: 手机</p>
<p>第3篇　约翰•沃诺克<br>2017-05-01<br>你编程有什么诀窍？ 沃诺克：我不知道能不能归结到几点上。我前面提到过一些。不要早作绑定，尽可能推迟决定时间。眼界放宽一些，设计要比你自认为需要的程度更加灵活，因为从长远看你最终会需要这样。快速让某样东西工作起来，然后还能弃之不用。 从小的开始实验而不是大的入手学习。不要一头扎进周期长达两年且中间不出什么成果的开发当中。最好每两个月就要出点成果，这样你才能进行评估、重组和重新开始。程序员经常在一开始时过度定义他们的方法。他们可能会从一个中心构思着手，从第一天就开始编码。然后他们发现自己陷入重围，每件东西都开始膨胀，因为它们依赖于太多其他因素。应当反其道而行之，如果让过程较为宽松，保持一定的自由度，并在最后阶段加快速度，长远来说，你会做出更好的产品。</p>
<p>第4篇　加里•基尔代尔<br>2017-05-01<br>你说编程对很多人来说也是一种宗教体验，这是什么意思呢？ 基尔代尔：嗯，如果你和一群使用相同编程语言的程序员谈论编程的话，他们几乎可以成为那种编程语言的传教士。他们组成了一个紧密结合的社群，坚持一定的信念，在编程时遵循一定的规则。就像是一个把编程语言当作是圣经的教会。 FORTH是一个很好的例子，它是一种编程语言，对于很多人来说，可能很接近宗教的体验。当FORTH刚出来的时候，其信徒就声称它做任何算法都能快上十倍。这是一个典型的宣言。如果你在这点或其他任何方面有异议，你会发现自己是对牛弹琴，而且你是绝对不会被容许加入“教会”的。我并不想贬低使用这一种语言的人。那是一个非常能给人帮助的团体，所用的也是一种非常有效的语言，但他们没有基于理性去讨论问题，他们是基于信仰的。说过这句话，我可能会收到一千封有关FORTH及人们对其宗教体验的邮件。但是就算我能整天鼓吹LISP的神奇，我也不会把自己归到一个特殊的派别中。<br>註: 哈哈。php</p>
<p>第5篇　比尔•盖茨<br>2017-05-01<br>不，我认为在过了最初的三四年后，就会非常明显地显现出你是否是一个优秀的程序员。刚开始的几年中，你可能会更多地知道怎样去管理大型项目和不同个性的人，但在三四年后，就能很清楚地看出你会成为什么样的程序员了。在微软没有哪个程序员是在平庸了几年之后突然间一鸣惊人的。我和一个人谈谈他的程序，马上就能知道他是否是个好程序员。如果他真的很棒，每个细节他都会脱口而出。 就像下棋的人一样。如果你特别喜欢下棋，会很容易记住10盘棋中的每一步，因为你已置身其中了。其他人看到国际象棋选手或程序员能记住每个细节时，觉得他们像个怪物。其实这很正常。即使到了今天，在我写了微软的BASIC程序10年后，我仍可以在黑板上大段大段写出当时的源代码。<br>2017-05-01<br>编程需要非常大量的精力，所以大多数程序员都比较年轻。这就会带来一个问题，因为编程需要很多的训练。在年轻时，目标不是很持久，可能会被这样那样的事分心。但是年轻的程序员应当坚持下去，他们会变得更出色。作为程序员，我认为自己在1975年到1980年之间的提高是最明显的。在1975年，我会说：“嘿，看看，我什么事情都能做。”我真的认为自己可以，因为我读了大量代码，从来没有发现哪段代码是我无法快速读懂的。今天我仍旧认为检验编程能力的最好方法之一就是给程序员一本30来页的代码，看看他阅读和理解的速度有多快</p>
<p>第6篇　约翰•佩奇<br>2017-05-01<br>从一个计算机程序员转变到运营一个庞大的公司，你觉得困难吗？ 佩奇：这个角色转换是一个非常平缓的过程，因为我已经做了二十多年的管理人员，我可以告诉你真相，最难的是从管理者重新变成程序员。在创办公司前，我 在惠普已经习惯于领导很多人了。再回到编程工作时，我被迫完全依靠自己。真是让人一震。事实上这有点儿可怕——我不知道自己是否还能编程。但是，就像骑自行车一样——你永远都不会忘记的，只要一踏脚蹬，车就奔着夕阳去了。<br>2017-05-01<br>独自一人编程和一个团队合作编程有什么不同？ 佩奇：如果一个产品需要四到五个人开发，那和你自己一个人编程时采取的方法是不同的。我坚信只能由一个人来做产品和高层结构的设计，最多不能超过两个人。所有的设计出于一个头脑，才能够实现和谐与一致。如果试图取悦于所有人，让一个委员会来做设计，你的方向就错了。那绝对是致命的。 所以我在定义阶段会用一个人数非常少的团队来工作，然后如果有必要，再扩大团队来实施编程设计。实施设计方案所需要的队伍越大，就越必须严格地把整个系统划分成可管理的模块，并定义好相互间的接 口。除非一个程序大到必须由两三个人以上来做，否则不必编写很多结构化程序报告，也不用为每个步骤都编写文档。 有些系统，例如设计一个控制航天飞机的程序，需要上百名程序员。那就必须严格地把结构划分成可管理的模块才行。一个小系统的架构可能会过于大，一个大系统的架构可能会过于小——使用的技术必须与问题的规模相匹配。我就是这样做的。<br>2017-05-01<br>有些人觉得完成项目真是太过瘾了，他们做完一个项目就接着又做另一个了。这样会把自己累垮的。如果连续开始新的项目，情况会变得很糟。 另外，当你在复杂的程序上艰苦工作时，锻炼身体是很重要的。大部分程序员都缺乏身体锻炼，这样会失去敏锐的思维。往往在连续完成了第二个或第三个工作后，身体就虚弱了，以至于你会产生幻灭感，你会对着镜子说：“上帝啊，看看我，我为什么要这样做呢？</p>
<p>第7篇　C.韦恩•莱特莱夫<br>2017-05-01<br>另一方面，非常有意思的是专家系统。我的预测是，在两三年之内，专家系统不必再和人工智能牵扯在一起。这就是人工智能的历史：当某件东西开始变得众所周知时，它就独立出来了。模式识别曾经被当作是人工智能，但现在这是一个独立的领域。这也正是专家系统当下的命运。我认为专家系统在我们产业里将变得非常重要，就像垂直应用一样。<br>註: 和现在一样</p>
<p>第11篇　雷•奥奇<br>2017-05-02<br>我推崇严谨、一致而清晰的结构。另外，我认为软件应该高度模块化和分层，非常灵活地运用大量文件和目录。如果你必须分别构建不同组件，那么接口自然就会更加凸显出来，要求你规范这些接口。<br>当许多人共同开发一个程序时，在项目早期确立全局的错误处理、参数传递和子程序命名规范（虽然不见得所有人都会同意），显得非常重要。不过，对于代码该怎么注释、大括号怎么用或者代码该怎么缩进，我觉得你绝不应该对别人指手画脚。在修改别人的模块时，你最好还是按照他的惯例编写代码。这是学会与他人共事的必修课。<br>交流想法的环境应该是开放的。设计会议上允许非常激烈和紧张的讨论。我发现许多优秀设计师往往固执己见，但只要他们觉得是对的，就会毫不客气地坚持，但他们也知道什么时候应该怎么让步。优秀设计师不会有“非此创造”综合征。<br>2017-05-02<br>我过去常想，个人时间管理程序应该会非常便利。结果现在却得在公文包里装一台计算机随身携带，打开并启动计算机，就只为了查看我的会面安排，远不及我那口袋大小的通讯记事簿来得方便。我想要一本通讯记事簿，让我的秘书和我可以同时写入，这非常有用，因为我们俩都能便捷地安排我的时间。我希望哪个聪明的家伙能发明这种记事簿。<br>註: 手机日程管理软件</p>
<p>第14篇　杰夫•拉斯金<br>2017-05-03<br>1979年，苹果公司正致力于开发Lisa。不管你信不信，它最初的目标是开发一款字符界面的机器。我在苹果公司担任高级系统经理，对Lisa很不满。它非常昂贵，我认为苹果公司不够理智，居然以小型机的价格去跟DEC、通用数据公司和IBM比拼。<br>70年代初，我在斯坦福大学人工智能实验室做访问学者期间，在施乐PARC度过了大量时光。在我看来，施乐PARC在位图屏幕、通用键盘和图形方面的研究真是不可思议。因此，我极力游说，说服苹果公司把Lisa改成位图机器。我把施乐和苹果公司撮合到一起。施乐一度持有苹果公司10%的股票。<br>我提议开发一款容易使用并融合文字和图形的电脑，售价在1000美元左右。乔布斯认为这想法太疯狂了，这种机器不会有销路，我们绝不要这种玩意。他试图否决这个项目。<br>因此，我越过乔布斯直接找到当时的董事长迈克·马库拉（Mike Markkula），和他探讨我的想法。幸运的是，马库拉和时任总裁迈克·斯科特（Mike Scott）叮嘱乔布斯别管我。<br>我招揽了早期成员：巴德·特里伯（Bud Tribble）、布里安·霍华德（Brian Howard）和布雷尔·史密斯（Burrell Smith）。我们搬到另一栋大楼，打造Macintosh及其软件的原型，搭建并让它运行起来。后来，乔布斯接手后，他还编了个故事，把Mac项目称为“海盗行动”。我们并未像他后来说的那样，试图让这个项目远离苹果公司。我们跟苹果公司其他部门的联系十分紧密，我们只是尽量不让乔布斯干预这个项目。在头两年，乔布斯总想着要毙掉这个项目，因为他不明白它到底是怎么回事。<br>最初的Macintosh设计得既精心又合理。最后，苹果公司所有人都意识到，这是公司继Apple II后推出新产品的希望所在。随后，乔布斯接管了这个项目。他径直走进来，对我说：“我接手Macintosh硬件，你可以负责软件和出版物。”他抛出软件设计，要求Macintosh软件与Lisa保持兼容，并坚持使用鼠标。机器变得更大、更复杂，也昂贵得多。现在它跑起来黏糊糊的。你有没有用过MacWrite？我们这里把它叫做MacWait。又过了几个月，乔布斯对我说：“我来接手软件，你可以负责出版物。”于是我回答：“你也可以接手出版物。”说完便离开了。那是1982年5月。他和马库拉对我说：“请别走。再过一个月，我们会提供一份你无法拒绝的薪酬。”于是我给了他们一个月时间，他们开了一份薪酬，我没接受。<br>2017-05-03<br>近期《新闻周刊》上的一篇文章把我逗乐了，他说：“我还有几个不错的设计。”他从来没做过什么设计，他一款产品都没设计过。沃兹（Steve Wozniak）设计了Apple II。肯·罗斯穆勒（Ken Rothmuller）等人设计了Lisa。我和我的团队设计了Macintosh。温德尔·桑德斯（Wendell Sanders）设计了Apple III。乔布斯设计了什么？什么也没有。<br>註: 哈哈，乔布斯<br>2017-05-03<br>人工智能教会了我们大量关于我们自身以及知识的内容。非常廉价的机器上用不了靠谱的人工智能程序，至少目前行不通。<br>真正的人工智能有点像宗教。从前人们都说天空上面就是天堂和天使。然后你搭乘火箭飞船到了那里，发现并不是那么回事。于是你知道原来的理解有误。一旦你实现了某样东西，它就不再是人工智能。<br>曾几何时，国际象棋博弈程序一度被认为包含人工智能的成分。当我还在念研究生时，只要学会编写国际象棋博弈程序，你就可以拿到人工智能博士学位。现在你花上29.95美元就能买到国际象棋博弈程序，没有人称之为人工智能。它只是个会下棋的小算法。<br>首先，有个定义的问题。然后，它变得更加复杂。人们认为程序应该理解自然语言，但我们的话语方式对电脑或别人来说太不精确，无法弄清楚要做什么。这正是我们创造编程语言的原因。只要试过以英文写成的规格为基础开展工作，他们就会知道自己无法借此编写程序，因为它不够精确。因此，如果人类都不能做到这一点，基本上就不可能指望还能让机器做到。当你面对所谓的人工智能程序时，电脑必须已经掌握一个词汇表。比方说，你有5个命令，你想让机器理解与之等价的所有可能的英文表述，但是它理解不了所有等价的英文表述。有人可能会说：“拿个工号。”而英国绅士可能会说：“劳烦你给我们的员工派个数字编号。”这正是搞AI的人试图解决的大麻烦。<br>人工智能相关的许多承诺都被误解了。人工智能已经教导我们的有关语言的东西是美好的。那么，我是否认为人工智能值得做？绝对是。我是否认为这会转化出很棒的产品？会有一些。我是否认为这会实现你在大众传媒上了解到的承诺？根本不会。我会投很多钱到人工智能领域吗？没门</p>
<p>第15篇　安迪•赫兹菲尔德<br>2017-05-03<br>有个故事是关于沃兹的。沃兹是公司创始人之一，不用说，他分到了大量股票。有些人一点股票都没有，而有的人却拥有这么多股票，对此他觉得很不公平。于是他拿出自己的股票，宣布只要是在苹果公司工作满一定年限的员工，都可以从他那里买到2500股。沃兹的用意无疑是最好的，但结果这反倒让那些坏心肠的人欢天喜地。事情是这样的，许多不在乎钱财的雇员并没有行使股票购买权，于是那些贪心的家伙就对他们说：“好吧，我给你钱，我来买你的股份。”有些人不再认真工作，反而成了股票买手；他们令人生厌，个性糟糕，是不够格的工程师，毛孔里都滴着贪婪。在一个月内，有个家伙光靠这个捞了几十万美元。这实质上是在窃取沃兹的钱财。但这也是苹果公司上市时发生的故事的一部分。<br>到了1980年年底，在苹果公司工作不再那么有趣。通常你的头儿是从另一家公司挖过来的，对产品一无所知。最后，迈克·斯科特意识到苹果公司聘请的管理人员都是些眼高手低的家伙，1981年2月，他在一天之内把这些人都给解雇了。工程部门一共有90人，他解雇了其中40人。这一天在苹果历史上被称为“黑色星期三”。人们都惊呆了。<br>2017-05-03<br>就在Mac发布之后，Mac团队开始组建管理层的时候，我离开了苹果公司。我跟新来的技术经理有矛盾，他最初是我面试和同意录用的，没想到他是个控制和权力狂。这家伙认为我太傲慢，自以为可以通过考核给我差评打击我。我很震惊。我掏心掏肺地为这家公司卖命，尽我所能做到最好，每天工作15个小时开发这个项目。Macintosh本不该是这样的，但是这家伙却进来把它搞成了这样。因此我不得不选择离开，但是我把自己生命中整整两年献给了Macintosh，它是我最在意的。所以我一直待到Mac发布之后才离开苹果公司，开始自己单干。</p>
]]></content>
      
        <categories>
            
            <category> 摘录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[读书摘录-调试九法：软硬件错误的排查之道]]></title>
      <url>/2017/04/30/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%EF%BC%9A%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B9%8B%E9%81%93/</url>
      <content type="html"><![CDATA[<p>【美】阿甘斯</p>
<p>第3章 理解系统<br>2017-04-07<br>你必须掌握系统的工作原理以及它是如何设计的。在某些情况下，还要知道为什么这样设计。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方。（这不仅仅是“墨菲定律”的问题，如果你不能理解你所设计的系统，你的工作可能会变得一团糟。）</p>
<p>3.1 阅读手册<br>2017-04-07<br>如果你是一位工程师，正在调试自己公司的产品，那么你需要读一读内部手册。工程师们设计它是用来做什么的？读一下功能说明以及所有的设计规范，研究一下图表、时序图和状态机。分析它们的代码，还要读一下注释。（是的，读一下注释，这非常重要。）一定要检查产品的设计。查明构建它的工程师们打算用它来做什么（除了用它来赚钱买辆宝马车以外）。<br>注意，手册上的信息也不可全信。手册（以及那些只想着赚钱买宝马车的工程师们）可能也是错的，很多难以发现的bug就出现在这里。但你仍需要了解他们的想法，哪怕其中有些信息是很难接受的。</p>
<p>3.2 逐字逐句阅读整个手册<br>2017-04-07<br>参考设计和样本程序给出了产品的一种使用方式，有时这些就是能获得的全部文档了。但是，在使用这些设计时一定要注意，创建它们的人往往只了解他们的产品，而没有遵循好的设计实践，或者不是为真实应用而设计的（最常见的缺点是不能进行错误恢复）。不要照搬这些设计，如果你没有在开始的时候发现bug，那么将来也会发现。此外，即使是最好的参考设计可能也不会完全符合应用程序的特定需求，而不符合的地方可能就是出问题的地方。当我照搬了朋友的微处理器设计时，就发生了问题，因为他的设计无法处理中<br><a id="more"></a><br>3.3 知道什么是正常的<br>2017-04-07<br>当你检查系统时，必须知道系统的正常工作状态。如果你不知道低位字节首先由使用了Intel芯片的PC程序来处理，那么你会认为所有长字（longword）都是随意处理的。如果你不知道缓存是干什么的，就会非常奇怪有些数据为什么没有马上写入内存。如果你不了解三态（tri-state）数据总线的工作原理，你将会认为它们可能是主板上的故障信号。如果你从未听说过电锯，你可能会认为那个发出讨厌的嗡嗡声的东西一定是出了什么毛病。知道什么是正常的可以帮助你注意到什么是不正常的。<br>你必须掌握一些你所工作的技术领域的基础知识。如果我不知道时钟选通脉冲和地址线是做什么的，那么即使我读了手册之后也无法理解中断问题。本书中几乎所有的（即使不是全部的话）示例都假定人们已经掌握了系统工具原理的一些基本知识。（如果我在前面使你误认为读完本书就可以调试任何技术领域的bug，那么请恕我无心之过。如果你是一位游戏编程人员，最好不要去管核电厂的调试。如果你不是医生，那么就不要试图诊断你手臂上的灰绿色斑点是什么。如果你是一位政客，那么就不要介入任何有关bug的事情。）</p>
<p>3.7 小结<br>2017-04-07<br>理解系统<br>这是第一条规则，因为它是最重要的。<br>阅读手册。它会告诉你在使用除草机时，要在除草头上涂润滑油，这样除草绳就不会被烧化。<br>仔细阅读每个细节。有关微处理器如何处理中断的详细信息就隐藏在数据手册的第37页。<br>掌握基础知识。电锯本来就会发出很大的噪声。<br>了解工作流程。引擎的转速可能与轮胎的转速不同，这是由传动轴造成的。<br>了解工具。弄清楚体温计的哪一端才是用来测量体温的，弄清楚Glitch-O-Matic逻辑分析器的强大功能是如何使用的。<br>查阅细节。连爱因斯坦都会去查阅细节，而Kneejerk却盲目相信自己的记忆力</p>
<p>第4章 制造失败<br>2017-04-09<br>“当你发现一个故障时该怎么办？”他会回答说：“试着让它再次发生。”（Charlie是一位训练有素的调试人员）。这样做有3个原因。<br>可以观察它。要观察错误（下一节将更详细地讨论这个问题），就必须使它发生。我们必须尽可能有规律地制造失败。在前面讲的电视游戏的例子中，当问题发生时我可以集中注意力观察示波器（虽然当时我已经很疲倦）。<br>可以专心查找原因。准确地知道问题在什么条件下会发生，有助于集中精力查找原因（但是请注意，有时这会产生误导，例如，“烤箱只有在你把面包放进去的时候才会把面包烤焦，因此问题就出在面包上。”这个问题后文也会详细讨论。）<br>可以判断是否已修复问题。当你认为已经修复了问题时，如何才能确信它确实已被修复呢？那就是明确知道问题是如何发生的。当问题没有修复时，如果你执行X操作，失败率为100%；在修复问题后，再执行X操作，如果失败率为0，那么你知道bug确实已被修复。（我这么说并不多余。很多时候，开发人员在修复bug时会修改软件，然后在一个与当初发现bug的不同条件下测试新软件。软件当然能运行，即使他在代码中输入一行打油诗，而他也高兴地回家了。然而，几星期后，在测试过程中，或者更糟，在客户现场，软件再次失败。后文将讨论更多这方面的内容。</p>
<p>4.4 不要模拟失败<br>2017-04-09<br>记住，这并不意味着不能用自动化过程来引发失败，也不意味着在这个过程中不能采用一些起到放大效果的措施。自动测试能够使间歇性的问题更快发生，例如电视游戏的例子。放大效果可以使得细微的问题更明显，例如在修窗户的例子中，我可以用喷水管来找到漏雨的窗户，而不用等待偶尔才有的暴风雨来检查。这两种技术都有助于引发失败，而不是模拟失败的机理。所做的改变应该是一些高层次的改变，只影响错误发生的频率，而不影响错误的发生方式。<br>此外，还要注意不要画蛇添足，引发新的问题。不要因为假设芯片的问题是由于热量引起的，就用热风枪来给芯片加热以模拟错误，这样只会把芯片烧化，然后你会误认为bug完全就是电路板上那堆被烧化的塑料。如果我用消防用的水龙来检查漏雨问题，可能会断定问题显然就是出在被击碎的窗子上。</p>
<p>4.9 小结<br>2017-04-10<br>制造失败<br>虽然看起来很简单，但如果不制造失败的话，调试就会变得很困难。<br>制造失败。目的是为了观察它，找到原因，并检查是否已修复。<br>从头开始。修车工需要知道汽车车窗在被冻结之前你洗过车。<br>引发失败。用喷水管向漏雨的那扇窗子喷水。<br>但不要模拟失败。用喷水管向漏雨的那扇窗子喷水，而不要向另一扇不同的、“类似的”窗子喷水。<br>查找不受你控制的条件（正是它导致了间歇性失败）。改变能够改变的每件事情，振动、摇晃、扭曲，直到再现失败。<br>记录每件事情，并找到间歇性bug的特征。我们的绑定系统总是只在呼叫顺序错乱时才会失败。<br>不要过于相信统计数据。绑定问题看起来与时间段有关，但实际上真正的原因是当地的年轻人占用了电话线路。<br>要认识到“那”是可能会发生的。甚至冰淇淋的口味也会影响汽车的发动。<br>永远不要丢掉一个调试工具。自动击球板可能在某一天就会派上用场。</p>
<p>5.6 猜测只是为了确定搜索的重点目标<br>2017-04-11<br>不要想，而要看”并不意味着不能做任何猜想。事实上猜测是好事，特别是当你理解了系统之后。你的猜测可能很接近事实，但猜测只是为了确定搜索的重点。在尝试修复问题之前，仍需要再次看到失败，以便确认你的猜测是正确的。</p>
<p>5.7 小结<br>2017-04-11<br>不要想，而要看<br>凭空想象，问题可能有几千条原因。而实际的原因只有去看了才能发现。<br>观察失败。高级工程师看到了真实的问题，并且能够找到原因。而初级工程师们认为他们知道错误发生在哪里，结果他们修复的地方根本没有出错。<br>查看细节。听到水泵似乎发出声音时不要停下来。到地下室查明是哪个水泵。<br>植入插装工具。使用源代码调试器、调试日志、状态消息、信号灯和臭鸡蛋的气味。<br>添加外部插装工具。使用分析器、示波器、量表、金属检测仪、心电图仪和肥皂泡。<br>不要害怕深入研究。虽然它是软件成品，但它出问题了，你必须打开并修复它。<br>注意海森堡效应。不要让仪器影响了系统。<br>猜测只是为了确定搜索的重点。大胆地猜测内存时序发生了错误，但在修复之前应该先查看它。</p>
<p>6.4 修复已知bug<br>2017-04-12<br>有时，我们很难相信一个系统中会有多个bug，就像在旅店预订的例子中一样。这使得用“分而治之”原则隔离每个bug变得更加困难。因此，如果同时出现了多个问题，当你确实查明了其中的一个问题时，应该立即修复它，然后再查找其他问题。我总听人们说“那里出问题了，但它不可能影响我们正在查找的问题。”事实上，它确实（而且经常）会产生影响。如果你修复了已知的错误，就可以专心致志地查找其他问题。在旅店预订系统中，技术人员只有在修复了转接盒中的双向电阻阻值过高的问题之后，才能够发现速度最慢的那台终端的接线问题。<br>有时修复了一个问题，另一个问题也解决了，两个问题实际上是同一个bug。<br>此外，如果修复某个问题对其他的问题有影响，一定要首先修复它之后再测试其他的问题。如果修复了一个问题后将会引发新的问题，那么你可以尽早发现，并有更多时间处理新的问题。</p>
<p>6.5 首先消除噪声干扰<br>2017-04-12<br>人们也很容易成为一个“完美主义者”，为了达到全面的高质量把你发现的所有不好的设计都“修复”一遍。你可能只是因为先前的程序员编写的GOTO语句看起来很差劲就删掉它们，但是，如果它们并没有实际引起问题，最好还是保留它们吧。</p>
<p>6.6 小结<br>2017-04-12<br>分而治之<br>当bug的藏身之地不断被缩小一半时，它将很难再隐藏下去。<br>通过逐次逼近缩小搜索范围。猜测1～100内的一个数字，只需7次。<br>确定范围。如果数字是135而你却认为它在1～100内，那么你必须扩大范围。<br>确定你位于bug的哪一侧。如果你所在的位置有排放物，则排放管就在上游。如果没有排放物，则排放管就在下游。<br>使用易于查看的测试模式。从干净、清澈的水开始，以便当排放物进入河流中时很容易看到它。<br>从有问题的一端开始搜索。如果你验证的是正确的部分，那么需要验证的地方太多了。应该从有问题的地方开始，然后向后追查原因。<br>修复已知bug。bug互相保护，互相隐藏。因此一旦找到，立即修复它们。<br>首先消除噪声干扰。注意那些导致系统问题的干扰因素。但对一些无足轻重的问题不要过于极端，也不要为了追求完美而去修改所有地方。</p>
<p>第7章 一次只改一个地方<br>2017-04-12<br>我们的软件工程师为了修复问题而更改了一个地方，但这个修改并没有解决问题，而他认为这不会产生什么影响。这是一个非常错误的假设。它确实有影响，它使得音频数据发生错误，只是两次错误与一次错误也没有什么太大的区别。当原来的错误被修复后，他犯的错误仍然存在，因此声音的质量仍很差。当他的修改没有解决问题时，应该立即把它改回来。<br>註: 经常遇到</p>
<p>7.2 用双手抓住黄铜杆<br>2017-04-23<br>在很多情况下，你可能想改变系统的不同部分，以便看看它们是否对问题有影响。这往往是一个危险的信号，说明你正在猜测，而不是使用插装工具来观察正在发生什么。你正在改变条件，而不是捕捉错误的自然发生。这可能会把最初的错误隐藏起来，而且引起更多错误。</p>
<p>7.5 自从上一次能够正常工作以来你更改了什么<br>2017-04-23<br>有时，正常的系统和错误的系统之间的区别是由于一项更改造成的。做了更改之后，正常的系统开始出现故障。一种非常有效的办法是找出第一个导致系统出错的版本，尽管这可能需要连续测试原来的版本，直到找到没有故障的版本。一旦找到了这个版本，再前进到下一个版本，验证故障是否再次出现。做完这一步之后，至少可以把问题的范围限定到两个版本之间所做的修改。<br>2017-04-23<br>问题已经存在了很长时间，但只是某个地方（例如时序或数据库大小）被改变之后，它才显露出来</p>
<p>7.6 小结<br>2017-04-23<br>一次只改一个地方<br>我们在生活中要有一点先见之明。如果你所做的更改没有起到预期的作用，那么就把它改回来。它们可能会产生无法预料的影响。<br>隔离关键因素。如果你在检查日照时间的影响，就不要改变灌溉方案。<br>用双手抓住黄铜杆。如果你在不知道具体发生了什么问题的情况下就试图去修理核潜艇，可能会引发一次水下的切尔诺贝利爆炸。<br>一次只改一个测试。我之所以知道我的VGA采集相位被破坏了，就是因为其他东西都没有发生改变。<br>与正常情况进行比较。如果所有出错的情况都有一些特征，而这些特征是正常情况所没有的，那么<br>你就找到了问题所在。<br>确定自从上一次正常工作以来你改变了什么地方。我的工友改变了唱机转盘上的唱头，因此这是一个很好的调试起点。</p>
<p>8.6 小结<br>2017-04-23<br>保持审计跟踪<br>不要只是在心里记住“保持审计跟踪”这条规则，而要把它写下来。<br>把你的操作、操作的顺序和结果全部记录下来。你上一次喝咖啡是什么时候？你的头痛是从什么时候开始的？<br>要知道，任何细节都可能是重要的。视频压缩芯片的崩溃是由于格子衬衫造成的。<br>把事件关联到一起。“它发出噪声，从21:04:53开始，持续4秒”比仅仅说“它发出噪声”要好得多。<br>用于设计的审计跟踪在测试中也非常有用。软件配置控制工具可以告诉你哪次修订引入了bug。<br>把事情记录下来！无论那个时刻多么恐怖，都要把它记到备忘录中，这样你才不会忘记。</p>
<p>9.4 小结<br>2017-04-23<br>检查插头<br>一些显而易见的假设往往是错误的。请恕我赘述，假设错误通常是最容易修复的错误。<br>置疑你的假设。是否运行了正确的代码？是不是燃气用完了？插头是否已插好？<br>从头开始。是否正确地对内存进行了初始化？是否按了除草机上的“primer bulb”按钮？开关是否已打开？<br>对工具进行测试。是否运行了正确的编译器？燃料油表是否被粘住了？量表是不是没电了？</p>
<p>10.5 小结<br>2017-04-23<br>获得全新观点<br>不管怎样，你都需要休息一下，喝杯咖啡。<br>征求别人的意见。甚至一个不说话的人体模特也能帮助你认识到你先前没有注意到的事情。<br>获取专业知识。只有VGA视频采集卡的厂商才能够肯定相位功能发生了错误。<br>听取别人的经验。别人会告诉你车内顶灯的线被挤压出来了。<br>帮助无处不在。同事、供应商、网络，还有书店，都在等待着为你提供帮助。<br>放下面子。bug发生了。以除掉bug为自豪，而不要非得以自己除掉bug才为自豪。<br>报告症状，而不要讲你的理论。不要把别人拖进你的思维定式中。<br>你提出的问题不必十分肯定。甚至连“穿了格子衬衫”这样的事情也可以提出来。</p>
<p>11.6 小结<br>2017-04-23<br>如果你不修复bug，它将依然存在<br>现在你已经掌握了所有的技术，没有理由再让bug存在了。<br>查证问题确实已被修复。不要假设是电路的问题，而仍然让汽车带着脏的滤油嘴上路。<br>查证确实是你的修复措施解决了问题。口中大喊“Wubba!”并不是使计算机打开的窍门。<br>要知道，bug从来不会自己消失。使用最初导致它失败的方法再次制造失败。如果必须交付产品，那么就在产品中设计一个用于捕捉bug的“陷阱”，以便产品在客户现场发生失败时，把它捉住。<br>从根本上解决问题。在烧坏另一台变压器之前，先把无用的8音轨磁带卡座扔掉。<br>对过程进行修复。不要只是擦掉地上的油，而要纠正设计机器的方式。</p>
<p>14.3 小结<br>2017-04-25<br>从帮助台得到的观点是不明确的<br>只能通过远程方式了解问题，眼睛和耳朵接收到的信息并不十分准确，而且关键是时间紧迫。<br>遵循规则。无论用户多么糊涂，都必须找到应用规则的途径。<br>对行动和结果加以确认。用户会误解你的意思，同时会犯错误。通过确认他们所说和所做的一切可以及早发现这些问题。<br>使用自动工具。不要让用户参与系统生成的日志和远程监控与控制工具。<br>即使是最简单的假设也需要确认。是的，有些人就是不知道有电才能使用字处理器。<br>使用可用的故障检修指南。要处理的很可能就是已知的、好的设计。不要忽略历史。<br>帮助完善故障检修指南。如果找到了某个已知系统的一个新问题，将解决问题的所有内容进行归档可以帮助下一位支持人员。</p>
]]></content>
      
        <categories>
            
            <category> 摘录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vs2017与vs2005冲突解决]]></title>
      <url>/2017/04/16/vs2017%E4%B8%8Evs2005%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<p>先安装vs2005，后安装vs2017，vs2017无法运行<br>原因：vs2005注册了Microsoft.VisualStudio.Shell.Interop.8.0.dll，优先于vs2017需要的dll。导致运行错误。</p>
<p>解决方法：</p>
<p>复制<br>C:\Program<em>Files</em>(x86)\Microsoft_Visual Studio\2017\Enterprise\Common7\IDE\PublicAssemblies\Microsoft.VisualStudio.Shell.Interop.8.0.dll<br>到<br>C:\Windows\assembly\GAC\Microsoft.VisualStudio.Shell.Interop.8.0\8.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualStudio.Shell.Interop.8.0.dll</p>
]]></content>
      
        <categories>
            
            <category> 技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-链表]]></title>
      <url>/2017/03/26/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>C语言程序由于没有标准库的存在，各种造轮子。Redis为了满足需求，同样写了一个链表。</p>
<p>实现文件在adlist.h/adlist.c中。</p>
<h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>和普通的C写的双向链表差不多。没有什么特点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后节点</span></div><div class="line">    <span class="keyword">void</span> *value; <span class="comment">// 值</span></div><div class="line">&#125; listNode;</div><div class="line"></div><div class="line"><span class="comment">// 迭代器</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></div><div class="line">    listNode *next;<span class="comment">// 下一个节点</span></div><div class="line">    <span class="keyword">int</span> direction;<span class="comment">// 方向</span></div><div class="line">&#125; listIter;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></div><div class="line">    listNode *head; <span class="comment">// 头</span></div><div class="line">    listNode *tail; <span class="comment">// 尾</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr); <span class="comment">// 自定义节点复制函数</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr); <span class="comment">// 自定义节点释放函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 自定义节点匹配函数</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">// 链表长度</span></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>定义了一些快速操作的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* Functions implemented as macros */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len) <span class="comment">// 获取list长度</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head) <span class="comment">// 获取list头节点指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail) <span class="comment">// 获取list尾节点指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev) <span class="comment">// 获取当前节点前一个节点</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next) <span class="comment">// 获取当前节点后一个节点</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value) <span class="comment">// 获取当前节点的值</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m)) <span class="comment">// 设定节点值复制函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m)) <span class="comment">// 设定节点值释放函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m)) <span class="comment">// 设定节点值匹配函数</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup) <span class="comment">// 获取节点值赋值函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free) <span class="comment">// 获取节点值释放函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match) <span class="comment">// 获取节点值匹配函数</span></span></div></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>都是些链表常用的API，比较有特点的是迭代器的C语言实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Prototypes */</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;</div><div class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;</div><div class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;</div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;</div><div class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</div><div class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-动态字符串sds]]></title>
      <url>/2017/03/26/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/</url>
      <content type="html"><![CDATA[<p>Redis没有使用c语言的字符串结构，自己设计了一个简单的动态字符串。特点是：修改时大小不足则扩容，大小足够直接使用不缩小。末尾使用‘\0’，与c语言字符串兼容。</p>
<p>sds的源代码在sds.h与sds.c中。</p>
<h2 id="sds的定义"><a href="#sds的定义" class="headerlink" title="sds的定义"></a>sds的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;<span class="comment">// 兼容C</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;<span class="comment">// 字符串长度</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;<span class="comment">// 未分配的空间</span></div><div class="line">    <span class="keyword">char</span> buf[];<span class="comment">// 末尾'/0'的C风格字符串</span></div><div class="line">&#125;;<span class="comment">// SDS的实际结构，兼容char*则返回buf地址</span></div></pre></td></tr></table></figure>
<h2 id="SDS这样设计的优点："><a href="#SDS这样设计的优点：" class="headerlink" title="SDS这样设计的优点："></a>SDS这样设计的优点：</h2><ol>
<li>重用部分C字符串库函数的函数。</li>
<li>在常数复杂度的情况下获取字符串长度(以下代码)。</li>
<li>杜绝缓冲区溢出，通过获取空余空间函数，来进行处理(sdscat函数)。</li>
<li>减少字符串内存的重分配。不足则分配更大的空间，足够也不减少空间，而是记录新的len、free值。</li>
<li>二进制兼容。C字符串以空字符结尾，而某些二进制数据中间可能存在空字符。SDS兼容该种数据。</li>
</ol>
<a id="more"></a>
<h2 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h2><h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 获取字符串长度</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line">    <span class="keyword">return</span> sh-&gt;len;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取空余空间</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SDS创建"><a href="#SDS创建" class="headerlink" title="SDS创建"></a>SDS创建</h3><p>有两个函数，一个定长创建，一个是不定长创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (init) &#123;</div><div class="line">        <span class="comment">//为空则使用malloc</span></div><div class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//不为空使用calloc分配</span></div><div class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 分配失败处理</span></div><div class="line">    <span class="comment">//设定sds的参数</span></div><div class="line">    sh-&gt;len = initlen;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="comment">//值的复制</span></div><div class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</div><div class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</div><div class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;<span class="comment">// 尾部结束符</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制一个char*</span></div><div class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</div><div class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成一个空sd</span></div><div class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制一个sds</span></div><div class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds释放函数"><a href="#sds释放函数" class="headerlink" title="sds释放函数"></a>sds释放函数</h3><p>先获取sdshdr的首地址，使用zfree释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">  	<span class="comment">// 获取真实首地址释放</span></div><div class="line">    zfree(s-<span class="keyword">sizeof</span>(struct sdshdr));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds动态空间调整"><a href="#sds动态空间调整" class="headerlink" title="sds动态空间调整"></a>sds动态空间调整</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 空间增长</span></div><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></div><div class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;<span class="comment">// 空间足够直接返回</span></div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">    newlen = (len+addlen);<span class="comment">// 新的长度</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)<span class="comment">// 不足1MB直接翻倍分配</span></div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span><span class="comment">// 超过1MB，多分配1MB空余空间</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);<span class="comment">// 分配空间</span></div><div class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 分配失败</span></div><div class="line">    <span class="comment">// 设置参数</span></div><div class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line">    <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 空间的重分配</span></div><div class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></div><div class="line"></div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">    sh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+sh-&gt;len+<span class="number">1</span>);</div><div class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> sh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds连接操作"><a href="#sds连接操作" class="headerlink" title="sds连接操作"></a>sds连接操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></div><div class="line">    <span class="keyword">size_t</span> curlen = sdslen(s); <span class="comment">// 获取字符串长度</span></div><div class="line"></div><div class="line">    s = sdsMakeRoomFor(s,len);<span class="comment">// 扩展字符串</span></div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);<span class="comment">// 连接字符串到末尾</span></div><div class="line">    sh-&gt;len = curlen+len;<span class="comment">// 设置长度</span></div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</div><div class="line">    s[curlen+len] = <span class="string">'\0'</span>;<span class="comment">// 设置尾部</span></div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sds复制"><a href="#sds复制" class="headerlink" title="sds复制"></a>sds复制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line">    <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</div><div class="line"></div><div class="line">    <span class="comment">// 空间不足，分配空间</span></div><div class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;</div><div class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</div><div class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 复制</span></div><div class="line">    <span class="built_in">memcpy</span>(s, t, len);</div><div class="line">    s[len] = <span class="string">'\0'</span>;</div><div class="line">    sh-&gt;len = len;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一些其他接口"><a href="#一些其他接口" class="headerlink" title="一些其他接口"></a>一些其他接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;<span class="comment">// 格式化输出</span></div><div class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>; <span class="comment">// 去除cset中所含字符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;<span class="comment">// 获取指定区间字符串</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>; <span class="comment">// 更新字符串长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>; <span class="comment">// 清空字符串</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span></span>; <span class="comment">// 字符串比较</span></div><div class="line"><span class="comment">// 依据sep将s分割，返回 一个二维数组</span></div><div class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span>;</div><div class="line"><span class="comment">// 释放由sdssplitlen函数解析的二维数组 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>; <span class="comment">// 转小写</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>; <span class="comment">// 转大写</span></div><div class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;<span class="comment">// ll转sds</span></div><div class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span></span>; <span class="comment">// 以分隔符连接字符串子数组构成新的字符串</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[读书摘录-程序员的思维方式]]></title>
      <url>/2017/03/26/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>2.2 德雷福斯模型的5个阶段</p>
<p>2017-01-24</p>
<p>但是，如果给新手提供与情境无关的规则去参照，他们就会变得能干起来。也就是说，需要这种形式的规则：“当X发生时，执行Y。”换言之，需要一份指令清单。<br>图2-2　玉米饼食谱，不过你知道需要烹饪多长时间吗<br>这就是呼叫中心的工作原理。你可以雇用一大批对当前技术没有很多经验的人，然后让他们按照一个决策树按部就班地执行下去。</p>
<p>3.3 L型和R型的特征</p>
<p>2017-02-06</p>
<p>事实上，综合是一项非常强大的学习技术，以至于麻省理工学院媒体实验室的尼葛洛庞蒂在Don’t Dissect the Frog, Build It [Neg94]中建议，真正想要了解一只青蛙，传统的解剖不是办法，更好的方式是构造一只青蛙。<br>也就是说，要求学生构造一个具有青蛙特征的生物。这是一种伟大的方式，可以真正了解到，什么使青蛙成之为青蛙，以及青蛙如何适应其特定环境。这是一个综合学习的绝佳例子。</p>
<p>4.4 收获R型线索</p>
<p>2017-02-08</p>
<p>这种方法为什么会起作用？我认为这是因为晨写让毫无防备的大脑倾倒想法。早上刚起床时，你还没有像你想的那样清醒。潜意识仍然占主角。你还没有提起所有防备，也还未适应有限的现实世界。你可以直接连通R型，至少一小会儿。</p>
<p>2017-02-08</p>
<p>你需要培养一种非目标驱动的思维方式。正如庞加莱所做，把一切都写在纸上（或者编辑器中，如果你必须得这么做的话），然后不去管它。不要试图思考。记住它，如布朗所说，不要关注它。只要简单地记住它。让事实和问题自由地搅和、浸泡（我们将在8.2节讨论这一话题）</p>
<a id="more"></a>
<p>4.5 收获模式</p>
<p>2017-02-08</p>
<p>“在开始练习武术之后，我感觉到我的注意力持续时间和控制能力（比如在糟糕的环境下集中注意力）都有了提高。我一直在向软件开发人员和其他知识工作者推荐我的实践经验。它就是气功，它既有武术的一面，也包含太极、冥想和呼吸的方面。</p>
<p>注</p>
<p>跑步应该也行的。</p>
<p>6.2 瞄准SMART目标</p>
<p>2017-03-05</p>
<p>使用SMART方法实现你的目标。<br>在这里，SMART代表具体的、可度量的、可实现的、相关的和时间可控的（Specific, Measurable, Achievable, Relevant, and Time-boxed）。对于任何目标（减肥、炒老板鱿鱼、征服世界等），你都需要制定一个计划，定出一系列帮助你实现目标的任务（objective）。每一个任务都应该具有SMART特性。</p>
<p>6.3 建立一个务实的投资计划</p>
<p>2017-03-05</p>
<p>就像任何投资一样——无论是金融还是艺术上的——都必须时刻进行管理。<br>很多年来，戴维·托马斯（Dave Thomas）和我一直把实用投资计划作为咨询实践的一部分，在这里我简单地介绍一下这些内容。实用投资计划基于一种非常简单但是有效的理念：像管理你的金融投资一样小心管理你的知识投资。</p>
<p>6.4 使用你的原生学习模式</p>
<p>2017-03-05</p>
<p>很多教育家把学习者分为三大类：视觉型、听觉型和动觉型。<br>视觉型学习者需要看到学习资料和老师。图片和图表对视觉型学习者都很有效，他们对肢体语言和面部表情也很敏感。<br>听觉型学习者必须听到学习材料。讲座、研讨会和播客都很有效。他们对语气、语速和其他细节都很敏感。<br>动觉型学习者通过活动和触摸来学习。他们需要亲身感受学习材料。特别是对运动、艺术和<br>工艺等领域，你都需要通过动手来学习。</p>
<p>6.9 利用文档的真正力量</p>
<p>2017-03-05</p>
<p>创建低层次的设计文档，简单地反映代码的细节（几乎很快就会过时）对任何人都没有意义。但是其他形式的文档可能是有价值的，即使没有明确的读者。</p>
<p>6.10 以教代学</p>
<p>2017-03-05</p>
<p>为了省掉你的同事过来，我们建议你在桌子上摆一只黄色橡皮鸭作替身，当你遇到问题时，先和它<br>聊聊。<br>另一种有用的办法是尝试向一个孩子或者你所在领域之外的人解释你的东西。诀窍就是用他们能理解的话语进行解释。这是一个向你的Edna大婶解释你的工作的好机会，也是一个练习从听众角度观察问题并创建隐喻的好机会，这些隐喻有助于解释、阐明你的工作。你可能会在这个过程中惊奇地发现一些新的收获和领悟。</p>
<p>第7章 积累经验</p>
<p>2017-03-05</p>
<p>我们应该小心翼翼地从实践中获得智慧并适可而止，否则我们就会像不慎坐在热炉子上的猫一样，它再也不会坐在热炉子上——这还好，但是它也再也不会坐在冷炉子上。<br>——马克·吐温</p>
<p>7.3 正确对待实践中的失败</p>
<p>2017-03-05</p>
<p>你可以在公司范围之外尝试，比如在家里做开源项目。这起码会减少产生负面结果的风险。但是仅仅这样不足以为你建立一个积极的学习环境。不论是在公司团队还是在黑夜里偷偷进行的独自实验，你都需要做到以下几点。</p>
<p>7.4 了解内在诀窍</p>
<p>2017-03-05</p>
<p>在采取纠正行动之前完全知道“这是什么”对于调试非常重要。太多程序员（包括我自己）往往在没有完全明白真正的错误是什么之前就着急修正它。匆忙地作出判断或者过早地进行修补。你需要首先完全明白系统的原理，然后再判断哪部分错了，最后提供解决方案。也就说，不要动手做，而是要袖手旁观。琼·金姆介绍下述方法来帮助大家充分了解。</p>
<p>8.2 通过分散注意力来集中注意力</p>
<p>2017-03-05</p>
<p>怎么区分你是在浸泡思想还是在拖延、浪费时间呢？<br>我总是把拖延称为“做纸娃娃”。一个密友（姓名保密）第二天有一门重要的考试，但是前一天晚上，她并不学习，而是坐在沙发上剪纸娃娃。当时这在我看来就是典型的耗费时间：一个无关的非生产性的活动阻碍了你需要做的真正工作。<br>但也许我错了。也许这不是拖延。这是一个高级触觉练习，也许是她浸泡思想的方法。她通过了测验并以优异成绩毕业。<br>如果某个任务你真的不想做，那么任何分散注意力的努力都很可能只是耗费时间。如果你仍然有兴趣，但感觉“困难”，那么思想其实是在继<br>续发酵，这当然没问题。</p>
<p>8.6 保持足够大的情境</p>
<p>2017-03-05</p>
<p>事实上，保持情境中任务相关的东西很有益处。不论你如何衡量生产力，仅仅多使用一台显示器就可以让你的生产力提升20%~30%。<br>这是为什么？<br>适合你的不是桌面隐喻，而是Frederick Brooks在几年前描述的拥挤的飞机座位隐喻。在一个大桌面上，你可以展开你的工作，看到你在做什么——同时看到所有的。在拥挤的飞机座位上，你没有足够的空间同时看两份以上的文档（或者文档的一部分）。你必须来回地切换文档。<br>我敢打赌，让你去Staples或者Office Depot等办公用品店寻找一张17英寸的办公桌，你找不到，因为这个尺寸实在是太小了。然而，大多数显示器都是17到21英寸。这点空间就是我们办公的地方。你不得不在活动窗口和应用程序之间切换，因为你无法在如此小的空间里保持足够的情境。<br>你知道Alt-Tab组合键（Mac上的Command-Tab）称为什么吗?情境切换。正如我们看到的，情景切换扼杀生产力。即使是类似使用Alt-Tab切换不同窗口的小动作也会花费时间、短期记忆力和精力。</p>
<p>2017-03-05</p>
<p>在最先进的操作系统上你可以使用虚拟桌面切换器，允许你拥有很多不同的屏幕，你可以使用特殊键随意切换。每一个屏幕都是独立的，称为工作空间。秘诀在于你如何在工作空间中分配应用。</p>
<p>9.2 明天上午做什么</p>
<p>2017-03-05</p>
<p>现在就开始吧！你选择开始做什么并不特别重要，重要的是主动尝试本书中提到的知识，这是你明天一大早要做的第一件事。<br>下面是对第一步的一些建议。<br>开始承担责任，不要害怕问“为什么”，也不要害怕问“你怎么知道的”或者“我怎么知道的”，同样要大方地回答“我目前还不知道”。<br>挑两件帮助你维持情境、免受干扰的事情，立即实施。<br>创建一个实用投资计划，设定SMART目标。<br>弄清楚你在所属专业领域中所处的位置（从新手到专家）和你期望的位置。保证诚实。你需要更多的诀窍还是更多的情境？更多规则还是更多直觉？<br>实践。某段代码遇到问题了吗？尝试用五种不同的方式编写。<br>允许犯更多错误——错误是许可的，要从中学习教训。<br>携带一个笔记本（最好不带横线）。涂鸦，做思维导图，记笔记。让你的思想自由地流动。<br>打开心扉接收美感和其他的感官输入。不论是<br>你的房间、桌面还是代码，关注它们是多么地赏心悦目。<br>开始在私人wiki上记录你感兴趣的事情。<br>开始写博客。为你读过的书写评论。阅读更多书，你会有更多可写的东西。使用SQ3R和思维导图。<br>让散步成为你每天生活的一部分。<br>启动一个读书小组。<br>再拿一个显示器，开始使用虚拟桌面。<br>回顾每章的“实践单元”，尝试去做。</p>
<p>9.3 超越专家</p>
<p>2017-03-05</p>
<p>达芬奇在600年前抱怨说：“人们看却没有看见，听却没有听见，吃却没有味觉，接触却没有触觉，说话却没有思考。”</p>
]]></content>
      
        <categories>
            
            <category> 摘录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-内存分配]]></title>
      <url>/2017/03/21/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>redis的内存分配主要就是对malloc和free进行了一层简单的封装。具体的实现在zmalloc.h和zmalloc.c中。</p>
<h2 id="内存分配器的选择"><a href="#内存分配器的选择" class="headerlink" title="内存分配器的选择"></a>内存分配器的选择</h2><p>redis支持多种内存分配器，可以选择的分配器tcmalloc、jemalloc、dlmalloc、malloc/malloc.h(apple)，这几个分配器自带内存大小的记录。如果不进行设置，则默认使用malloc进行分配。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// zmalloc.h</span></div><div class="line"><span class="comment">// 选择使用的内存分配器，分别为tcmalloc、jemalloc、dlmalloc、malloc/malloc.h</span></div><div class="line"><span class="comment">// 同时设置HAVE_MALLOC_SIZE为真，内存分配器自带大小统计。</span></div><div class="line"><span class="comment">// 如果不选择内存分配器，则使用默认的malloc，同时同时设置HAVE_MALLOC_SIZE为假。</span></div><div class="line"><span class="comment">// 指定zmalloc_size</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"tcmalloc-"</span> __xstr(TC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(TC_VERSION_MINOR))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6) || (TC_VERSION_MAJOR &gt; 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) tc_malloc_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of tcmalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"jemalloc-"</span> __xstr(JEMALLOC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_MINOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_BUGFIX))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jemalloc/jemalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (JEMALLOC_VERSION_MAJOR == 2 &amp;&amp; JEMALLOC_VERSION_MINOR &gt;= 1) || (JEMALLOC_VERSION_MAJOR &gt; 2)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) je_malloc_usable_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of jemalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) malloc_size(p)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_DLMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Win32_Interop/win32_dlmalloc.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"dlmalloc-"</span> __xstr(2) <span class="meta-string">"."</span> __xstr(8) )</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p)  g_msize(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ZMALLOC_LIB</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB <span class="meta-string">"libc"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// zmalloc.c</span></div><div class="line"><span class="comment">// 依据选择的内存分配器，设定好宏定义，否则使用系统默认分配。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) tc_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) tc_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) tc_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) tc_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) je_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) je_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) je_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) je_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_DLMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) g_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) g_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) g_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) g_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h2 id="功能函数一栏"><a href="#功能函数一栏" class="headerlink" title="功能函数一栏"></a>功能函数一栏</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;<span class="comment">// 调用malloc，分配size大小的空间</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;<span class="comment">// 调用calloc，分配size大小的空间</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;<span class="comment">// 调用realloc，重新分配size大小的空间</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;<span class="comment">// 释放ptr</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">// c风格字符串copy</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>); <span class="comment">// 获取当前占用的内存大小</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_enable_thread_safeness</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 设置线程安全</span></div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)); // 设置内存分配失败的处理方法</div><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">size_t</span> rss)</span></span>;<span class="comment">// 获取所给内存和已经使用的内存大小之比</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>); <span class="comment">// 获取RSS信息（Resident Set Size）</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_get_private_dirty(<span class="keyword">void</span>);<span class="comment">// 获取实际内存大小</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_get_smap_bytes_by_field(<span class="keyword">char</span> *field);<span class="comment">// 获取/proc/self/smaps字段的字节数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlibc_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 获取物理内存大小</span></div><div class="line">WIN32_ONLY(<span class="keyword">void</span> zmalloc_free_used_memory_mutex(<span class="keyword">void</span>);) <span class="comment">//原始系统free的释放方法</span></div></pre></td></tr></table></figure>
<h2 id="统计使用的内存总数"><a href="#统计使用的内存总数" class="headerlink" title="统计使用的内存总数"></a>统计使用的内存总数</h2><p>redis每次分配内存、释放内存都会进行记录。用来统计redis使用的总内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;<span class="comment">// 获取使用的内存，直接获取used_memory的变量的值。</span></div><div class="line">    <span class="keyword">size_t</span> um;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123;<span class="comment">// 线程安全</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC)</span></div><div class="line">        um = update_zmalloc_stat_add(<span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        pthread_mutex_lock(&amp;used_memory_mutex);</div><div class="line">        um = used_memory;</div><div class="line">        pthread_mutex_unlock(&amp;used_memory_mutex);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 非线程安全</span></div><div class="line">        um = used_memory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> um;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;<span class="comment">// 定义了一个全局变量，用来记录使用的内存数量。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;<span class="comment">// 默认不线程安全，调用zmalloc_enable_thread_safeness进行设置为线程安全。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32<span class="comment">// 根据系统选择多线程锁。</span></span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// __ATOMIC_RELAXED提供原子加减操作</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) __atomic_add_fetch(&amp;used_memory, (__n), __ATOMIC_RELAXED)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) __atomic_sub_fetch(&amp;used_memory, (__n), __ATOMIC_RELAXED)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAVE_ATOMIC)<span class="comment">// GCC提供的原子加减操作</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) __sync_add_and_fetch(&amp;used_memory, (__n))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) __sync_sub_and_fetch(&amp;used_memory, (__n))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">// 使用多线程锁来实现多线程加减操作</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory += (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory -= (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// 增加redis内存计数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    <span class="keyword">size_t</span> _n = (__n); \</div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(PORT_LONG)-(_n&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>)); \ <span class="comment">// 将n调整为sizeof(PORT_LONG)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \ <span class="comment">// 开启线程安全</span></div><div class="line">        update_zmalloc_stat_add(_n); \</div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory += _n; \ <span class="comment">// 不开启线程安全</span></div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment">// 减少redis内存计数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></div><div class="line">    <span class="keyword">size_t</span> _n = (__n); \</div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(PORT_LONG)-(_n&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>)); \ <span class="comment">// 将n调整为sizeof(PORT_LONG)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_sub(_n); \<span class="comment">// 开启线程安全</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory -= _n; \<span class="comment">// 不开启线程安全</span></div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h2 id="内存管理函数"><a href="#内存管理函数" class="headerlink" title="内存管理函数"></a>内存管理函数</h2><h3 id="异常处理函数"><a href="#异常处理函数" class="headerlink" title="异常处理函数"></a>异常处理函数</h3><p>异常处理函数, 在内存分配失败时进行调用。</p>
<p>默认使用zmalloc_default_oom，也可以通过zmalloc_set_oom_handler进行设置异常处理方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</div><div class="line"></div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) &#123;</div><div class="line">    zmalloc_oom_handler = oom_handler;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %Iu bytes\n"</span>,    WIN_PORT_FIX <span class="comment">/* %zu -&gt; %Iu */</span></div><div class="line">        size);<span class="comment">// 打印日志</span></div><div class="line">    fflush(<span class="built_in">stderr</span>);</div><div class="line">    <span class="built_in">abort</span>();<span class="comment">// 中断退出</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zmalloc"><a href="#zmalloc" class="headerlink" title="zmalloc"></a>zmalloc</h3><p>zmalloc用来分配指定大小的内存。实际上对malloc进行了一层封装，加入了异常处理和内存统计。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用malloc进行内存分配</span></div><div class="line">    <span class="comment">// 多出的PREFIX_SIZE大内存用来记录该段内存大小。</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 分配失败的异常处理</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 统计内存使用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line"></div><div class="line">    <span class="comment">// 内存分配器自带内存大小</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zcalloc"><a href="#zcalloc" class="headerlink" title="zcalloc"></a>zcalloc</h3><p>calloc是分配内存，并初始化为0。封装的和zmalloc类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配内存</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 分配失败的异常处理</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 统计内存使用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zrealloc"><a href="#zrealloc" class="headerlink" title="zrealloc"></a>zrealloc</h3><p>zrealloc用来重新调整分配的内存大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line">    <span class="keyword">void</span> *newptr;</div><div class="line"></div><div class="line">    <span class="comment">// ptr为空，直接使用zmalloc进行分配size大小内存。</span></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    oldsize = zmalloc_size(ptr); <span class="comment">// 获取ptr指向的内存大小</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(ptr,size); <span class="comment">// 重新分配内存</span></div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size); <span class="comment">// 异常处理</span></div><div class="line"></div><div class="line">    update_zmalloc_stat_free(oldsize);<span class="comment">// 先减</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));<span class="comment">// 后加</span></div><div class="line">    <span class="keyword">return</span> newptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);<span class="comment">// 获取ptr指向的内存大小</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);<span class="comment">// 重新分配内存</span></div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);<span class="comment">// 异常处理</span></div><div class="line"></div><div class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</div><div class="line">    update_zmalloc_stat_free(oldsize);<span class="comment">// 先减</span></div><div class="line">    update_zmalloc_stat_alloc(size);<span class="comment">// 后加</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zfree"><a href="#zfree" class="headerlink" title="zfree"></a>zfree</h3><p>释放函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">// 空直接返回</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));<span class="comment">// 减少统计数量</span></div><div class="line">    <span class="built_in">free</span>(ptr);<span class="comment">// 释放</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE; <span class="comment">// 获取真实的指针</span></div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);<span class="comment">// 获取大小</span></div><div class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);<span class="comment">// 减少统计数量</span></div><div class="line">    <span class="built_in">free</span>(realptr);<span class="comment">// 释放</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="zmalloc-size"><a href="#zmalloc-size" class="headerlink" title="zmalloc_size"></a>zmalloc_size</h3><p>获取指针指向内存大小，在内存分配器不自带该函数时定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// zmalloc.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">// zmalloc.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</div><div class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(PORT_LONG) by</span></div><div class="line"><span class="comment">     * the underlying allocator. */</span></div><div class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(PORT_LONG)-(size&amp;(<span class="keyword">sizeof</span>(PORT_LONG)<span class="number">-1</span>));</div><div class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码阅读-开始]]></title>
      <url>/2017/03/21/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>自本博客之后的文章大概都是依照《Redis设计与实现》对Redis的源码进行阅读的记录。目的是为了对于Redis有一个了解，同时对之后需要使用Redis的项目上能够有所帮助。</p>
<h2 id="Redis的介绍"><a href="#Redis的介绍" class="headerlink" title="Redis的介绍"></a>Redis的介绍</h2><p>redis是一个使用C编写的key-value数据库。性能极高且支持丰富的数据类型。它所有的操作都是原子性的。代码精简，只有3w行不到，利于阅读。</p>
<h2 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h2><p><a href="http://blog.huangz.me/diary/2014/how-to-read-redis-source-code.html" target="_blank" rel="external">如何阅读Redis源码？</a>阅读的顺序主要还是按照黄建宏老师所建议的顺序进行阅读,暂时不看多机部分的实现。</p>
<ol>
<li>阅读数据结构的实现。</li>
<li>阅读内存编码数据结构的实现。</li>
<li>阅读数据类型的实现。</li>
<li>阅读数据库实现相关代码。</li>
<li>阅读客户端和服务端相关代码。</li>
</ol>
<p>至此将Redis阅读完毕。</p>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gitlab workflow]]></title>
      <url>/2017/01/29/gitlab-workflow/</url>
      <content type="html"><![CDATA[<p>建立一个长期分支，就是master，master分支上的版本都是能够编译运行的版本。<br>整个工作流程如下。<br>第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。<br>第二步：新分支开发完成后，或者需要讨论的时候，先从master合并到分支，解决冲突，然后向master发起一个pull request（简称PR）。<br>第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。<br>第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</p>
<h1 id="建立测试项目"><a href="#建立测试项目" class="headerlink" title="建立测试项目"></a>建立测试项目</h1><p>新建一个项目用于测试工作流。<br>演示项目地址：<a href="http://10.10.10.98/MekaYangyi/workflow" target="_blank" rel="external">http://10.10.10.98/MekaYangyi/workflow</a><br><img src="/img/gitlab工作流程/10-21-42.jpg" alt=""></p>
<h1 id="设置分支保护"><a href="#设置分支保护" class="headerlink" title="设置分支保护"></a>设置分支保护</h1><p>新建项目默认master用户才能够push和merge。<br>其余用户只能新建分支，在分支测试完毕后，再发起Merge Requests。发起后，由master进行审核后合并。<br><img src="/img/gitlab工作流程/10-32-56.jpg" alt=""></p>
<a id="more"></a>
<h1 id="设置开发成员"><a href="#设置开发成员" class="headerlink" title="设置开发成员"></a>设置开发成员</h1><p>项目创建者在项目页面选择Member。<br><img src="/img/gitlab工作流程/10-31-10.jpg" alt=""></p>
<p>设置开发人员分为两种，一种是直接设置用户，一种是设置一Group都为指定权限。<br>权限分为四类：</p>
<blockquote>
<p>Guest<br>Reporter<br>Developer<br>Master</p>
</blockquote>
<p>一般开发人员指定为Developer。<br>具体权限在<a href="http://10.10.10.98/help/user/permissions.md查看。" target="_blank" rel="external">http://10.10.10.98/help/user/permissions.md查看。</a><br>设置用户权限<br><img src="/img/gitlab工作流程/11-23-52.jpg" alt=""><br>设置整个Group的权限<br><img src="/img/gitlab工作流程/11-24-20.jpg" alt=""></p>
<h1 id="建立本地分支"><a href="#建立本地分支" class="headerlink" title="建立本地分支"></a>建立本地分支</h1><p>在项目文件夹右键，选择TortoiseGit→Create Branch。<br><img src="/img/gitlab工作流程/11-43-08.jpg" alt=""><br>填写信息<br><img src="/img/gitlab工作流程/11-52-57.jpg" alt=""></p>
<h1 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h1><p>在项目文件夹右键，选择TortoiseGit→Switch/Checkout。<br><img src="/img/gitlab工作流程/11-54-23.jpg" alt=""><br>选择OK。<br><img src="/img/gitlab工作流程/11-55-03.jpg" alt=""></p>
<h1 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h1><p>分出分支后，可以在本地进行Commit，知道一个功能开发完毕后，再上传到服务器。<br>修改本地的文件，Commit。<br><img src="/img/gitlab工作流程/11-57-19.jpg" alt=""><br>填写上传备注，Commit。</p>
<h1 id="将Master向Test-WorkFlow合并"><a href="#将Master向Test-WorkFlow合并" class="headerlink" title="将Master向Test_WorkFlow合并"></a>将Master向Test_WorkFlow合并</h1><p>先从服务器pull最新版本，然后将master向Test_WorkFlow合并，防止master在分支分出之后被修改导致的冲突。<br>从服务器pull最新版本。<br><img src="/img/gitlab工作流程/22-39-02.jpg" alt=""><br>将master向Test_WorkFlow合并。<br><img src="/img/gitlab工作流程/22-41-09.jpg" alt=""><br>合并解决冲突。<br><img src="/img/gitlab工作流程/22-41-37.jpg" alt=""></p>
<h1 id="push"><a href="#push" class="headerlink" title="push"></a>push</h1><p>上传成功后选择push。<br><img src="/img/gitlab工作流程/22-44-54.jpg" alt=""></p>
<p>确认。<br><img src="/img/gitlab工作流程/11-59-05.jpg" alt=""><br>成功。<br><img src="/img/gitlab工作流程/11-59-45.jpg" alt=""></p>
<h1 id="发起Merge-Request"><a href="#发起Merge-Request" class="headerlink" title="发起Merge Request"></a>发起Merge Request</h1><p>在项目页面找到分支，选择Merge Request<br><img src="/img/gitlab工作流程/12-05-10.jpg" alt=""><br>填写相关信息，Submit merge request<br><img src="/img/gitlab工作流程/12-06-31.jpg" alt=""></p>
<h1 id="检视代码并讨论"><a href="#检视代码并讨论" class="headerlink" title="检视代码并讨论"></a>检视代码并讨论</h1><p>选择Merge Request。<br>单击测试分支合并功能这一个Merge Request<br><img src="/img/gitlab工作流程/12-08-38.jpg" alt=""><br>弹出页面。<br><img src="/img/gitlab工作流程/12-09-43.jpg" alt=""><br>检视代码</p>
<h2 id="Commit，查看修改记录。"><a href="#Commit，查看修改记录。" class="headerlink" title="Commit，查看修改记录。"></a>Commit，查看修改记录。</h2><p>图中红色区域单击可以Diff与查看源文件。<br><img src="/img/gitlab工作流程/12-11-44.jpg" alt=""><br>单击任意版本提交记录，增加检视意见，在diff时，任意处可以添加讨论。或者在页面底部对整个修改进行评价。<br><img src="/img/gitlab工作流程/112-18-49.jpg" alt=""></p>
<p><img src="/img/gitlab工作流程/12-19-25.jpg" alt=""></p>
<h2 id="Changes，查看版本区别。"><a href="#Changes，查看版本区别。" class="headerlink" title="Changes，查看版本区别。"></a>Changes，查看版本区别。</h2><p><img src="/img/gitlab工作流程/12-12-47.jpg" alt=""></p>
<h2 id="Discusion，填写建议"><a href="#Discusion，填写建议" class="headerlink" title="Discusion，填写建议"></a>Discusion，填写建议</h2><p>填写建议后，选择Comment可以互相讨论。<br>或者选择Close merge request关闭请求。<br><img src="/img/gitlab工作流程/12-15-41.jpg" alt=""></p>
<h2 id="Accept-merge-request或者Close-merge-request"><a href="#Accept-merge-request或者Close-merge-request" class="headerlink" title="Accept merge request或者Close merge request"></a>Accept merge request或者Close merge request</h2><p><img src="/img/gitlab工作流程/12-22-44.jpg" alt=""></p>
<h2 id="合并完成"><a href="#合并完成" class="headerlink" title="合并完成"></a>合并完成</h2><p>选择Accept Merge Request,同时选择合并时将分支删除。<br><img src="/img/gitlab工作流程/12-23-55.jpg" alt=""><br>合并结果。<br><img src="/img/gitlab工作流程/12-25-09.jpg" alt=""></p>
<h1 id="本地pull"><a href="#本地pull" class="headerlink" title="本地pull"></a>本地pull</h1><p>在本地项目进行pull,同步服务器版本。<br><img src="/img/gitlab工作流程/12-26-33.jpg" alt=""><br>本地同步结果。<br><img src="/img/gitlab工作流程/12-27-07.jpg" alt=""></p>
<h1 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h1><p>由于远程分支与本地分支没有关系，那么当远程正式Merge之后，需要删除本地分支，防止以后分支一直增加，不减少。<br>在项目文件夹右键，选择TortoiseGit→Switch/Checkout，先把分支切换到本地master。<br><img src="/img/gitlab工作流程/11-54-23.jpg" alt=""><br>切换完成后，再次进入该界面选择….<br><img src="/img/gitlab工作流程/12-47-04.jpg" alt=""><br>删除分支<br><img src="/img/gitlab工作流程/12-45-50.jpg" alt=""></p>
<h1 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h1><p>Issue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。</p>
<h2 id="新建Issue"><a href="#新建Issue" class="headerlink" title="新建Issue"></a>新建Issue</h2><p>选择New Issue<br><img src="/img/gitlab工作流程/12-32-50.jpg" alt=""><br>填写相关信息。<br>功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如”1-测试Issue”。<br><img src="/img/gitlab工作流程/12-36-52.jpg" alt=""></p>
<p>新建完成,每一个Issue都有一个编号，本Issue的编号为#1。<br><img src="/img/gitlab工作流程/12-37-36.jpg" alt=""><br>在分支开发完成后，在commit message里面，可以写上”fixes #14”或者”closes #67”。<br><img src="/img/gitlab工作流程/12-39-48.jpg" alt=""><br>Github规定，只要commit message里面有下面这些动词 + 编号，就会关闭对应的issue。</p>
<blockquote>
<p>close<br>closes<br>closed<br>fix<br>fixes<br>fixed<br>resolve<br>resolves<br>resolved</p>
</blockquote>
<p>这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是username/repository#issue_number。<br>Pull Request被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。</p>
<h2 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h2><p><img src="/img/gitlab工作流程/12-41-19.jpg" alt=""><br><img src="/img/gitlab工作流程/12-41-51.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> gitlab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一次使用gitlab]]></title>
      <url>/2017/01/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab/</url>
      <content type="html"><![CDATA[<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>版本差别不大，目前使用的版本git2.11.0.3。<br>一路下一步,不修改安装位置，直接使用默认设置。</p>
<h1 id="安装TortoiseGit"><a href="#安装TortoiseGit" class="headerlink" title="安装TortoiseGit"></a>安装TortoiseGit</h1><p>一路下一步，不修改安装位置，直接使用默认设置。</p>
<h1 id="登录账户"><a href="#登录账户" class="headerlink" title="登录账户"></a>登录账户</h1><h2 id="管理员创建账户"><a href="#管理员创建账户" class="headerlink" title="管理员创建账户"></a>管理员创建账户</h2><p>Admin→New User。新建账户、并设置密码。同时设置该用户所属Group。</p>
<blockquote>
<p>name：上传显示的名字，可以经常更改，使用中文名好。</p>
<p>username：登陆的用户名，不可修改，用于账户登陆。</p>
<p>email：账户email，内网联系email。</p>
<p>password：密码，牢记，root用户可修改。</p>
</blockquote>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登陆内网gitlab，目前网址：10.10.10.98。<br><img src="/img/第一次使用gitlab/22-04-07.jpg" alt=""></p>
<a id="more"></a>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>登录后会要求修改密码，自己输入即可。<br><img src="/img/第一次使用gitlab/22-05-00.jpg" alt=""></p>
<h1 id="设置TortoiseGit"><a href="#设置TortoiseGit" class="headerlink" title="设置TortoiseGit"></a>设置TortoiseGit</h1><p>将注册的用户填入TortoiseGit中,设置为全局账号。<br><img src="/img/第一次使用gitlab/21-07-01.jpg" alt=""></p>
<h1 id="添加ssh"><a href="#添加ssh" class="headerlink" title="添加ssh"></a>添加ssh</h1><p>如果不添加shh，每次修改都会要求输入账号密码，比较麻烦。添加后与设备绑定，修改不再需要填写账号密码。如果不再使用一个设备，请删除ssh。</p>
<h2 id="生成ssh"><a href="#生成ssh" class="headerlink" title="生成ssh"></a>生成ssh</h2><p>任意空白处，选择git bash。<br><img src="/img/第一次使用gitlab/06-27-40.jpg" alt=""><br>窗口中输入，一路按回车。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;你注册的email地址&quot;</div></pre></td></tr></table></figure></p>
<p>生成后的公钥会存放在 C:/Users/You_User_Name/.ssh/id_rsa.pub。<br>用记事本打开，复制。<br><img src="/img/第一次使用gitlab/06-30-35.jpg" alt=""></p>
<h2 id="将ssh加入gitlab"><a href="#将ssh加入gitlab" class="headerlink" title="将ssh加入gitlab"></a>将ssh加入gitlab</h2><p>浏览器转到<a href="http://10.10.10.98/profile/keys。" target="_blank" rel="external">http://10.10.10.98/profile/keys。</a><br>将复制的Key粘贴，Add key。<br><img src="/img/第一次使用gitlab/06-32-52.jpg" alt=""></p>
<h1 id="新建一个项目"><a href="#新建一个项目" class="headerlink" title="新建一个项目"></a>新建一个项目</h1><h2 id="新建一个私有项目"><a href="#新建一个私有项目" class="headerlink" title="新建一个私有项目"></a>新建一个私有项目</h2><p>新建一个私有项目进行实验，gitlab是否能够正常上传。<br>选择new project。<br><img src="/img/第一次使用gitlab/06-07-09.jpg" alt=""></p>
<h2 id="填写基本信息"><a href="#填写基本信息" class="headerlink" title="填写基本信息"></a>填写基本信息</h2><blockquote>
<p>Project name：项目名称。<br>Project description：项目描述。<br>Visibility Level：项目级别，内网使用只选择public与private。private除了项目成员不可见，public在内网均可见。</p>
</blockquote>
<p>选择Create project创建项目。<br><img src="/img/第一次使用gitlab/06-08-43.jpg" alt=""></p>
<h1 id="Clone项目"><a href="#Clone项目" class="headerlink" title="Clone项目"></a>Clone项目</h1><p>项目创建完成，复制项目地址。<br>复制浏览器的项目地址：<a href="http://10.10.10.98/test/test_project。" target="_blank" rel="external">http://10.10.10.98/test/test_project。</a><br><img src="/img/第一次使用gitlab/06-14-02.jpg" alt=""><br>选择计算机一个文件夹，右键，选择git clone。<br><img src="/img/第一次使用gitlab/06-15-28.jpg" alt=""><br>clone之前复制地址项目，确认，输入用户名与密码，clone成功，会新建一个文件夹。<br><img src="/img/第一次使用gitlab/06-16-37.jpg" alt=""></p>
<h1 id="第一次push"><a href="#第一次push" class="headerlink" title="第一次push"></a>第一次push</h1><p>在该文件夹中建立一个README.md文件。<br><img src="/img/第一次使用gitlab/06-18-54.jpg" alt=""></p>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>右键add，确认，ok。<br><img src="/img/第一次使用gitlab/06-19-25.jpg" alt=""></p>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>commit将修改更新到本地。<br>在项目文件夹空白处右键，选择git commit。<br><img src="/img/第一次使用gitlab/06-25-26.jpg" alt=""><br>填写上传理由，commit。<br><img src="/img/第一次使用gitlab/06-26-03.jpg" alt=""></p>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>选择push，push能够将修改push到服务器。<br><img src="/img/第一次使用gitlab/06-36-23.jpg" alt=""><br>确认。<br><img src="/img/第一次使用gitlab/06-37-12.jpg" alt=""><br>成功界面。<br><img src="/img/第一次使用gitlab/06-37-36.jpg" alt=""></p>
<h1 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h1><p>成功在网页端看到修改记录(之前误上传为.md.txt文件，修改为.md文件网页端会显示文字)。<br><img src="/img/第一次使用gitlab/06-40-03.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> gitlab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] stl源码剖析 总结]]></title>
      <url>/2016/11/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>大致上是将STL源码剖析看过了一篇。<br>前三章看到比较认真，后面几章就看到比较粗略了。<br>我想STL的精髓正是在内存配置、迭代器、容器中。<br>至于后面的一些关联式容器，用的红黑树稍复杂，不过在之前的数据结构的基础上和前几章对stl的一些常用方法是熟悉下，其实也就简单了。算法，利用迭代器，同时特化不同的版本。仿函数则是模仿函数效果的对象。整体上都算简单了。<br>我的计划是在未来的一小段日子里实现一个小型的stl，所谓实现，可能也不过是重新将sgi的代码打一遍罢了。不过对于整个stl的理解，我相信会更好一些。<br>之后我应该会更新一些写小型stl遇到的问题和解决方案。<br>项目的地址：<br><a href="https://github.com/MekaYangyi/STL/" target="_blank" rel="external">https://github.com/MekaYangyi/STL/</a></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] stl源码剖析 第四章 序列式容器]]></title>
      <url>/2016/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>容器分类<br><img src="/img/20161120124915.png" alt=""></p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>vector还是比较简单，也就是一个动态数组，提供了些操作，带三个指针，start/finish/end<br>核心就是动态调整内存的方法，也就是满了开大一倍空间，拷贝过去。<br>push_back等操作都是值语义的，拷贝传进来的内容放入到vector中。<br>因为是连续的空间，所有元素连续存储在一整块内存上，迭代器直接用的原始指针。</p>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>list复杂些.<br>模型和常见的list是一致的，动态创建节点，插入。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span> &#123;</span></div><div class="line">  _List_node_base* _M_next;</div><div class="line">  _List_node_base* _M_prev;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> _<span class="title">List_node</span> :</span> <span class="keyword">public</span> _List_node_base &#123;</div><div class="line">  _Tp _M_data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//迭代器base</span></div><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator_base</span> &#123;</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>                     size_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</div><div class="line"></div><div class="line">  _List_node_base* _M_node;<span class="comment">//节点指针</span></div><div class="line"></div><div class="line">  _List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125;</div><div class="line">  _List_iterator_base() &#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</div><div class="line">  <span class="keyword">void</span> _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125;</div><div class="line"></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> _M_node == __x._M_node;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> _M_node != __x._M_node;</div><div class="line">  &#125;</div><div class="line">&#125;;  </div><div class="line"></div><div class="line"><span class="comment">//迭代器,重载了++ -- == * -&gt;等操作</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Ref</span>, <span class="title">class</span> _<span class="title">Ptr</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> _<span class="title">List_iterator</span> :</span> <span class="keyword">public</span> _List_iterator_base &#123;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,<span class="keyword">const</span> _Tp&amp;,<span class="keyword">const</span> _Tp*&gt; const_iterator;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Ref,_Ptr&gt;             _Self;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  <span class="keyword">typedef</span> _Ptr pointer;</div><div class="line">  <span class="keyword">typedef</span> _Ref reference;</div><div class="line">  <span class="keyword">typedef</span> _List_node&lt;_Tp&gt; _Node;</div><div class="line"></div><div class="line">  _List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125;</div><div class="line">  _List_iterator() &#123;&#125;</div><div class="line">  _List_iterator(<span class="keyword">const</span> iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125;</div><div class="line"></div><div class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ((_Node*) _M_node)-&gt;_M_data; &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></div><div class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></div><div class="line"></div><div class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; </div><div class="line">    <span class="keyword">this</span>-&gt;_M_incr();</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </div><div class="line">    _Self __tmp = *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;_M_incr();</div><div class="line">    <span class="keyword">return</span> __tmp;</div><div class="line">  &#125;</div><div class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; </div><div class="line">    <span class="keyword">this</span>-&gt;_M_decr();</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </div><div class="line">    _Self __tmp = *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;_M_decr();</div><div class="line">    <span class="keyword">return</span> __tmp;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>双向开头的连续空间</p>
<p><img src="/img/20161120163459.png" alt=""><br>比较特别的地方是用一个双指针维护了一个多个连续的空间</p>
<p><img src="/img/20161120165939.png" alt=""><br>迭代器保持连续的方式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> __size) &#123;</div><div class="line">  <span class="keyword">return</span> __size &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / __size) : <span class="keyword">size_t</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Ref</span>, <span class="title">class</span> _<span class="title">Ptr</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> _<span class="title">Deque_iterator</span> &#123;</span></div><div class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</div><div class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, <span class="keyword">const</span> _Tp&amp;, <span class="keyword">const</span> _Tp*&gt; const_iterator;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_buffer_size() &#123; <span class="keyword">return</span> __deque_buf_size(<span class="keyword">sizeof</span>(_Tp)); &#125;</div><div class="line"></div><div class="line">.....</div><div class="line"></div><div class="line">  _Tp* _M_cur;</div><div class="line">  _Tp* _M_first;</div><div class="line">  _Tp* _M_last;</div><div class="line">  _Map_pointer _M_node;</div><div class="line"></div><div class="line">  _Deque_iterator(_Tp* __x, _Map_pointer __y) </div><div class="line">    : _M_cur(__x), _M_first(*__y),</div><div class="line">      _M_last(*__y + _S_buffer_size()), _M_node(__y) &#123;&#125;</div><div class="line">  _Deque_iterator() : _M_cur(<span class="number">0</span>), _M_first(<span class="number">0</span>), _M_last(<span class="number">0</span>), _M_node(<span class="number">0</span>) &#123;&#125;</div><div class="line">  _Deque_iterator(<span class="keyword">const</span> iterator&amp; __x)</div><div class="line">    : _M_cur(__x._M_cur), _M_first(__x._M_first), </div><div class="line">      _M_last(__x._M_last), _M_node(__x._M_node) &#123;&#125;</div><div class="line"></div><div class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *_M_cur; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></div><div class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _M_cur; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></div><div class="line"></div><div class="line">  difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> difference_type(_S_buffer_size()) * (_M_node - __x._M_node - <span class="number">1</span>) +</div><div class="line">      (_M_cur - _M_first) + (__x._M_last - __x._M_cur);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">//++</span></div><div class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123;</div><div class="line">    ++_M_cur;</div><div class="line">    <span class="keyword">if</span> (_M_cur == _M_last) &#123;</div><div class="line">    <span class="comment">//到尾部了就进入下一个区域</span></div><div class="line">      _M_set_node(_M_node + <span class="number">1</span>);<span class="comment">//_M_node + 1就是下一个区域</span></div><div class="line">      _M_cur = _M_first;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </div><div class="line">  &#125;</div><div class="line">......</div><div class="line"><span class="comment">//重置first等指针</span></div><div class="line">  <span class="keyword">void</span> _M_set_node(_Map_pointer __new_node) &#123;</div><div class="line">    _M_node = __new_node;</div><div class="line">    _M_first = *__new_node;</div><div class="line">    _M_last = _M_first + difference_type(_S_buffer_size());</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果map不足，分配空间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></div><div class="line"><span class="class"><span class="title">class</span> _<span class="title">Deque_base</span> &#123;</span></div><div class="line">....</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  _Tp** _M_map;</div><div class="line">  <span class="keyword">size_t</span> _M_map_size;  <span class="comment">//记录的map的大小</span></div><div class="line">  iterator _M_start;</div><div class="line">  iterator _M_finish;</div><div class="line">  ....</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>空间不足分配空间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; <span class="keyword">__t</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (_M_finish._M_cur != _M_finish._M_last - <span class="number">1</span>) &#123;</div><div class="line">      construct(_M_finish._M_cur, <span class="keyword">__t</span>);</div><div class="line">      ++_M_finish._M_cur;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      _M_push_back_aux(<span class="keyword">__t</span>);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;_Tp,_Alloc&gt;:</span>:_M_push_back_aux(<span class="keyword">const</span> value_type&amp; <span class="keyword">__t</span>)</div><div class="line">&#123;</div><div class="line">  value_type __t_copy = <span class="keyword">__t</span>;</div><div class="line">  _M_reserve_map_at_back();</div><div class="line">  *(_M_finish._M_node + <span class="number">1</span>) = _M_allocate_node();</div><div class="line">  __STL_TRY &#123;</div><div class="line">    construct(_M_finish._M_cur, __t_copy);</div><div class="line">    _M_finish._M_set_node(_M_finish._M_node + <span class="number">1</span>);</div><div class="line">    _M_finish._M_cur = _M_finish._M_first;</div><div class="line">  &#125;</div><div class="line">  __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + <span class="number">1</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>以deuqe为底部结构，封闭头端开口，就是stack。<br>没有迭代器。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里设定了了 以deque为基础</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, </span></div><div class="line"><span class="class">          <span class="title">class</span> _<span class="title">Sequence</span> __<span class="title">STL_DEPENDENT_DEFAULT_TMPL</span>(<span class="title">deque</span>&lt;_Tp&gt;) &gt;</span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span>;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Seq</span>&gt;</span></div><div class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">stack</span>&lt;_Tp,_Seq&gt;&amp; __<span class="title">x</span>, <span class="title">const</span> <span class="title">stack</span>&lt;_Tp,_Seq&gt;&amp; __<span class="title">y</span>);</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Seq</span>&gt;</span></div><div class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">template &lt;class _Tp, class _Sequence&gt;</span></div><div class="line"><span class="class">class stack &#123;</span></div><div class="line"><span class="class">.....</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">#ifdef __STL_MEMBER_TEMPLATES</span></div><div class="line"><span class="class">  template &lt;class _Tp1, class _Seq1&gt;</span></div><div class="line"><span class="class">  friend bool operator== (const stack&lt;_Tp1, _Seq1&gt;&amp;,</span></div><div class="line"><span class="class">                          const stack&lt;_Tp1, _Seq1&gt;&amp;);</span></div><div class="line"><span class="class">  template &lt;class _Tp1, class _Seq1&gt;</span></div><div class="line"><span class="class">  friend bool operator&lt; (const stack&lt;_Tp1, _Seq1&gt;&amp;,</span></div><div class="line"><span class="class">                         const stack&lt;_Tp1, _Seq1&gt;&amp;);</span></div><div class="line"><span class="class">#else /* __STL_MEMBER_TEMPLATES */</span></div><div class="line"><span class="class">  friend bool __STD_QUALIFIER</span></div><div class="line"><span class="class">  operator== __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</span></div><div class="line"><span class="class">  friend bool __STD_QUALIFIER</span></div><div class="line"><span class="class">  operator&lt; __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</span></div><div class="line"><span class="class">#endif /* __STL_MEMBER_TEMPLATES */</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">.....</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">protected:</span></div><div class="line"><span class="class">  _Sequence c;</span></div><div class="line"><span class="class">public:</span></div><div class="line"><span class="class">  stack() : c() &#123;&#125;</span></div><div class="line"><span class="class">  explicit stack(const _Sequence&amp; __s) : c(__s) &#123;&#125;</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">  bool empty() const &#123; return c.empty(); &#125;</span></div><div class="line"><span class="class">  size_type size() const &#123; return c.size(); &#125;</span></div><div class="line"><span class="class">  reference top() &#123; return c.back(); &#125;</span></div><div class="line"><span class="class">  const_reference top() const &#123; return c.back(); &#125;</span></div><div class="line"><span class="class">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</span></div><div class="line"><span class="class">  void pop() &#123; c.pop_back(); &#125;</span></div><div class="line"><span class="class">&#125;;</span></div></pre></td></tr></table></figure></p>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>同样以deque为基础<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, </span></div><div class="line"><span class="class">          <span class="title">class</span> _<span class="title">Sequence</span> __<span class="title">STL_DEPENDENT_DEFAULT_TMPL</span>(<span class="title">deque</span>&lt;_Tp&gt;) &gt;</span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span>;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Seq</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">queue</span>&lt;_Tp, _Seq&gt;&amp;, <span class="title">const</span> <span class="title">queue</span>&lt;_Tp, _Seq&gt;&amp;);</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Seq</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>&lt;(const queue&lt;_Tp, _Seq&gt;&amp;, const queue&lt;_Tp, _Seq&gt;&amp;);</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">template &lt;class _Tp, class _Sequence&gt;</span></div><div class="line"><span class="class">class queue &#123;</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">.....</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">#ifdef __STL_MEMBER_TEMPLATES </span></div><div class="line"><span class="class">  template &lt;class _Tp1, class _Seq1&gt;</span></div><div class="line"><span class="class">  friend bool operator== (const queue&lt;_Tp1, _Seq1&gt;&amp;,</span></div><div class="line"><span class="class">                          const queue&lt;_Tp1, _Seq1&gt;&amp;);</span></div><div class="line"><span class="class">  template &lt;class _Tp1, class _Seq1&gt;</span></div><div class="line"><span class="class">  friend bool operator&lt; (const queue&lt;_Tp1, _Seq1&gt;&amp;,</span></div><div class="line"><span class="class">                         const queue&lt;_Tp1, _Seq1&gt;&amp;);</span></div><div class="line"><span class="class">#else /* __STL_MEMBER_TEMPLATES */</span></div><div class="line"><span class="class">  friend bool __STD_QUALIFIER</span></div><div class="line"><span class="class">  operator== __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</span></div><div class="line"><span class="class">  friend bool __STD_QUALIFIER</span></div><div class="line"><span class="class">  operator&lt;  __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</span></div><div class="line"><span class="class">#endif /* __STL_MEMBER_TEMPLATES */</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">.....</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">protected:</span></div><div class="line"><span class="class">  _Sequence c;</span></div><div class="line"><span class="class">public:</span></div><div class="line"><span class="class">  queue() : c() &#123;&#125;</span></div><div class="line"><span class="class">  explicit queue(const _Sequence&amp; __c) : c(__c) &#123;&#125;</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">  bool empty() const &#123; return c.empty(); &#125;</span></div><div class="line"><span class="class">  size_type size() const &#123; return c.size(); &#125;</span></div><div class="line"><span class="class">  reference front() &#123; return c.front(); &#125;</span></div><div class="line"><span class="class">  const_reference front() const &#123; return c.front(); &#125;</span></div><div class="line"><span class="class">  reference back() &#123; return c.back(); &#125;</span></div><div class="line"><span class="class">  const_reference back() const &#123; return c.back(); &#125;</span></div><div class="line"><span class="class">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</span></div><div class="line"><span class="class">  void pop() &#123; c.pop_front(); &#125;</span></div><div class="line"><span class="class">&#125;;</span></div></pre></td></tr></table></figure></p>
<h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><p>堆也就是个完全二叉树。用个数组或者vector就能实现<br>stl中的heap是保证每个父节点大于等于子节点，每次插入删除节点需要重新调整树</p>
<h2 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h2><p>push操作,后调整树，查看父节点是不是符合要求<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">__push_heap(_RandomAccessIterator __first,</div><div class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value)</div><div class="line">&#123;</div><div class="line">  _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//父节点</span></div><div class="line">  <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123;</div><div class="line">    <span class="comment">//调整节点</span></div><div class="line">    *(__first + __holeIndex) = *(__first + __parent);</div><div class="line">    __holeIndex = __parent;</div><div class="line">    __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//再判断父节点</span></div><div class="line">  &#125;    </div><div class="line">  *(__first + __holeIndex) = __value;<span class="comment">//把新值移动到新位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></div><div class="line"><span class="class">__<span class="title">push_heap_aux</span>(_<span class="title">RandomAccessIterator</span> __<span class="title">first</span>,</span></div><div class="line"><span class="class">                _<span class="title">RandomAccessIterator</span> __<span class="title">last</span>, _<span class="title">Distance</span>*, _<span class="title">Tp</span>*)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  __push_heap(__first, _Distance((__last - __first) - <span class="number">1</span>), _Distance(<span class="number">0</span>), </div><div class="line">              _Tp(*(__last - <span class="number">1</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//push_heap算法，这个时候值已经插入heap的最尾端，调用此函数调整heap</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></div><div class="line"><span class="class"><span class="title">push_heap</span>(_<span class="title">RandomAccessIterator</span> __<span class="title">first</span>, _<span class="title">RandomAccessIterator</span> __<span class="title">last</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</div><div class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</div><div class="line">                 _LessThanComparable);</div><div class="line">  __push_heap_aux(__first, __last,</div><div class="line">                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h2><p>调整相关节点，使得上部全部填满，最底层空出区域。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span> </span></div><div class="line"><span class="class">__<span class="title">adjust_heap</span>(_<span class="title">RandomAccessIterator</span> __<span class="title">first</span>, _<span class="title">Distance</span> __<span class="title">holeIndex</span>,</span></div><div class="line"><span class="class">              _<span class="title">Distance</span> __<span class="title">len</span>, _<span class="title">Tp</span> __<span class="title">value</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  _Distance __topIndex = __holeIndex;</div><div class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>;</div><div class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</div><div class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>)))</div><div class="line">      __secondChild--;</div><div class="line">    *(__first + __holeIndex) = *(__first + __secondChild);</div><div class="line">    __holeIndex = __secondChild;</div><div class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;</div><div class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>));</div><div class="line">    __holeIndex = __secondChild - <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></div><div class="line"><span class="class">__<span class="title">pop_heap</span>(_<span class="title">RandomAccessIterator</span> __<span class="title">first</span>, _<span class="title">RandomAccessIterator</span> __<span class="title">last</span>,</span></div><div class="line"><span class="class">           _<span class="title">RandomAccessIterator</span> __<span class="title">result</span>, _<span class="title">Tp</span> __<span class="title">value</span>, _<span class="title">Distance</span>*)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="comment">//把first放到last-1</span></div><div class="line">  *__result = *__first;</div><div class="line">  <span class="comment">//重新整理first到last-1之间重新成为heap</span></div><div class="line">  __adjust_heap(__first, _Distance(<span class="number">0</span>), _Distance(__last - __first), __value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></div><div class="line"><span class="class">__<span class="title">pop_heap_aux</span>(_<span class="title">RandomAccessIterator</span> __<span class="title">first</span>, _<span class="title">RandomAccessIterator</span> __<span class="title">last</span>,</span></div><div class="line"><span class="class">               _<span class="title">Tp</span>*)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="comment">//pop出的是最大值，也就是删除掉first，把first放到last-1，然后重新整理first到last-1之间重新成为heap</span></div><div class="line">  <span class="comment">//这样之后只要去取last-1的值，就是弹出的值了。</span></div><div class="line">  __pop_heap(__first, __last - <span class="number">1</span>, __last - <span class="number">1</span>, </div><div class="line">             _Tp(*(__last - <span class="number">1</span>)), __DISTANCE_TYPE(__first));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//pop</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">pop_heap</span>(_<span class="title">RandomAccessIterator</span> __<span class="title">first</span>, </span></div><div class="line"><span class="class">                     _<span class="title">RandomAccessIterator</span> __<span class="title">last</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</div><div class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</div><div class="line">                 _LessThanComparable);</div><div class="line">  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h2><p>不断调用__adjust_heap调整heap的话，最终会是一个heap<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span> </span></div><div class="line"><span class="class">__<span class="title">make_heap</span>(_<span class="title">RandomAccessIterator</span> __<span class="title">first</span>,</span></div><div class="line"><span class="class">            _<span class="title">RandomAccessIterator</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) <span class="keyword">return</span>;</div><div class="line">  _Distance __len = __last - __first;</div><div class="line">  _Distance __parent = (__len - <span class="number">2</span>)/<span class="number">2</span>;</div><div class="line">    </div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));</div><div class="line">    <span class="keyword">if</span> (__parent == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    __parent--;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></div><div class="line"><span class="class"><span class="title">make_heap</span>(_<span class="title">RandomAccessIterator</span> __<span class="title">first</span>, _<span class="title">RandomAccessIterator</span> __<span class="title">last</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</div><div class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</div><div class="line">                 _LessThanComparable);</div><div class="line">  __make_heap(__first, __last,</div><div class="line">              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h2><p>对一个heap一直pop，最大值移到末尾，那么就是增序序列 了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span> <span class="title">sort_heap</span>(_<span class="title">RandomAccessIterator</span> __<span class="title">first</span>, _<span class="title">RandomAccessIterator</span> __<span class="title">last</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</div><div class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</div><div class="line">                 _LessThanComparable);</div><div class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">1</span>)</div><div class="line">    pop_heap(__first, __last--);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>优先弹出权值高的项目，用上面的max_heap就能够实现。<br>操作不多。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, </span></div><div class="line"><span class="class">          <span class="title">class</span> _<span class="title">Sequence</span> __<span class="title">STL_DEPENDENT_DEFAULT_TMPL</span>(<span class="title">vector</span>&lt;_Tp&gt;),</span></div><div class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span></span></div><div class="line"><span class="class">          __<span class="title">STL_DEPENDENT_DEFAULT_TMPL</span>(<span class="title">less</span>&lt;typename _Sequence::value_type&gt;) &gt;</span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">priority_queue</span> &#123;</span></div><div class="line">......</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  _Sequence c;</div><div class="line">  _Compare comp;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  priority_queue() : c() &#123;&#125;</div><div class="line">  explicit priority_queue(const _Compare&amp; __x) :  c(), comp(__x) &#123;&#125;</div><div class="line">  priority_queue(<span class="keyword">const</span> _Compare&amp; __x, <span class="keyword">const</span> _Sequence&amp; __s) </div><div class="line">    : c(__s), comp(__x) </div><div class="line">    &#123; make_heap(c.begin(), c.end(), comp); &#125;</div><div class="line">.....</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.empty(); &#125;</div><div class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.size(); &#125;</div><div class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.front(); &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; __x)</span> </span>&#123;</div><div class="line">    __STL_TRY &#123;</div><div class="line">      c.push_back(__x); </div><div class="line">      push_heap(c.begin(), c.end(), comp);</div><div class="line">    &#125;</div><div class="line">    __STL_UNWIND(c.clear());</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">    __STL_TRY &#123;</div><div class="line">      pop_heap(c.begin(), c.end(), comp);</div><div class="line">      c.pop_back();</div><div class="line">    &#125;</div><div class="line">    __STL_UNWIND(c.clear());</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] stl源码剖析 第三章 迭代器]]></title>
      <url>/2016/11/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>迭代器是一种抽象的设计概念。iterator模式：提供一种方法，使能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表述方式。</p>
<h1 id="迭代器的设计思维-stl关键所在"><a href="#迭代器的设计思维-stl关键所在" class="headerlink" title="迭代器的设计思维-stl关键所在"></a>迭代器的设计思维-stl关键所在</h1><p>STL的中心思想在于：将数据容器和算法分开，彼此独立设计。容器和算法的泛型化。<br>迭代器就是扮演着粘胶角色。</p>
<h1 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h1><p>list迭代器stl的实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//listnode的基础类</span></div><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span> &#123;</span></div><div class="line">  _List_node_base* _M_next;</div><div class="line">  _List_node_base* _M_prev;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//listnode</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> _<span class="title">List_node</span> :</span> <span class="keyword">public</span> _List_node_base &#123;</div><div class="line">  _Tp _M_data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//迭代器基础类</span></div><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator_base</span> &#123;</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>                     size_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</div><div class="line"></div><div class="line">  _List_node_base* _M_node;<span class="comment">//包含一个node</span></div><div class="line"></div><div class="line">  _List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125;</div><div class="line">  _List_iterator_base() &#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</div><div class="line">  <span class="keyword">void</span> _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125;</div><div class="line"></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> _M_node == __x._M_node;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> _M_node != __x._M_node;</div><div class="line">  &#125;</div><div class="line">&#125;;  </div><div class="line"><span class="comment">//迭代器</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Ref</span>, <span class="title">class</span> _<span class="title">Ptr</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> _<span class="title">List_iterator</span> :</span> <span class="keyword">public</span> _List_iterator_base &#123;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,<span class="keyword">const</span> _Tp&amp;,<span class="keyword">const</span> _Tp*&gt; const_iterator;</div><div class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Ref,_Ptr&gt;             _Self;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  <span class="keyword">typedef</span> _Ptr pointer;</div><div class="line">  <span class="keyword">typedef</span> _Ref reference;</div><div class="line">  <span class="keyword">typedef</span> _List_node&lt;_Tp&gt; _Node;</div><div class="line"></div><div class="line">  _List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125;</div><div class="line">  _List_iterator() &#123;&#125;</div><div class="line">  _List_iterator(<span class="keyword">const</span> iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125;</div><div class="line"></div><div class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ((_Node*) _M_node)-&gt;_M_data; &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></div><div class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></div><div class="line">  <span class="comment">//重载了几个操作实现了迭代器，不是很复杂</span></div><div class="line">  <span class="comment">//++i</span></div><div class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; </div><div class="line">    <span class="keyword">this</span>-&gt;_M_incr();</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//i++</span></div><div class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </div><div class="line">    _Self __tmp = *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;_M_incr();</div><div class="line">    <span class="keyword">return</span> __tmp;</div><div class="line">  &#125;</div><div class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; </div><div class="line">    <span class="keyword">this</span>-&gt;_M_decr();</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </div><div class="line">    _Self __tmp = *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;_M_decr();</div><div class="line">    <span class="keyword">return</span> __tmp;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="Traits编程技法"><a href="#Traits编程技法" class="headerlink" title="Traits编程技法"></a>Traits编程技法</h1><p>之前就见到用过，通过类型获取，其余的类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Category</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span> = <span class="title">ptrdiff_t</span>,</span></div><div class="line"><span class="class">          <span class="title">class</span> _<span class="title">Pointer</span> = _<span class="title">Tp</span>*, <span class="title">class</span> _<span class="title">Reference</span> = _<span class="title">Tp</span>&amp;&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span> &#123;</span></div><div class="line">  <span class="keyword">typedef</span> _Category  iterator_category;</div><div class="line">  <span class="keyword">typedef</span> _Tp        value_type;</div><div class="line">  <span class="keyword">typedef</span> _Distance  difference_type;</div><div class="line">  <span class="keyword">typedef</span> _Pointer   pointer;</div><div class="line">  <span class="keyword">typedef</span> _Reference reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iterator</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//对原生指针特化</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;_Tp*&gt; &#123;</span></div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</div><div class="line">  <span class="comment">//ptrdiff_t是C/C++标准库中定义的一个与机器相关的数据类型。ptrdiff_t类型变量通常用来保存两个指针减法操作的结果。ptrdiff_t定义在stddef.h（cstddef）这个文件内。ptrdiff_t通常被定义为long int类型。</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> _Tp*                        pointer;</div><div class="line">  <span class="keyword">typedef</span> _Tp&amp;                        reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const _Tp*&gt; &#123;</span></div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*                  pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;                  reference;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>迭代器的分类：<br>input iter：只读iter<br>output iter:只写iter<br>forward iter:允许写入型算法在这种迭代器所形成的区间操作，前向迭代器<br>bidirectional iterator：双向移动iter。<br>random access iter：前三种支持++,第四种支持++ –。这种支持所有指针的算术能力。</p>
<p><img src="/img/20161116205706.png" alt=""><br>typedef typename _Iterator::iterator_category iterator_category;的作用就是能够在编译器发现迭代器的类型，选用最合适的函数版本。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(_<span class="title">InputIter</span>&amp; __<span class="title">i</span>, _<span class="title">Distance</span> __<span class="title">n</span>, <span class="title">input_iterator_tag</span>) &#123;</span></div><div class="line">  <span class="keyword">while</span> (__n--) ++__i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIterator</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(_<span class="title">BidirectionalIterator</span>&amp; __<span class="title">i</span>, _<span class="title">Distance</span> __<span class="title">n</span>, </span></div><div class="line"><span class="class">                      <span class="title">bidirectional_iterator_tag</span>) &#123;</span></div><div class="line">  __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);</div><div class="line">  <span class="keyword">if</span> (__n &gt;= <span class="number">0</span>)</div><div class="line">    <span class="keyword">while</span> (__n--) ++__i;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">while</span> (__n++) --__i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(_<span class="title">RandomAccessIterator</span>&amp; __<span class="title">i</span>, _<span class="title">Distance</span> __<span class="title">n</span>, </span></div><div class="line"><span class="class">                      <span class="title">random_access_iterator_tag</span>) &#123;</span></div><div class="line">  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);</div><div class="line">  __i += __n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(_<span class="title">InputIterator</span>&amp; __<span class="title">i</span>, _<span class="title">Distance</span> __<span class="title">n</span>) &#123;</span></div><div class="line">  __STL_REQUIRES(_InputIterator, _InputIterator);</div><div class="line">  <span class="comment">//通过下面的函数，选用合适的版本</span></div><div class="line">  <span class="comment">//不需要传递参数，能够在编译器选定版本</span></div><div class="line">  __advance(__i, __n, iterator_category(__i));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="type-traits"><a href="#type-traits" class="headerlink" title="__type_traits"></a>__type_traits</h1><p>提供一种机制，允许针对不同的型别熟悉，完成函数派送。<br>在内存配置器中就用到了，比如有没有拷贝构造函数等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span> &#123;</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span> &#123;</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//选择使用__false_type为struct的目的是为了类型推倒，而不是使用bool值作为参数的话只是运行时的选择。</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span> &#123;</span> </div><div class="line">   <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</div><div class="line">                   <span class="comment">/* Do not remove this member. It informs a compiler which</span></div><div class="line"><span class="comment">                      automatically specializes __type_traits that this</span></div><div class="line"><span class="comment">                      __type_traits template is special. It just makes sure that</span></div><div class="line"><span class="comment">                      things work if an implementation is using a template</span></div><div class="line"><span class="comment">                      called __type_traits for something unrelated. */</span></div><div class="line"></div><div class="line">   <span class="comment">/* The following restrictions should be observed for the sake of</span></div><div class="line"><span class="comment">      compilers which automatically produce type specific specializations </span></div><div class="line"><span class="comment">      of this class:</span></div><div class="line"><span class="comment">          - You may reorder the members below if you wish</span></div><div class="line"><span class="comment">          - You may remove any of the members below if you wish</span></div><div class="line"><span class="comment">          - You must not rename members without making the corresponding</span></div><div class="line"><span class="comment">            name change in the compiler</span></div><div class="line"><span class="comment">          - Members you add will be treated like regular members unless</span></div><div class="line"><span class="comment">            you add the appropriate support in the compiler. */</span></div><div class="line"> </div><div class="line"></div><div class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</div><div class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</div><div class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</div><div class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</div><div class="line">   <span class="keyword">typedef</span> __false_type    is_POD_type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在这个文件里定义了大量的特化，主要是特化C++标准类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;bool&gt; &#123;</span></div><div class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</div><div class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</div><div class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</div><div class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</div><div class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//等。。。</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] stl源码剖析 第一章、第二章 概论、内存配置器]]></title>
      <url>/2016/11/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%AE%BA%E3%80%81%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>第一章基本都是C++基础的知识，读了《C++ Primer》的话都懂。关于各种C++的特性、STL特性都有。</p>
<h2 id="STL六大组件-功能与运用"><a href="#STL六大组件-功能与运用" class="headerlink" title="STL六大组件 功能与运用"></a>STL六大组件 功能与运用</h2><p>STL提供六大组件，彼此可以组合套用</p>
<ol>
<li>容器：各种数据结构。Vector,list,deque,set,map</li>
<li>算法：各种常用算法如sort,search,copy,erase</li>
<li>迭代器：扮演容器与算法之间的粘合剂，所谓的泛型指针。五种类型</li>
<li>仿函数：行为类似函数，可以作为算法的某种策略。仿函数是重载了()的class或者class template，一般函数指针可视为狭义的仿函数</li>
<li>配接器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>配置器：负责控件的配置与管理。</li>
</ol>
<a id="more"></a>
<p><img src="/img/20161108212017.png" alt=""></p>
<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p>SGI STL时间了一个专属的，拥有次层配置能力的、效率优越的特殊配置器。<br>SGI STL的缺省分配器都是其自己的分配器。</p>
<h2 id="SGI特殊的空间配置器-std-alloc"><a href="#SGI特殊的空间配置器-std-alloc" class="headerlink" title="SGI特殊的空间配置器 std::alloc"></a>SGI特殊的空间配置器 std::alloc</h2><p>使用::construct() ::destroy()构造和析构<br>使用alloc::allocate() alloc::deallocate()分配 释放<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//直接利用这个类能够用指定类型指针，转换为其他引用等</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const _Tp*&gt; &#123;</span></div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*                  pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;                  reference;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果有non-trivial 析构函数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span></span></div><div class="line"><span class="class">__<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, __<span class="title">false_type</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)</div><div class="line">    destroy(&amp;*__first);</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果没有non-trivial 析构函数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt; </span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span>, _<span class="title">ForwardIterator</span>, __<span class="title">true_type</span>) &#123;</span>&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></div><div class="line"><span class="class">__<span class="title">destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, _<span class="title">Tp</span>*)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp&gt;::has_trivial_destructor</div><div class="line">          _Trivial_destructor;</div><div class="line">  __destroy_aux(__first, __last, _Trivial_destructor());<span class="comment">//_Trivial_destructor()将会是_true_type 或者_false_type</span></div><div class="line">  <span class="comment">//利用模板和特化</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></div><div class="line">  __destroy(__first, __last, __VALUE_TYPE(__first));<span class="comment">//__VALUE_TYPE(__first)获取到了类型的指针，然后调用上面函数</span></div><div class="line">  <span class="comment">//利用模板和特化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="空间的配置与释放-std-alloc"><a href="#空间的配置与释放-std-alloc" class="headerlink" title="空间的配置与释放 std::alloc"></a>空间的配置与释放 std::alloc</h2><p>sgi设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略。<br>当分配大于128bytes时候调用第一级，小于128时候，为了降低额外负担，使用负责的memory pool整理方式。</p>
<h3 id="第一级配置器-malloc-alloc-template剖析"><a href="#第一级配置器-malloc-alloc-template剖析" class="headerlink" title="第一级配置器 __malloc_alloc_template剖析"></a>第一级配置器 __malloc_alloc_template剖析</h3><p>以malloc free realloc实现。<br>然后自己实现了一个new handler机制。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</div><div class="line"><span class="keyword">void</span>*</div><div class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (* __my_malloc_handler)();</div><div class="line">    <span class="keyword">void</span>* __result;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</div><div class="line">        (*__my_malloc_handler)();</div><div class="line">        __result = <span class="built_in">malloc</span>(__n);</div><div class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第二级配置器"><a href="#第二级配置器" class="headerlink" title="第二级配置器"></a>第二级配置器</h3><p>SIG第二级配置器的做法，如果区块够大，超过128bytes时候，就移交第一级配置器处理。当区块小鱼128bytes时候，则以内存池管理。每次配置一大块内存，并维护对应之自由链表，下次若再有相同大小的内存需求从free-lists中拨出。如果客端释放小额区块，就由配置器回收到fres-lists中。<br>分配区块时候，自动上调到8的倍数，并维护16个fres-lists,分别管理大小为8/16/24/32/40/48/56/64/72/80/88/96/104/112/120/128的小额区块。</p>
<blockquote>
<p>其实这里和公司用的NG_malloc是一样的策略。ng_malloc之前对于大小的区分是256k的样子，更大。后来又改写了，支持更大的内存块了。</p>
</blockquote>
<p>节点如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__PRIVATE:</div><div class="line">  <span class="keyword">union</span> _Obj &#123;</div><div class="line">        <span class="keyword">union</span> _Obj* _M_free_list_link;</div><div class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p>使用union的话，可以不用每次都去转换。char _M_client_data的存在是，方便去取首地址。实际上下面用到的就是_M_free_list_link，用来作为链表。这样的话，就可以用一个4字节的空间(32位机器指针大小)，实现两个功能。而不是使用struct，因为那样就会浪费空间。</p>
<h4 id="空间配置函数allocate"><a href="#空间配置函数allocate" class="headerlink" title="空间配置函数allocate()"></a>空间配置函数allocate()</h4><p>功能：判断大小，大于128用第一级分配，小于128就查找free list。如果free list中有可用的区块，就直接拿来用，如果没有就将区块大小上调至8的倍数边界，然后调用refill()，准备为free list重新填充空间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">//超过设定的最大值就调用第一级配置器，STL设置为128</span></div><div class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</div><div class="line">      __ret = malloc_alloc::allocate(__n);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//寻找合适的free lists中适当的一个</span></div><div class="line">      _Obj* __STL_VOLATILE* __my_free_list</div><div class="line">          = _S_free_list + _S_freelist_index(__n);</div><div class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></div><div class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></div><div class="line">      <span class="comment">// unwinding.</span></div><div class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></div><div class="line">      <span class="comment">/*REFERENCED*/</span></div><div class="line">      <span class="comment">//多线程锁</span></div><div class="line">      _Lock __lock_instance;</div><div class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></div><div class="line">      _Obj* __RESTRICT __result = *__my_free_list;</div><div class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</div><div class="line">        <span class="comment">//没找到的话，就重新填充free list</span></div><div class="line">        __ret = _S_refill(_S_round_up(__n));</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//指向后一个成员</span></div><div class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</div><div class="line">        __ret = __result;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> __ret;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<h4 id="空间释放函数-deallocate"><a href="#空间释放函数-deallocate" class="headerlink" title="空间释放函数 deallocate()"></a>空间释放函数 deallocate()</h4><p>先判断大小，大于128调用第一级，小于128找出对应的free list，将区块回收。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* __p may not be 0 */</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</div><div class="line">      malloc_alloc::deallocate(__p, __n);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      _Obj* __STL_VOLATILE*  __my_free_list</div><div class="line">          = _S_free_list + _S_freelist_index(__n);</div><div class="line">      _Obj* __q = (_Obj*)__p;</div><div class="line"></div><div class="line">      <span class="comment">// acquire lock</span></div><div class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></div><div class="line">      <span class="comment">/*REFERENCED*/</span></div><div class="line">      _Lock __lock_instance;</div><div class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></div><div class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</div><div class="line">      *__my_free_list = __q;</div><div class="line">      <span class="comment">// lock is released here</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="重新填充free-lists"><a href="#重新填充free-lists" class="headerlink" title="重新填充free lists"></a>重新填充free lists</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</div><div class="line"><span class="keyword">void</span>*</div><div class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</div><div class="line">    <span class="comment">//尝试分配空间 __nobjs是引用传递，作为返回值</span></div><div class="line">    <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</div><div class="line">    _Obj* __STL_VOLATILE* __my_free_list;</div><div class="line">    _Obj* __result;</div><div class="line">    _Obj* __current_obj;</div><div class="line">    _Obj* __next_obj;</div><div class="line">    <span class="keyword">int</span> __i;</div><div class="line">    </div><div class="line">    <span class="comment">//对只分配出一个的时候的优化</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</div><div class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</div><div class="line"></div><div class="line">    <span class="comment">//形成链表</span></div><div class="line">    <span class="comment">/* Build free list in chunk */</span></div><div class="line">      __result = (_Obj*)__chunk;</div><div class="line">      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);</div><div class="line">      <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</div><div class="line">        __current_obj = __next_obj;</div><div class="line">        __next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);</div><div class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;</div><div class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span>(__result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p>从内存池中取空间给free list 使用，是chunk_alloc的工作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</div><div class="line"><span class="keyword">char</span>*</div><div class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, </div><div class="line">                                                            <span class="keyword">int</span>&amp; __nobjs)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span>* __result;<span class="comment">//返回值</span></div><div class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;<span class="comment">//需要分配的空间大小</span></div><div class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;<span class="comment">//内存池剩余空间</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;</div><div class="line">        __result = _S_start_free;<span class="comment">//返回</span></div><div class="line">        _S_start_free += __total_bytes;<span class="comment">//内存池可用空间起始处后移</span></div><div class="line">        <span class="keyword">return</span>(__result);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;<span class="comment">//能够分配一部分空间</span></div><div class="line">        __nobjs = (<span class="keyword">int</span>)(__bytes_left/__size);<span class="comment">//判断能够分配的块数</span></div><div class="line">        __total_bytes = __size * __nobjs;</div><div class="line">        __result = _S_start_free;</div><div class="line">        _S_start_free += __total_bytes;<span class="comment">//与上同</span></div><div class="line">        <span class="keyword">return</span>(__result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//不能够分配一块的大小</span></div><div class="line">        <span class="keyword">size_t</span> __bytes_to_get = </div><div class="line">	  <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</div><div class="line">        <span class="comment">// Try to make use of the left-over piece.</span></div><div class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;<span class="comment">//把剩余空间，分配到合适的free list</span></div><div class="line">            _Obj* __STL_VOLATILE* __my_free_list =</div><div class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</div><div class="line"></div><div class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</div><div class="line">            *__my_free_list = (_Obj*)_S_start_free;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//从堆上重新分配出部分空间</span></div><div class="line">        _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;</div><div class="line">            <span class="keyword">size_t</span> __i;</div><div class="line">            _Obj* __STL_VOLATILE* __my_free_list;</div><div class="line">	    _Obj* __p;</div><div class="line">            <span class="comment">// Try to make do with what we have.  That can't</span></div><div class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></div><div class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></div><div class="line">            <span class="keyword">for</span> (__i = __size;</div><div class="line">                 __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES;</div><div class="line">                 __i += (<span class="keyword">size_t</span>) _ALIGN) &#123;</div><div class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</div><div class="line">                __p = *__my_free_list;</div><div class="line">                <span class="comment">//malloc失败的话，在现有的free list中找未用的、足够大的fee list分配</span></div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</div><div class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</div><div class="line">                    _S_start_free = (<span class="keyword">char</span>*)__p;</div><div class="line">                    _S_end_free = _S_start_free + __i;</div><div class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</div><div class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></div><div class="line">                    <span class="comment">// right free list.</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">	    _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></div><div class="line">            _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(__bytes_to_get);</div><div class="line">            <span class="comment">// This should either throw an</span></div><div class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></div><div class="line">            <span class="comment">// succeeded.</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拿到新空间</span></div><div class="line">        _S_heap_size += __bytes_to_get;</div><div class="line">        _S_end_free = _S_start_free + __bytes_to_get;</div><div class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h3><p>uninitialized_copy、uninitialized_fill、uninitialized_fill_n用来处理一些特殊的复制构造的情况。</p>
<h4 id="uninitialized-fill-n实现"><a href="#uninitialized-fill-n实现" class="headerlink" title="uninitialized_fill_n实现"></a>uninitialized_fill_n实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> </span></div><div class="line"><span class="class"><span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="keyword">return</span> __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Tp1</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> </span></div><div class="line"><span class="class">__<span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, _<span class="title">Tp1</span>*)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;</div><div class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());<span class="comment">//判断有没有复制构造函数，调用不同的函数处理</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//没有复制构造函数的版本</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></div><div class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></div><div class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">true_type</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="keyword">return</span> fill_n(__first, __n, __x);</div><div class="line">&#125;</div><div class="line"><span class="comment">//有复制构造函数的版本</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></div><div class="line"><span class="class">_<span class="title">ForwardIter</span></span></div><div class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></div><div class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">false_type</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  _ForwardIter __cur = __first;</div><div class="line">  __STL_TRY &#123;</div><div class="line">    <span class="keyword">for</span> ( ; __n &gt; <span class="number">0</span>; --__n, ++__cur)</div><div class="line">      _Construct(&amp;*__cur, __x);</div><div class="line">    <span class="keyword">return</span> __cur;</div><div class="line">  &#125;</div><div class="line">  __STL_UNWIND(_Destroy(__first, __cur));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>uninitialized_copy、uninitialized_fill的实现类似</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阅读谷歌编程规范]]></title>
      <url>/2016/11/06/%E9%98%85%E8%AF%BB%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<h1 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h1><p>好的东西就是这样，你每次看都能够有新的收获。<br>这次也一样，读了一遍谷歌编程规范，又有些新的理解，也有一些需要重新让自己记住的点。<br>遂记录下来，成此博文。</p>
<a id="more"></a>
<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h2 id="define保护"><a href="#define保护" class="headerlink" title="#define保护"></a>#define保护</h2><p>谷歌的格式是<br>当是： <project> <em> <path></path> </em> <file> <em>H</em><br>为保证唯一性，头文件的命名应基于其所在项目源代码树的全路径。例如，项目 foo 中的头<br>文件 foo/src/bar/baz.h 按如下方式保护：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO_BAR_BAZ_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_BAR_BAZ_H_</span></div><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></div></pre></td></tr></table></figure></file></project></p>
<p>比较起来我们的格式是使用项目前缀来防止重复，考虑到我们项目的规模一般是不会重复的，因为文件命名上就不一致。</p>
<h2 id="头文件依赖"><a href="#头文件依赖" class="headerlink" title="头文件依赖"></a>头文件依赖</h2><p>尽量使用前置声明减少头文件的依赖。<br>因为引入一个新的头文件，头文件改变时，包含这个头文件的其他头文件也会被重新编译。<br>1.强数据成员声明为Foo* Foo&amp;<br>2.参数、返回值类型为Foo的函数，只是声明<br>3.今天数据成员的类型可以被声明为Foo，因为静态数据成员定义在类定义之外<br>至于使用指针成员替代成员对象，则会降低可读性，执行效率，不要这样做。</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>少于十行的函数定义为内联函数。<br>小巧的代码更好的利用指令缓存。<br>短小的内联函数直接放在.h文件中，对于比较复杂的内联应该放在-inl.h文件中</p>
<h2 id="函数参数的顺序"><a href="#函数参数的顺序" class="headerlink" title="函数参数的顺序"></a>函数参数的顺序</h2><p>输入参数在前，输出在后。</p>
<h2 id="包含文件顺序"><a href="#包含文件顺序" class="headerlink" title="包含文件顺序"></a>包含文件顺序</h2><p>C库 C++库 其他库 项目内的<br>头文件应该有带有目录信息,不要使用当前目录和父目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">举例来说， google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下 ：</div><div class="line">#include &quot;foo/public/fooserver.h&quot; // 优先位置</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;hash_map&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &quot;base/basictypes.h&quot;</div><div class="line">#include &quot;base/commandlineflags.h&quot;</div><div class="line">#include &quot;foo/public/bar.h&quot;</div></pre></td></tr></table></figure></p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在.CC文件中，允许甚至提倡使用不具名命名空间，以避免运行时候的命名冲突。<br>最好不要使用using，不要声明命名空间std下的恩和内容。</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>公开嵌套类作为接口的一部分时候，虽然可以直接放在全局作用域中，但是最好还是放在命名空间里。<br>使用起来的话，</p>
<h2 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h2><p>尽量放在命名空间里。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>将函数变量尽可能置于最小作用域内，在声明变量时候将其初始化。靠近第一次使用，利于阅读。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>全局变量的构造函数、西沟函数以及初始化操作的调用顺序只是被部分规定，每次生产可能会有变化。<br>很多可以用单例模式替代。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。"><a href="#构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。" class="headerlink" title="构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。"></a>构造函数中只进行哪些没有实际意义的初始化。在Init中集中初始化有意义的数据。</h2><p>构造函数的问题是，没有异常处理。</p>
<h2 id="明确的构造函数"><a href="#明确的构造函数" class="headerlink" title="明确的构造函数"></a>明确的构造函数</h2><p>使用explicit，防止自动转换。</p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>大量类并不要拷贝构造函数，所以应该使用DISALLOW_COPY_AND_ASSIGN来防止拷贝构造函数的自动生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 禁止使用拷贝构造函数和赋值操作的宏</div><div class="line">// 应在类的 private:中使用</div><div class="line">#define DISALLOW_COPY_AND_ASSIGN(TypeName) \</div><div class="line">TypeName(const TypeName&amp;); \</div><div class="line">void operator=(const TypeName&amp;)</div><div class="line">class Foo &#123;</div><div class="line">public:</div><div class="line">Foo(int f);</div><div class="line">~Foo();</div><div class="line">private:</div><div class="line">DISALLOW_COPY_AND_ASSIGN(Foo);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>使用组合一般都比使用继承合适，继承只使用public继承<br>虚析构函数只在有继承同时有虚函数的时候使用。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是指满足特定条件的类，这些类以Interface为后缀<br>定义：纯接口</p>
<blockquote>
<p>只有纯虚函数和静态函数<br>没有非静态数据成员<br>没有定义任何构造函数，如果有，也不含参数，并且为protected<br>如果是子类，也只能继承满足上述条件并以Interface为后缀的类</p>
</blockquote>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>除了少数特定环境外，不要重载操作符。<br>缺点</p>
<blockquote>
<p>混淆你的直觉，让你误以为费时的操作和内建操作一样轻巧<br>查找重载操作符的调用处困难<br>有的操作符可以对指针进行操作<br>重载的副作用，重载操作符&amp;的类不能被前置声明</p>
</blockquote>
<h2 id="声明次序"><a href="#声明次序" class="headerlink" title="声明次序"></a>声明次序</h2><p>在类中使用特定的声明次序：public:在 private:之前，成员函数在数据成员（变量）前。<br>定义次序如下：public:、protected:、private:，如果那一块没有，直接忽略即可。<br>每一块中，声明次序一般如下：<br>1) typedefs 和 enums；<br>2) 常量；<br>3) 构造函数；<br>4) 析构函数；<br>5) 成员函数，含静态成员函数；<br>6) 数据成员，含静态数据成员。<br>宏 DISALLOW_COPY_AND_ASSIGN 置于 private:块之后，作为类的最后部分。参考 拷<br>贝构造函数。<br>.cc 文件中函数的定义应尽可能和声明次序一致。<br>不要将大型函数内联到类的定义中，通常，只有那些没有特别意义的或者性能要求高的，并<br>且是比较短小的函数才被定义为内联函数。更多细节参考译文第一篇的 内联函数。</p>
<h2 id="编写短小函数"><a href="#编写短小函数" class="headerlink" title="编写短小函数"></a>编写短小函数</h2><p>超过40行，考虑分割。</p>
<h1 id="Google特有的风情"><a href="#Google特有的风情" class="headerlink" title="Google特有的风情"></a>Google特有的风情</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>需要使用智能指针的话scoped_ptr完全可以胜任。特殊情况下使用share_ptr。不要使用auto_ptr。<br>倾向于设计对象隶属明确的代码。最明确的对象隶属是根本不使用指针，直接将对象作为一个域或者局部变量使用。</p>
<h1 id="其他C-特征"><a href="#其他C-特征" class="headerlink" title="其他C++特征"></a>其他C++特征</h1><h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>所有按引用传递的参数必须加上const </p>
<h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>禁止使用缺省函数参数，所有参数必须明确指定的话，避免程序员不知道存在的缺省参数。</p>
<h2 id="编程数组和alloca"><a href="#编程数组和alloca" class="headerlink" title="编程数组和alloca"></a>编程数组和alloca</h2><p>禁止使用变长数组。使用安全的分配器。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>将一个单元测试用类声明为待测类的友元，很方便。</p>
<h2 id="不使用C-异常"><a href="#不使用C-异常" class="headerlink" title="不使用C++异常"></a>不使用C++异常</h2><h2 id="不使用RTTI"><a href="#不使用RTTI" class="headerlink" title="不使用RTTI"></a>不使用RTTI</h2><p>直接利用虚函数处理不同类型就好了。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>使用 static_cast<br>比较好处理，直接查找static_cast，就能找到哪里用了转换。C语言转换语义模糊。<br>1) static_cast：和 C 风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上<br>转换；<br>2) const_cast：移除 const 属性；<br>3) reinterpret_cast：指针类型和整型或其他指针间不安全的相互转换，仅在你对所做一<br>切了然于心时使用；<br>4) dynamic_cast：除测试外不要使用，除单元测试外，如果你需要在运行时确定类型信<br>息，说明设计有缺陷（参考  RTTI）。</p>
<h2 id="流-streams"><a href="#流-streams" class="headerlink" title="流 streams"></a>流 streams</h2><p>只在记录日志的时候使用。<br>其他时候使用printf替代。<br>估计是stream的构造使用成本高，printf简单直接。<br>然后steam重载&lt;&lt;会产生很多意想不到的错误，在深入理解C++面向对象的书里面也有提到。</p>
<h2 id="前置自增和自减"><a href="#前置自增和自减" class="headerlink" title="前置自增和自减"></a>前置自增和自减</h2><p>效率更高。<br>对于简单数值来说无所谓，但是对于迭代器这种，前置更好。</p>
<h2 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h2><p>在能够使用const的时候使用const.</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>C++中使用 stdint.h中的确定大小整型<br>不要使用无符号，使用断言声明变量非负数。也就是在传参的时候，在执行前断言判断。</p>
<h2 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h2><p>宏尽量被内联函数、枚举和常量替代<br>下面给出的用法模式可以避免一些使用宏的问题，供使用宏时参考：<br>1) 不要在.h 文件中定义宏；<br>2) 使用前正确#define，使用后正确#undef；<br>3) 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；<br>4) 不使用会导致不稳定的 C++构造（unbalanced C++ constructs，译者注） 的宏，<br>至少文档说明其行为。<br>像我们项目里的宏，完全应该被替代，起码使用一个命名空间，防止污染全局空间事情的发生。</p>
<h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h2><p>不缩写<br>易于理解第一</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TODO(kl@gmail.com): Use a "*" here for concatenation operator.</span></div><div class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></div></pre></td></tr></table></figure>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="swich"><a href="#swich" class="headerlink" title="swich"></a>swich</h2><p>如果 default 永不会执行，可以简单的使用 assert：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (var) &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">0</span>: &#123; <span class="comment">// 2 space indent</span></div><div class="line">... <span class="comment">// 4 space indent</span></div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;</div><div class="line">...</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">default</span>: &#123;</div><div class="line">assert(<span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> google </tag>
            
            <tag> 编程规范 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows下Pyqt + guiqwt环境的搭建]]></title>
      <url>/2016/10/19/windows%E4%B8%8BPyqt-guiqwt%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h1><p>这几天为了搭一个PyQt的生产环境遇到了好一些坑。<br>本身搭建PyQt的目的是为了进行试验，使用PyQt开发曾经开发过的项目的难度。<br>原项目是使用MFC开发，利用自己开发的折线绘制控件，进行高速的工控数据采集后，显示到界面上。难点主要在，高速采集之后，绘图的效率问题。<br>最终通过自己开发了一套平移显示绘图控件，在新增数据的时候，每一次只绘制一部分数据，然后通过平移之前的图像与之后的链接在一起，这样达到比较高的绘图效率，才解决了问题。但是MFC界面开发复杂，在MFC界面上花费过多的时间。同时本身绘图控件的开发，可能可以利用现有开源控件进行开发来避免重复造轮子。<br>于是利用PyQt+guiqwt绘图库来开发的方案构建起来。guiqwt本身是QT下常用的绘图控件，效率足够高，经过一些优化是能够使用的。相对Python经常使用的matplotlib来说不够漂亮，但是进行实时数据的平移绘图，效率高出很多。PyQt是模仿QT写的图形库，可以利用QTCreate进行快速的界面构建，而Python相对C++来说，需要处理的坑更少，出现各类崩溃的异常的情况会更少一些。<br>本文主要讲的是PyQt+guiqwt在windows上的搭建。<br>目的是在之后能够通过本文进行快速的开发环境的搭建。</p>
<a id="more"></a>
<h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2><p><a href="https://www.python.org/downloads/" target="_blank" rel="external">Python官网</a><br>通过Python官网下载相应版本的Python,我这里下载的是：python-3.5.2-amd64。<br>64位版本，记住版本号，用于之后的库的选择。</p>
<h2 id="安装PyQt"><a href="#安装PyQt" class="headerlink" title="安装PyQt"></a>安装PyQt</h2><p>PyQt有完整的安装包，过程中会自动安装PyQt+Qt等完整的依赖库。<br><a href="https://sourceforge.net/projects/pyqt/?source=directory" target="_blank" rel="external">PyQt下载站点</a><br>浏览所有文件找到对应的PyQt完整安装包。<br>我下的是下面网址中的64位版本。<br>PyQt5-5.6-gpl-Py3.5-Qt5.6.0-x64-2<br><a href="https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.6/" target="_blank" rel="external">PyQt完整安装包下载</a><br>安装一路下一步完成。</p>
<h2 id="安装NumPy"><a href="#安装NumPy" class="headerlink" title="安装NumPy"></a>安装NumPy</h2><p>为了能够使用guiqwt必须安装依赖的库。<br>首先安装numpy，注意的是需要安装+mk1的numpy库，否则scipy无法正常安装后使用。<br><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">下载地址</a><br>搜索Numpy找到相应的位置。<br>我选择下载的是，与Python版本对应：numpy-1.11.2+mkl-cp35-cp35m-win_amd64.whl<br>使用pip3.5安装</p>
<h2 id="安装scipy"><a href="#安装scipy" class="headerlink" title="安装scipy"></a>安装scipy</h2><p>同上，在上面的网站找到scipy。<br>版本我选择的是：scipy-0.18.1-cp35-cp35m-win_amd64<br>使用pip3.5在numpy之后安装</p>
<h2 id="安装guiqwt"><a href="#安装guiqwt" class="headerlink" title="安装guiqwt"></a>安装guiqwt</h2><p>安装guiqwt<br>上面网站搜索guiqwt<br>选择guiqwt-3.0.3-cp35-cp35m-win_amd64。<br>在sicpy之后使用pip3.5安装</p>
<h2 id="安装eric6"><a href="#安装eric6" class="headerlink" title="安装eric6"></a>安装eric6</h2><p><a href="https://sourceforge.net/projects/eric-ide/" target="_blank" rel="external">下载地址</a><br>我选择的是：eric6-6.1.10和eric6-i18n-zh_CN-6.1.10<br>解压，放到python的安装目录下：python35/eric6<br>运行python35/eric6、install.py进行安装。<br>运行Python35\Scripts\eric6.bat 就打开了eric6</p>
<p>至此开发环境搭建完成。</p>
]]></content>
      
        <categories>
            
            <category> 开发环境 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第三章 模块化 对象和状态]]></title>
      <url>/2016/09/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%8A%B6%E6%80%81/</url>
      <content type="html"><![CDATA[<p>有效的程序综合还需要一些组织原则，它们能够指导我们系统化地完成系统的整体设计。特别的需要一些能够帮助我们构造起模块化的大型系统策略，也就是说，使这些系统能够“自然地”划分为一些具有内聚力的部分，使这些部分可以分别进行开发和维护。<br>有一种非常强有力的设计策略，特别适合用于构造那类模拟真实物理系统的程序，那就是基于被模拟程序的结构去设计程序的结构。那么有关的物理系统里的每一个对象，我们构造起一个与之对象的计算对象；对该系统里的每种活动，我们在自己的计算系统里顶一种符号操作。采用这一策略时的希望是，在需要针对系统中的新对象或者新活动扩充对应的计算模型时候，我们能够不必对程序的组织方面做得很成功，那么在需要添加新特城或者排除旧东西里的错误时候，就只需要在系统里的一些小局部中工作。<br>本章研究两种特点鲜明的策略。第一种策略将注意力集中在对象上，将大型系统看成一大批对象，它们的行为可能随着时间的进展而不断的变化。另一种组织策略将注意力集中在流过的系统的信息流上，非常像电子工程师观察一个信号处理系统。<br>对于对象途径而言，我们必须关注计算对象可以怎样变化而又同时保持其标识。这将迫使我们抛弃老的计算的代换模型，转向更机械式的，理论上也更不同意把握的计算的环境模型。在处理对象、变化和标识时，各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗。如果允许程序并发指向的可能性，事情会变得更困难许多。流方式特别能用于松解在我们模型中对时间的模拟与计算机求值过程中的各种时间发生的顺序。我们将通过一种称为延时求值的技术做到这一点。</p>
<h1 id="赋值和局部状态"><a href="#赋值和局部状态" class="headerlink" title="赋值和局部状态"></a>赋值和局部状态</h1><p>一个由许多对象组成的系统里，其中的这些对象极少会是完全独立的。每个对象都可能通过交互作用，影响其他对象的状态，所谓交互就是建立起一个对象的状态变量与其他对象的状态变量之间的联系。确实如果一个系统中的状态变量可以分组，形成一些内部紧密结合的子系统，每个子系统与其他子系统之间只存在松散的练习，此时将这个系统看作是由一些独立对象组成的观点就会特别有用。<br>对于一个系统的这种观点，有可能成为组织这一系统的计算模型的有力框架。要使这样的一个模型成为模块化的，就要求它能够分解为一批计算对象，使它们能够模拟系统里的实际对象。每个计算对象必须有它自己的一些局部状态变量，用于描述实际对象的状态。对于被模拟系统里的对象的状态是随着时间的变化的，与它们对象的计算对象的状态也必须变化。<br><a id="more"></a></p>
<h2 id="局部状态变量"><a href="#局部状态变量" class="headerlink" title="局部状态变量"></a>局部状态变量</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">set!</span> &lt;name&gt; &lt;new-value&gt;)<span class="comment">;设置值</span></div><div class="line">(<span class="name">begin</span> &lt;exp1&gt; &lt;exp2&gt;)<span class="comment">;顺序求值</span></div><div class="line"></div><div class="line">(<span class="name">define</span> balance <span class="number">100</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">      (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">             balance)</div><div class="line">      <span class="string">"Insufficient funds"</span>))</div></pre></td></tr></table></figure>
<p>上面使用了全局变量<br>下面使用局部变量</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> new-withdraw</div><div class="line">  (<span class="name">let</span> ((<span class="name">balance</span> <span class="number">100</span>))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">      (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">          (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">                 balance)</div><div class="line">          <span class="string">"Insufficient funds"</span>))))</div></pre></td></tr></table></figure>
<p>构建一个提款机<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>)))</div></pre></td></tr></table></figure></p>
<p>创建一个账户<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) withdraw)</div><div class="line">          ((<span class="name">eq</span>? m 'deposit) deposit)</div><div class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknoew request --MAKE-ACCOUNT"</span></div><div class="line">                       m))))</div><div class="line">  dispatch)</div></pre></td></tr></table></figure></p>
<h2 id="引进赋值带来的收益"><a href="#引进赋值带来的收益" class="headerlink" title="引进赋值带来的收益"></a>引进赋值带来的收益</h2><p>能够简化一部分需要变量状态的过程。</p>
<h2 id="引进赋值的代价"><a href="#引进赋值的代价" class="headerlink" title="引进赋值的代价"></a>引进赋值的代价</h2><p>相比函数是编程，输入什么结果就是什么。显然引进赋值让程序变得更复杂。<br>需要存在一个位置存储变量。</p>
<h3 id="命令式程序设计的缺陷"><a href="#命令式程序设计的缺陷" class="headerlink" title="命令式程序设计的缺陷"></a>命令式程序设计的缺陷</h3><p>与函数式程序设计相对，广泛采用的赋值程序设计被称为命令是程序设计。<br>求值顺序需要保证。</p>
<h1 id="求值的环境模型"><a href="#求值的环境模型" class="headerlink" title="求值的环境模型"></a>求值的环境模型</h1><p>类似于C++的区域。<br>过程也是对象。<br>调用过程就会产生新的上下文环境，过程内的是过程内的环境。过程外全局环境等。</p>
<p>过程应用的环境模型两条规则：</p>
<ol>
<li>将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在构造起的这一新环境的上下文中求</li>
<li>相对于一个给定的环境求值一个lambda表达式，将创建其一个过程对象，这个过程对象是一个序对，由该lambda表达式的征文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时候的环境。</li>
</ol>
<h2 id="简单过程的应用"><a href="#简单过程的应用" class="headerlink" title="简单过程的应用"></a>简单过程的应用</h2><h2 id="将框架看做局部状态的展台"><a href="#将框架看做局部状态的展台" class="headerlink" title="将框架看做局部状态的展台"></a>将框架看做局部状态的展台</h2><h2 id="内部定义"><a href="#内部定义" class="headerlink" title="内部定义"></a>内部定义</h2><ol>
<li>局部过程的名字不会与包容它们的过程之外的名字互相干扰，这是因为这些局部过程名 都是该过程运行时创建的框架里约束的，而不是在全局环境里约束的。</li>
<li>局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数，这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属。</li>
</ol>
<h1 id="用变动的数据做模拟"><a href="#用变动的数据做模拟" class="headerlink" title="用变动的数据做模拟"></a>用变动的数据做模拟</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">append!</span> x y)</div><div class="line">  (<span class="name">set-cdr!</span> (<span class="name">last-pair</span> x) y)</div><div class="line">  x)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">last-pair</span> x)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? (<span class="name">cdr</span> x))</div><div class="line">      x</div><div class="line">      (<span class="name">last-pair</span> (<span class="name">cdr</span> x))))</div></pre></td></tr></table></figure>
<h3 id="共享与相等"><a href="#共享与相等" class="headerlink" title="共享与相等"></a>共享与相等</h3><p>共享会导致多个对象都拥有同一个对象，修改一个会导致另外的也跟着被修改。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">eq</span>? x y)<span class="comment">;检查是不是一个对象</span></div></pre></td></tr></table></figure></p>
<h3 id="改变也就是赋值"><a href="#改变也就是赋值" class="headerlink" title="改变也就是赋值"></a>改变也就是赋值</h3><p>主要是构建了一前一后两个指针。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">cons</span> x y)</div><div class="line">  (<span class="name">define</span> (<span class="name">set-x!</span> v) (<span class="name">set!</span> x v))</div><div class="line">  (<span class="name">define</span> (<span class="name">set-y!</span> v) (<span class="name">set!</span> y v))</div><div class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? m 'car) x)</div><div class="line">          ((<span class="name">eq</span>? m 'cdr) y)</div><div class="line">          ((<span class="name">eq</span>? m 'set-car!) set-x!)</div><div class="line">          ((<span class="name">eq</span>? m 'set-cdr!) set-y!)</div><div class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Undefined operation -- CONS"</span> m))))</div><div class="line">  dispatch)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">car</span> z) (<span class="name">z</span> 'car))</div><div class="line">(<span class="name">define</span> (<span class="name">cdr</span> z) (<span class="name">z</span> 'cdr))</div><div class="line">(<span class="name">define</span> (<span class="name">set-car!</span> z new-value)</div><div class="line">  ((<span class="name">z</span> 'set-car!) new-value)</div><div class="line">  z)</div><div class="line">(<span class="name">define</span> (<span class="name">set-cdr!</span> z new-value)</div><div class="line">  ((<span class="name">z</span> 'set-cdr!) new-value)</div><div class="line">  z)</div></pre></td></tr></table></figure></p>
<h2 id="队列的表示"><a href="#队列的表示" class="headerlink" title="队列的表示"></a>队列的表示</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;构造函数</span></div><div class="line">(<span class="name">define</span> (<span class="name">make-queue</span>) (<span class="name">cons</span> '() '()))</div><div class="line"><span class="comment">;选择函数</span></div><div class="line">(<span class="name">define</span> (<span class="name">front-queue</span> queue)</div><div class="line">  (<span class="name">if</span> (<span class="name">empty-queue</span>? queue)</div><div class="line">      (<span class="name">error</span> <span class="string">"FRONT called with an empty queue"</span> queue)</div><div class="line">      (<span class="name">car</span> (<span class="name">front-ptr</span> queue))))</div><div class="line"><span class="comment">;检测队列是否为空</span></div><div class="line">(<span class="name">define</span> (<span class="name">empty-queue</span>? queue) (<span class="name">null</span>? (<span class="name">front-ptr</span> queue)))</div><div class="line"><span class="comment">;改变函数</span></div><div class="line">(<span class="name">define</span> (<span class="name">insert-queue!</span> queue item)</div><div class="line">  (<span class="name">let</span> ((<span class="name">new-pair</span> (<span class="name">cons</span> item '())))</div><div class="line">    (<span class="name">cond</span> ((<span class="name">empty-queue</span>? queue)</div><div class="line">           (<span class="name">set-front-ptr!</span> queue new-pair)</div><div class="line">           (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">           queue)</div><div class="line">          (<span class="name">else</span></div><div class="line">           (<span class="name">set-cdr!</span> (<span class="name">rear-ptr</span> queue) new-pair)</div><div class="line">           (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">           queue))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">delete-queue!</span> queue)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">empty-queue</span>? queue)</div><div class="line">         (<span class="name">error</span> <span class="string">"DELETE! called with an empty queue"</span> queue))</div><div class="line">        (<span class="name">else</span></div><div class="line">         (<span class="name">set-front-ptr!</span> queue (<span class="name">cdr</span> (<span class="name">front-ptr</span> queue)))</div><div class="line">         queue)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">front-ptr</span> queue) (<span class="name">car</span> queue))</div><div class="line">(<span class="name">define</span> (<span class="name">rear-ptr</span> queue) (<span class="name">cdr</span> queue))</div><div class="line">(<span class="name">define</span> (<span class="name">set-front-ptr!</span> queue item) (<span class="name">set-car!</span> queue item))</div><div class="line">(<span class="name">define</span> (<span class="name">set-rear-ptr!</span> queue item) (<span class="name">set-car!</span> queue item))</div></pre></td></tr></table></figure>
<h2 id="表格的表示"><a href="#表格的表示" class="headerlink" title="表格的表示"></a>表格的表示</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">lookup</span> key table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">cdr</span> record)</div><div class="line">        false)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">assoc</span> key records)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? records) false)</div><div class="line">        ((<span class="name">equal</span>? key (<span class="name">caar</span> records)) (<span class="name">car</span> records))</div><div class="line">        (<span class="name">else</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> records)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">insert!</span> key value table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">set-cdr!</span> record value)</div><div class="line">        (<span class="name">set-cdr!</span> table</div><div class="line">                  (<span class="name">cons</span> (<span class="name">cons</span> key value) (<span class="name">cdr</span> table))))))</div><div class="line">(<span class="name">define</span> (<span class="name">make-table</span>)</div><div class="line">  (<span class="name">list</span> '*table*))</div></pre></td></tr></table></figure>
<h2 id="数字电路的模拟器"><a href="#数字电路的模拟器" class="headerlink" title="数字电路的模拟器"></a>数字电路的模拟器</h2><h1 id="并发：时间本质是个问题"><a href="#并发：时间本质是个问题" class="headerlink" title="并发：时间本质是个问题"></a>并发：时间本质是个问题</h1><p>和普通的并发问题是一致的。<br>串行化共享部分。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> s make-serializer)</div><div class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">=</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line">  (<span class="name">let</span> ((<span class="name">protected</span> (<span class="name">make-serializer</span>)))</div><div class="line">    (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) (<span class="name">protected</span> withdraw))</div><div class="line">            ((<span class="name">eq</span>? m 'deposit) (<span class="name">protected</span> deposit))</div><div class="line">            ((<span class="name">eq</span>? m 'balance) balance)</div><div class="line">            (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request --MAKE-ACCOUNT"</span></div><div class="line">                         m))))</div><div class="line">    dispatch))</div></pre></td></tr></table></figure></p>
<h2 id="串行化的实现"><a href="#串行化的实现" class="headerlink" title="串行化的实现"></a>串行化的实现</h2><p>互斥元同步机制。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-serializer</span>)</div><div class="line">  (<span class="name">let</span> ((<span class="name">mutex</span> (<span class="name">make-mutex</span>)))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">p</span>)</div><div class="line">      (<span class="name">define</span> (<span class="name">serialized-p</span> . args)</div><div class="line">        (<span class="name">mutex</span> 'acquire)</div><div class="line">        (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">apply</span> p args)))</div><div class="line">          (<span class="name">mutex</span> 'release)</div><div class="line">          val))</div><div class="line">      serialized-p)))</div><div class="line"></div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-mutex</span>)</div><div class="line">  (<span class="name">let</span> ((<span class="name">cell</span> (<span class="name">list</span> false)))</div><div class="line">    (<span class="name">define</span> (<span class="name">the-mutex</span> m)</div><div class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'acquire)</div><div class="line">             (<span class="name">if</span> (<span class="name">test-and-set!</span> cell)</div><div class="line">                 (<span class="name">the-mutex</span> 'acquire)))</div><div class="line">            ((<span class="name">eq</span>? m 'release) (<span class="name">clea!</span> cell))))</div><div class="line">    the-mutex))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">test-and-set!</span> cell)</div><div class="line">  (<span class="name">if</span> (<span class="name">car</span> cell)</div><div class="line">      true</div><div class="line">      (<span class="name">begin</span> (<span class="name">set-car!</span> cell true)</div><div class="line">             false)))</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sicp </tag>
            
            <tag> 计算机程序的构造与解释 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第二章 带有通用型操作的系统]]></title>
      <url>/2016/09/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E6%9C%89%E9%80%9A%E7%94%A8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h1 id="通用型算术运算"><a href="#通用型算术运算" class="headerlink" title="通用型算术运算"></a>通用型算术运算</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">add</span> x y) (<span class="name">apply-generic</span> 'add x y))</div><div class="line">(<span class="name">define</span> (<span class="name">sub</span> x y) (<span class="name">apply-generic</span> 'sub x y))</div><div class="line">(<span class="name">define</span> (<span class="name">mul</span> x y) (<span class="name">apply-generic</span> 'mul x y))</div><div class="line">(<span class="name">define</span> (<span class="name">div</span> x y) (<span class="name">apply-generic</span> 'div x y))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">install-scheme-number-package</span>)</div><div class="line">  (<span class="name">define</span> (<span class="name">tag</span> x)</div><div class="line">    (<span class="name">attach-tag</span> 'scheme-number x))</div><div class="line">  (<span class="name">put</span> 'add '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">+</span> x y))))</div><div class="line">  (<span class="name">put</span> 'sub '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">-</span> x y))))</div><div class="line">  (<span class="name">put</span> 'mul '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">*</span> x y))))</div><div class="line">  (<span class="name">put</span> 'div '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">/</span> x y))))</div><div class="line">  (<span class="name">put</span> 'make '(scheme-number scheme-number)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">tag</span> x)))</div><div class="line">  'done)</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">make-scheme-number</span> n)</div><div class="line">  ((<span class="name">get</span> 'make 'scheme-number) n))</div></pre></td></tr></table></figure>
<p>利用同样的方法可以加入有理数/复数等操作</p>
<a id="more"></a>
<h1 id="不同类型数据的组合"><a href="#不同类型数据的组合" class="headerlink" title="不同类型数据的组合"></a>不同类型数据的组合</h1><p>处理跨类型的操作。<br>为每一种跨类型操作提供专门的过程处理，是可以，但是太麻烦。每添加一种类型，要增加太多过程。</p>
<h2 id="强制"><a href="#强制" class="headerlink" title="强制"></a>强制</h2><p>类型转换处理能够解决一部分问题。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;实数转虚数</span></div><div class="line">(<span class="name">define</span> (<span class="name">scheme-number-&gt;complex</span> n)</div><div class="line">  (<span class="name">make-complex-from-real-imag</span> (<span class="name">contents</span> n) <span class="number">0</span>))</div></pre></td></tr></table></figure></p>
<p>将这些强制过程安装到一个特护的表格里，用两个类型的名字作为索引。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">put-coercion</span> 'scheme-number 'complex scheme-number-&gt;complex)</div></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">apply-generic</span> op . args)</div><div class="line">  (<span class="name">let</span> ((<span class="name">type-tags</span> (<span class="name">map</span> type-tag args)))</div><div class="line">    (<span class="name">let</span> ((<span class="name">proc</span> (<span class="name">get</span> op type-tags)))</div><div class="line">      (<span class="name">if</span> proc</div><div class="line">          (<span class="name">apply</span> proc (<span class="name">map</span> contents args))</div><div class="line">          (<span class="name">if</span> (<span class="name">=</span> (<span class="name">length</span> args) <span class="number">2</span>)</div><div class="line">              (<span class="name">let</span> ((<span class="name">type1</span> (<span class="name">car</span> type-tags))</div><div class="line">                    (<span class="name">type2</span> (<span class="name">cadr</span> type-tags))</div><div class="line">                    (<span class="name">a1</span> (<span class="name">car</span> args))</div><div class="line">                    (<span class="name">a2</span> (<span class="name">cadr</span> args)))</div><div class="line">                (<span class="name">let</span> ((<span class="name">t1-&gt;t2</span> (<span class="name">get-coercion</span> type1 type2))</div><div class="line">                      (<span class="name">t2-&gt;t1</span> (<span class="name">get-coercion</span> type2 type1)))</div><div class="line">                  (<span class="name">cond</span> (<span class="name">t1-&gt;t2</span></div><div class="line">                         (<span class="name">apply-generic</span> op (<span class="name">t1-&gt;t2</span> a1) a2))</div><div class="line">                        (<span class="name">t2-&gt;t1</span></div><div class="line">                         (<span class="name">apply-generic</span> op a1 (<span class="name">t2-&gt;t1</span> a2)))</div><div class="line">                        (<span class="name">else</span></div><div class="line">                         (<span class="name">error</span> <span class="string">"No method for these types"</span></div><div class="line">                                (<span class="name">list</span> op type-tags))))))</div><div class="line">              (<span class="name">error</span> <span class="string">"No method for these types"</span></div><div class="line">                     (<span class="name">list</span> op type-tags)))))))</div></pre></td></tr></table></figure>
<h1 id="类型的层次结构"><a href="#类型的层次结构" class="headerlink" title="类型的层次结构"></a>类型的层次结构</h1><p>就是继承嘛。子类型有父类型的所有操作。</p>
<p>#层次结构的不足<br>可能产生菱形的层次结构。</p>
<p>在设计大型系统时，处理好一大批相互有关的类型而同时又能保持模块性，这是一个困难的问题，也是当前正在继续研究的领域。<br>编者注：这句话出现在书的第一版本。它的现在就像20年前写出时候正确。开发出一种有用的，具有一般意义的框架，以描述不同类型对象之间的关系(哲学中本体论)，看来是一件极其困难的工作。在10年前存在的混乱和今天存在的混乱之间的主要差异在于，今天已经有了一批各式各样的并不合适的本体理论，它们已经嵌入数量过多而又先天不足的各种程序设计语言里。举例来说，面向对象语言的大部分复杂性-以及当前各种面向对象语言之间细微的而且诗人迷惑的差异-的核心，就是类型之间通用型操作的处理。我们在第三章有关计算性对象的讨论中完全避免了这些问题。熟悉面向对象程序涉及到读者将会注意到，在第三章里关于局部状态说了许多东西，但是却根本没有提到“类”或者“继承”。事实上，我们的猜想是，如果没有知识表示和自动推理工作的帮助，这些问题是无法仅仅通过计算机语言设计的方式合理处理的。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sicp </tag>
            
            <tag> 计算机程序的构造与解释 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第二章 抽象数据的多重表示]]></title>
      <url>/2016/09/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>对于一个数据对象可以能存在多种有用的表示形式，而且我们也希望所涉及的系统能够处理多种表示形式。<br>例子：复数的极坐标形式和直角坐标的形式<br>构造通用型过程：可以在不止一种数据表示上操作的过程。采用的技术：让它们在带有类型标志的数据对象上工作。也就是说，让数据对象包含着它们应该如何处理的明确信息。</p>
<h1 id="复数的表示"><a href="#复数的表示" class="headerlink" title="复数的表示"></a>复数的表示</h1><p>为一个数据提供了多种操作，存在多种形式<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">real-part</span> z) (<span class="name">car</span> z))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">imag-part</span> z) (<span class="name">cdr</span> z))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">magnitude</span> z)</div><div class="line">  (<span class="name">sqrt</span> (<span class="name">+</span> (<span class="name">square</span> (<span class="name">real-part</span> z)) (<span class="name">square</span> (<span class="name">imag-part</span> z)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">angle</span> z)</div><div class="line">  (<span class="name">atan</span> (<span class="name">imag-part</span> z) (<span class="name">real-part</span> z)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-from-real-imag</span> x y) (<span class="name">cons</span> x y))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-from-mag-ang</span> r a)</div><div class="line">  (<span class="name">cons</span> (<span class="name">*</span> r (<span class="name">cos</span> a)) (<span class="name">*</span> r (<span class="name">sin</span> a))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">add-complex</span> z1 z2)</div><div class="line">  (<span class="name">make-from-real-imag</span> (<span class="name">+</span> (<span class="name">real-part</span> z1) (<span class="name">real-part</span> z2))</div><div class="line">                       (<span class="name">+</span> (<span class="name">imag-part</span> z1) (<span class="name">imag-part</span> z2))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sub-complex</span> z1 z2)</div><div class="line">  (<span class="name">make-from-real-imag</span> (<span class="name">-</span> (<span class="name">real-part</span> z1) (<span class="name">real-part</span> z2))</div><div class="line">                       (<span class="name">-</span> (<span class="name">imag-part</span> z1) (<span class="name">imag-part</span> z2))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">mul-complex</span> z1 z2)</div><div class="line">  (<span class="name">make-from-mag-ang</span> (<span class="name">*</span> (<span class="name">magnitude</span> z1) (<span class="name">magnitude</span> z2))</div><div class="line">                     (<span class="name">+</span> (<span class="name">angle</span> z1) (<span class="name">angle</span> z2))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">div-complex</span> z1 z2)</div><div class="line">  (<span class="name">make-from-mag-ang</span> (<span class="name">/</span> (<span class="name">magnitude</span> z1) (<span class="name">magnitude</span> z2))</div><div class="line">                     (<span class="name">-</span> (<span class="name">angle</span> z1) (<span class="name">angle</span> z2))))</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="带标志数据"><a href="#带标志数据" class="headerlink" title="带标志数据"></a>带标志数据</h1><p>认识数据抽象的一种方式是将其看做”最小允诺原则“的一个应用。在实现上面的复数系统的时候，采用两种形式，由选择函数和构造函数形成的抽象屏障，使我们可以把为自己所用的数据对象选择具体表现形式的事情尽量往后推，而且还能够保持系统设计的最大灵活性。<br>方式，利用类型标志，来确定什么类型，选择什么函数。<br>增加类型标示<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">attach-tag</span> type-tag contents)</div><div class="line">  (<span class="name">cons</span> type-tag contents))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">type-tag</span> datum)</div><div class="line">  (<span class="name">if</span> (<span class="name">pair</span>? datum)</div><div class="line">      (<span class="name">car</span> datum)</div><div class="line">      (<span class="name">error</span> <span class="string">"Bad tagged datum -- TYPE-TAG"</span> datum)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">contents</span> datum)</div><div class="line">  (<span class="name">if</span> (<span class="name">pair</span>? datum)</div><div class="line">      (<span class="name">cdr</span> datum)</div><div class="line">      (<span class="name">error</span> <span class="string">"Bad tagged datum -- CONTENTS"</span> datum)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rectangular</span>? z)</div><div class="line">  (<span class="name">eq</span>? (<span class="name">type-tag</span> z) 'rectangular))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">polar</span>? z)</div><div class="line">  (<span class="name">eq</span>? (<span class="name">type-tag</span> z) 'polar))</div></pre></td></tr></table></figure></p>
<p>修改新的直角坐标表示<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">real-part-rectangular</span> z) (<span class="name">car</span> z))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">imag-part-rectangular</span> z) (<span class="name">cdr</span> z))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">magnitude-rectangular</span> z)</div><div class="line">  (<span class="name">sqrt</span> (<span class="name">+</span> (<span class="name">square</span> (<span class="name">real-part-rectangular</span> z)) (<span class="name">square</span> (<span class="name">imag-part-rectangular</span> z)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">angle-rectangular</span> z)</div><div class="line">  (<span class="name">atan</span> (<span class="name">imag-part-rectangular</span> z) (<span class="name">real-part-rectangular</span> z)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-from-real-imag-rectangular</span> x y) (<span class="name">attach-tag</span> 'rectangular (<span class="name">cons</span> x y)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-from-mag-ang-rectangular</span> r a)</div><div class="line">  (<span class="name">attach-tag</span> 'rectangular (<span class="name">cons</span> (<span class="name">*</span> r (<span class="name">cos</span> a)) (<span class="name">*</span> r (<span class="name">sin</span> a)))))</div></pre></td></tr></table></figure></p>
<p>修改极坐标的表现形式<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">real-part-polat</span> z)</div><div class="line">  (<span class="name">*</span> (<span class="name">magnitude-polat</span> z) (<span class="name">cos</span> (<span class="name">angle-polat</span> z))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">imag-part-polat</span> z)</div><div class="line">  (<span class="name">*</span> (<span class="name">magnitude-polat</span> z) (<span class="name">sin</span> (<span class="name">angle-polat</span> z))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">magnitude-polat</span> z)</div><div class="line">  (<span class="name">car</span> z))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">angle-polat</span> z)</div><div class="line">  (<span class="name">cdr</span> z))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-from-real-imag-polatr</span> x y)</div><div class="line">  (<span class="name">attach-tag</span> 'polar</div><div class="line">              (<span class="name">cons</span> (<span class="name">sqrt</span> (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</div><div class="line">                    (<span class="name">atan</span> y x))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-from-mag-ang-polat</span> r a)</div><div class="line">  (<span class="name">attach-tag</span> 'polar (<span class="name">cons</span> r a)))</div></pre></td></tr></table></figure></p>
<p>在通用选择函数都添加检查类型的标志，调用合适的函数。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">real-patr</span> z)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">rectangular</span>? z)</div><div class="line">         (<span class="name">real-part-rectangular</span> (<span class="name">contents</span> z)))</div><div class="line">        ((<span class="name">polar</span>? z)</div><div class="line">         (<span class="name">real-part-polat</span> (<span class="name">contents</span> z)))</div><div class="line">        (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown type -- REAL-PART"</span> z))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">imag-patr</span> z)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">rectangular</span>? z)</div><div class="line">         (<span class="name">imag-part-rectangular</span> (<span class="name">contents</span> z)))</div><div class="line">        ((<span class="name">polar</span>? z)</div><div class="line">         (<span class="name">imag-part-polat</span> (<span class="name">contents</span> z)))</div><div class="line">        (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown type -- IMAG-PART"</span> z))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">magnitude</span> z)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">rectangular</span>? z)</div><div class="line">         (<span class="name">magnitude-rectangular</span> (<span class="name">contents</span> z)))</div><div class="line">        ((<span class="name">polar</span>? z)</div><div class="line">         (<span class="name">magnitude-polat</span> (<span class="name">contents</span> z)))</div><div class="line">        (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown type -- MAGNITUDE"</span> z))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">angle</span> z)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">rectangular</span>? z)</div><div class="line">         (<span class="name">angle-rectangular</span> (<span class="name">contents</span> z)))</div><div class="line">        ((<span class="name">polar</span>? z)</div><div class="line">         (<span class="name">angle-polat</span> (<span class="name">contents</span> z)))</div><div class="line">        (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown type -- ANGLE"</span> z))))</div></pre></td></tr></table></figure></p>
<p>实现算数操作的时候不需要改变。还是原来的形式就可以。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">add-complex</span> z1 z2)</div><div class="line">  (<span class="name">make-from-real-imag</span> (<span class="name">+</span> (<span class="name">real-part</span> z1) (<span class="name">real-part</span> z2))</div><div class="line">                       (<span class="name">+</span> (<span class="name">imag-part</span> z1) (<span class="name">imag-part</span> z2))))</div></pre></td></tr></table></figure></p>
<p>需要修改下构造函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-from-real-imag</span> x y)</div><div class="line">  (<span class="name">make-from-real-imag-rectangular</span> x y))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-from-mag-ang</span> r a)</div><div class="line">  (<span class="name">make-from-mag-ang-polat</span> r a))</div></pre></td></tr></table></figure></p>
<h1 id="数据导向的程序设计和可加性"><a href="#数据导向的程序设计和可加性" class="headerlink" title="数据导向的程序设计和可加性"></a>数据导向的程序设计和可加性</h1><p>检查一个数据项的类型，并据此去调用某个适当的过程称为基于类型的分派。<br>在系统设计中，这是一种获得模块性的强有力策略（可能oo是更好的方式，检测类型还是比较麻烦的）。<br>存在两个弱点：</p>
<ol>
<li>其中的通用型接口过程，必须知道素有的不同表示。需要检测类型，选择适当函数</li>
<li>独立的表现形式分别设计，需要拥有不同的名字。<br>那么这就导致，这种实现不具有可加性。在每一次增加一种新形式的时候，需要去修改原过程，修改类型判断，增加代码，修改过程名字。</li>
</ol>
<p>现在我们需要的是一种能够将系统设计进一步模块化的方法。一种称为数据导向的程序设计都编程技术提供了这种能力（其实在数据中保存能够处理数据的过程，就能够不用选择函数直接处理了嘛）。<br>（实际上这里讲的是一种注册机制）<br>假定存在put get来制造表格<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">install-rectangular-package</span>)</div><div class="line">  <span class="comment">;internal procedures</span></div><div class="line">  (<span class="name">define</span> (<span class="name">real-part</span> z) (<span class="name">car</span> z))</div><div class="line">  (<span class="name">define</span> (<span class="name">imag-part</span> z) (<span class="name">cdr</span> z))</div><div class="line">  (<span class="name">define</span> (<span class="name">make-from-real-imag</span> x y) (<span class="name">cons</span> x y))</div><div class="line">  (<span class="name">define</span> (<span class="name">magnitude</span> z)</div><div class="line">  (<span class="name">sqrt</span> (<span class="name">+</span> (<span class="name">square</span> (<span class="name">real-part</span> z)) (<span class="name">square</span> (<span class="name">imag-part</span> z)))))</div><div class="line">  (<span class="name">define</span> (<span class="name">angle</span> z)</div><div class="line">  (<span class="name">atan</span> (<span class="name">imag-part</span> z) (<span class="name">real-part</span> z)))</div><div class="line">  (<span class="name">define</span> (<span class="name">make-from-mag-ang</span> r a)</div><div class="line">  (<span class="name">cons</span> (<span class="name">*</span> r (<span class="name">cos</span> a)) (<span class="name">*</span> r (<span class="name">sin</span> a))))</div><div class="line">  <span class="comment">;interface the rest of the system</span></div><div class="line">  (<span class="name">define</span> (<span class="name">tag</span> x) (<span class="name">attach-tag</span> 'rectangular x))</div><div class="line">  (<span class="name">put</span> 'real-part '('rectangular) real-part)</div><div class="line">  (<span class="name">put</span> 'imag-part '('rectangular) imag-part)</div><div class="line">  (<span class="name">put</span> 'magnitude '('rectangular) magnitude)</div><div class="line">  (<span class="name">put</span> 'angle '('rectangular) angle)</div><div class="line">  (<span class="name">put</span> 'make-from-real-imag '('rectangular)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">make-from-real-imag</span> x y))))</div><div class="line">  (<span class="name">put</span> 'make-from-mag-ang '('rectangular)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">r</span> a) (<span class="name">tag</span> (<span class="name">make-from-mag-ang</span> r a))))</div><div class="line">  'done)</div></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">install-polar-package</span>)</div><div class="line">  <span class="comment">;internal procedures</span></div><div class="line">  (<span class="name">define</span> (<span class="name">magnitude</span> z) (<span class="name">car</span> z))</div><div class="line">  (<span class="name">define</span> (<span class="name">angle</span> z) (<span class="name">cdr</span> z))</div><div class="line">  (<span class="name">define</span> (<span class="name">make-from-mag-ang</span> r a) (<span class="name">cons</span> r a))</div><div class="line">  (<span class="name">define</span> (<span class="name">real-part</span> z)</div><div class="line">  (<span class="name">*</span> (<span class="name">magnitude</span> z) (<span class="name">cos</span> (<span class="name">angle</span> z))))</div><div class="line">  (<span class="name">define</span> (<span class="name">imag-part</span> z)</div><div class="line">   (<span class="name">*</span> (<span class="name">magnitude</span> z) (<span class="name">sin</span> (<span class="name">angle</span> z))))</div><div class="line">  (<span class="name">define</span> (<span class="name">make-from-real-imag</span> x y)</div><div class="line">    (<span class="name">cons</span> (<span class="name">sqrt</span> (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</div><div class="line">          (<span class="name">atan</span> y x)))</div><div class="line">  <span class="comment">;interface the rest of the system</span></div><div class="line">  (<span class="name">define</span> (<span class="name">tag</span> x) (<span class="name">attach-tag</span> 'polar x))</div><div class="line">  (<span class="name">put</span> 'real-part '('polar) real-part)</div><div class="line">  (<span class="name">put</span> 'imag-part '('polar) imag-part)</div><div class="line">  (<span class="name">put</span> 'magnitude '('polar) magnitude)</div><div class="line">  (<span class="name">put</span> 'angle '('polar) angle)</div><div class="line">  (<span class="name">put</span> 'make-from-real-imag '('polar)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name">make-from-real-imag</span> x y))))</div><div class="line">  (<span class="name">put</span> 'make-from-mag-ang '('polar)</div><div class="line">       (<span class="name">lambda</span> (<span class="name">r</span> a) (<span class="name">tag</span> (<span class="name">make-from-mag-ang</span> r a))))</div><div class="line">  'done)</div></pre></td></tr></table></figure>
<p>下面操作用于访问表格<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">apply-generic</span> op . args)</div><div class="line">  (<span class="name">let</span> ((<span class="name">type-tags</span> (<span class="name">map</span> type-tag args)))</div><div class="line">    (<span class="name">let</span> ((<span class="name">proc</span> (<span class="name">get</span> op type-tags)))</div><div class="line">      (<span class="name">if</span> proc</div><div class="line">          (<span class="name">apply</span> proc (<span class="name">map</span> contents args))</div><div class="line">          (<span class="name">error</span></div><div class="line">           <span class="string">"No method for these types -- APPLY-GENERIC"</span></div><div class="line">           (<span class="name">list</span> op type-tags))))))</div></pre></td></tr></table></figure></p>
<p>那么通用操作。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">real-part</span> z) (<span class="name">apply-generic</span> 'real-part z))</div><div class="line">(<span class="name">define</span> (<span class="name">imag-part</span> z) (<span class="name">apply-generic</span> 'imag-part z))</div><div class="line">(<span class="name">define</span> (<span class="name">magnitude</span> z) (<span class="name">apply-generic</span> 'magnitude z))</div><div class="line">(<span class="name">define</span> (<span class="name">angle</span> z) (<span class="name">apply-generic</span> 'angle z))</div></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-from-real-imag</span> x y)</div><div class="line">  ((<span class="name">get</span> 'make-from-real-imag 'rectangular) x y))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-from-mag-ang</span> r a)</div><div class="line">  ((<span class="name">get</span> 'make-from-mag-ang 'polat) r a))</div></pre></td></tr></table></figure>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>数据导向的程序设计，最关键的思想是通过显式的操作-类型表格的方式，管理程序中的各种通用性操作。上面使用的程序设计风格是一种基于类型进行分派的组织方式，其中让每个操作管理自己的分派。从效果上看，这种方式就是将操作-类型表哥格分解位一行一行，每个通用型过程表示表格中的一行。<br>另一种实现策略是将这一表格按列进行分解，不是采用一批“只能”操作区基于数据类型进行分派，而是采用“只能数据对象”，让它们基于操作名完成所需要的分派工作。<br>需要做的，将每一个数据对象表示为一个过程。（实际上类似于数据封装，每个数据对象保存专有的函数，利用虚函数就行了。思想是一致的。stl）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-from-real-imag</span> x y)</div><div class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> op)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? op 'real-part) x)</div><div class="line">          ((<span class="name">eq</span>? op 'iamg-part) y)</div><div class="line">          ((<span class="name">eq</span>? op 'magnitude)</div><div class="line">           (<span class="name">sqrt</span> (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y))))</div><div class="line">          ((<span class="name">eq</span>? op 'angle) (<span class="name">atan</span> y x))</div><div class="line">          (<span class="name">else</span></div><div class="line">           (<span class="name">error</span> <span class="string">"Unkonown op -- MAKE-FROM-REAL-IMAG"</span> op))))</div><div class="line">dispatch)</div><div class="line"><span class="comment">;查找函数</span></div><div class="line">(<span class="name">define</span> (<span class="name">apply-generic</span> op arg)</div><div class="line">  (<span class="name">arg</span> op))</div></pre></td></tr></table></figure>
<p>这种风格的程序设计称为消息传递，将数据对象设想位一个实体，它以消息的方式接受所需要操作的名字。（设计模式里面有一种这种模式）。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sicp </tag>
            
            <tag> 计算机程序的构造与解释 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第二章 符号数据]]></title>
      <url>/2016/09/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">list</span> 'a 'b)</div><div class="line">(<span class="name">eq</span>? a b)</div></pre></td></tr></table></figure>
<h1 id="符号求导"><a href="#符号求导" class="headerlink" title="符号求导"></a>符号求导</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">;e是变量吗</span></div><div class="line">(<span class="name">define</span> (<span class="name">variable</span>? x)</div><div class="line">  (<span class="name">symbol</span>? x))<span class="comment">;symbol?判断变量是不是符号</span></div><div class="line"></div><div class="line"><span class="comment">;v1和v2是同一个变量吗</span></div><div class="line">(<span class="name">define</span> (<span class="name">same-variable</span>? v1 v2)</div><div class="line">  (<span class="name">and</span> (<span class="name">variable</span>? v1) (<span class="name">variable</span>? v2) (<span class="name">eq</span>? v1 v2)))</div><div class="line"></div><div class="line"><span class="comment">;e是和式吗</span></div><div class="line">(<span class="name">define</span> (<span class="name">sum</span>? x)</div><div class="line">  (<span class="name">and</span> (<span class="name">pair</span>? x) (<span class="name">eq</span>? (<span class="name">car</span> x) '+)))</div><div class="line"></div><div class="line"><span class="comment">;e的被加数</span></div><div class="line">(<span class="name">define</span> (<span class="name">addend</span> s) (<span class="name">cadr</span> s))</div><div class="line"></div><div class="line"><span class="comment">;e的加数</span></div><div class="line">(<span class="name">define</span> (<span class="name">augend</span> s) (<span class="name">caddr</span> s))</div><div class="line"></div><div class="line"><span class="comment">;构造起a1和a2的和式</span></div><div class="line">(<span class="name">define</span> (<span class="name">make-sum</span> a1 a2) (<span class="name">list</span> '+ a1 a2))</div><div class="line"></div><div class="line"><span class="comment">;e是乘式吗</span></div><div class="line">(<span class="name">define</span> (<span class="name">product</span>? x)</div><div class="line">  (<span class="name">and</span> (<span class="name">pair</span>? x) (<span class="name">eq</span>? (<span class="name">car</span> x) '*)))</div><div class="line"></div><div class="line"><span class="comment">;e的被乘数</span></div><div class="line">(<span class="name">define</span> (<span class="name">multiplier</span> p) (<span class="name">cadr</span> p))</div><div class="line"></div><div class="line"><span class="comment">;e的乘数</span></div><div class="line">(<span class="name">define</span> (<span class="name">multiplicand</span> p) (<span class="name">caddr</span> p))</div><div class="line"></div><div class="line"><span class="comment">;构造起来m1与m2的乘式</span></div><div class="line">(<span class="name">define</span> (<span class="name">make-product</span> m1 m2)</div><div class="line">       (<span class="name">list</span> '* m1 m2))</div><div class="line"></div><div class="line"><span class="comment">;求导</span></div><div class="line">(<span class="name">define</span> (<span class="name">deriv</span> exp var)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">number</span>? exp) <span class="number">0</span>)</div><div class="line">        ((<span class="name">variable</span>? exp)</div><div class="line">         (<span class="name">if</span> (<span class="name">same-variable</span>? exp var) <span class="number">1</span> <span class="number">0</span>))</div><div class="line">        ((<span class="name">sum</span>? exp)</div><div class="line">         (<span class="name">make-sum</span> (<span class="name">deriv</span> (<span class="name">addend</span> exp) var)</div><div class="line">                   (<span class="name">deriv</span> (<span class="name">augend</span> exp) var)))</div><div class="line">        ((<span class="name">product</span>? exp)</div><div class="line">         (<span class="name">make-sum</span></div><div class="line">          (<span class="name">make-product</span> (<span class="name">multiplier</span> exp)</div><div class="line">                        (<span class="name">deriv</span> (<span class="name">multiplicand</span> exp) var))</div><div class="line">          (<span class="name">make-product</span> (<span class="name">deriv</span> (<span class="name">multiplier</span> exp) var)</div><div class="line">                        (<span class="name">multiplicand</span> exp))))</div><div class="line">        (<span class="name">else</span></div><div class="line">         (<span class="name">error</span> <span class="string">"unknown expression type -- DERIV"</span> exp))))</div><div class="line"></div><div class="line">(<span class="name">deriv</span> '(+ x <span class="number">3</span>) 'x)</div><div class="line">(<span class="name">deriv</span> '(* x y) 'x)</div><div class="line">(deriv '(* (* x y) (+ x <span class="number">3</span>)) 'x)</div><div class="line"></div><div class="line">'(+ <span class="number">1</span> <span class="number">0</span>)</div><div class="line">'(+ (* x <span class="number">0</span>) (* <span class="number">1</span> y))</div><div class="line">'(+ (* (* x y) (+ <span class="number">1</span> <span class="number">0</span>)) (* (+ (* x <span class="number">0</span>) (* <span class="number">1</span> y)) (+ x <span class="number">3</span>)))</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h1><h2 id="集合作为未排序的表"><a href="#集合作为未排序的表" class="headerlink" title="集合作为未排序的表"></a>集合作为未排序的表</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;判断是不是表成员</span></div><div class="line">(<span class="name">define</span> (<span class="name">element-of-set</span>? x set)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? set) false)</div><div class="line">        ((<span class="name">equal</span>? x (<span class="name">car</span> set)) true)</div><div class="line">        (<span class="name">else</span> (<span class="name">element-of-set</span>? x (<span class="name">cdr</span> set)))))</div><div class="line"><span class="comment">;向表增加一项</span></div><div class="line">(<span class="name">define</span> (<span class="name">adjoin-set</span> x set)</div><div class="line">  (<span class="name">if</span> (<span class="name">element-of-set</span>? x set)</div><div class="line">      set</div><div class="line">      (<span class="name">cons</span> x set)))</div><div class="line"><span class="comment">;合并</span></div><div class="line">(<span class="name">define</span> (<span class="name">intersection-set</span> set1 set2)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">or</span> (<span class="name">null</span>? set1) (<span class="name">null</span>? set2)) '())</div><div class="line">        ((<span class="name">element-of-set</span>? (<span class="name">car</span> set1) set2)</div><div class="line">         (<span class="name">cons</span> (<span class="name">car</span> set1)</div><div class="line">               (<span class="name">intersection-set</span> (<span class="name">cdr</span> set1) set2)))</div><div class="line">        (<span class="name">else</span> (<span class="name">intersection-set</span> (<span class="name">cdr</span> set1) set2))))</div></pre></td></tr></table></figure>
<h2 id="集合作为排序的表"><a href="#集合作为排序的表" class="headerlink" title="集合作为排序的表"></a>集合作为排序的表</h2><p>排序的存在的好处就是减少复杂度<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">element-of-set</span>? x set)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? set) false)</div><div class="line">        ((<span class="name">=</span> x (<span class="name">car</span> set)) true)</div><div class="line">        ((<span class="name">&lt;</span> x (<span class="name">car</span> set)) false)</div><div class="line">        (<span class="name">else</span> (<span class="name">element-of-set</span>? x (<span class="name">cdr</span> set)))))</div><div class="line">    </div><div class="line">(<span class="name">define</span> (<span class="name">intersection-set</span> set1 set2)</div><div class="line">  (<span class="name">if</span> (<span class="name">or</span> (<span class="name">null</span>? set1) (<span class="name">null</span>? set2))</div><div class="line">       '()</div><div class="line">       (<span class="name">let</span> ((<span class="name">x1</span> (<span class="name">car</span> set1)) (<span class="name">x2</span> (<span class="name">car</span> set2)))</div><div class="line">         (<span class="name">cond</span> ((<span class="name">=</span> x1 x2)</div><div class="line">                (<span class="name">cons</span> x1</div><div class="line">                      (<span class="name">intersection-set</span> (<span class="name">cdr</span> set1)</div><div class="line">                                        (<span class="name">cdr</span> set2))))</div><div class="line">               ((<span class="name">&lt;</span> x1 x2)</div><div class="line">                (<span class="name">intersection-set</span> (<span class="name">cdr</span> set1) set2))</div><div class="line">               ((<span class="name">&lt;</span> x2 x1)</div><div class="line">                (<span class="name">intersection-set</span> set (<span class="name">cdr</span> set2)))))))</div></pre></td></tr></table></figure></p>
<h2 id="集合作为二叉树"><a href="#集合作为二叉树" class="headerlink" title="集合作为二叉树"></a>集合作为二叉树</h2><p>有序二叉树<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">entry</span> tree) (<span class="name">car</span> tree))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">left-branch</span> tree) (<span class="name">cadr</span> tree))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">right-branch</span> tree) (<span class="name">caddr</span> tree))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-tree</span> entry left right)</div><div class="line">  (<span class="name">list</span> entry left right))</div><div class="line">  </div><div class="line">(<span class="name">define</span> (<span class="name">element-of-set</span>? x set)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? set) false)</div><div class="line">        ((<span class="name">=</span> x (<span class="name">entry</span> set)) true)</div><div class="line">        ((<span class="name">&lt;</span> x (<span class="name">entry</span> set))</div><div class="line">         (<span class="name">element-of-set</span>? x (<span class="name">left-branch</span> set)))</div><div class="line">        ((<span class="name">&gt;</span> x (<span class="name">entry</span> set))</div><div class="line">         (<span class="name">element-of-set</span>? x (<span class="name">right-branch</span> set)))))</div><div class="line"><span class="comment">;插入要找到正确位置</span></div><div class="line">(<span class="name">define</span> (<span class="name">adjoin-set</span> x set)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? set) (<span class="name">make-tree</span> x '() '()))</div><div class="line">        ((<span class="name">=</span> x (<span class="name">entry</span> set)) set)</div><div class="line">        ((<span class="name">&lt;</span> x (<span class="name">entry</span> set))</div><div class="line">         (<span class="name">make-tree</span> (<span class="name">entry</span> set)</div><div class="line">                    (<span class="name">adjoin-set</span> x (<span class="name">left-branch</span> set))</div><div class="line">                    (<span class="name">right-branch</span> set)))</div><div class="line">        ((<span class="name">&gt;</span> x (<span class="name">entry</span> set))</div><div class="line">         (<span class="name">make-tree</span> (<span class="name">entry</span> set)</div><div class="line">                    (<span class="name">left-branch</span> set)</div><div class="line">                    (<span class="name">adjoin-set</span> x (<span class="name">right-branch</span> set))))))</div></pre></td></tr></table></figure></p>
<h1 id="huffman编码树"><a href="#huffman编码树" class="headerlink" title="huffman编码树"></a>huffman编码树</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;树的表示</span></div><div class="line"><span class="comment">;leaf 符号 权重</span></div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-leaf</span> symbol weight)</div><div class="line">  (<span class="name">list</span> 'leaf symbol weight))</div><div class="line">  </div><div class="line">(<span class="name">define</span> (<span class="name">leaf</span>? object)</div><div class="line">  (<span class="name">eq</span>? (<span class="name">car</span> object) 'leaf))</div><div class="line">  </div><div class="line">(<span class="name">define</span> (<span class="name">symbol-leaf</span> x) (<span class="name">cadr</span> x))</div><div class="line">(<span class="name">define</span> (<span class="name">weight-leaf</span> x) (<span class="name">caddr</span> x))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-code-tree</span> left right)</div><div class="line">  (<span class="name">list</span> left</div><div class="line">        right</div><div class="line">        (<span class="name">append</span> (<span class="name">symbols</span> left) (<span class="name">symbols</span> right))</div><div class="line">        (<span class="name">+</span> (<span class="name">weight</span> left) (<span class="name">weight</span> right))))</div><div class="line">        </div><div class="line">(<span class="name">define</span> (<span class="name">left-branch</span> tree) (<span class="name">car</span> tree))</div><div class="line">(<span class="name">define</span> (<span class="name">right-branch</span> tree) (<span class="name">cadr</span> tree))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">symbols</span> tree)</div><div class="line">  (<span class="name">if</span> (<span class="name">leaf</span>? tree)</div><div class="line">      (<span class="name">list</span> (<span class="name">symbol-leaf</span> tree))</div><div class="line">      (<span class="name">caddr</span> tree)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">weight</span> tree)</div><div class="line">  (<span class="name">if</span> (<span class="name">leaf</span>? tree)</div><div class="line">      (<span class="name">weight-leaf</span> tree)</div><div class="line">      (<span class="name">caddr</span> tree)))</div></pre></td></tr></table></figure>
<h2 id="解码过程"><a href="#解码过程" class="headerlink" title="解码过程"></a>解码过程</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">decode</span> bits tree)</div><div class="line">  (<span class="name">define</span> (<span class="name">decode-1</span> bits current-branch)</div><div class="line">    (<span class="name">if</span> (<span class="name">null</span>? bits)</div><div class="line">        '()</div><div class="line">        (<span class="name">let</span> ((<span class="name">next-branch</span></div><div class="line">               (<span class="name">choose-branch</span> (<span class="name">car</span> bits) current-branch)))</div><div class="line">          (<span class="name">if</span> (<span class="name">leaf</span>? next-branch)</div><div class="line">              (<span class="name">cons</span> (<span class="name">symbol-leaf</span> next-branch)</div><div class="line">                    (<span class="name">decode-1</span> (<span class="name">cdr</span> bits) tree))</div><div class="line">              (<span class="name">decode-1</span> (<span class="name">cdr</span> bits) next-branch)))))</div><div class="line">  (<span class="name">decode-1</span> bits tree))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">choose-branch</span> bit branch)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">=</span> bit <span class="number">0</span>) (<span class="name">left-branch</span> branch))</div><div class="line">        ((<span class="name">=</span> bit <span class="number">1</span>) (<span class="name">right-branch</span> branch))</div><div class="line">        (<span class="name">else</span> (<span class="name">error</span> <span class="string">"bad bit -- CHOOSE-BRANCH"</span> bit))))</div></pre></td></tr></table></figure>
<h2 id="带权重的集合"><a href="#带权重的集合" class="headerlink" title="带权重的集合"></a>带权重的集合</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">adjoin-set</span> x set)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? set) (<span class="name">list</span> x))</div><div class="line">        ((<span class="name">&lt;</span> (<span class="name">weight</span> x) (<span class="name">weight</span> (<span class="name">car</span> set))) (<span class="name">cons</span> x set))</div><div class="line">        (<span class="name">else</span> (<span class="name">cons</span> (<span class="name">car</span> set)</div><div class="line">                    (<span class="name">adjoin-set</span> x (<span class="name">cdr</span> set))))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">make-leaf-set</span> pairs)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? pairs)</div><div class="line">      '()</div><div class="line">      (<span class="name">let</span> ((<span class="name">pair</span> (<span class="name">car</span> pairs)))</div><div class="line">        (<span class="name">adjoin-set</span> (<span class="name">make-leaf</span> (<span class="name">car</span> pair)</div><div class="line">                               (<span class="name">cadr</span> pair))</div><div class="line">                    (<span class="name">make-leaf-set</span> (<span class="name">cdr</span> pairs))))))</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sicp </tag>
            
            <tag> 计算机程序的构造与解释 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第二章 构造数据抽象]]></title>
      <url>/2016/09/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>第一章关注的是计算过程，以及过程在程序中所扮演的角色。<br>本章，讲将数据对象组合起来，形成复合数据的方式。<br>复合数据：能够提升我们在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。<br>将程序中处理数据对象的表示的部分与处理数据对象的使用部分相互 隔离的技术，称为数据抽象。<br>复合数据中的一个关键性思想是闭包的概念，也就是说，用于组合数据对象的粘合剂不但能用于组合基本的数据对象，也能组合复合数据对象。<br>复合数据对象能够称为以混合与匹配的方式组合程序模块的方便接口。</p>
<h1 id="数据抽象引导"><a href="#数据抽象引导" class="headerlink" title="数据抽象引导"></a>数据抽象引导</h1><p>数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在抽象数据上操作一样。</p>
<h2 id="有理数的算数运算"><a href="#有理数的算数运算" class="headerlink" title="有理数的算数运算"></a>有理数的算数运算</h2><p>假定存在构造函数与选择函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">make-rat</span> n d)<span class="comment">;返回一个有理数，分子是整数n，分母是整数d</span></div><div class="line">(<span class="name">numer</span> x)<span class="comment">;返回有理数x的分子</span></div><div class="line">(denom x));返回有理数x的分母</div></pre></td></tr></table></figure></p>
<p>那么可以定义以下的规则<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;加法</span></div><div class="line">(<span class="name">define</span> (<span class="name">add-rat</span> x y)</div><div class="line">  (<span class="name">make-rat</span> (<span class="name">+</span> (<span class="name">*</span> (<span class="name">numer</span> x) (<span class="name">denom</span> y))</div><div class="line">               (<span class="name">*</span> (<span class="name">numer</span> y) (<span class="name">denom</span> x)))</div><div class="line">            (<span class="name">*</span> (<span class="name">denom</span> x) (<span class="name">denom</span> y))))</div><div class="line"><span class="comment">;减法</span></div><div class="line">(<span class="name">define</span> (<span class="name">sub-rat</span> x y)</div><div class="line">  (<span class="name">make-rat</span> (<span class="name">-</span> (<span class="name">*</span> (<span class="name">numer</span> x) (<span class="name">denom</span> y))</div><div class="line">               (<span class="name">*</span> (<span class="name">numer</span> y) (<span class="name">denom</span> x)))</div><div class="line">            (<span class="name">*</span> (<span class="name">denom</span> x) (<span class="name">denom</span> y))))</div><div class="line"><span class="comment">;乘法</span></div><div class="line">(<span class="name">define</span> (<span class="name">mul-rat</span> x y)</div><div class="line">  (<span class="name">make-rat</span> (<span class="name">*</span> (<span class="name">numer</span> x) (<span class="name">numer</span> y))</div><div class="line">            (<span class="name">*</span> (<span class="name">denom</span> x) (<span class="name">denom</span> y))))</div><div class="line"><span class="comment">;除法</span></div><div class="line">(<span class="name">define</span> (<span class="name">div-rat</span> x y)</div><div class="line">  (<span class="name">make-rat</span> (<span class="name">*</span> (<span class="name">numer</span> x) (<span class="name">denom</span> y))</div><div class="line">            (<span class="name">*</span> (<span class="name">denom</span> x) (<span class="name">numer</span> y))))</div><div class="line"><span class="comment">;等于？</span></div><div class="line">(<span class="name">define</span> (<span class="name">equal-rat</span>? x y)</div><div class="line">  (<span class="name">=</span> (<span class="name">*</span> (<span class="name">numer</span> x) (<span class="name">denom</span> y))</div><div class="line">     (<span class="name">*</span> (<span class="name">numer</span> y) (<span class="name">denom</span> x))))</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="序对"><a href="#序对" class="headerlink" title="序对"></a>序对</h3><p>lisp存在基本过程cons，car,cdr。存在下列关系<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> x (<span class="name">cons</span> <span class="number">1</span> <span class="number">2</span>))</div><div class="line"></div><div class="line">(<span class="name">car</span> x)</div><div class="line"><span class="number">1</span></div><div class="line"></div><div class="line">(<span class="name">cdr</span> x)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure></p>
<h3 id="有理数的表示"><a href="#有理数的表示" class="headerlink" title="有理数的表示"></a>有理数的表示</h3><p>利用序对完成有理数的实现<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-rat</span> n d)</div><div class="line">  (<span class="name">cons</span> n d))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">numer</span> x)</div><div class="line">  (<span class="name">car</span> x))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">denom</span> x)</div><div class="line">  (<span class="name">cdr</span> x))</div></pre></td></tr></table></figure></p>
<p>打印有理数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">print-rat</span> x)</div><div class="line">  (<span class="name">newline</span>)</div><div class="line">  (<span class="name">display</span> (<span class="name">numer</span> x))</div><div class="line">  (<span class="name">display</span> <span class="string">"/"</span>)</div><div class="line">  (<span class="name">display</span> (<span class="name">denom</span> x)))</div></pre></td></tr></table></figure></p>
<p>化简有理数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-rat</span> n d)</div><div class="line">  (<span class="name">let</span> ((<span class="name">g</span> (<span class="name">gcd</span> n d)))</div><div class="line">  (<span class="name">cons</span> (<span class="name">/</span> n g) (<span class="name">/</span> d g))))</div></pre></td></tr></table></figure></p>
<h2 id="抽象屏障"><a href="#抽象屏障" class="headerlink" title="抽象屏障"></a>抽象屏障</h2><p>每一个层次中国策构成了所定义的抽象 屏障的接口，联系起系统中的不同层次。使得系统简单，修改容易。</p>
<h2 id="数据意味着什么"><a href="#数据意味着什么" class="headerlink" title="数据意味着什么"></a>数据意味着什么</h2><p>一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及使这些过程成为一套合法的表示，它们必须满足一组特定的条件。<br>使用过程实现cons car cdr<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">cons</span> x y)</div><div class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">=</span> m <span class="number">0</span>) x)</div><div class="line">          ((<span class="name">=</span> n <span class="number">1</span>) y)</div><div class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Argument not 0 or 1 -- CONS"</span> m))))</div><div class="line">  dispatch)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">car</span> z) (<span class="name">z</span> <span class="number">0</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">cdr</span> z) (<span class="name">z</span> <span class="number">1</span>))</div></pre></td></tr></table></figure></p>
<p>尽管实际语言的实现不是上面的形式，但是我们定义的函数已经能够正常完成工作了。过程和数据的界限被模糊，满足关于序对的描述。</p>
<h1 id="层次性数据和闭包性质"><a href="#层次性数据和闭包性质" class="headerlink" title="层次性数据和闭包性质"></a>层次性数据和闭包性质</h1><p>某种组合数据对象的操作满足闭包性质，那就是说，通过它组合起数据对象得到的结果本身可以通过同样的操作再进行组合。闭包性质是任何一种组合功能的威力的关键要素，因为它使我们能够建立起层次性的结构，这种结构由一些部分构成，而其中的各个部分又是由它们的部分构成，并且可以继续下去。</p>
<h2 id="序列的表示"><a href="#序列的表示" class="headerlink" title="序列的表示"></a>序列的表示</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">list</span> &lt;a1&gt; &lt;a2&gt;...&lt;an&gt;)</div><div class="line"><span class="comment">;等于</span></div><div class="line">(<span class="name">cons</span> &lt;a1&gt; (<span class="name">cons</span> &lt;a2&gt; (<span class="name">cons</span> ... (<span class="name">cons</span> &lt;an&gt; <span class="literal">nil</span>)...)))</div></pre></td></tr></table></figure>
<p>nil是拉丁词汇nihil的缩写，拉丁语表示什么也没有，表示序对的链结束，代表一个不包含任何元素的序对，空表。</p>
<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;第n个元素</span></div><div class="line">(<span class="name">define</span> (<span class="name">list-ref</span> items n)</div><div class="line">  (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</div><div class="line">      (<span class="name">car</span> items)</div><div class="line">      (<span class="name">list-ref</span> (<span class="name">cdr</span> items) (<span class="name">-</span> n <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> squares (<span class="name">list</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>))</div><div class="line"></div><div class="line">(<span class="name">list-ref</span> squares <span class="number">3</span>)</div><div class="line"><span class="number">16</span></div><div class="line"></div><div class="line"><span class="comment">;表长 递归</span></div><div class="line">(<span class="name">define</span> (<span class="name">length</span> items)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? items)</div><div class="line">      <span class="number">0</span></div><div class="line">      (<span class="name">+</span> <span class="number">1</span> (<span class="name">length</span> (<span class="name">cdr</span> items)))))</div><div class="line">  </div><div class="line"><span class="comment">;表长 迭代</span></div><div class="line">(<span class="name">define</span> (<span class="name">length</span> items)</div><div class="line">  (<span class="name">define</span> (<span class="name">length-iter</span> a count)</div><div class="line">    (<span class="name">if</span> (<span class="name">null</span>? a)</div><div class="line">        count</div><div class="line">        (<span class="name">length-iter</span> (<span class="name">cdr</span> a) (<span class="name">+</span> <span class="number">1</span> count))))</div><div class="line">  (<span class="name">length-iter</span> items <span class="number">0</span>))</div><div class="line">  </div><div class="line">(<span class="name">length</span> squares)</div><div class="line"><span class="number">5</span></div><div class="line"></div><div class="line">(<span class="name">define</span> odds (<span class="name">list</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span>))</div><div class="line"></div><div class="line"><span class="comment">;组合两个表</span></div><div class="line">(<span class="name">define</span> (<span class="name">append</span> list1 list2)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? list1)</div><div class="line">      list2</div><div class="line">      (<span class="name">cons</span> (<span class="name">car</span> list1) (<span class="name">append</span> (<span class="name">cdr</span> list1) list2))))</div><div class="line"></div><div class="line">(<span class="name">append</span> odds squares)</div><div class="line">'(<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>)</div></pre></td></tr></table></figure>
<h3 id="对表的映射"><a href="#对表的映射" class="headerlink" title="对表的映射"></a>对表的映射</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;DrRacket中未定义nil，若要使用nil</span></div><div class="line">(<span class="name">define</span> <span class="literal">nil</span> '())</div><div class="line"></div><div class="line"><span class="comment">;缩放</span></div><div class="line">(<span class="name">define</span> (<span class="name">scale-list</span> items factor)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? items)</div><div class="line">      <span class="literal">nil</span></div><div class="line">      (<span class="name">cons</span> (<span class="name">*</span> (<span class="name">car</span> items) factor)</div><div class="line">            (<span class="name">scale-list</span> (<span class="name">cdr</span> items) factor))))</div><div class="line">            </div><div class="line">(<span class="name">scale-list</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>) <span class="number">10</span>)</div><div class="line">'(<span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span>)</div><div class="line"></div><div class="line"><span class="comment">;更一般的过程</span></div><div class="line">(<span class="name">define</span> (<span class="name">map</span> proc items)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? items)</div><div class="line">      <span class="literal">nil</span></div><div class="line">      (<span class="name">cons</span> (<span class="name">proc</span> (<span class="name">car</span> items))</div><div class="line">            (<span class="name">map</span> proc (<span class="name">cdr</span> items)))))</div><div class="line">            </div><div class="line">(<span class="name">define</span> (<span class="name">scale-list</span> items factor)</div><div class="line">  (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x factor))</div><div class="line">       items))</div></pre></td></tr></table></figure>
<p>map构建一层抽象屏障，将实现表变换的过程的实现，与如何提取表中元素以及组合结果的细节隔离开。</p>
<h2 id="层次性结构"><a href="#层次性结构" class="headerlink" title="层次性结构"></a>层次性结构</h2><p>树的分支，而那些本身也是序列的元素就形成了树中的子树。<br>实现count-leaver<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">count-leaves</span> x)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? x) <span class="number">0</span>)</div><div class="line">        ((<span class="name">not</span> (<span class="name">pair</span>? x)) <span class="number">1</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">+</span> (<span class="name">count-leaves</span> (<span class="name">car</span> x))</div><div class="line">                 (<span class="name">count-leaves</span> (<span class="name">cdr</span> x))))))</div></pre></td></tr></table></figure></p>
<h2 id="对树的映射"><a href="#对树的映射" class="headerlink" title="对树的映射"></a>对树的映射</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">sacle-tree</span> tree factor)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? tree) <span class="literal">nil</span>)</div><div class="line">        ((<span class="name">not</span> (<span class="name">pair</span>? tree)) (<span class="name">*</span> tree factor))</div><div class="line">        (<span class="name">else</span> (<span class="name">cons</span> (<span class="name">sacle-tree</span> (<span class="name">car</span> tree) factor)</div><div class="line">                    (<span class="name">sacle-tree</span> (<span class="name">cdr</span> tree) factor)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">scale-tree</span> tree factor)</div><div class="line">  (<span class="name">map</span>  (<span class="name">lambda</span> (<span class="name">sub-tree</span>)</div><div class="line">          (<span class="name">if</span> (<span class="name">pair</span>? sub-tree)</div><div class="line">              (<span class="name">scale-tree</span> sub-tree factor)</div><div class="line">              (<span class="name">*</span> sub-tree factor)))</div><div class="line">        tree))</div></pre></td></tr></table></figure>
<h2 id="序列作为一种约定的接口"><a href="#序列作为一种约定的接口" class="headerlink" title="序列作为一种约定的接口"></a>序列作为一种约定的接口</h2><p>强有力的设计原理-使用约定的接口。<br>考虑下面的过程，它以一棵树为参数，计算出那些值为奇数的叶子的平方和。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">sum-odd-squares</span> tree)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? tree) <span class="number">0</span>)</div><div class="line">        ((<span class="name">not</span> (<span class="name">pair</span>? tree))</div><div class="line">         (<span class="name">if</span> (<span class="name">odd</span>? tree) (<span class="name">square</span> tree) <span class="number">0</span>))</div><div class="line">        (<span class="name">else</span> (<span class="name">+</span> (<span class="name">sum-odd-squares</span> (<span class="name">car</span> tree))</div><div class="line">                 (<span class="name">sum-odd-squares</span> (<span class="name">cdr</span> tree))))))</div></pre></td></tr></table></figure></p>
<p>偶数的斐波那契数列的表。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">even-fibs</span> n)</div><div class="line">  (<span class="name">define</span> (<span class="name">next</span> k)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;</span> k n)</div><div class="line">        <span class="literal">nil</span></div><div class="line">        (<span class="name">let</span> ((<span class="name">f</span> (<span class="name">fib</span> k)))</div><div class="line">          (<span class="name">if</span> (<span class="name">even</span>? f)</div><div class="line">              (<span class="name">cons</span> f (<span class="name">next</span> (<span class="name">+</span> k l)))</div><div class="line">              (<span class="name">next</span> (<span class="name">+</span> k <span class="number">1</span>))))))</div><div class="line">  (<span class="name">next</span> <span class="number">0</span>))</div></pre></td></tr></table></figure></p>
<p>虽然表面上结构差异大，但是计算的抽象描述存在极大的相似性。<br>都是从枚举器开始，产生给定的树的树叶组成的信号。信号流过过滤器，过滤掉不符合规则的信号。通过一个映射，转换每一个元素。积累器把所有的元素组合起来。<br>但是上面的程序是将以上的操作混合在一起。</p>
<h3 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h3><p>修改map过程</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">map</span> square (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</div><div class="line">(<span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>)</div></pre></td></tr></table></figure>
<p>过滤器<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">filter</span> predicate sequence)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? sequence) <span class="literal">nil</span>)</div><div class="line">        ((<span class="name">predicate</span> (<span class="name">car</span> sequence))</div><div class="line">         (<span class="name">cond</span> (<span class="name">car</span> sequence)<span class="comment">;真就保留</span></div><div class="line">               (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence))))</div><div class="line">        (<span class="name">else</span> (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence)))))</div></pre></td></tr></table></figure></p>
<p>积累器<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">accumulate</span> op initial sequence)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? sequence)</div><div class="line">      initial</div><div class="line">      (<span class="name">op</span> (<span class="name">car</span> sequence)</div><div class="line">          (<span class="name">accumulate</span> op initial (<span class="name">cdr</span> sequence)))))</div></pre></td></tr></table></figure></p>
<p>fib枚举器<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">enumerate-interval</span> low high)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> low high)</div><div class="line">      <span class="literal">nil</span></div><div class="line">      (<span class="name">cons</span> low (<span class="name">enumerate-interval</span> (<span class="name">+</span> low <span class="number">1</span>) high))))</div></pre></td></tr></table></figure></p>
<p>树叶枚举器<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">enumerate-tree</span> tree)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? tree) <span class="literal">nil</span>)</div><div class="line">        ((<span class="name">not</span> (<span class="name">pair</span>? tree)) (<span class="name">list</span> tree))</div><div class="line">        (<span class="name">else</span> (<span class="name">append</span> (<span class="name">enumerate-tree</span> (<span class="name">car</span> tree))</div><div class="line">                      (<span class="name">enumerate-tree</span> (<span class="name">cdr</span> tree))))))</div></pre></td></tr></table></figure></p>
<p>重构<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">sum-odd-squares</span> tree)</div><div class="line">  (<span class="name">accumulate</span> +</div><div class="line">              <span class="number">0</span></div><div class="line">              (<span class="name">map</span> square</div><div class="line">                   (<span class="name">filter</span> odd?</div><div class="line">                           (<span class="name">enumerate-tree</span> tree)))))</div></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">even-fibs</span> n)</div><div class="line">  (<span class="name">accumulate</span> cons</div><div class="line">              <span class="literal">nil</span></div><div class="line">              (<span class="name">filter</span> even?</div><div class="line">                      (<span class="name">map</span> fib</div><div class="line">                           (<span class="name">enumerate-interval</span> <span class="number">0</span> n)))))</div></pre></td></tr></table></figure>
<p>通过提供一个标准不见的库，并使这些不见都有着一些能以灵活方式互相连接的约定接口，将能够进一步推动模块化设计。<br>在工程设计中，模块化结构是控制复杂性的一种威力巨大的策略。（类似西门子的自动化软件 plc等）</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sicp </tag>
            
            <tag> 计算机程序的构造与解释 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] sicp 第一章 构造过程抽象]]></title>
      <url>/2016/09/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sicp-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="关于读书的目的"><a href="#关于读书的目的" class="headerlink" title="关于读书的目的"></a>关于读书的目的</h1><p>很多时候对于一本比较复杂的书，你在到达一定阶段的时候是难以读进去的。Sicp我曾经在几个月前尝试的去读了第一章。很快就读完的，但是对于其的理解实在浅薄。<br>我希望在这一次的阅读的过程中能够顺利的过一次不本书有所收获。<br>在接下来的日子里，我会记录下读书笔记以及习题的解答。<br>这是一个开始。</p>
<h1 id="构造过程抽象"><a href="#构造过程抽象" class="headerlink" title="构造过程抽象"></a>构造过程抽象</h1><p>每一种强有力的语言为此提供了三种机制</p>
<ul>
<li>基本的表达形式， 用于表示语言所关心的最简单的个体。</li>
<li>组合的方法，通过它们可以从简单的东西出发构建出复合的元素。</li>
<li>抽象的方法，通过它们可以为 复合对象命名，并将它们作为单元去操作。</li>
</ul>
<p>在程序设计中，我们需要处理两类元素：过程和数据。非形式的说，数据是一种我们希望去操作的”东西“，而过程是有关操作这些数据的规则的描述。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">*</span> ( <span class="name">+</span> <span class="number">2</span> ( <span class="name">*</span> <span class="number">5</span> <span class="number">6</span> ))</div><div class="line">	( <span class="name">+</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">square</span> x) (<span class="name">*</span> x x))</div><div class="line"></div><div class="line">(<span class="name">square</span> <span class="number">21</span>)</div><div class="line"><span class="number">441</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="过程应用的带换模型"><a href="#过程应用的带换模型" class="headerlink" title="过程应用的带换模型"></a>过程应用的带换模型</h2><p>对于符合过程，过程的应用的计算过程是：</p>
<ul>
<li>将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程求值。</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">f</span> <span class="number">5</span>)</div><div class="line"></div><div class="line">(<span class="name">sum-of-squares</span>(<span class="name">+</span> <span class="number">5</span> <span class="number">1</span>) (<span class="name">*</span> <span class="number">5</span> <span class="number">2</span>))</div><div class="line"></div><div class="line">(<span class="name">+</span> (<span class="name">square</span> <span class="number">6</span>) (<span class="name">square</span> <span class="number">10</span>))</div><div class="line"></div><div class="line">(<span class="name">+</span> (<span class="name">*</span> <span class="number">6</span> <span class="number">6</span>) (<span class="name">*</span> <span class="number">10</span> <span class="number">10</span>))</div><div class="line"></div><div class="line">(<span class="name">+</span> <span class="number">36</span> <span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="number">136</span></div></pre></td></tr></table></figure>
<p>这种计算过程称为过程应用的代换模型。</p>
<h3 id="应用系和正则序"><a href="#应用系和正则序" class="headerlink" title="应用系和正则序"></a>应用系和正则序</h3><p>完全展开而后归约的求值模型是正则序求值。<br>先求值参数而后应用的方式为应用序求值。</p>
<h3 id="条件语法"><a href="#条件语法" class="headerlink" title="条件语法"></a>条件语法</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">abs</span> x)</div><div class="line">	(<span class="name">cond</span> ((<span class="name">&gt;</span> x <span class="number">0</span>) x)</div><div class="line">			  (( <span class="name">=</span> x <span class="number">0</span>) <span class="number">0</span>)</div><div class="line">			  (( <span class="name">&lt;</span> x <span class="number">0</span>) (<span class="name">-</span> x))))</div><div class="line"></div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">abs</span> x)</div><div class="line">	(<span class="name">cond</span> (( <span class="name">&lt;</span> x <span class="number">0</span>) (<span class="name">-</span> x))</div><div class="line">			  (<span class="name">else</span> x)))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">abs</span> x)</div><div class="line">	(<span class="name">if</span>	( <span class="name">&lt;</span> x <span class="number">0</span>) </div><div class="line">        (<span class="name">-</span> x)</div><div class="line">		x))</div></pre></td></tr></table></figure>
<h2 id="过程与它们所产生的计算"><a href="#过程与它们所产生的计算" class="headerlink" title="过程与它们所产生的计算"></a>过程与它们所产生的计算</h2><p>一个过程也就是一种模式，它描述了一个计算过程的局部演化方法。</p>
<p>两种描述阶乘的方式。（lisp的迭代不是说形式上的迭代，实际上如果说调用本身的层面上还是递归，但是思想是迭代的思想，应用序来看的话。）<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</div><div class="line">	(<span class="name">if</span>  (<span class="name">=</span> n <span class="number">1</span>)</div><div class="line">		 <span class="number">1</span></div><div class="line">		 (<span class="name">*</span> n (<span class="name">factorial</span> (<span class="name">-</span> n <span class="number">1</span>)))))</div><div class="line"></div><div class="line"><span class="comment">;迭代的形式</span></div><div class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</div><div class="line">	(<span class="name">fact-iter</span> <span class="number">1</span> <span class="number">1</span> n))</div><div class="line"></div><div class="line"><span class="comment">;应用序的话会优先求值，那么就不会有上面的方式那么深的层次，尝试求值都能够求出来。</span></div><div class="line">(<span class="name">define</span> (<span class="name">fact-iter</span> product counter max-count)</div><div class="line">	(<span class="name">if</span> (<span class="name">&gt;</span> counter max-count)</div><div class="line">		product</div><div class="line">		(<span class="name">fact-iter</span> (<span class="name">*</span> counter product)</div><div class="line">					   (<span class="name">+</span> counter <span class="number">1</span>)</div><div class="line">					   max-count)))</div></pre></td></tr></table></figure></p>
<p>迭代计算过程就是那种其状态可以用固定数据的状态变量描述的计算过程，而与此同时，又存在着一套固定的规则，描述了计算过程从一个状态到下一个状态的转换时候，这些变量的更新方式。还有一个结束检测，它描述着一计算过程应该终止的条件。<br>在计算n!时候，所需要的计算不走随着n线性增长，这种过程称为线性迭代过程。<br>在迭代的情况下，在计算过程中的任何一点，那几个程序变量都提供了有关计算状态的一个完整描述。而递归计算过程而言，这里存在着另外的一些隐含信息，它们并未保存在程序变量里面，而是由解释器维持着，指明了在所推迟的运算所形成的链条里的漫游中，这以计算过程处在合出。链条越长，需要保存的信息越多。</p>
<h3 id="换零钱的实现"><a href="#换零钱的实现" class="headerlink" title="换零钱的实现"></a>换零钱的实现</h3><p>采用递归过程：<br>将总数为a的现金换成n中硬币的不同方式的数目等于</p>
<ul>
<li>将现金数a换成除第一种硬币之外的所有其他硬币的不同方式数目，加上</li>
<li>将现金数a-d换成所有种类的硬币的不同数目，其中d是第一种硬币的币值<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">first-denomination</span> kinds-of-coins)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">=</span> kinds-of-coins <span class="number">1</span>) <span class="number">1</span>)</div><div class="line">        ((<span class="name">=</span> kinds-of-coins <span class="number">2</span>) <span class="number">5</span>)</div><div class="line">        ((<span class="name">=</span> kinds-of-coins <span class="number">3</span>) <span class="number">10</span>)</div><div class="line">        ((<span class="name">=</span> kinds-of-coins <span class="number">4</span>) <span class="number">25</span>)</div><div class="line">        ((<span class="name">=</span> kinds-of-coins <span class="number">5</span>) <span class="number">50</span>)))</div><div class="line">  </div><div class="line">(<span class="name">define</span> (<span class="name">cc</span> amount kinds-of-coins)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">=</span> amount <span class="number">0</span>) <span class="number">1</span>)</div><div class="line">        ((<span class="name">or</span> (<span class="name">&lt;</span> amount <span class="number">0</span>) (<span class="name">=</span> kinds-of-coins <span class="number">0</span>)) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">+</span> (<span class="name">cc</span> amount</div><div class="line">                     (<span class="name">-</span> kinds-of-coins <span class="number">1</span>))</div><div class="line">                 (<span class="name">cc</span> (<span class="name">-</span> amount</div><div class="line">                        (<span class="name">first-denomination</span> kinds-of-coins))</div><div class="line">                     kinds-of-coins)))))</div><div class="line">(<span class="name">define</span> (<span class="name">count-change</span> amount)</div><div class="line">  (<span class="name">cc</span> amount <span class="number">5</span>))</div><div class="line"></div><div class="line">(<span class="name">count-change</span> <span class="number">100</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="增长的阶"><a href="#增长的阶" class="headerlink" title="增长的阶"></a>增长的阶</h3><p>空间与时间的消耗。大O记号</p>
<p>一个例子求幂</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> n)</div><div class="line">  (<span class="name">*</span> n n))</div><div class="line">(<span class="name">define</span> (<span class="name">fast-expt</span> b n)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">=</span> n <span class="number">0</span>) <span class="number">1</span>)</div><div class="line">        ((<span class="name">even</span>? n) (<span class="name">square</span> (<span class="name">fast-expt</span> b (<span class="name">/</span> n <span class="number">2</span>))))</div><div class="line">        (<span class="name">else</span> (<span class="name">*</span> b (<span class="name">fast-expt</span> b (<span class="name">-</span> n <span class="number">1</span>))))))</div><div class="line">(<span class="name">fast-expt</span> <span class="number">2</span> <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">gcd</span> a b)</div><div class="line">    (<span class="name">if</span> ( <span class="name">=</span> b <span class="number">0</span>)</div><div class="line">        a</div><div class="line">        (<span class="name">gcd</span> b (<span class="name">remainder</span> a b))))</div></pre></td></tr></table></figure>
<h3 id="素数检测"><a href="#素数检测" class="headerlink" title="素数检测"></a>素数检测</h3><p>两种计算方法<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> n)</div><div class="line">  (<span class="name">*</span> n n))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">smallest-divisor</span> n)</div><div class="line">  (<span class="name">find-divisor</span> n <span class="number">2</span>))</div><div class="line">  </div><div class="line"><span class="comment">;寻找最小因子</span></div><div class="line">(<span class="name">define</span> (<span class="name">find-divisor</span> n test-divisor)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">&gt;</span> (<span class="name">square</span> test-divisor) n) n)<span class="comment">;根号n为检测上限</span></div><div class="line">        ((<span class="name">divides</span>? test-divisor n) test-divisor)</div><div class="line">        (<span class="name">else</span> (<span class="name">find-divisor</span> n (<span class="name">+</span> test-divisor <span class="number">1</span>)))))<span class="comment">;查找下一个</span></div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">divides</span>? a b)</div><div class="line">  (<span class="name">=</span> (<span class="name">remainder</span> b a) <span class="number">0</span>))</div><div class="line">  </div><div class="line"><span class="comment">;最小因子等于本身的时候为素数</span></div><div class="line">(<span class="name">define</span> (<span class="name">prime</span> n)</div><div class="line">  (<span class="name">=</span> n (<span class="name">smallest-divisor</span> n)))</div></pre></td></tr></table></figure></p>
<p>费马检测<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> n)</div><div class="line">  (<span class="name">*</span> n n))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">expmod</span> base exp m)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">=</span> exp <span class="number">0</span>) <span class="number">1</span>)</div><div class="line">        ((<span class="name">even</span>? exp)</div><div class="line">         (<span class="name">remainder</span> (<span class="name">square</span> (<span class="name">expmod</span> base (<span class="name">/</span> exp <span class="number">2</span>) m))</div><div class="line">                    m))</div><div class="line">        (<span class="name">else</span></div><div class="line">         (<span class="name">remainder</span> (<span class="name">*</span> base (<span class="name">expmod</span> base (<span class="name">-</span> exp <span class="number">1</span>) m))</div><div class="line">                    m))))</div><div class="line">(<span class="name">define</span> (<span class="name">try-it</span> a n)</div><div class="line">  (<span class="name">=</span> (<span class="name">expmod</span> a n n) a))</div><div class="line"></div><div class="line"><span class="comment">;使用随机数来测试</span></div><div class="line">(<span class="name">define</span> (<span class="name">fermat-test</span> n)</div><div class="line">  (<span class="name">try-it</span> (<span class="name">+</span> <span class="number">1</span> (<span class="name">random</span> (<span class="name">-</span> n <span class="number">1</span>))) n))</div><div class="line"></div><div class="line"><span class="comment">;通过多次的费马测试来概率的推断是不是位素数</span></div><div class="line">(<span class="name">define</span> (<span class="name">fast-prime</span>? n times)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">=</span> times <span class="number">0</span>) true)</div><div class="line">        ((<span class="name">fermat-test</span> n) (<span class="name">fast-prime</span>? n (<span class="name">-</span> times <span class="number">1</span>)))</div><div class="line">        (<span class="name">else</span> false)))</div></pre></td></tr></table></figure></p>
<h2 id="高阶函数抽象"><a href="#高阶函数抽象" class="headerlink" title="高阶函数抽象"></a>高阶函数抽象</h2><p>以过程作为参数。以过程作为返回值。这类操作过程的过程称为高阶过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#lang racket</div><div class="line">(<span class="name">define</span> (<span class="name">cube</span> n)</div><div class="line">  (<span class="name">*</span> n n n))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sum</span> term a next b)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> a b)</div><div class="line">      <span class="number">0</span></div><div class="line">      (<span class="name">+</span> (<span class="name">term</span> a)</div><div class="line">         (<span class="name">sum</span> term (<span class="name">next</span> a) next b))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">inc</span> n) (<span class="name">+</span> n <span class="number">1</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sum-cubes</span> a b)</div><div class="line">  (<span class="name">sum</span> cube a inc b))</div><div class="line"></div><div class="line">(<span class="name">sum-cubes</span> <span class="number">1</span> <span class="number">10</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">integral</span> f a b dx)</div><div class="line">  (<span class="name">define</span> (<span class="name">add-dx</span> x) (<span class="name">+</span> x dx))</div><div class="line">  (<span class="name">*</span> (<span class="name">sum</span> f (<span class="name">+</span> a (<span class="name">/</span> dx <span class="number">2.0</span>)) add-dx b)))</div><div class="line"></div><div class="line">(<span class="name">integral</span> cube <span class="number">0</span> <span class="number">1</span> <span class="number">0.01</span>)</div></pre></td></tr></table></figure>
<h3 id="用lambda构造过程"><a href="#用lambda构造过程" class="headerlink" title="用lambda构造过程"></a>用lambda构造过程</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">+</span> <span class="number">4</span> x)))</div></pre></td></tr></table></figure>
<p>匿名的过程，对于一些简单的过程构造适合</p>
<h3 id="用let创建局部变了"><a href="#用let创建局部变了" class="headerlink" title="用let创建局部变了"></a>用let创建局部变了</h3><p>一种方法是利用辅助过程去约束局部变量<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">f</span> x y)</div><div class="line">  (<span class="name">let</span> ((<span class="name">a</span> (<span class="name">+</span> <span class="number">1</span> x))</div><div class="line">        (<span class="name">b</span> (<span class="name">+</span> <span class="number">2</span> y)))</div><div class="line">  (<span class="name">+</span> a b)))</div><div class="line">(<span class="name">f</span> <span class="number">1</span> <span class="number">2</span>)</div></pre></td></tr></table></figure></p>
<h3 id="过程作为一般性的方法"><a href="#过程作为一般性的方法" class="headerlink" title="过程作为一般性的方法"></a>过程作为一般性的方法</h3><h4 id="通过区间折半寻找方程的根"><a href="#通过区间折半寻找方程的根" class="headerlink" title="通过区间折半寻找方程的根"></a>通过区间折半寻找方程的根</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span>(<span class="name">close-enough</span>? x y)</div><div class="line">  (<span class="name">&lt;</span> (<span class="name">abs</span> (<span class="name">-</span> x y)) <span class="number">0.001</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">average</span> x y)</div><div class="line">  (<span class="name">/</span> (<span class="name">+</span> x y) <span class="number">2</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">search</span> f neg-point pos-point)</div><div class="line">  (<span class="name">let</span> ((<span class="name">midpoint</span> (<span class="name">average</span> neg-point pos-point)))</div><div class="line">    (<span class="name">if</span> (<span class="name">close-enough</span>? neg-point pos-point)</div><div class="line">        midpoint</div><div class="line">        (<span class="name">let</span> ((<span class="name">test-value</span> (<span class="name">f</span> midpoint)))</div><div class="line">          (<span class="name">cond</span> ((<span class="name">positive</span>? test-value)</div><div class="line">                 (<span class="name">search</span> f neg-point midpoint))</div><div class="line">                ((<span class="name">negative</span>? test-value)</div><div class="line">                 (<span class="name">search</span> f midpoint pos-point))</div><div class="line">                (<span class="name">else</span> midpoint))))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">half-interval-method</span> f a b)</div><div class="line">  (<span class="name">let</span> ((<span class="name">a-value</span> (<span class="name">f</span> a))</div><div class="line">        (<span class="name">b-value</span> (<span class="name">f</span> b)))</div><div class="line">    (<span class="name">cond</span> ((<span class="name">and</span> (<span class="name">negative</span>? a-value) (<span class="name">positive</span>? b-value))</div><div class="line">           (<span class="name">search</span> f a ))</div><div class="line">          ((<span class="name">and</span> (<span class="name">negative</span>? b-value) (<span class="name">positive</span>? a-value))</div><div class="line">           (<span class="name">search</span> f b a))</div><div class="line">          (<span class="name">else</span></div><div class="line">           (<span class="name">error</span> <span class="string">"Values are not of opposite sign"</span> a b)))))</div><div class="line"></div><div class="line">(<span class="name">half-interval-method</span> sin <span class="number">2.0</span> <span class="number">4.0</span>)</div></pre></td></tr></table></figure>
<h3 id="寻找函数不动点"><a href="#寻找函数不动点" class="headerlink" title="寻找函数不动点"></a>寻找函数不动点</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> tolerance <span class="number">0.00001</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">average</span> x y)</div><div class="line">  (<span class="name">/</span> (<span class="name">+</span> x y) <span class="number">2</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">fixed-point</span> f first-guess)</div><div class="line">  (<span class="name">define</span> (<span class="name">close-enought</span>? v1 v2)</div><div class="line">    (<span class="name">&lt;</span> (<span class="name">abs</span> (<span class="name">-</span> v1 v2)) tolerance))</div><div class="line">  (<span class="name">define</span> (<span class="name">try</span> guess)</div><div class="line">    (<span class="name">let</span> ((<span class="name">next</span> (<span class="name">f</span> guess)))</div><div class="line">      (<span class="name">if</span> (<span class="name">close-enought</span>? guess next)</div><div class="line">          next</div><div class="line">          (<span class="name">try</span> next))))</div><div class="line">  (<span class="name">try</span> first-guess))</div><div class="line"></div><div class="line">(<span class="name">fixed-point</span> cos <span class="number">1.0</span>)</div><div class="line"><span class="comment">;不收敛</span></div><div class="line">(<span class="name">define</span> (<span class="name">sqrt</span> x)</div><div class="line">  (<span class="name">fixed-point</span> (<span class="name">lambda</span> (<span class="name">y</span>) (<span class="name">/</span> x y))</div><div class="line">               <span class="number">1.0</span>))</div><div class="line"><span class="comment">;引入阻尼</span></div><div class="line">(<span class="name">define</span> (<span class="name">sqrt</span> x)</div><div class="line">  (<span class="name">fixed-point</span> (<span class="name">lambda</span> (<span class="name">y</span>) (<span class="name">average</span> y (<span class="name">/</span> x y)))</div><div class="line">               <span class="number">1.0</span>))</div></pre></td></tr></table></figure>
<h3 id="过程作为返回值"><a href="#过程作为返回值" class="headerlink" title="过程作为返回值"></a>过程作为返回值</h3><p>新的开方方法<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">average-damp</span> f)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">average</span> x (<span class="name">f</span> x))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sqrt</span> x)</div><div class="line">  (<span class="name">fixed-point</span> (<span class="name">average-damp</span> (<span class="name">lambda</span>(<span class="name">y</span>) (<span class="name">/</span> x y)))))</div></pre></td></tr></table></figure></p>
<p>新的牛顿法</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">deriv</span> g)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">    (<span class="name">/</span> (<span class="name">-</span> (<span class="name">+</span> x dx) (<span class="name">g</span> x))</div><div class="line">       dx)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">newton-transform</span> g)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">    (<span class="name">-</span> x (<span class="name">/</span> (<span class="name">g</span> x) ((<span class="name">deriv</span> g) x)))))</div></pre></td></tr></table></figure>
<h1 id="抽象和第一级过程"><a href="#抽象和第一级过程" class="headerlink" title="抽象和第一级过程"></a>抽象和第一级过程</h1><p>复合过程是一种至关重要的抽象机制，因为它使得我们能将一般性的计算方法，用这一程序设计语言里的元素明确描述。现在我们又看到，高阶函数能如何去操作这一些一般性的方法，以便建立起进一步的抽象。<br>作为编程者，我们应该对这类可能性保持高度敏感，设法从中识别出程序里的基本抽象，基于它们去进一步构造，程序设计专家指导的如何根据工作中的情况，去选择合适的抽象层次。但是，能够基于这种抽象去思考确实是最重要的，只有这样才可能在新的上下文中去应用它们。高阶的过程的重要性，就在于使我们能够显式的用程序设计语言的要素去描述这些抽象，使我们能够像操作其他计算元素一样去操作它们。<br>一般而言，程序设计语言总会对计算元素的可能使用方式强加上某些显式。带有最少限制的元素被称为具有第一级状态。第一级元素的某些权利与特权包括:</p>
<ul>
<li>可以用变量命名</li>
<li>可以提供给过程作为参数</li>
<li>可以由过程作为结果返回</li>
<li>可以包含在数据结构中<br>lisp给了过程完全的第一级的状态。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sicp </tag>
            
            <tag> 计算机程序的构造与解释 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书摘录] 黑客与画家]]></title>
      <url>/2016/09/03/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95-%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/</url>
      <content type="html"><![CDATA[<p> 2016-08-31 08:09:42</p>
<p>为什么小孩子会这样做呢？</p>
<p>　　一部分原因是，青少年在心理上还没有摆脱儿童状态，许多人都会残忍地对待他人。他们折磨书呆子的原因就像拔掉一条蜘蛛腿一样，觉得很好玩。在一个人产生良知之前，折磨就是一种娱乐。</p>
<p>　　孩子们欺负书呆子的另一个原因是为了让自己感到好受一些。当你踩水的时候，你把水踩下去，你的身体就会被托起来。同样，在任何社会等级制度中，那些对自己没自信的人就会通过虐待他们眼中的下等人来突显自己的身份。我已经意识到，正是因为这个原因，在美国社会中底层白人是对待黑人最残酷的群体。</p>
<p> 2016-08-31 08:12:26</p>
<p>我认为，真实世界的关键并非在于它是由成年人组成的，而在于它的庞大规模使得你做的每件事都能产生真正意义上的效果。学校、监狱、上流社会的女士午餐会，都做不到这一点。这些场合的成员都好像关在封闭的泡沫之中，所作所为只对泡沫内部有影响，对外部没有影响。那么很自然地，这些场合就会产生野蛮的做法。因为它们不具备实际功能，所以也就无所谓采用的形式^。</p>
<p> 2016-08-31 08:13:16</p>
<p>真实世界的特点是，它极其庞大。如果总体足够大，即使是人数最少的少数派，只要聚集在一起，也能产生可观的力量。在真实世界中，书呆子在某些地方聚集起来，形成自己的社区，智力因素成为那里最被看重的东西。有时，这种因素甚至会以相反的形式表现出来，特别是在大学的数理学系，书呆子甚至会夸大笨拙，以显示自己的聪明。约翰·纳什^非常钦佩诺伯特·维纳^^就学维纳的样子，经过走廊的时候都用手扶着墙走路。</p>
<a id="more"></a>
<p> 2016-08-31 08:14:01</p>
<p>书呆子感到不适应的真正原因是其他人都是疯子。我记得读髙中的时候，有一次在体育馆观看校运动队的出征大会，啦啦队把对手的模拟像扔到看台上，观众一哄而起，把它撕成碎片。我感到自己仿佛是一个探险家，正在目睹某种奇特的部落仪式。</p>
<p> 2016-08-31 08:15:36</p>
<p>为什么人们要搬到郊区去住？为了养育下一代！难怪郊区生活是如此地乏味和贫瘠。整个镇子就像一个巨大的幼儿园，所有一切都是为了教育下一代而有意识地造出来的。</p>
<p>　　在我生长的这个地方，感觉整个世界就是这么大，你根本没有别的地方可去，没有别的事情可做。这一点都不令人意外。郊区就是故意这样设计的，与外部世界隔离，不让儿童沾染到外界有害的东西。</p>
<p>　　至于学校，不过是这个虚假环境中关住牲口的围栏。表面上，学校的使命是教育儿童。事实上，学校的真正目的是把儿童都关在同一个地方，以便大人们白天可以腾出手来把事情做完。我对这一点没有意见，在一个高度工业化的社会，对孩子不加管束，让他们四处乱跑，无疑是一场灾难。</p>
<p>　　让我困扰的，不是把孩子关在监狱里，而是（a）不告诉他们这一点，（b）把这监狱的大部分交给犯人来管理。孩子们被送进来，花6年时间，记住一些毫无意义的事实，还要身处在一个由四肢发达的小巨人管理的世界，那些巨人们只知道追逐一个椭圆形的、棕色的球^，好像这是全世界最天经地义的事情。这简直就像一场超现实的鸡尾酒化妆晚会，如果孩子畏缩不前、瑟瑟发抖，他们就会被视为怪人。</p>
<p> 2016-09-01 08:17:47</p>
<p>但是，流行的道德观念不是这样，它们往往不是偶然产生的，而是被刻意创造出来的。如果有些观点我们不能说出口，原因很可能是某些团体不允许我们说。</p>
<p>　　那些团体神经越紧张，它们所产生的禁止力量就越大。伽利略因为宣传日心说而遭到教廷的审判，这件事讽刺的地方在于，他只是在宣传哥白尼的观点，而后者却安然无恙。事实上，哥白尼不仅不反对教廷，还是一个虔诚的天主教教士，他把自己的著作献给教皇。不幸的是，伽利略正赶上教廷内部反对派上台，宗教改革被压制，任何非正统的思想遭受到前所未有的严厉控制和禁止。</p>
<p>　　为了在全社会制造出一个禁忌，负责实施的团体必定既不是特别强大也不是特别弱小。如果一个团体强大到无比自信，它根本不会在乎别人的抨击。美国人或者英国人对外国媒体的诋毁就毫不在意。但是，如果一个团体太弱小，就会无力推行禁忌。有一种行为怪癖叫做“嗜粪症”（coprophila），它的患者人数以及影响势力眼下似乎就不太强大，无法把自己的观点推广给其他人。</p>
<p>注: 穆斯林 女权</p>
<p> 2016-09-01 08:28:17</p>
<p>各种各样的标签可能是外部线索的最大来源，帮助你发现这个时代流行的是什么。如果一个命题是错的，这就是它所能得到的最坏评价，足够批判它了，根本不用再加上任何其他标签。伹是，如果一个命题不是错的，却被加上各种标签，进行压制和批判，那就有问题。因为只要不是错的观点，就不应该被压制讨论。所以每当你看到有些话被攻击为出自XX分子或XX主义，这就是一个明确的信号，表明背后有问题。不管在1630年还是在2030年，都是如此。当你听到有人在用这样的标签，就要问为什么。</p>
<p> 2016-09-01 19:31:06</p>
<p>《人月神话》（The Mythical Man-Month）是布鲁克斯（Frederick Brooks）所写的一本软件项目管理名著。所谓“人月”就是一个人在一个月内所能完成的工作量。假如某个项目预估需要12个人月，那么派4个人处理这个项目，理论上需要3个月，派6个人则只需要2个月。但是，布鲁克斯认为这种换算机制在软件业行不通，是一个神话，因为软件项目是交互关系复杂的工作，需要大量的沟通成本，人力的增加会使沟通成本急剧上升，反而无法达到缩短工期的目的。在本质上，软件项目的人力与工期是无法互换的，当项目进度落后时，光靠增加人力到该项目中，并不会加快进度，反而有可能使进度更加延后。</p>
<p> 2016-09-01 19:35:16</p>
<p>没有盗版是一种“优势”，但也是一个问题。一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。</p>
<p> 2016-09-01 19:42:05</p>
<p>你可能会问，如果Mac电脑真那么出色，为什么后来它的市场表现不佳？还是那个老生常谈的原因：成本太高。微软公司把所有精力都集中在软件上面，所以很多厂商只要专攻硬件就可以了，把硬件成本降了下来。单单是微软的软件或者第三方厂商的硬件都不足以赢得市场优势，但是它们结合起来，就在个人电脑出现后一段关键时期中主导了市场。苹果公司同时做软件和硬件，所以成本上没有优势。（但是，苹果公司还没有失败，如果它能把iPod升级成手机，并且将网络浏览器包括在其中，那么微软公司就有大麻烦了。）（译者注：这段话写于2001年9月，苹果公司的iPhone手机已于2007年6月上市。</p>
<p>2016-09-02 19:23:17</p>
<p>高级语言比汇编语言更接近人类语言，而某些高级语言又比其他语言更进一步。举例来说，C语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言，而Lisp语言的层次则是相当高。</p>
<p>　　如果高层级语言比汇编语言更有利于编程，你也许会认为语言的层次越高越好。一般情况下确实如此，但不是绝对的。编程语言可以变得很抽象，完全脱离硬件，但也有可能走错了方向。比如，我觉得Prolog语言就有这个问题。它的抽象能力强得不可思议，但是只能用来解决2%的问题，其余时间你苦思冥想、运用这些抽象能力写出来的程序实际上就是Pascal语言的程序。</p>
<p>　　另一个你会用到低层次语言的原因就是效率问题。如果你非常关注运行速度，那么最好使用接近机器的语言。大多数操作系统都是用C语言写的，这并非偶然。不过，硬件的运行速度越来越快了，所以使用C这样的低层次语言开发应用程序的必要性正在不断减少，但是大家似乎还是要求操作系统越快越好。（另一种可能是，人们还是希望“缓存区溢出攻击”继续存在下去，以便让大家时时保持警惕）^。</p>
<p> 2016-09-02 19:29:39</p>
<p>不仅编程语言有这种现象，这实际上是一种普遍的历史趋势。随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。30年前的人要是看到我们今天如此随意地使用长途电话，一定会感到震惊。100年前的人要是看到一个普通的包裹竟然也能享受一天内从波士顿发件、途经孟菲斯、抵达纽约的待遇，恐怕就要更震惊了。</p>
<p> 2016-09-03 08:03:35</p>
<p>Lisp比图灵机表达起来更简洁。证明这一点的一种方法就是写一个Lisp通用函数，证明它比图灵机的一般性描述更短、更易僅。这个Lisp函数就是eval……它用来计算Lisp表达式的值……。编写eval函数需要发明一种表示法，能够把Lisp函数表示成Lisp数据。设计这种书写法完全是为了满足论文写作的需要。（我）根本没有想过用它来编写Lisp程序并在计算机上运行。</p>
<p> 2016-09-03 08:07:56</p>
<p>Lisp语言诞生的时候就包含了9种新思想。其中一些我们今天已经习以为常，另一些则刚刚在其他高级语言中出现，至今还有2种是Lisp独有的。按照被大众接受的程度，这9种思想依次如下排列。</p>
<ol>
<li>条件结构（即if-then-else结构）。现在大家都觉得这是理所当然的，但是Fortran I就没有这个结构，它只有基于底层机器指令的goto结构。</li>
<li>函数也是一种数据类型。在Lisp语言中，函数与整数或字符串一样，也属于数据类型的一种。它有自己的字面表示形式（literal representation），能够存储在变量中，也能当作参数传递。一种数据类型应该有的功能，它都有。</li>
<li>递归。Lisp是第一种支持递归函数的高级语言^。<br>^「Lisp语言的许多特性（比如，把程序写成列表形式以及实现某种形式的递归）都在20世纪50年代的IPL-V语言中出现过。但是，IPL-V更像是汇编语言，它的程序中充满了操作码/地址对。参见Alien Newell等人编著的《IPL-V语言操作手册》（Information Processing Language-V Manual），Prentice-Hail，1961年出版。」</li>
<li>变量的动态类型。在Lisp语言中，所有变量实际上都是指针，所指向的值有类型之分，而变量本身没有。复制变量就相当于复制指针，而不是复制它们指向的数据。</li>
<li>垃圾回收机制。</li>
<li>程序由表达式组成。Lisp程序是一些表达式树的集合，每个表达式都返回一个值。这与Fortran和大多数后来的语言都截然不同，它们的程序由表达式和语句组成。<br>　　区分表达式和语句在Fortran I中是很自然的，因为它不支持语句嵌套。所以，如果你需要用数学式子计算一个值，那就只有用表达式返回这个值，没有其他语法结构可用，否则就无法处理这个值。<br>2016-09-03 08:08:15<br>后来，新的编程语言支持块结构，这种限制当然也就不存在了。但是为时已晚，表达式和语句的区分已经根深蒂固。它从Fortran扩散到Algol语言，接着又扩散到它们两者的后继语言。</li>
<li>符号类型。符号实际上是一种指针，指向存储在散列表中的字符串。所以，比较两个符号是否相等，只要看它们的指针是否一样就行了，不用逐个字符地比较。</li>
<li>代码使用符号和常量组成的树形表示法。</li>
<li>无论什么时候，整个语言都是可用的。Lisp并不真正区分读取期、编译期和运行期。你可以在读取期编译或运行代码，也可以在编译期读取或运行代码，还可以在运行期读取或者编译代码。<br>　　在读取期运行代码，使得用户可以重新调整（reprogram）Lisp的语法；在编译期运行代码，则是Lisp宏的工作基础；在运行期编译代码，使得Lisp可以在Emacs这样的程序中充当扩展语言（extension language）；在运行期读取代码，使得程序之间可以用S表达式（S-expression）通信，近来XML格式的出现使得这个概念被重新“发明”出来了^。<br>「如果你不想让经理发现你正在使用Lisp编程，你可以告诉他你用的是XML。」</li>
</ol>
<p> 2016-09-03 08:20:26</p>
<p>这种实践不仅很普遍，而且已经制度化了。举例来说，在面向对象编程的世界中，我们大量听到“模式”（pattern）这个词，我觉得那些“模式”就是现实中的因素（c），也就是人肉编译器^。当我在自己的程序中发现用到了模式，我觉得这就表明某个地方出错了。程序的形式应该仅仅反映它所要解决的问题。代码中其他任何外加的形式都是一个信号，（至少对我来说）表明我对问题的抽象还不够深，也经常提醒我，自己正在手工完成的事情，本应该写代码通过宏的扩展自动实现。</p>
<p>「皮特·诺维格发现，总共23种设计模式之中，有16种在Lisp语言中“本身就提供，或者被大大简化”。</p>
]]></content>
      
        <categories>
            
            <category> 摘录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] 深入探索C++对象模型 第六章 执行期语意学]]></title>
      <url>/2016/08/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/</url>
      <content type="html"><![CDATA[<h1 id="执行期语意学"><a href="#执行期语意学" class="headerlink" title="执行期语意学"></a>执行期语意学</h1><p>以下一个简单的式子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (yy == xx.getValue)</div></pre></td></tr></table></figure></p>
<p>xx  yy定义如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">X xx;</div><div class="line">Y yy;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Y();</div><div class="line"> ~Y();</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span>&amp; Y) <span class="keyword">const</span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  X();</div><div class="line">  ~X();</div><div class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Y</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="function">X <span class="title">getValue</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>那么编译器在我们之后做了什么呢<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(yy == xx.getValue())</div><div class="line"></div><div class="line"><span class="comment">//转换为</span></div><div class="line"><span class="keyword">if</span>(yy.<span class="keyword">operator</span>==(xx.getValue())</div><div class="line"></div><div class="line"><span class="comment">//接着转换</span></div><div class="line"><span class="keyword">if</span>(yy.<span class="keyword">operator</span>==(xx.getValue().<span class="keyword">operator</span> Y()))</div><div class="line"></div><div class="line"><span class="comment">//接着转换</span></div><div class="line">X temp1 = xx.getValue();</div><div class="line">Y temp2 = temp1.<span class="keyword">operator</span> Y();</div><div class="line"><span class="keyword">int</span> temp3 = (yy.<span class="keyword">operator</span>==(temp2));</div><div class="line"><span class="keyword">if</span>(temp3)</div><div class="line"></div><div class="line">temp2.y::~Y();</div><div class="line">temp1.x::~X();</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="对象的构造与析构"><a href="#对象的构造与析构" class="headerlink" title="对象的构造与析构"></a>对象的构造与析构</h2><h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> Point p;</div><div class="line"> <span class="comment">// p.Point::Point();</span></div><div class="line"> ...</div><div class="line"> <span class="comment">//p.Point::~Point();</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> 如果一个函数拥有多个离开点，那么会在每一个离开点之前对对象进行析构。</p>
<h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Matrix identity;</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">    Matrix ml = identity;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++ 保证一定会在main()中第一次用到identity之前把 didentity构造出来，在main()函数结束之前销毁。<br>C++程序中所有全局对象都被防止在程序的data segment中，如果明确指定给它一个值,object将以该值为初值。否咋object所配置到的内存内容为0。</p>
<blockquote>
<ul>
<li>class object在编译器可以被放置与data sement中并且为0,但是它的构造函数需要在程序激活的时候才会被实施。(也就是说全局对象的初始化的问题，对于类对象的有些门道。)</li>
</ul>
</blockquote>
<p><img src="/img/20160820 inside C++ 0.jpg" alt=""><br>￼<br>（还是不是很清楚全局对象是如何初始化的）</p>
<h3 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Matrix&amp;</div><div class="line">identity()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> Matrix mat_identity;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> mat_identity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于局部静态的变量，他们的构造和析构必须只施行一次。<br>编译器的策略是，导入一个临时性的对象以保护mat_identity的初始化操作。第一次处理identity()时候，这临时对象被评估为false，于是构造函数被调用，然后临时对象改为true。同理析构也是如此。<br>（但是具体现代编译器怎么操作的我还是不清楚。）。</p>
<h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point knots[<span class="number">10</span>];</div></pre></td></tr></table></figure>
<p>需要做什么。如果是一个没有构造函数的，也没有析构函数的。那么工作不会比建立一个内建类型所组成的数组更多。<br>如果有的话，那么整齐的操作必须施行与每一个元素上。<br>在cfront中，使用一个命名为vec_new()的函数，产生以class objects构造而成的数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* </div><div class="line">ver_new(</div><div class="line">    <span class="keyword">void</span> *<span class="built_in">array</span>,                            <span class="comment">//数组的起始位置</span></div><div class="line">    <span class="keyword">size_t</span> elem_size,                       <span class="comment">//一个对象的大小</span></div><div class="line">    <span class="keyword">int</span> elem_count,                         <span class="comment">//数组的元素个数</span></div><div class="line">    <span class="keyword">void</span> (*constructor)( <span class="keyword">void</span>*),</div><div class="line">    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*, <span class="keyword">char</span>)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>调用操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Point knots[<span class="number">10</span>];</div><div class="line">ver_new(&amp;knots, <span class="keyword">sizeof</span>(Point), <span class="number">10</span>, &amp;Point::Point, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>同样如果Point有一个析构函数会有一个类似ver_delete()的函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* </div><div class="line">ver_delete(</div><div class="line">    <span class="keyword">void</span> *<span class="built_in">array</span>,                            <span class="comment">//数组的起始位置</span></div><div class="line">    <span class="keyword">size_t</span> elem_size,                       <span class="comment">//一个对象的大小</span></div><div class="line">    <span class="keyword">int</span> elem_count,                         <span class="comment">//数组的元素个数</span></div><div class="line">    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*, <span class="keyword">char</span>)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>不同的编译器会有不同的实现。<br>如果数组部分被赋予了初值的，那么会产生什么转换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Point knots[<span class="number">10</span>] = &#123;</div><div class="line">    Point(),</div><div class="line">    Point(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>),</div><div class="line">    <span class="number">-1.0</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>对于有了初值的元素ver_new不必要，但是未被初始化的部分会调用vec_new。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Point knots[<span class="number">10</span>] = &#123;</div><div class="line">    Point(),</div><div class="line">    Point(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>),</div><div class="line">    <span class="number">-1.0</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//明确的初始化前三个</span></div><div class="line">Point::Point(&amp;knots[<span class="number">0</span>]);</div><div class="line">Point::Point(&amp;knots[<span class="number">1</span>], <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>);</div><div class="line">Point::Point(&amp;knots[<span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</div><div class="line">ver_new(&amp;knots + <span class="number">3</span>, <span class="keyword">sizeof</span>(Point), <span class="number">7</span>, &amp;Point::Point, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<h3 id="default-Constructors和数组"><a href="#default-Constructors和数组" class="headerlink" title="default Constructors和数组"></a>default Constructors和数组</h3><p>为了支持<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">complex</span>:: <span class="keyword">complex</span>(<span class="keyword">double</span> = <span class="number">0.0</span>, <span class="keyword">double</span> = <span class="number">0.0</span>);</div><div class="line">complext c_array[<span class="number">10</span>];</div><div class="line"><span class="comment">//编译器最终调用</span></div><div class="line">vec_new(&amp;c_array, <span class="keyword">sizeof</span>(<span class="keyword">complex</span>), <span class="number">10</span>, &amp;<span class="keyword">complex</span>::<span class="keyword">complex</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">//cfront采用如下方法支持</span></div><div class="line"><span class="comment">//产生一个默认构造函数 调用带默认参数的构造函数</span></div><div class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">complex</span>(<span class="number">0.0</span>,<span class="number">0.0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//来完成调用</span></div></pre></td></tr></table></figure></p>
<p>（有一个问题，那么这个不就是产生了两个不带参数的构造函数吗，虽然一个有参数，但是都用默认的。怎么解决的。不过大部分构造过程都是在编译期间，那么都是静态指定调用的话，还是解决掉了的。不是很清楚这个问题。）</p>
<h2 id="new-delete运算符"><a href="#new-delete运算符" class="headerlink" title="new delete运算符"></a>new delete运算符</h2><p>运算符new的使用，之前的几章一直都有。<br>会转换成两步，一步是使用适当的函数，分配内存。<br>后一步是给对象设置初值，类对象的话，调用的对应的构造函数等等<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="keyword">size_t</span> size )</span>   </span></div><div class="line"><span class="function"></span>&#123;   </div><div class="line">    <span class="keyword">if</span>( size == <span class="number">0</span> )   </div><div class="line">    size = <span class="number">1</span>; <span class="comment">// 这里保证像 new T[0] 这样得语句也是可行的   </span></div><div class="line">   </div><div class="line">    <span class="keyword">void</span> *last_alloc;   </div><div class="line">    <span class="keyword">while</span>( !(last_alloc = <span class="built_in">malloc</span>( size )) )   </div><div class="line">    &#123;   </div><div class="line">       <span class="keyword">if</span>( _new_handler )   </div><div class="line">           ( *_new_handler )(); <span class="comment">//调用handler函数  </span></div><div class="line">        <span class="keyword">else</span>   </div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;   </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">return</span> last_alloc;         </div><div class="line">&#125;   </div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">( <span class="keyword">void</span> *ptr )</span>   </span></div><div class="line"><span class="function"></span>&#123;   </div><div class="line">    <span class="keyword">if</span>(ptr) <span class="comment">// 从这里可以看出，删除一个空指针是安全的   </span></div><div class="line">    <span class="built_in">free</span>( (<span class="keyword">char</span>*)ptr );   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="针对数组的new语意"><a href="#针对数组的new语意" class="headerlink" title="针对数组的new语意"></a>针对数组的new语意</h3><p>内建的或者没有默认构造函数的，直接默认的new就能完成任务。<br>对于有默认构造函数的，某些版本的vec_new()就会被调用。</p>
<h2 id="临时性对象"><a href="#临时性对象" class="headerlink" title="临时性对象"></a>临时性对象</h2><p>很多简短的代码实际上都会产生一些临时对象。<br>是不是真的产生，需要看编译器的具体实现了。</p>
<h3 id="临时性对象的迷思"><a href="#临时性对象的迷思" class="headerlink" title="临时性对象的迷思"></a>临时性对象的迷思</h3>]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 理论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记]深入探索C++对象模型 第五章 构造 解构 拷贝语意学]]></title>
      <url>/2016/08/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0-%E8%A7%A3%E6%9E%84-%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/</url>
      <content type="html"><![CDATA[<h1 id="构造、解构、拷贝语意学"><a href="#构造、解构、拷贝语意学" class="headerlink" title="构造、解构、拷贝语意学"></a>构造、解构、拷贝语意学</h1><h3 id="纯虚函数的存在"><a href="#纯虚函数的存在" class="headerlink" title="纯虚函数的存在"></a>纯虚函数的存在</h3><p>纯虚函数能够被静态的调用，不能经过虚拟机制调用。<br>虚析构函数不能定义为纯虚的，一定要有定义，否则即使可以编译，但是链接的时候会有错误。因为其子类会静态调用上一层的析构函数。如果说上一层的析构函数是一个纯虚函数的话，那么链接的时候会失败。</p>
<h3 id="虚拟规格的存在"><a href="#虚拟规格的存在" class="headerlink" title="虚拟规格的存在"></a>虚拟规格的存在</h3><p>不应该把所有的函数都声明为虚函数，然后靠编译器去优化操作吧virtual invocation去除。</p>
<h3 id="虚拟规格中的const的存在"><a href="#虚拟规格中的const的存在" class="headerlink" title="虚拟规格中的const的存在"></a>虚拟规格中的const的存在</h3><p>实际上你很难知道一个类的子类对于这个函数是不是应该定义为const，因为即使现在你不需要修改类的内容，但子类可能需要修改，你没法预料到。那么最好不要定义一个有const函数的基类了。</p>
<h2 id="“无继承”情况下的对象构造"><a href="#“无继承”情况下的对象构造" class="headerlink" title="“无继承”情况下的对象构造"></a>“无继承”情况下的对象构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">float</span> x,y,z;</div><div class="line">&#125; Point;</div></pre></td></tr></table></figure>
<p>编译器会分析声明，贴上Plaint OI’ Data的卷标，被贴上该卷标的类，不会有构造函数或者析构函数的调用了。直接使用C的方式。<br><a id="more"></a></p>
<h2 id="继承体系下的对象构造"><a href="#继承体系下的对象构造" class="headerlink" title="继承体系下的对象构造"></a>继承体系下的对象构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T object;</div></pre></td></tr></table></figure>
<p>定义一个object如上时候，实际会发生什么。如果T有一个construct，它会被调用。<br>Constructor可能带有大量 隐藏码，因为编译器会扩充每一个constructor，扩充程度视class T的继承体系而定，一般而言编译器所做的扩充操作大约如下：</p>
<ol>
<li>记录在member initialization list中的data members初始化操作会被放进constructor函数本身，并以members的声明顺序为顺序。</li>
<li>如果有一个member没有出现在member initialization list中，但是它有一个default constructor, 那么该default construtor必须被调用。</li>
<li>在那之前，如果class object有virtual table pointer(s)，它们必须被设定初值。指向适合的virtual table(s)</li>
<li>在那之前，所有上一层的base class constructirs必须被调用，以base class的声明顺序为顺序<blockquote>
<ul>
<li>如果base class被列于初始化列表中，那么任何明确的指定参数都应该传递过去</li>
<li>如果base class 没有被列于初始化列表中，而它有默认构造函数，那么调用之</li>
<li>如果base class 是多重继承下的第二或者后继的base class那么this指针必须被调整</li>
</ul>
</blockquote>
</li>
<li>在那之前，所有的virtual base class constructor必须被调用，从左到右，从最深到最浅<blockquote>
<ul>
<li>如果class被列于初始化列表中，那么如果有任何明确指定的参数，都应该传递过去。若没有在list中，而class有默认构造函数，也应该调用</li>
<li>此外，class中的每一个virtual base class subobject的偏移量必须在执行期间可被存取</li>
<li>如果class object是最底层的class，其构造函数可能被调用。某些用以支持这个行为的机制被加入</li>
</ul>
</blockquote>
</li>
</ol>
<p>虚函数不见得一定有运行期绑定，如果能够编译期确定的，编译期乐于去进行静态的调用。</p>
<h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p><img src="/img/20160818 inside C++ 0.jpg" alt=""><br>￼<br>有如上图的继承结构。<br>Vertex的构造函数必须调用Point的构造函数。但是Vertex和P哦Point3d同为Vertex3d的 subobjects的时候，它们对Point的构造函数的调用操作一定不可以发生，取而代之的是，作为底层的class，Vertex3d有责任将Point初始化，而更往后的继承，则由PVertex,而不是Vertex3d来负责完成共享的Point subobject的构造.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Point3d*</div><div class="line">Point3d::Point3d(Point3d *<span class="keyword">this</span>, <span class="keyword">bool</span> __most__derived,</div><div class="line">                            <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(__most_derived != <span class="literal">false</span>)</div><div class="line">        <span class="keyword">this</span>-&gt;Point::Point(x,y);</div><div class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d = __vtbl_Pint3d;</div><div class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d__Point = __vtbl_Point3d__Point;</div><div class="line">    <span class="keyword">this</span>-&gt;_z = rhs._z;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Vertex3d*</div><div class="line">Vertex3d::Vertex3d( Vertex3d *<span class="keyword">this</span>, <span class="keyword">bool</span> __most_deriver,</div><div class="line">                                <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(__most_derived != <span class="literal">false</span>)</div><div class="line">        <span class="keyword">this</span>-&gt;Point::Point(x,y);</div><div class="line">    <span class="keyword">this</span>-&gt;Point3d::Point3d(<span class="literal">false</span>, x, y, z);</div><div class="line">    <span class="keyword">this</span>-&gt;Vertex::Vertex (<span class="literal">false</span>, x, y);</div><div class="line">    <span class="comment">//设定vptrs</span></div><div class="line">    <span class="comment">//安插USER CODE</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##vptr 初始化语意学<br>当我们定义一个PVertex object的时候，构造函数的调用顺序是</p>
<blockquote>
<ul>
<li>Point()</li>
<li>Point3d()</li>
<li>Vertex()</li>
<li>Vertex3d()</li>
<li>PVertex()</li>
</ul>
</blockquote>
<p> 构造函数调用成员函数会决议为静态的，不会使用多态机制。主要是考虑到构造函数中对象可能是不完整的，编译器需要找到合适的函数对象来调用，只能调用到此时能够起作用的函数。</p>
<ol>
<li>在派生类的构造函数中，所有的Virtual base classes以及上一层base class的constructors会被调用</li>
<li>上述完成之后，对象的vptr(s)被初始化，指向相关的虚表</li>
<li>如果有初始化列表的话，将在构造函数内扩展开来，这必须在vptr设定之后进行，以免一个virtual member function调用</li>
<li>最后执行程序员所提供的的代码</li>
</ol>
<p>构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PVertex::PVertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z) : _next(<span class="number">0</span>), Vertex3d(x, y, z), Point(x, y) &#123;</div><div class="line">    <span class="keyword">if</span> (spyOn)</div><div class="line">       <span class="built_in">cerr</span> &lt;&lt; <span class="string">"within Point3d::Point3d()"</span> &lt;&lt; <span class="string">" size: "</span> &lt;&lt; size() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>会被编译器扩展为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">PVertex* PVertex::PVertex( Pvertex* <span class="keyword">this</span>, <span class="keyword">bool</span> __most_derived, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z )  &#123;</div><div class="line">    <span class="comment">//有条件地调用virtual base class的ctor</span></div><div class="line">    <span class="keyword">if</span> ( __most_derived != <span class="literal">false</span> )</div><div class="line">       <span class="keyword">this</span>-&gt;Point::Point( x, y );</div><div class="line">    <span class="comment">//无条件地调用上一层的base class的ctor</span></div><div class="line">    <span class="keyword">this</span>-&gt;Vertex3d::Vertex3d( x, y, z );</div><div class="line">    <span class="comment">//初始化vptr</span></div><div class="line">    <span class="keyword">this</span>-&gt;__vptr__PVertex = __vtbl__PVertex;</div><div class="line">    <span class="keyword">this</span>-&gt;__vptr__Point__PVertex = __vtbl__Point__PVertex;</div><div class="line">    <span class="comment">//显式的用户代码</span></div><div class="line">    <span class="keyword">if</span> ( spyOn )</div><div class="line">        <span class="comment">// 虚拟机制调用size()函数</span></div><div class="line">       <span class="built_in">cerr</span> &lt;&lt; <span class="string">"within Point3d::Point3d()"</span>&lt;&lt; <span class="string">" size: "</span></div><div class="line">             &lt;&lt; (*<span class="keyword">this</span>-&gt;__vptr__PVertex[ <span class="number">3</span> ].faddr)(<span class="keyword">this</span>)</div><div class="line">             &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对象复制语意学"><a href="#对象复制语意学" class="headerlink" title="对象复制语意学"></a>对象复制语意学</h2><p>bitwise copy不够的情况和之前几章记录的一致。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> Point&amp; Point::<span class="keyword">operator</span>= (<span class="keyword">const</span> Point &amp;p)</div><div class="line">&#123;</div><div class="line">    _x = p._x;</div><div class="line">    _y = p._y;</div><div class="line">&#125;</div><div class="line"><span class="comment">//派生一个类</span></div><div class="line">classPoint3d : <span class="keyword">virtual</span> <span class="keyword">public</span> Point</div><div class="line"> &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">       Point3d( <span class="keyword">float</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span> );</div><div class="line">       ...</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">       <span class="keyword">float</span> _z;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//编译器会合成一个</span></div><div class="line"><span class="keyword">inline</span> Point3d&amp; Point3d::<span class="keyword">operator</span>=( Point3d *constthis, <span class="keyword">const</span> Point3d &amp;p ) &#123;</div><div class="line">   <span class="comment">//调用base class的operator=</span></div><div class="line">   <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=( p );</div><div class="line">   <span class="comment">// memberwise copy the derived class members</span></div><div class="line">   _z = p._z;</div><div class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是考虑到上面那个虚拟继承层次的结构的话。<br>怎么在虚拟继承中去处理复制这个问题。<br>事实上，copy assignment operator在虚拟继承的情况下行为不佳，需要小心的设计和说明，许多编译器甚至不尝试取得正取的语意，造成多次调用虚拟基类的copy assignment operator的多个实体被调用。（我的话，好像多次调用并不会产生大的问题，只是重复复制罢了，实际上没产生什么错误，效率貌似有下降。）</p>
<h2 id="析构语意学"><a href="#析构语意学" class="headerlink" title="析构语意学"></a>析构语意学</h2><p>如果class没有定义析构函数，那么只有在class内带的成员对象有析构函数的情况下，编译器才会自动合成析构函数，否则析构函数视为不需要的。即使它拥有一个虚函数等。<br>也就是构造函数和析构函数并不是一定要成对的出现，没必要定义了构造函数，就定义出析构函数。</p>
<p>析构函数的扩展</p>
<ol>
<li>析构函数的本身被执行，user code</li>
<li>如果class拥有成员类对象，而后者拥有析构函数，声明顺序的相反顺序调用其析构函数</li>
<li>如果对象有vptr需要重新被设定，指向合适的base class的vtbl</li>
<li>如果任何一个直接的nonvirtual base classes拥有析构函数，它们会以声明次序的相反顺序被调用</li>
<li>如果任何virtual base classes拥有析构 函数，而当前讨论的这个class是最尾端的class,那么会以其原来的构造函数相反的顺序被调用</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 理论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记]深入探索C++对象模型 第四章 Function语意学]]></title>
      <url>/2016/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-Function%E8%AF%AD%E6%84%8F%E5%AD%A6/</url>
      <content type="html"><![CDATA[<h1 id="第三章：Function语意学"><a href="#第三章：Function语意学" class="headerlink" title="第三章：Function语意学"></a>第三章：Function语意学</h1><h2 id="Member的各种调用方式"><a href="#Member的各种调用方式" class="headerlink" title="Member的各种调用方式"></a>Member的各种调用方式</h2><h3 id="Nonstatic-Member-Functions"><a href="#Nonstatic-Member-Functions" class="headerlink" title="Nonstatic Member Functions"></a>Nonstatic Member Functions</h3><p>C++的设计准则之一就是:nonstatic member function 至少必须和一般的nonmember function有相同的效率。<br>nonstatic member function会转换为nonmember形式。</p>
<ol>
<li>改写函数原型，安插一个额外的参数，也就是this指针。</li>
<li>将每一个对“nonstatic data member的存取操作”改为经由this指针来存取。</li>
<li>将member function重写成一个外部函数，对函数名称进行“mangling”处理，使它在程序中成为一个独一无二的词汇。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize__7Point3dFv</span><span class="params">(<span class="keyword">register</span> <span class="keyword">const</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>,</span></span></div><div class="line"><span class="function"><span class="params">                                                Point3d &amp;__result)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">register</span> <span class="keyword">float</span> mag = <span class="keyword">this</span>-&gt;magnitude();</div><div class="line">    __result.Point3d::Point3d();</div><div class="line">    </div><div class="line">    __result._x = <span class="keyword">this</span>-&gt;_x/mag;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="名称的特殊处理"><a href="#名称的特殊处理" class="headerlink" title="名称的特殊处理"></a>名称的特殊处理</h3><p>一般而言，member的名称前面会加上class名称，形成独一无二的命名。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> ival; ...&#125;;</div><div class="line"><span class="comment">//其中ival有可能变成这样</span></div><div class="line">ival__3Bar</div></pre></td></tr></table></figure></p>
<p>主要考虑是存在继承的问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//防止函数的重名</span></div><div class="line"><span class="comment">//加入类名</span></div><div class="line"><span class="comment">//加入参数链，使得支持重载</span></div><div class="line"><span class="comment">//cfront采用的编码方式</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x__5PointFf</span><span class="params">(<span class="keyword">float</span> newX)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x__5PointFv</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Virtual-Member-Functions"><a href="#Virtual-Member-Functions" class="headerlink" title="Virtual Member Functions"></a>Virtual Member Functions</h3><p>如果normalize()是virtual member function<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数会变成</span></div><div class="line">ptr-&gt; normalize()</div><div class="line">(*ptr-&gt;vptr[<span class="number">1</span>])(ptr); <span class="comment">//1为vtbl slot的索引值，关联到normalize</span></div></pre></td></tr></table></figure></p>
<h3 id="Static-Member-Function"><a href="#Static-Member-Function" class="headerlink" title="Static Member Function"></a>Static Member Function</h3><p>你可能会看到形如以下的调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((Point3d*)<span class="number">0</span>)-&gt;test();</div></pre></td></tr></table></figure></p>
<p>这种调用在test中没有对类对象的数据成员存储时候是不会出错的。<br>因为根据之前的转化形式看，没有是还用this指针进行操作。<br>这个式子的功能实际上就是实现static 成员函数的功能。在static member function成为c++的标准之前。<br>函数的转化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Point3d::object_cout()</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//转化为</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_cout__5Point3dSFv</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Virtual-Member-Functions-1"><a href="#Virtual-Member-Functions-1" class="headerlink" title="Virtual Member Functions"></a>Virtual Member Functions</h2><p>对于多态的class object身上增加两个members</p>
<ol>
<li>一个字符串或者数字，表示class的类型</li>
<li>一个指针，指向某表格，表格中带有程序的virtual functions的执行地址</li>
</ol>
<p>一个class只会有一个virtual table，每个table内含其对应的class object中所有active virtual functions函数实体地址。这些active virtual functions包括：</p>
<blockquote>
<ul>
<li>这个class所定义的函数实体。它会改写一个可能存在的Base class virtual function函数实体</li>
<li>继承自base class的函数实体。这是派生类不改写的部分</li>
<li>一个Pure_virtual_called()函数实体，它既扮演pure virtual function的空间保卫者角色，也可以作为执行期异常处理函数（有时候会用到）</li>
</ul>
</blockquote>
<p><img src="/img/20160815 inside C++ 1.jpg" alt=""><br>￼</p>
<h3 id="多重继承下的Virtual-Functions"><a href="#多重继承下的Virtual-Functions" class="headerlink" title="多重继承下的Virtual Functions"></a>多重继承下的Virtual Functions</h3><p>在多重继承中支持virtual functions，其复杂度围绕在第二个以及后继的base classes中，以及必须在执行期间调整的this指针这一点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A,B...</div><div class="line">A* pA = <span class="keyword">new</span> C;</div><div class="line"></div><div class="line">B* pB = <span class="keyword">new</span> C;</div><div class="line"><span class="comment">//</span></div><div class="line">C* pC = <span class="keyword">new</span> C;</div><div class="line">B* pB = pC;</div><div class="line"></div><div class="line"><span class="comment">//转化</span></div><div class="line">B* pB = pB ? pB + <span class="keyword">sizeof</span>(A) : <span class="number">0</span>;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">delete</span> pB;</div></pre></td></tr></table></figure></p>
<p>delete 操作会要求调用合适的虚析构函数，那么就要求指针再一次被调整。使得指针再次指向C对象的头。</p>
<p>thunk是小段assembly代码，来完成这个工作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pbase2_dtor_thunk:</div><div class="line">    <span class="keyword">this</span> += <span class="keyword">sizeof</span>(base1);</div><div class="line">    Derived::~Derived(<span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<h3 id="多重继承下的Virtual-Functions-1"><a href="#多重继承下的Virtual-Functions-1" class="headerlink" title="多重继承下的Virtual Functions"></a>多重继承下的Virtual Functions</h3><p>没讲明白</p>
<h2 id="函数的效能"><a href="#函数的效能" class="headerlink" title="函数的效能"></a>函数的效能</h2><h2 id="指向Member-Function的指针"><a href="#指向Member-Function的指针" class="headerlink" title="指向Member Function的指针"></a>指向Member Function的指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//指向成员函数的指针声明</span></div><div class="line"><span class="keyword">double</span> (Point :: *coord) () = &amp;Point :: x;</div><div class="line">coord = &amp;Point::y;</div><div class="line"></div><div class="line"><span class="comment">//要想要调用，需要</span></div><div class="line">(origin.*coord)();</div><div class="line">(ptr-&gt;*coord)();</div><div class="line"><span class="comment">//操作会自动被编译器转化</span></div><div class="line">(coord) (&amp;origin);</div><div class="line">(coord)(ptr);</div></pre></td></tr></table></figure>
<p>指向member function的指针的声明语法，以及指向member selection运算符的指针，其作用是作为this指针的空间保留者。这就是为什么static member functions的类型是函数指针，而不是指向member function指针的原因。<br>利用上述方式去获取一个虚函数的指针，一样能够支持多态。因为实际上获取的是一个索引值，指向虚表的内容。</p>
<h3 id="在多重继承下，指向member-funcitons的指针"><a href="#在多重继承下，指向member-funcitons的指针" class="headerlink" title="在多重继承下，指向member funcitons的指针"></a>在多重继承下，指向member funcitons的指针</h3><p>为了让指向member funcitons的指针能够支持多重继承和虚拟继承，Stroustrup设计了下面一个机构体</p>
<p>index faddr分别带有virtual table和nonvirtual member function地址（为了方便，index不指向virtual table时候会被设为-1）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">mpter</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> delta;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    <span class="keyword">union</span></div><div class="line">    &#123;</div><div class="line">        ptrtofunc faddr;</div><div class="line">        <span class="keyword">int</span>            v_offset;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//在该模型之下，像这样的操作</span></div><div class="line">(ptr-&gt;*pmf)();</div><div class="line"><span class="comment">//转变为</span></div><div class="line">(pmf.index &lt; <span class="number">0</span>)</div><div class="line">    ? (*pmf.faddr)(ptr)<span class="comment">// nonvirtual invocation</span></div><div class="line">    : (*ptr-&gt;vptr[pmf.index](ptr));<span class="comment">//virtual invocation</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 理论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] 深入探索C++对象模型 第三章 Data语意学]]></title>
      <url>/2016/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-Data%E8%AF%AD%E6%84%8F%E5%AD%A6/</url>
      <content type="html"><![CDATA[<h1 id="第三章：Data语意学"><a href="#第三章：Data语意学" class="headerlink" title="第三章：Data语意学"></a>第三章：Data语意学</h1><p>class的大小：<br>内存对齐<br>空Class需要1byte来占位，说明是独一无二的存在<br>有虚函数时候会有虚表指针<br>static 成员不属于类对象，不占空间</p>
<h2 id="Data-Member的绑定"><a href="#Data-Member的绑定" class="headerlink" title="Data Member的绑定"></a>Data Member的绑定</h2><p>早期的编译器可能看不到Class后面的内容，导致数据成员的用了外层的同名的。现在已经没有这种情况了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> length;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    length x;<span class="comment">//是long long</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> length;    </div><div class="line">    length y;<span class="comment">//是 int</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="Data-Member的布局"><a href="#Data-Member的布局" class="headerlink" title="Data Member的布局"></a>Data Member的布局</h2><p>Nonstatic data members在class object中的排列顺序是和声明顺序一致的。<br>但是没有规定多个access sections中的数据成员的排列，可以自由排列。实际上的编译器处理来看，还是按照顺序来的。这些顺序成员依靠声明次序在一个连续的区域里。<br>虚表也有强制的规定放在尾部还是头部等位置。</p>
<h2 id="Data-Member的存取"><a href="#Data-Member的存取" class="headerlink" title="Data Member的存取"></a>Data Member的存取</h2><p>下面的一段代码中的x的存取成本<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Point3d origin;</div><div class="line">origin.x = <span class="number">0.0</span>;</div></pre></td></tr></table></figure></p>
<p>需要视x和Point3d如何声明而定。</p>
<h2 id="Static-Data-Member的存取"><a href="#Static-Data-Member的存取" class="headerlink" title="Static Data Member的存取"></a>Static Data Member的存取</h2><p>Static Data Member实际上是一种全局变量，放在类对象之外。每一个Static Data Member对象的存取操作都会转化为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point3d::x == <span class="number">250</span>;<span class="comment">//不论是. 或者-&gt;来存取</span></div></pre></td></tr></table></figure></p>
<p>不论该class是单一的类还是继承有虚函数的类或者多重继承，Static Data Member的路径仍然是这么直接。</p>
<p>编译器会给每一个Static Data Member暗中编码指定独一无二的名字。</p>
<h2 id="NonStatic-Data-Member的存取"><a href="#NonStatic-Data-Member的存取" class="headerlink" title="NonStatic Data Member的存取"></a>NonStatic Data Member的存取</h2><p>NonStatic Data Member是存放在每一个类对象中的，除非经由明确的或者暗喻的类对象，否则么有办法直接存取它们。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Point3d::translate()</div><div class="line">&#123;</div><div class="line">    x = <span class="number">1</span>;</div><div class="line">    y = <span class="number">2</span>;</div><div class="line">    z = <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上都会转化为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Point3d::translate(Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">this</span>-&gt; x = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;y = <span class="number">2</span>;</div><div class="line">    <span class="keyword">this</span>-&gt;z = <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>欲对一个NonStatic Data Member访问必须在类对象的起始地址加上一个数据成员的偏移值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin._y = <span class="number">0.0</span>;</div><div class="line"><span class="comment">//origin._y的地址实际上等于</span></div><div class="line">&amp;origin + (&amp;Point3d::_y - <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>存取这种数据成员和一个struct的成员是一致的。除了虚拟继承，此种情况下会引入一层间接性。</p>
<h2 id="继承与Data-Member"><a href="#继承与Data-Member" class="headerlink" title="继承与Data Member"></a>继承与Data Member</h2><p>在C++中的继承模型中，一个derived class object所表现出来的东西，是其自己的members加上其base lass members的总和。</p>
<h3 id="只要继承不要多态"><a href="#只要继承不要多态" class="headerlink" title="只要继承不要多态"></a>只要继承不要多态</h3><p>base class的padding也会随之而来。这种设计是为了防止把派生类赋值给基类对象的时候导致基类对象的后面部位有数据而不是0（如果不保留padding的话，而是直接接上去）</p>
<p><img src="/img/20160814 inside C++ 0.jpg" alt=""></p>
<h3 id="加上多态"><a href="#加上多态" class="headerlink" title="加上多态"></a>加上多态</h3><p>加上多态的额外负担：</p>
<blockquote>
<ul>
<li>导入一个相关的virtual table,用来存放它所声明的每一个虚函数的地址。这个table元素的数目一般而言是被声明的虚函数的数目，再加上一个或者两个slots（用来支持runtime type idetification）。</li>
<li>在每一个类对象中导入一个vptr，提供执行器的连接，使每一个对象能够找到对应的vittual table。</li>
<li>加强构造函数</li>
<li>加强虚构函数</li>
</ul>
</blockquote>
<p>vptr的放置没有强制规定。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>多重继承实际上对于第一继承没什么影响，主要是对于第二或者后继的base class<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Vertex3d v3d;</div><div class="line">Vertex *pv;</div><div class="line">Point2d *p2d;</div><div class="line">Point3d *p3d;</div><div class="line"></div><div class="line">pv = &amp;v3d;</div><div class="line"><span class="comment">//需要这样的内部转化</span></div><div class="line">pv = (Vertex*)(((<span class="keyword">char</span>*)&amp;v3d + <span class="keyword">sizeof</span>(Point3d));</div><div class="line"><span class="comment">//下面的只要简单的拷贝地址就行</span></div><div class="line">p2d = &amp;v3d;</div><div class="line"></div><div class="line">pv = pv3d;</div><div class="line"><span class="comment">//要考虑pv3d位0的情况</span></div><div class="line">pv = pv3d</div><div class="line">        ? (Vertex*)(((<span class="keyword">char</span>*)&amp;v3d + <span class="keyword">sizeof</span>(Point3d</div><div class="line">        : <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>多重继承的存储模型，没有规定怎么存储，但是大部分编译器都是采用下面的方式存储的。</p>
<p><img src="/img/20160814 inside C++ 1.jpg" alt=""></p>
<h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>一般的实现方法：class如果含有一个或者多个virtual base class，分割为亮哥部分:一个是不变的局部，一个是共享的局部。不变的局部中的数据，不管后继如何衍化，总有固定的offset，所以这一部分数据可以被直接存取。至于共享局部，所表现的是virtual base class suboject.这一部分的数据，其位置会因为每次的派生操作而变化，所以它们只可以被间接存取。</p>
<p><img src="/img/20160814 inside C++ 2.jpg" alt=""></p>
<p>例子继承体系<br>微软的解决方案：引入所谓的virtual base class table.每一个类对象如果有一个或者多个virtual base classes就会由编译器安插一个指针，指向virtual base class table。至于真正的virtual base class指针，被安放在这个表格中。<br>第二种解决方案</p>
<p><img src="/img/20160814 inside C++ 3.jpg" alt=""></p>
<p>在virtula function table中放置 virtula base class的offset。<br>如同虚函数的指针，虚函数指针的在虚表中是正的offset，负的部分就给了虚基类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">this</span> +__vptr__Point3d[<span class="number">-3</span>]-&gt;_x += (&amp;rhs + +__vptr__Point3d[<span class="number">-3</span>]-&gt;_x)</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Point3d *p2d = pv3d;</div><div class="line"><span class="comment">//转换为</span></div><div class="line">Point3d *p2d = pv3d ? pv3d +__vptr__Point3d[<span class="number">-3</span>] : <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>一般而言，virtual base class 最有效的一种运行形势是：一个抽象的virtual base class，没有任何data members。</p>
<h2 id="对象成员的效率"><a href="#对象成员的效率" class="headerlink" title="对象成员的效率"></a>对象成员的效率</h2><h2 id="指向Data-Members的指针"><a href="#指向Data-Members的指针" class="headerlink" title="指向Data Members的指针"></a>指向Data Members的指针</h2><p>&amp; Point3d::z;的值为z在class object中的偏移量。</p>
<p>书上的代码试了在VS2015，并没有偏移量增加1的出现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (&amp;Point3d::x));<span class="comment">//4</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (&amp;Point3d::y));<span class="comment">//8</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (&amp;Point3d::z));<span class="comment">//c</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 理论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记]深入理解C++对象模型 第二章 构造函数的语意学]]></title>
      <url>/2016/08/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%84%8F%E5%AD%A6/</url>
      <content type="html"><![CDATA[<h1 id="第二章：构造函数语意学"><a href="#第二章：构造函数语意学" class="headerlink" title="第二章：构造函数语意学"></a>第二章：构造函数语意学</h1><p>由于C++的编译器在程序员之外做了太多事情，导致会产生很多意料之外的错误。<br>例子 Conversion运算符。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为了支持</span></div><div class="line"><span class="keyword">if</span>(<span class="built_in">cin</span>);</div><div class="line"><span class="comment">//定义了一个perator int()</span></div><div class="line"><span class="comment">//但是导致了以下错误的代码能够正常运行</span></div><div class="line"><span class="keyword">int</span> inVal;</div><div class="line"><span class="built_in">cin</span> &lt;&lt; inVal;</div><div class="line"><span class="comment">//此处&lt;&lt;被解释为左移操作符</span></div><div class="line"><span class="keyword">int</span> temp = <span class="built_in">cin</span>.<span class="keyword">operator</span> <span class="keyword">int</span>();</div><div class="line">temp &lt;&lt; intVal;</div></pre></td></tr></table></figure></p>
<h1 id="Default-Constructor的构建操作"><a href="#Default-Constructor的构建操作" class="headerlink" title="Default Constructor的构建操作"></a>Default Constructor的构建操作</h1><p>默认构造函数只在编译器认为需要的时候才创建。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Foo test;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>这种情况实际没有默认构造函数，编译器什么都没做。<br><a id="more"></a></p>
<h2 id="带有Default-Constructor的-Member-class-Object"><a href="#带有Default-Constructor的-Member-class-Object" class="headerlink" title="带有Default Constructor的 Member class Object"></a>带有Default Constructor的 Member class Object</h2><p>如果一个Class没有任何构造函数，但是包含一个member object，而后者又有default constructor，那么会在constructor真正被调用时合成出一个默认构造函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">classFoo &#123;<span class="keyword">public</span>: Foo(),Foo(<span class="keyword">int</span>);...&#125;;</div><div class="line">classBar &#123;<span class="keyword">public</span>: Foofoo; <span class="keyword">char</span> *str;&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</div><div class="line">   Bar bar; <span class="comment">//Bar::foo应在此处被初始化</span></div><div class="line">   <span class="keyword">if</span>(str)&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时的Bar合成默认构造函数会调用Foo的默认构造函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Bar::Bar()</div><div class="line">&#123; </div><div class="line">    foo.Foo::Foo(); <span class="comment">//合成出的</span></div><div class="line">    <span class="comment">//但是str等成员是不会管的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果已经写了一个默认构造函数，那么就会扩张该函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Bar::Bar()</div><div class="line">&#123; </div><div class="line">    foo.Foo::Foo(); <span class="comment">//扩展的</span></div><div class="line">    str=<span class="number">0</span>;<span class="comment">//程序员代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C++会以member objects在class中声明的次序来调用各个构造函数，由编译器完成。如果成员没有默认构造函数的话，就不会有扩张。</p>
<h2 id="带有Default-Constructor的-Base-Class"><a href="#带有Default-Constructor的-Base-Class" class="headerlink" title="带有Default Constructor的 Base Class"></a>带有Default Constructor的 Base Class</h2><p>一个没有任何构造函数的类派生子一个带有默认构造函数的基类，那么会合成出一个一个默认构造函数，调用上一层的默认构造函数（根据声明次序）。<br>如果是一个有多个构造函数的类，但是没有默认构造函数，则会扩张每一个构造函数，加入有必要的基类部分的默认构造。<br>但是不会合成默认构造函数，因为已经存在了程序员编写的构造函数。<br>如果也存在带有构造函数的成员，那么会在基类的部分构造之后，调用这些成员的构造函数。</p>
<h2 id="带有一个Virtual-Function的-Class"><a href="#带有一个Virtual-Function的-Class" class="headerlink" title="带有一个Virtual Function的 Class"></a>带有一个Virtual Function的 Class</h2><p>另有两种情况，也需要合成出default constructor</p>
<blockquote>
<ul>
<li>class声明（或者继承）一个virtual function</li>
<li>class派生自一个继承串链，其中有一个或者更多的virtual base classes</li>
</ul>
</blockquote>
<p>如果程序员没有声明自己的构造函数，编译器就会详细记录合成一个default constructor的必要信息。<br>编译器需要做以下的几个功能：</p>
<blockquote>
<ul>
<li>一个virtual function table会被编译器产生出来，内放class的virtual function地址。</li>
<li>在每一个class object中，一个额外的pointer member会被编译器合成，内含相关的classs vtbl的地址。</li>
</ul>
</blockquote>
<p>此外如果必要，虚函数表的部分会被重写，以改变为需要的情况。<br>为了支持这种功能，编译器必须为每个w对象设置它的vptr（这是成员变量，此时需要指向合适的vtbl），因此编译器需要在default ctor中安插一些代码来完成这种工作。</p>
<h2 id="带有一个Virtual-Base-Class-的Class"><a href="#带有一个Virtual-Base-Class-的Class" class="headerlink" title="带有一个Virtual Base Class 的Class"></a>带有一个Virtual Base Class 的Class</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">classX &#123; <span class="keyword">public</span>: inti; &#125;;</div><div class="line">classA : publicvirtualX   &#123; <span class="keyword">public</span>: intj; &#125;;</div><div class="line">classB : publicvirtualX   &#123; <span class="keyword">public</span>: doubled; &#125;;</div><div class="line">classC : publicA, publicB &#123; <span class="keyword">public</span>: intk; &#125;;</div><div class="line"><span class="comment">//无法在编译期间解析出 pa-&gt;i 的位置（给一个pa无法确定i的地址）。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( constA* pa )</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</div><div class="line">main() &#123;</div><div class="line">   foo( <span class="keyword">new</span> A );</div><div class="line">   foo( <span class="keyword">new</span> C );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//由于pa的真正类型不确定，所以某些编译器会记录一个指针例（如 __vbcX）来记录X，然后通过这个指针来定位pa指向的i。</span></div><div class="line"><span class="comment">//上述</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( constA* pa )</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</div><div class="line"><span class="comment">//变成了：</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( constA* pa )</span> </span>&#123; pa-&gt; __vbcX -&gt;i = <span class="number">1024</span>; &#125;</div></pre></td></tr></table></figure>
<p>其中<strong>vbcX标示编译器产生的指针，指向 virtual base class X。
</strong>vbcX需要在每一个构造函数按错那么“允许每一个 virtual base class的执行期间存取操作“的码。如果class没有声明任何构造函数，就需要合成一个默认构造函数。</p>
<h1 id="Copy-Constructor的构建操作"><a href="#Copy-Constructor的构建操作" class="headerlink" title="Copy Constructor的构建操作"></a>Copy Constructor的构建操作</h1><p>有三种情况会执行拷贝构造函数：</p>
<blockquote>
<ul>
<li>显式的使用 =</li>
<li>传参</li>
<li>返回</li>
</ul>
</blockquote>
<h2 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h2><p>一个class没有提供显式的拷贝构造函数的话，那么利用Memberwise Initialization(对每一个成员将源对象所有的member复制给目标对象)</p>
<h2 id="非逐位拷贝"><a href="#非逐位拷贝" class="headerlink" title="非逐位拷贝"></a>非逐位拷贝</h2><blockquote>
<ul>
<li>这个类的某个member object有拷贝构造函数。（不管成员的拷贝构造函数是合成的还是显式的定义的，都需要合成一个拷贝构造函数）。</li>
<li>这个类继承自某个有copy ctor的base class。（同上）。</li>
<li>这个类声明了若干个virtual function。（如果继承的基类有virtual function那么一定有拷贝构造函数，符合第二条。）</li>
<li>这个类派生自的继承链中有virtual base class。</li>
</ul>
</blockquote>
<p>第三四种情况需要合成的复制构造函数构建正确的虚表指针给每一个对象。<br>因为复制构造函数可以 派生类赋值给基类。那么派生类的虚表指针是没法用逐位拷贝来赋值，需要一个合成的复制构造函数正确的设定虚表指针。</p>
<h1 id="程序转化语意学"><a href="#程序转化语意学" class="headerlink" title="程序转化语意学"></a>程序转化语意学</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    X xx;</div><div class="line">    <span class="keyword">return</span> xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个人可能会做出以下假设：</p>
<blockquote>
<ul>
<li>每次foo()调用，就会传回xx的值.</li>
<li>如果class X定义了一个拷贝构造函数，那么每次调用foo()，保证该拷贝构造函数也会被调用。</li>
</ul>
</blockquote>
<p>均不一定。move语意和外面没有接收的可能导致以上假设不一定。</p>
<h2 id="明确的初始化操作"><a href="#明确的初始化操作" class="headerlink" title="明确的初始化操作"></a>明确的初始化操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">X x0;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;             <span class="comment">//定义了x1</span></div><div class="line">   X x2 = x0;           <span class="comment">//定义了x2</span></div><div class="line">   X x3 = X(x0);       <span class="comment">//定义了x3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//转化的两个动作<br>//即变成了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</div><div class="line">   X x1;    <span class="comment">//定义被重写，初始化操作被剥除</span></div><div class="line">   X x2;    <span class="comment">//定义被重写，初始化操作被剥除</span></div><div class="line">   X x3;    <span class="comment">//定义被重写，初始化操作被剥除</span></div><div class="line"></div><div class="line">   <span class="comment">//编译器安插X copy ctor。</span></div><div class="line">   x1.X::X( x0 );</div><div class="line">   x2.X::X( x0 );</div><div class="line">   x3.X::X( x0 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中:<br>x1.X::X( x0 );<br>会表现为对拷贝构造函数的调用：<br> X::X( constX&amp; xx);）</p>
<h2 id="参数的初始化"><a href="#参数的初始化" class="headerlink" title="参数的初始化"></a>参数的初始化</h2><p> 如下代码的变化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x0)</span></span>;</div><div class="line"><span class="comment">//...</span></div><div class="line">X xx;</div><div class="line">foo(xx)</div></pre></td></tr></table></figure></p>
<p>这种方式把函数的参数变成了引用，然后将拷贝构造函数构造的参数传入。<br>变成了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X&amp; x0)</span></span>;</div><div class="line"><span class="comment">//...</span></div><div class="line">X __tmp;</div><div class="line">__tmp.X::X( XX );</div><div class="line">foo(__tmp);</div></pre></td></tr></table></figure></p>
<p>其中X声明了destructor，它在foo调用完成后销毁暂时性的对象。</p>
<h2 id="返回初始值"><a href="#返回初始值" class="headerlink" title="返回初始值"></a>返回初始值</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="function">X <span class="title">bar</span><span class="params">()</span></span>&#123;</div><div class="line">   X xx;</div><div class="line">   <span class="comment">//...</span></div><div class="line">   <span class="keyword">return</span> xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先添加一个额外的引用参数，然后在返回之前调用一个复制构造函数构造这个返回对象。<br>于是变成了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X&amp; _result)</span></span>&#123;</div><div class="line">   X xx;</div><div class="line">   <span class="comment">//...</span></div><div class="line">   _result.X::X(xx);</div><div class="line">   <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">X xx = bar();</div><div class="line"><span class="comment">//转换为</span></div><div class="line">X xx;</div><div class="line">bar(xx);</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bar().memfunc();</div><div class="line"><span class="comment">//可能转换为</span></div><div class="line">X _temp0;</div><div class="line">(bar(_temp0), _temp0).memfunc();</div></pre></td></tr></table></figure>
<h2 id="在使用者层面的优化"><a href="#在使用者层面的优化" class="headerlink" title="在使用者层面的优化"></a>在使用者层面的优化</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">X <span class="title">bar</span><span class="params">(<span class="keyword">const</span> T &amp;y,  <span class="keyword">const</span> T &amp;z)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    X xx;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而是定义一个新的构造函数，这样在转换之后效率更高<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">X <span class="title">bar</span><span class="params">(<span class="keyword">const</span> T &amp;y,  <span class="keyword">const</span> T &amp;z)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> X(y , z);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 转换后<br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result, <span class="keyword">const</span> T &amp;y,  <span class="keyword">const</span> T &amp;z)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    _result X::X(y, z);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="在编译器层面优化"><a href="#在编译器层面优化" class="headerlink" title="在编译器层面优化"></a>在编译器层面优化</h2><p>  就是上面那个转换代码</p>
<p>  理论上合成的拷贝构造函数就能够正常的工作了。某些情况不会有合成的拷贝构造函数，而是直接逐位拷贝。这样的情况下，就没法实施，上面的编译器层面的优化。<br>那么我们应该预见这个类是不是有很多传值的操作，比如上面的函数的参数，返回值。如果有，那么提供一个，编译器才能够实施优化。</p>
<p>  <strong>成员们的初始化队伍</strong><br>构造函数初始化列表</p>
<blockquote>
<ul>
<li>初始化一个引用成员（不这样做出错）</li>
<li>初始化一个const成员（不这样做出错）</li>
<li>调用一个base class的构造函数，而它拥有一组参数时（不这样做出错）</li>
<li>调用一个member class的构造函数，而它拥有一组参数时（比赋值更有效率）</li>
</ul>
</blockquote>
<p>编译器会一一操作初始化列表，以适当次序（成员的声明次序）在构造函数之内安插初始化操作，并且在任何显式写的代码之前完成操作。<br>初始化列表能够使用成员函数来初始化一个成员。（这里如果比较复杂的初始化能够使用这种方式提高初始化的效率，但是要注意该函数使用的变量是不是在调用前都被初始化了。合法的原因是此时this指针已经创建好了。）</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 理论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记]深入探索C++ 对象模型 第一章 关于对象]]></title>
      <url>/2016/08/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="阅读的目的"><a href="#阅读的目的" class="headerlink" title="阅读的目的"></a>阅读的目的</h1><p>在阅读《C++ primer》的时候，书里面写了各种各样的情况下，C++的处理方式。囫囵吞枣的记下后，也就不求甚解了。而C++在工作中的使用已经有了那么一段时间。但是对于C++的很多现象，却依旧是只知道是这样，却不知道为什么是这样。<br>那么阅读这本同样是 Lippman的书籍，就是为了解惑，为什么C++会导致我们看到的现象，而不是其他情况。<br>我希望，通过这么本书，能够解答我的一部分疑问。</p>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>工作里常听到的对于C++的抱怨是C++的编译器为程序员做了太多的服务，导致很多情况不受控制。不像C,大部分都需要手动去执行，可以明确的知道，什么时候做了什么。<br>我想这部分抱怨一方面来源于对于C++的不熟悉，一方面又来源于C++的特性。那么当对C++怎么实现各种特性了解后，对于编译器的行为有了概念后，我相信我应该能够解答很多疑问了。<br>就像Lippman在本书贴出的一封信件一般<br><img src="/img/20160807 inside C++ 0.jpg" alt=""></p>
<p>他希望这本书是这些问题的解答。<br><a id="more"></a></p>
<h1 id="第一章：关于对象"><a href="#第一章：关于对象" class="headerlink" title="第一章：关于对象"></a>第一章：关于对象</h1><p>本章主要是对于对象模型的一个大概浏览，但是对多重继承和虚拟继承等情况没有太多的观察<br>C语言，数据和处理数据操作是分开声明的，语言本身没有支持数据和函数的关联性。由一组分布在各个以功能为导向的函数中的算法所驱动，它们的处理的是共同的外部数据。<br>C++的实现使用的是ADT<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">classPoint &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Point(<span class="keyword">float</span> x);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">float</span> _x;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这种形式将数据和函数相关联，数据封装。<br>那么这样的数据封装有成本吗？没有<br>所有的Class只会生成出一个函数实体。data members则是直接包含在class object中与C的struct一致。<br>C++的布局和存储时间的额外负担是由virtual引起的：</p>
<blockquote>
<ul>
<li>virtual function机制 用来支持一个有效率的“执行期绑定”。 </li>
<li>virtual base class 用来实现“多次出现在继承体系中的base class,有一个单一而被共享的实体”。</li>
</ul>
</blockquote>
<p>此外，还有一些多重继承下的额外负担。</p>
<h1 id="C-的对象模型"><a href="#C-的对象模型" class="headerlink" title="C++的对象模型"></a>C++的对象模型</h1><p>C++中存在两种数据成员 static、nostatic，三种成员函数 static、nostatic、virtual。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">classPoint &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Point(<span class="keyword">float</span> xval);</div><div class="line">    <span class="keyword">virtual</span> ~Point();</div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function">staticint <span class="title">PointCount</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> ostream&amp;</div><div class="line">    print(ostream &amp;os) <span class="keyword">const</span>;</div><div class="line">    float_x;</div><div class="line">    staticint_point_count;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/img/20160807 inside C++ 1.jpg" alt=""></p>
<p>上图为C++的对象模型：</p>
<blockquote>
<ul>
<li>nostatic data members 被配置在每一个class object之内。</li>
<li>static data members 被存放在所有的class object之外。</li>
<li>staitic 和 nostatic function members存放在class object之外。</li>
<li>virtual functions以两个步骤支持：</li>
<li>①每一个class产生出一堆指向virtual functions 的指针，放在表格之中。也就是虚表。</li>
<li>②每一个class object被添加了一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设和重置由每一个classd constructor destructor 和 copy assignmemt运算符自动完成。每一个class所关联的type_info object用意支持runtiome tyoe identification，rtti也经由virtual table被指出来，通常是放在第一个slot处。</li>
</ul>
</blockquote>
<h2 id="加上继承"><a href="#加上继承" class="headerlink" title="加上继承"></a>加上继承</h2><p>c++支持单一继承、多重继承、虚拟继承。<br><img src="/img/20160807 inside C++ 2.jpg" alt=""></p>
<p>具体的讨论需要3.4中见到。</p>
<h2 id="对象模型如何影响程序"><a href="#对象模型如何影响程序" class="headerlink" title="对象模型如何影响程序"></a>对象模型如何影响程序</h2><p>class X定义了一个拷贝构造函数，一个虚析构函数，一个虚函数foo();<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">X <span class="title">foobar</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    X xx;</div><div class="line">    X *px = <span class="keyword">new</span> X;</div><div class="line">    xx.foo();</div><div class="line">    px-&gt;foo();</div><div class="line">    <span class="keyword">delete</span> px;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数可能在内部转换为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//可能的内部转换结果</span></div><div class="line"><span class="comment">//虚拟C++码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(X&amp; _result)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//使用引用返回，属于编译器的优化了。</span></div><div class="line">    <span class="comment">//构造</span></div><div class="line">    _result.X::X();</div><div class="line"></div><div class="line">    <span class="comment">//申请内存</span></div><div class="line">    px = _new(<span class="keyword">sizeof</span>(X));</div><div class="line">    <span class="comment">//调用构造函数</span></div><div class="line">    <span class="keyword">if</span>( px != <span class="number">0</span>)</div><div class="line">        px-&gt;X::X();</div><div class="line"></div><div class="line">    <span class="comment">//成员函数的形式的转换，成员函数就是普通函数不过有一个this指针</span></div><div class="line">    foo(&amp;_result);</div><div class="line"></div><div class="line">    <span class="comment">//虚函数的基本调用方式，通过vptr来调用</span></div><div class="line">    (*px-&gt;vtbl[<span class="number">2</span>])(px);</div><div class="line"></div><div class="line">    <span class="comment">//调用虚析构函数</span></div><div class="line">    <span class="keyword">if</span>( px != <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        (*px-&gt;vtbl[<span class="number">1</span>])(px);</div><div class="line">        _delete(px);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//不需要使用named return statement</span></div><div class="line">    <span class="comment">//不需要摧毁Local object xx</span></div><div class="line">    <span class="comment">//而是使用了传入参数_result</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="关键词所带来的差异"><a href="#关键词所带来的差异" class="headerlink" title="关键词所带来的差异"></a>关键词所带来的差异</h1><h2 id="策略性正确的struct"><a href="#策略性正确的struct" class="headerlink" title="策略性正确的struct"></a>策略性正确的struct</h2><p>把单一元素的数组放在一个struct的尾端，于是每个 struct objects 可以拥有可变大小的数组：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span> &#123;</span></div><div class="line">    <span class="keyword">char</span> pc[<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//获取一个字符串，然后为struct本身和该字符串配置足够的内存</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span> *<span class="title">pmumbl</span> = (<span class="title">struct</span> <span class="title">mumble</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span></span></div><div class="line"><span class="class"><span class="title">mumble</span>) + <span class="title">strlen</span>(<span class="title">string</span>) + 1);</span></div><div class="line"><span class="built_in">strcpy</span>(pmumbl-&gt;pc, <span class="built_in">string</span>);</div></pre></td></tr></table></figure></p>
<p>这在C++中是很有问题的。不一定在pc后面就没有存放数据。</p>
<h1 id="对象的差异"><a href="#对象的差异" class="headerlink" title="对象的差异"></a>对象的差异</h1><p>C++支持多种程序设计典范：程序模型、抽象数据类型模型、面向对象模型</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 理论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记] 《如何阅读一本书》]]></title>
      <url>/2016/08/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B/</url>
      <content type="html"><![CDATA[<h1 id="阅读的活力与艺术"><a href="#阅读的活力与艺术" class="headerlink" title="阅读的活力与艺术"></a>阅读的活力与艺术</h1><p>阅读存在很多个层次：娱乐、获取资讯、加深理解力。<br>本书更多的是为了读者能够加深理解力而写的书籍，教导人们如何通过各种手段，来阅读一本值得阅读的书籍。<br>阅读是一种主动的学习方式。而教师的教导等方式更多的是被动的接受。阅读作为主动的学习方式。这里的主动是你主动去获取知识，比如编程的书籍，看了不代表主动，需要更多的实践，这就是主动。不断的去实践、检测书籍中的内容，这样才能够对于艰深的书籍有更多的理解。</p>
<p>作者的观点里存在四个阅读的层次：(这里的层次更多的是阅读方法上的分类)</p>
<h1 id="基础阅读"><a href="#基础阅读" class="headerlink" title="基础阅读"></a>基础阅读</h1><p>基础阅读：认识字,能够读大部分读物，能够大概的描述阅读的内容说的是什么。</p>
<h1 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h1><p>这一个层次要求能够快速的、准确的通过各种方式抓住一本书的重点。<br>分为两类<br>有系统的略读：<br>1、看书名、序言。了解整个书讲的什么。<br>2、研究目录，对书的骨架有了了解。<br>3、看索引，能够快速的知道本书内容的范围。<br>4、阅读其他人写的介绍。<br>5、抽取部分篇章阅读。<br>6、不要忽略最后几页<br>粗浅的阅读：<br>1、快速的阅读，即使对很多内容不理解也要将书籍读完。这样才不会停滞不前。<br>2、提高阅读速度的方式，不断移动眼球，不要后退暂停。大脑要跟上阅读的速度。<br>3、需要判断不同的书籍类型，不同的种类使用不同的阅读速度。</p>
<a id="more"></a>
<h1 id="如何做一个自我要求的读者"><a href="#如何做一个自我要求的读者" class="headerlink" title="如何做一个自我要求的读者"></a>如何做一个自我要求的读者</h1><p>主动阅读需要提出的四个问题，在整个阅读的过程中需要不断的去尝试的回答这些问题：<br>1、整体而言，这本书到底谈些什么？<br>2、作者细部说了什么，怎么说的？<br>3、这本书说都有道理吗？是全部由道理，还是部分有道理？<br>4、这本书跟你有什么关系？</p>
<h1 id="如何让一本书真正属于你自己"><a href="#如何让一本书真正属于你自己" class="headerlink" title="如何让一本书真正属于你自己"></a>如何让一本书真正属于你自己</h1><p>想要真正拥有一本书，不是花钱买了它。而是阅读它，做好笔记，实践书中的内容。<br>笔记是一个能够提升阅读主动性的存在，有与有笔记的存在，阅读者能够不断提醒自己，不至于打瞌睡，同时对内容的输出也是加深对书籍理解的方式，它迫使你不断的去思考，组织语言回应一个又一个事实。</p>
<h1 id="存在三种笔记："><a href="#存在三种笔记：" class="headerlink" title="存在三种笔记："></a>存在三种笔记：</h1><p>结构笔记：这种笔记的目的是记录下全书的架构，而不是内容。<br>概念笔记：书中一般会有很多新的概念或者其他你了解过的概念。这里记录的是作者的想法，与结构无关。<br>辩证笔记：对于更高层次的读者，已经不是全部接受作者观点了，他们需要的是对于本书已有的观点事实进行讨论，那么记录的笔记更多的是辩证的性质。</p>
<h1 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h1><p>分析阅读的三个阶段<br>第一个阶段：找出一本书在谈些什么<br>1、依照书的种类与主题分类。<br>2、使用最简短的问题说明一本书谈什么。<br>3、将主要部分按照顺序与关联性列举出来。将全书的大纲列举出来，并将各个部分的大纲也列出来。<br>4、确定作者想要解决的问题。<br>第二个阶段：诠释一本书的内容<br>1、诠释作者使用的关键字，与作者达成共识。<br>2、从最重要的句子中抓住作者的重要主旨<br>3、找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。<br>4、确定作者已经解决了哪些问题，还有哪些是未解决的。未解决的问题中，确定哪些是作者认为自己无法解决的问题。<br>第三个阶段：像是沟通知识一样地评论一本书的规则<br>A．智慧礼节的一般规则<br>（9）除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。（在你说出：“我读懂了！”之前，不要说你同意、不同意或暂缓评论。）<br>（10）不要争强好胜，非辩到底不可。<br>（11）在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。<br>B．批评观点的特别标准<br>（12）证明作者的知识不足。<br>（13）证明作者的知识错误。<br>（14）证明作者不合逻辑。<br>（15）证明作者的分析与理由是不完整的。</p>
<h1 id="批评式阅读条件"><a href="#批评式阅读条件" class="headerlink" title="批评式阅读条件"></a>批评式阅读条件</h1><p>本章的三个规则说明的是批评式阅读的条件，而在这样的阅读中，读者应该能够与作者“辩论”。<br>第一，要求读者先完整地了解一本书，不要急着开始批评。<br>第二，恳请读者不要争强好辩或盲目反对。<br>第三，将知识上的不同意见看作是大体上可以解决的问题。这个规则再进一步的话，就是要求读者要为自己不同的意见找到理论基础，这样这个议题才不只是被说出来，而且会解释清楚。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 杂谈 </tag>
            
            <tag> 杂书 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[读书笔记]多任务下的数据结构与算法 序章]]></title>
      <url>/2016/08/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>序章部分都是周先生之前的一些经验之谈，感觉在实际编程过程中还是比较有用的，程序里经常遇到这么些问题。<br><a id="more"></a></p>
<h1 id="1、参数校验"><a href="#1、参数校验" class="headerlink" title="1、参数校验"></a>1、参数校验</h1><pre><code>参数校验，大部分函数开始和使用传进来的参数的都是都是需要参数校验的。有时候不知道该不该校验，怎么样才能划分这部分工作是函数使用者的工作，还是函数设计者的工作呢。一直比较迷糊吧。
</code></pre><blockquote>
<p><em>对于在大循环里调用的函数，不需要再函数内校验。比如链表的遍历，如果校验的话，每一个链表的节点都需要校验，那么函数的效率就要大幅度下降了。
</em>底层的函数调用频度都比较高，一般不校验？这个为什么不校验了，是因为调用频度高？<br><em>如果在一个函数中多次使用这个底层函数，实际上只要在调用函数之前，一次性校验一次就行了。而不需要在底层函数中进行校验，否则多次校验，影响效率。
</em>调用频率低的校验，和上面一条类似，调用频率低了，自然自带校验好。<br><em>执行时间开销很大，参数校验对于函数运行时间来说忽略不计。
</em>可以大幅度提高软件的稳定性的。</p>
</blockquote>
<h1 id="2、return语句的使用"><a href="#2、return语句的使用" class="headerlink" title="2、return语句的使用"></a>2、return语句的使用</h1><pre><code>函数对于return语句的使用，多次使用该语句的话，要对资源进行回收完全，但实际情况中，经常会忘记写一些，这样就造成内存泄露比较容易发生。但是你不用return语句的话，一般写程序条件过多，分支过多，读程序的困难就比较大的提升了。
</code></pre><blockquote>
<p><em>参数校验失败后直接return，并对资源回收
</em>函数内不同的出错，要使用不同的return来表示不同的出错原因<br>*函数内部同类出错，尽量使用同一个return语句，尽量不要让两个return返回同一个返回值</p>
</blockquote>
<h1 id="3、while循环和for循环的问题"><a href="#3、while循环和for循环的问题" class="headerlink" title="3、while循环和for循环的问题"></a>3、while循环和for循环的问题</h1><pre><code>死循环时，在pc-lint中会检测成错误？
普通时候，循环变量在循环中改变的话，用while，在循环后改变用for
</code></pre><h1 id="4、if语句多个判断的问题"><a href="#4、if语句多个判断的问题" class="headerlink" title="4、if语句多个判断的问题"></a>4、if语句多个判断的问题</h1><pre><code>需要校验多个参数时候，把条件放在一个if中，这要就少了return。当然，这些条件要产生不容的return结果的时候，就需要分开了。
</code></pre><h1 id="5、goto语句的使用"><a href="#5、goto语句的使用" class="headerlink" title="5、goto语句的使用"></a>5、goto语句的使用</h1><pre><code>我看周先生在一些代码中还是使用的一些goto语句的，根据之前的描述看，就是运用在出错的时候，跳转到资源回收时，比较方便使用。
但是goto的语句使用有一些原则goto语句只能goto到同一函数内，而不能从一个函数里goto到另一个函数里使用goto语句在同一个函数内goto时候，goto的起点应该是函数内一小段功能结束处，目的地是一小段功能开始处，而不是乱跳不能从一段复杂的执行状态中的位置goto，这样很容易遗漏东西。
</code></pre><h1 id="6、swich…case-if-else-if区别"><a href="#6、swich…case-if-else-if区别" class="headerlink" title="6、swich…case if else if区别"></a>6、swich…case if else if区别</h1><pre><code>一般swich效率更高些，但是实际情况是，每一个条件存在不同概率时候，把概率大的放最前的话，效率最高。
</code></pre><h1 id="7、任意数据类型的处理方式-C"><a href="#7、任意数据类型的处理方式-C" class="headerlink" title="7、任意数据类型的处理方式 C"></a>7、任意数据类型的处理方式 C</h1><pre><code>数据类型几乎存在无限种组合了，c++使用模板，而在c语言中使用void指针是很不错的方法。其实在C++中也经常用到void指针，因为可以指向任意类型的数据。C使用void*时候不知道适合该数据结构的一些操作，所以需要使用回调函数，来传进这些操作。
</code></pre><blockquote>
<p><em>数据的比较
</em>数据的资源释放<br><em>数据的访问
</em>数据的拷贝<br>*数据的一些其他计算操作</p>
</blockquote>
<p><strong>例子</strong></p>
<blockquote>
<p><em>typedef void    (</em>DESTROYFUNC)( void *pArgs);</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《The Last Of Us》]]></title>
      <url>/2016/07/26/%E3%80%8AThe-Last-Of-Us%E3%80%8B/</url>
      <content type="html"><![CDATA[<h1 id="关于结局"><a href="#关于结局" class="headerlink" title="关于结局"></a>关于结局</h1><h2 id="1、我不信任马琳。"><a href="#1、我不信任马琳。" class="headerlink" title="1、我不信任马琳。"></a>1、我不信任马琳。</h2><p>可以确定的是他们确实是想要找到疫苗，即使马琳在爱丽出身开始就在她的旁边，也要杀死爱丽。马琳是抛弃了爱丽的，从最初的国会大厦，到玛利亚医院，她存活下来之后，才开始在其记录的本子录音中关心起爱丽来，当然更多的是关心有免疫体的爱丽。其实作为爱丽没有必要跟着马琳走的，完全可以在波士顿生活下去，爱丽是重情，而马琳就不是了。</p>
<h2 id="2、火萤是一个怎么样的组织呢？"><a href="#2、火萤是一个怎么样的组织呢？" class="headerlink" title="2、火萤是一个怎么样的组织呢？"></a>2、火萤是一个怎么样的组织呢？</h2><p>从剧情看乔尔的弟弟在离开乔尔之后，加入了火萤，然后从火萤离开，到达森林之中构筑起他的小村落。火萤能不能给人类带来新的希望呢，我觉得是不能的，在长期的对抗之下，火萤显然是从最初的想要找回原来国家秩序的组织退化了，也是由于这个原因让汤米出走，寻找自己的出路，最后汤米接近于实现他的想法。</p>
<h2 id="3、汤米的村落才是人类的希望。"><a href="#3、汤米的村落才是人类的希望。" class="headerlink" title="3、汤米的村落才是人类的希望。"></a>3、汤米的村落才是人类的希望。</h2><p>汤米的村落才是真正的人类希望。不论是军事管理区、猎人、还是火萤，都让这个国家的秩序不再存在了。从整个游戏的不断对抗之中我们能够发现的是，往往人类比感染者更加难缠，乔尔与爱丽最惊险的时刻还是在与猎人、军政府、火萤的对抗的时候。实际上感染者，可能并没有那么可怕。汤米的小村落，在回归秩序之后，需要担心的更多是猎人，而不是感染者能够说明，如果社会重新回归秩序，那么感染者并没有那么可怕，可怕的更多的是人心。<br><a id="more"></a></p>
<h1 id="关于细节"><a href="#关于细节" class="headerlink" title="关于细节"></a>关于细节</h1><h2 id="1、汤米和乔尔的分裂是必然的。"><a href="#1、汤米和乔尔的分裂是必然的。" class="headerlink" title="1、汤米和乔尔的分裂是必然的。"></a>1、汤米和乔尔的分裂是必然的。</h2><p>在游戏开场的时候，汤米开车载着乔尔和萨拉，路上有人求救，汤米想要停下来载人，乔尔是强烈反对的。乔尔要求开车冲过人群，不管前面不断涌来的人流，汤米是不愿意的。就如后面剧情所描述的那般，乔尔成为了走私客，当过猎人。帮助他与汤米活了下来。而对于汤米来说，这对他是一场噩梦。两个人的处事原则不一致，导致了他们最终的分裂。而从这一点来看，乔尔为了救爱丽，杀医生与马琳这么些中性的人物也就不奇怪了。</p>
<h2 id="2、关于火萤的疫苗研究。"><a href="#2、关于火萤的疫苗研究。" class="headerlink" title="2、关于火萤的疫苗研究。"></a>2、关于火萤的疫苗研究。</h2><p>当乔尔一行躲过军队的追击时，问爱丽火萤的安排的时候，爱丽说火萤有着自己的隔离区正在研究疫苗，乔尔与泰丝不屑一顾。说明火萤研究疫苗人尽皆知，但从来不知道真假。</p>
<h2 id="3、泰丝无声的死亡"><a href="#3、泰丝无声的死亡" class="headerlink" title="3、泰丝无声的死亡"></a>3、泰丝无声的死亡</h2><p>当军队追击到来，泰丝希望能够阻止一会。乔尔与爱丽刚到达二楼，就是一声参加。当我们终于在二楼解决掉敌人的时候，回过头来，泰丝的尸体就躺在了那里。没有太多反抗能力的，无声的死去了。所有关于她的故事，精彩的一生，就这样消失了。带给我的是孤寂。</p>
<h2 id="4、山姆与亨利"><a href="#4、山姆与亨利" class="headerlink" title="4、山姆与亨利"></a>4、山姆与亨利</h2><p>当终于躲过了猎人与感染者的追击，乔尔爱丽与黑人兄弟建立起来友谊。夜晚来临，亨利对于未来充满想象，愉快的吃着东西讨论着哈雷机车，让我没想到的是，这会是最后一个夜晚了。亨利饮弹自尽，十多秒的黑屏，让我思考很久。</p>
<h2 id="5、爱丽梦到飞机"><a href="#5、爱丽梦到飞机" class="headerlink" title="5、爱丽梦到飞机"></a>5、爱丽梦到飞机</h2><p>当快要到达旅途的终点，爱丽在一个飞机的海报之前停了下来。描述着之前她做的梦。失去控制的飞机，没有机长的机长室，只能由她来拯救这一飞机上的人，她试图驾驶，但飞机却要坠落了。失控的飞机代表着这个失控的世界，而爱丽就是拯救世界的关键人物，没人可以给与她指引，只能她自己去摸索，但是终究可能会坠落，她害怕失去朋友，害怕完成不了自己的使命。</p>
<h2 id="6、两人关系进展的一些点"><a href="#6、两人关系进展的一些点" class="headerlink" title="6、两人关系进展的一些点"></a>6、两人关系进展的一些点</h2><p>乔尔在电梯处，掉了下去之后，他问爱丽是不是OK，爱丽回答“NO,你吓到我了”<br>爱丽在乔尔差点被猎人溺死的情况下拯救了乔尔，但是乔尔嘴硬的不愿意承认，爱丽直说乔尔怎么就不知道感谢。游戏设计上立马设计一个乔尔一个人推不动的钢琴，需要爱丽与他一起。同时接着就是乔尔需要爱丽进行掩护攻击猎人。<br>躲避机车的关卡，乔尔没有爬山去的情况下，爱丽直接跳下来与乔尔一起面对难关。在关键时刻需要跳桥的情况下，乔尔关心的是爱丽不会游泳，而爱丽信任他，一句不要让我沉下去，就果断跳了。<br>乔尔寻找会出走的爱丽，爱丽直言，她害怕失去，所有她关心的人都离她而去，除了乔尔。她不需要什么更懂行的汤米，只需要乔尔，只有这样她才能够心安。</p>
<p>爱丽打败大卫，疯狂的痛砍大卫的尸体的时候，乔尔及时的出现，像安慰女儿一样安慰着爱丽（神态语气如同萨拉死去的时候一般），同时抚平了自己的内心。</p>
]]></content>
      
        <categories>
            
            <category> 游戏 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RPG </tag>
            
            <tag> PS4 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2016/07/24/hello-world/</url>
      <content type="html"><![CDATA[<p>新的博客 Hello World</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
